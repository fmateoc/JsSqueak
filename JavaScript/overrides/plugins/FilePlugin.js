/* * Copyright (c) 2022  Florin Mateoc * * This file is part of JsSqueak. * * JsSqueak is free software: you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JsSqueak is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with JsSqueak.  If not, see <https://www.gnu.org/licenses/>. *//*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }/*** Constants ***/const DirBadPath = 2;const DirNoMoreEntries = 1;const PrimErrBadArgument = 3;const PrimErrBadIndex = 4;const PrimErrNoMemory = 9;const PrimErrObjectMayMove = 14;const PrimErrUnsupported = 7;const PrimNoErr = 0;globalThis.FilePlugin = {primitiveDirectoryCreate(dirName) {	if (!(dirName.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!Squeak.dirCreate(dirName.valueOf())) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDirectoryDelete(dirName) {	if (!(dirName.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!Squeak.dirDelete(dirName.valueOf())) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDirectoryDelimitor() {	throw Object.create(PrimitiveReturn).setPayload('/');},primitiveDirectoryEntry: function(dirNameObj, fileNameObj) {	const fileName = FilePlugin.filenameFromSqueak(fileNameObj.valueOf());	const dirName = FilePlugin.filenameFromSqueak(dirNameObj.valueOf());	const entries = Squeak.dirList(dirName, true);	if (!entries) {//		console.log("Directory not found: " + dirName);		throw Object.create(PrimitiveFailed).setPayload(1);	}	const entry = entries[fileName];	if (entry) {		entry[0] = SmalltalkGlobals._ByteString.from(entry[0]);		throw Object.create(PrimitiveReturn).setPayload(SmalltalkGlobals._Array.from(entry));	} else		throw Object.create(PrimitiveReturn).setPayload(nil);},primitiveDirectoryLookup(pathName, index) {	arguments.length !== 2 || !Number.isSafeInteger(index.valueOf()) ? PrimitiveFailed.signal() : index;	if (!(pathName.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const sqDirName = pathName.valueOf();	const dirName = FilePlugin.filenameFromSqueak(sqDirName);	const entries = Squeak.dirList(dirName, true);	if (!entries) {//		console.log("Directory not found: " + dirName);		throw Object.create(PrimitiveFailed).setPayload(1);	}	let keys = Object.keys(entries).sort(),		entry = entries[keys[index - 1]];	if (sqDirName === "/") { // fake top-level dir		if (index === 1) {			if (!entry) entry = [0, 0, 0, 0, 0];			entry[0] = "JsSqueak";			entry[3] = true;		}		else entry = null;	}	if (entry) {		entry[0] = SmalltalkGlobals._ByteString.from(entry[0]);		throw Object.create(PrimitiveReturn).setPayload(SmalltalkGlobals._Array.from(entry));	} else		throw Object.create(PrimitiveReturn).setPayload(nil);}, /*	If the security plugin can be loaded, use it to turn off file access	 If not, assume it's ok */primitiveDisableFileAccess() {	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileAtEnd(handle) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.filePos >= handle.file.size);}, primitiveFileClose(handle) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof handle.file === "string") {		FilePlugin.fileConsoleFlush(handle.file);	} else {		const file = handle.file;		if (file.modified) {			let buffer = file.contents.buffer;			if (buffer.byteLength !== file.size) {				buffer = new ArrayBuffer(file.size);				(new Uint8Array(buffer)).set(file.contents.subarray(0, file.size));			}			const holder = {completed: false, value: this};			if (!Squeak.filePut(				file.name,				buffer,				() => {					file.modified = false;					if (--file.refCount === 0) delete SqueakFiles[file.name];					handle.file = null;//					console.log("File (flush for) close request completed successfully");					holder.completed = true				}))				throw Object.create(PrimitiveFailed).setPayload(1);//			console.log("File (flush for) close request initiated for: " + file.name);			throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileDelete(namePointer) {	if (!(namePointer.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const fileName = FilePlugin.filenameFromSqueak(namePointer.valueOf());	const holder = {completed: false, value: this};	if (!Squeak.fileDelete(fileName, false,() => {//			console.log("File delete requested completed successfully");			holder.completed = true})) {		throw Object.create(PrimitiveFailed).setPayload(1);	}//	console.log("File delete request initiated for: " + fileName);	throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run}, primitiveFileFlush(handle) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof handle.file === "string") {		FilePlugin.fileConsoleFlush(handle.file);	} else {		const file = handle.file;		if (file.modified) {			let buffer = file.contents.buffer;			if (buffer.byteLength !== file.size) {				buffer = new ArrayBuffer(file.size);				(new Uint8Array(buffer)).set(file.contents.subarray(0, file.size));			}			const holder = {completed: false, value: this};			if (!Squeak.filePut(				file.name,				buffer,				() => {					file.modified = false;//					console.log("File flush request completed successfully");					holder.completed = true				}))				throw Object.create(PrimitiveFailed).setPayload(1);//			console.log("File flush request initiated for: " + file.name);			throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileGetPosition(handle) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.filePos);},makeFileHandle: function(filename, file, writeFlag) {	const handle = SmalltalkGlobals._ByteString.from("squeakjs:" + filename);	handle.file = file;             // shared between handles	handle.fileWrite = writeFlag;   // specific to this handle	handle.filePos = 0;             // specific to this handle	return handle;},primitiveFileOpen(namePointer, _arg2) {	const writeFlag = typeof _arg2.valueOf() !== "boolean" ? PrimitiveFailed.signal() : _arg2.valueOf();	if (!(namePointer.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	let filepath = FilePlugin.filenameFromSqueak(namePointer.valueOf());	// if a file is opened for read and write at the same time,	// they must share the contents. That's why all open files	// are held in the ref-counted global SqueakFiles	if (typeof SqueakFiles == 'undefined')		window.SqueakFiles = {};	if (filepath[0] !== '/') filepath = '/' + filepath;	filepath = filepath.replace(/\/\//g, '/');      // replace double-slashes	const matches = filepath.match(/(.*)\/(.*)/),		dirname = matches[1] ? matches[1] : '/',		basename = matches[2] ? matches[2] : null;	if (!basename)	    // malformed filename		throw Object.create(PrimitiveFailed).setPayload(1);	// fetch or create directory entry	const directory = Squeak.dirList(dirname, true);	if (!directory)		throw Object.create(PrimitiveFailed).setPayload(1);	let entry = directory[basename],		contents = null,		file;	if (entry) {		// if it is open already, return it		file = SqueakFiles[filepath];		if (file) {			++file.refCount;		} else {			// make the file object			file = {				name: filepath,				size: entry[4],         // actual file size, may differ from contents.length				contents: contents,     // possibly null, fetched when needed				modified: false,				refCount: 1			};			SqueakFiles[file.name] = file;		}		const handle = FilePlugin.makeFileHandle(file.name, file, writeFlag);		throw Object.create(PrimitiveReturn).setPayload(handle);	} else {		if (!writeFlag) {//			console.log("File not found: " + filepath);			throw Object.create(PrimitiveFailed).setPayload(1);		}		contents = new Uint8Array();		const holder = {completed: false};		entry = Squeak.filePut(filepath, contents.buffer, function () {//			console.log("File created: " + filepath);			holder.completed = true;		});		if (!entry) {			console.log("Cannot create file: " + filepath);			throw Object.create(PrimitiveFailed).setPayload(1);		}		// make the file object		file = {			name: filepath,			size: entry[4],         // actual file size, may differ from contents.length			contents: contents,     // possibly null, fetched when needed			modified: false,			refCount: 1		};		SqueakFiles[file.name] = file;		holder.value = FilePlugin.makeFileHandle(file.name, file, writeFlag);//		console.log("File creation request initiated for: " + filepath);		throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run	}},primitiveFileRead(handle, array, _arg3, _arg4) {	let count = Number.isSafeInteger(_arg4.valueOf()) && _arg4 >= 0 ? _arg4 : PrimitiveFailed.signal();	const startIndex = Number.isSafeInteger(_arg3.valueOf()) && _arg3 >= 0 ? _arg3 - 1 : PrimitiveFailed.signal();	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(["words", "bytes"].indexOf(array.storageType) !== -1)) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadArgument);	}	if (count === 0)		throw Object.create(PrimitiveReturn).setPayload(0);	const size = (array.storageType === "words") ? array.words.length : array.bytes.length;	if (startIndex < 0 || startIndex + count > size) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadIndex);	}	if (typeof handle.file === "string") {		//this.fileConsoleRead(handle.file, array, startIndex, count);		throw Object.create(PrimitiveReturn).setPayload(0);	}	const file = handle.file;	if (file.contents === false) // failed to get contents before		throw Object.create(PrimitiveFailed).setPayload(1);	const byteCount = array.storageType === "words" ? count * 4 : count;	if (file.modified || file.size - handle.filePos >= byteCount && file.contents && file.contents.length - handle.filePos >= byteCount ) {		//memory has the freshest contents, or it can satisfy the full request		if (file.size <= handle.filePos)			throw Object.create(PrimitiveReturn).setPayload(0);		let srcArray, dstArray;		if (array.storageType === "words") {			count = Math.min(count, (file.size - handle.filePos) >> 2);			srcArray = new DataView(file.contents.buffer, handle.filePos, Math.min(byteCount, file.size - handle.filePos));			dstArray = array.words;			for (let i = 0; i < count; i++)				dstArray[startIndex + i] = srcArray.getUint32(i << 2);			handle.filePos += count << 2;		} else {			srcArray = file.contents;			dstArray = array.bytes;			count = Math.min(count, file.size - handle.filePos);			for (let i = 0; i < count; i++)				dstArray[startIndex + i] = srcArray[handle.filePos++];		}		if (array instanceof SmalltalkGlobals._String)			array.dirty = true;//		console.log((array.storageType === "words" ? count * 4 : count) + " bytes read from memory file.contents out of " + byteCount + " requested");		throw Object.create(PrimitiveReturn).setPayload(count);	}	const holder = {completed: false};	if (Squeak.fileGet(file.name,		function success(contents) {			if (!contents)				throw Object.create(PrimitiveFailed).setPayload(1);			file.contents = FilePlugin.asUint8Array(contents);			let srcArray, dstArray;			if (array.storageType === "words") {				count = Math.min(count, (file.size - handle.filePos) >> 2);				srcArray = new DataView(file.contents.buffer, handle.filePos, Math.min(byteCount, file.size - handle.filePos));				dstArray = array.words;				for (let i = 0; i < count; i++)					dstArray[startIndex + i] = srcArray.getUint32(i << 2);				handle.filePos += count << 2;			} else {				srcArray = file.contents;				dstArray = array.bytes;				count = Math.min(count, file.size - handle.filePos);				for (let i = 0; i < count; i++)					dstArray[startIndex + i] = srcArray[handle.filePos++];			}			if (array instanceof SmalltalkGlobals._String)				array.dirty = true;			holder.value = Math.max(0, count);//			console.log((array.storageType === "words" ? holder.value * 4 : holder.value) + " bytes actually read");			return holder.completed = true;		},		function error(msg) {			console.log("File get failed: " + msg);			file.contents = false;			throw Object.create(PrimitiveFailed).setPayload(1);		})	) {//		console.log("File read request initiated for: " + file.name + ", position " + position + " and byte count " + (array.storageType === "words" ? _arg4.valueOf() * 4 : _arg4.valueOf()));		throw Object.create(PrimitiveYield).setPayload(holder);	}	throw Object.create(PrimitiveFailed).setPayload(1);},primitiveFileRename(oldNamePointer, newNamePointer) {	if (!((newNamePointer.storageType === "bytes") && ((oldNamePointer.storageType === "bytes")))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const oldName = FilePlugin.filenameFromSqueak(oldNamePointer.valueOf()),		newName = FilePlugin.filenameFromSqueak(newNamePointer.valueOf());	const holder = {completed: false, value: this};	if (!Squeak.fileRename(oldName, newName, () => {//			console.log("File rename request completed successfully");			holder.completed = true})) {		throw Object.create(PrimitiveFailed).setPayload(1);	}//	console.log("File rename request initiated for: " + oldName);	throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run}, primitiveFileSetPosition(handle, _arg1) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const arg1Val = _arg1.valueOf();	if (!Number.isSafeInteger(arg1Val) || arg1Val < 0) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	handle.filePos = arg1Val;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileSize(handle) {	if (handle.file === undefined) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.file.size);}, /*	Answer an Array of file handles for standard in, standard out and standard error,	 with nil in entries that are unvailable, e.g. because the platform does not provide	 standard error, etc.  Fail if there are no standard i/o facilities on the platform or	 if the security plugin denies access or if memory runs out. */primitiveFileStdioHandles() {	const handles = [		null, // stdin		FilePlugin.makeFileHandle('console.log', 'log', true),		FilePlugin.makeFileHandle('console.error', 'error', true),	];	throw Object.create(PrimitiveReturn).setPayload(SmalltalkGlobals._Array.from(handles));},/*	ftruncate is not an ansi function so we have a macro to point to a suitable platform implementation */primitiveFileTruncate(handle, _arg1) {	if (handle.file === undefined || !handle.fileWrite) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const arg1Val = _arg1.valueOf();	if (!Number.isSafeInteger(arg1Val) || arg1Val < 0) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (handle.file.size > arg1Val) {		handle.file.size = arg1Val;		handle.file.modified = true;		if (handle.filePos > handle.file.size) handle.filePos = handle.file.size;	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileWrite(handle, array, _arg3, _arg4) {	let count;	let elementSize;	let startIndex;	count = Number.isSafeInteger(_arg4.valueOf()) && _arg4 >= 0 ? _arg4 : PrimitiveFailed.signal();	startIndex = Number.isSafeInteger(_arg3.valueOf()) && _arg3 > 0 ? _arg3 - 1 : PrimitiveFailed.signal();	if (handle.file === undefined || !handle.fileWrite) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (count === 0)		throw Object.create(PrimitiveReturn).setPayload(0);	if (!(["words", "bytes"].indexOf(array.storageType) !== -1)) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadArgument);	}	elementSize = (array.storageType === "words") ? 4 : 1;	if (!((startIndex >= 0) && (startIndex + count <= SIZEOF(array)))) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadIndex);	}	const bytes = array.bytes || new Uint8Array(array.words.buffer, 0, array.words.length * elementSize);	const byteCount = count * elementSize, byteStartIndex = startIndex * elementSize;	const file = handle.file;	if (typeof file === "string") {		FilePlugin.fileConsoleWrite(file, bytes, byteStartIndex, byteCount);		throw Object.create(PrimitiveReturn).setPayload(count);	}	let dstArray = file.contents;	const currentLength = dstArray ? dstArray.length : 0;	if (handle.filePos + byteCount > currentLength) {		const newSize = currentLength === 0 ? handle.filePos + byteCount :			Math.max(handle.filePos + byteCount, currentLength + 10000);		file.contents = new Uint8Array(newSize);		if (dstArray)			file.contents.set(dstArray);		dstArray = file.contents;	}	for (let i = 0; i < byteCount; i++)		dstArray[handle.filePos++] = bytes[byteStartIndex + i];	if (handle.filePos > file.size) file.size = handle.filePos;	file.modified = true;//	console.log("successfully written " + byteCount + " bytes to file");	throw Object.create(PrimitiveReturn).setPayload(count);}, primitiveHasFileAccess() {	throw Object.create(PrimitiveReturn).setPayload(true);},	asUint8Array: function(buffer) {		// A direct test of the buffer's constructor doesn't work on Safari 10.0.		if (buffer instanceof Uint8Array) return buffer;		if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);		if (typeof buffer === "string") {			const bytes = new Uint8Array(buffer.length);			let p = 0;			for (const c of buffer) {				const codePoint = c.codePointAt(0);				if (codePoint >= 256)					return SmalltalkGlobals._WideSymbol.from(buffer).wordsAsUint8Array();				bytes[p++] = codePoint;			}			return bytes;		}		throw Error("unknown buffer type");	},	fileConsoleBuffer: {		log: '',		error: ''	},	fileConsoleWrite: function(logOrError, array, startIndex, count) {		// buffer until there is a newline		const bytes = array.subarray(startIndex, startIndex + count);		let buffer = FilePlugin.fileConsoleBuffer[logOrError] + String.fromCodePoint(...bytes);		const lines = buffer.match('([^]*)\n(.*)');		if (lines) {			console[logOrError](lines[1]);  // up to last newline			buffer = lines[2];              // after last newline		}		FilePlugin.fileConsoleBuffer[logOrError] = buffer;	},	fileConsoleFlush: function(logOrError) {		const buffer = FilePlugin.fileConsoleBuffer[logOrError];		if (buffer) {			console[logOrError](buffer);			FilePlugin.fileConsoleBuffer[logOrError] = '';		}	},	filenameFromSqueak: function(filepath) {		return filepath.replace(/^\/*JsSqueak\/?/, "/") || "/";            // strip JsSqueak /**/	},}