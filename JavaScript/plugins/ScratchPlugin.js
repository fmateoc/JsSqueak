/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 26 July 2023 12:02:07 am *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	ScratchPlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/globalThis.ScratchPlugin = {/*	Answer the hue, an angle between 0 and 360. */hueFromRGBminmax(r, g, b, min, max) {	let result;	let span;	span = max - min;	if (span === 0) {		return 0;	} else {		result = (r === max) ? (Math.trunc((60 * (g - b)) / span)) : ((g === max) ? (120 + (Math.trunc((60 * (b - r)) / span))) : (240 + (Math.trunc((60 * (r - g)) / span))));		return (result < 0) ? (result + 360) : result;	}}, primitiveBlur(inOop, outOop, width) {	let bTotal;	let dX;	let dY;	let gTotal;	let height;	let in_;	let n;	let out;	let outPix;	let pix;	let rTotal;	let sz;	let x;	let y;	((typeof width === "number") ? width : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	height = Math.trunc(sz / width);	const yLimiT = height - 2;	for (y = 1; y <= yLimiT; y++) {		const xLimiT = width - 2;		for (x = 1; x <= xLimiT; x++) {			n = (rTotal = (gTotal = (bTotal = 0)));			for (dY = -1; dY <= 1; dY++) {				for (dX = -1; dX <= 1; dX++) {					/* add 1 when testing in Squeak */					pix = UBANDS(in_[((y + dY) * width) + (x + dX)], 16777215);					if (pix !== 0) {						/* skip transparent pixels */						rTotal += UBANDS((pix >>> 16), 255);						gTotal += UBANDS((pix >>> 8), 255);						bTotal += UBANDS(pix, 255);						++n;					}				}			}			outPix = (n === 0) ? 0 : ((((Math.trunc(rTotal / n)) << 16 >>> 0) + ((Math.trunc(gTotal / n)) << 8 >>> 0)) + (Math.trunc(bTotal / n)));			out[(y * width) + x] = outPix;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveBrightnessShift(inOop, outOop, shift) {	let b;	let brightness;	let g;	let hue;	let i;	let in_;	let max;	let min;	let out;	let pix;	let r;	let saturation;	let sz;	let result;	let span;	let hF;	let hI;	let outPix;	let p;	let q;	let t;	let v;	((typeof shift === "number") ? shift : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (i = 0; i < sz; i++) {		pix = UBANDS(in_[i], 16777215);		if (pix !== 0) {			/* skip pixel values of 0 (transparent) */			r = UBANDS((pix >>> 16), 255);			g = UBANDS((pix >>> 8), 255);			/* find min and max color components */			b = UBANDS(pix, 255);			max = (min = r);			if (g > max) {				max = g;			}			if (b > max) {				max = b;			}			if (g < min) {				min = g;			}			if (b < min) {				min = b;			}			/* begin hueFromR:G:B:min:max: */			span = max - min;			if (span === 0) {				hue = 0;			} else {				result = (r === max) ? (Math.trunc((60 * (g - b)) / span)) : ((g === max) ? (120 + (Math.trunc((60 * (b - r)) / span))) : (240 + (Math.trunc((60 * (r - g)) / span))));				hue = (result < 0) ? (result + 360) : result;			}			/* end hueFromR:G:B:min:max: */			saturation = (max === 0) ? 0 : (Math.trunc(((max - min) * 1000) / max));			/* compute new brigthness */			brightness = Math.trunc((max * 1000) / 255);			brightness += shift * 10;			if (brightness > 1000) {				brightness = 1000;			}			if (brightness < 0) {				brightness = 0;			}			/* begin bitmap:at:putH:s:v: */			hI = Math.trunc(hue / 60);			hF = MOD(hue, 60);			p = (1000 - saturation) * brightness;			q = (1000 - (Math.trunc((saturation * hF) / 60))) * brightness;			t = (1000 - (Math.trunc((saturation * (60 - hF)) / 60))) * brightness;			v = Math.trunc((brightness * 1000) / 3922);			p = Math.trunc(p / 3922);			q = Math.trunc(q / 3922);			t = Math.trunc(t / 3922);						switch (hI) {			case 0:								outPix = ((v << 16 >>> 0) + (t << 8 >>> 0)) + p;				break;			case 1:								outPix = ((q << 16 >>> 0) + (v << 8 >>> 0)) + p;				break;			case 2:								outPix = ((p << 16 >>> 0) + (v << 8 >>> 0)) + t;				break;			case 3:								outPix = ((p << 16 >>> 0) + (q << 8 >>> 0)) + v;				break;			case 4:								outPix = ((t << 16 >>> 0) + (p << 8 >>> 0)) + v;				break;			case 5:								outPix = ((v << 16 >>> 0) + (p << 8 >>> 0)) + q;				break;			default:								null;			}			if (outPix === 0) {				outPix = 1;			}			out[i] = outPix;			/* end bitmap:at:putH:s:v: */		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveCondenseSound(srcOop, dstOop, factor) {	let count;	let dst;	let i;	let j;	let max;	let src;	let sz;	let v;	var _src = 0;	var _dst = 0;	((typeof factor === "number") ? factor : PrimitiveFailed.signal());	if (!(srcOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(dstOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	count = Math.trunc((2 * SIZEOF(srcOop)) / factor);	sz = 2 * SIZEOF(dstOop);	if (!(sz >= count)) throw Object.create(PrimitiveFailed).setPayload(1);	;	src = srcOop.wordsAsInt16Array();	dst = dstOop.wordsAsInt16Array();	for (i = 1; i <= count; i++) {		max = 0;		for (j = 1; j <= factor; j++) {			v = src[_src++];			if (v < 0) {				v = 0 - v;			}			if (v > max) {				max = v;			}		}		dst[_dst++] = max;	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDoubleSize(inOop, inW, inH, outOop, outW, outH, dstX, dstY) {	let baseIndex;	let i;	let in_;	let out;	let pix;	let x;	let y;	((typeof inW === "number") ? inW : PrimitiveFailed.signal());	((typeof inH === "number") ? inH : PrimitiveFailed.signal());	((typeof outW === "number") ? outW : PrimitiveFailed.signal());	((typeof outH === "number") ? outH : PrimitiveFailed.signal());	((typeof dstX === "number") ? dstX : PrimitiveFailed.signal());	((typeof dstY === "number") ? dstY : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	if (!((dstX + (2 * inW)) < outW)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstY + (2 * inH)) < outH)) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (y = 0; y < inH; y++) {		baseIndex = ((dstY + (2 * y)) * outW) + dstX;		for (x = 0; x < inW; x++) {			pix = in_[x + (y * inW)];			i = baseIndex + (2 * x);			out[i] = pix;			out[i + 1] = pix;			out[i + outW] = pix;			out[(i + outW) + 1] = pix;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveExtractChannel(srcOop, dstOop, _arg3) {	let dst;	let i;	let rightFlag;	let src;	let sz;	var _src = 0;	var _dst = 0;	rightFlag = (typeof _arg3 === "boolean" ? _arg3 : PrimitiveFailed.signal());	if (!(srcOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(dstOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	sz = SIZEOF(srcOop);	if (!(SIZEOF(dstOop) >= (sz >> 1))) throw Object.create(PrimitiveFailed).setPayload(1);	;	src = srcOop.wordsAsInt16Array();	dst = dstOop.wordsAsInt16Array();	if (rightFlag) {		_src++;	}	for (i = 1; i <= sz; i++) {		dst[_dst++] = src[_src]; _src += 2;	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFisheye(inOop, outOop, width, power) {	let ang;	let centerX;	let centerY;	let dx;	let dy;	let height;	let in_;	let out;	let pix;	let r;	let scaledPower;	let srcX;	let srcY;	let sz;	let x;	let y;	let bottomPix;	let index;	let topPix;	let x1;	let xFrac;	let y1;	let yFrac;	let zzzTemp;	let zzzTemp1;	let pix2;	let b;	let frac1;	let g;	let r1;	let result;	let zzzTemp2;	let pix21;	let b1;	let frac11;	let g1;	let r2;	let result1;	let zzzTemp3;	let b2;	let frac12;	let g2;	let r3;	let result2;	let zzzTemp4;	((typeof width === "number") ? width : PrimitiveFailed.signal());	((typeof power === "number") ? power : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	height = Math.trunc(sz / width);	centerX = width >> 1;	centerY = height >> 1;	height = Math.trunc(sz / width);	centerX = width >> 1;	centerY = height >> 1;	scaledPower = power / 100.0;	for (x = 0; x < width; x++) {		for (y = 0; y < height; y++) {			dx = (x - centerX) / centerX;			dy = (y - centerY) / centerY;			r = Math.pow(Math.sqrt((dx * dx) + (dy * dy)),scaledPower);			if (r <= 1.0) {				ang = Math.atan2(dy,dx);				srcX = ((1024 * (centerX + ((r * Math.cos(ang)) * centerX))) | 0);				srcY = ((1024 * (centerY + ((r * Math.sin(ang)) * centerY))) | 0);			} else {				srcX = 1024 * x;				srcY = 1024 * y;			}			/* begin interpolatedFrom:x:y:width:height: */			x1 = srcX >>> 10;			if ((x1 < -1) || (x1 >= width)) {				pix = 0;			} else {				y1 = srcY >>> 10;				if ((y1 < -1) || (y1 >= height)) {					zzzTemp = 0;				} else {					xFrac = UBANDS(srcX, 1023);					if (x1 === -1) {						x1 = 0;						xFrac = 0;					}					if (x1 === (width - 1)) {						xFrac = 0;					}					yFrac = UBANDS(srcY, 1023);					if (y1 === -1) {						y1 = 0;						yFrac = 0;					}					if (y1 === (height - 1)) {						yFrac = 0;					}					index = (y1 * width) + x1;					topPix = UBANDS(in_[index], 16777215);					if (xFrac > 0) {						/* begin interpolate:and:frac: */						pix2 = UBANDS(in_[index + 1], 16777215);						if (topPix === 0) {							topPix = pix2;						} else {							if (pix2 === 0) {								zzzTemp2 = topPix;							} else {								frac1 = 1024 - xFrac;								r1 = ((frac1 * (UBANDS((topPix >>> 16), 255))) + (xFrac * (UBANDS((pix2 >>> 16), 255)))) >> 10;								g = ((frac1 * (UBANDS((topPix >>> 8), 255))) + (xFrac * (UBANDS((pix2 >>> 8), 255)))) >> 10;								b = ((frac1 * (UBANDS(topPix, 255))) + (xFrac * (UBANDS(pix2, 255)))) >> 10;								result = ((r1 << 16 >>> 0) + (g << 8 >>> 0)) + b;								if (result === 0) {									result = 1;								}								zzzTemp2 = result;							}							topPix = zzzTemp2;						}						/* end interpolate:and:frac: */					}					if (yFrac === 0) {						zzzTemp1 = topPix;					} else {						index = ((y1 + 1) * width) + x1;						bottomPix = UBANDS(in_[index], 16777215);						if (xFrac > 0) {							/* begin interpolate:and:frac: */							pix21 = UBANDS(in_[index + 1], 16777215);							if (bottomPix === 0) {								bottomPix = pix21;							} else {								if (pix21 === 0) {									zzzTemp3 = bottomPix;								} else {									frac11 = 1024 - xFrac;									r2 = ((frac11 * (UBANDS((bottomPix >>> 16), 255))) + (xFrac * (UBANDS((pix21 >>> 16), 255)))) >> 10;									g1 = ((frac11 * (UBANDS((bottomPix >>> 8), 255))) + (xFrac * (UBANDS((pix21 >>> 8), 255)))) >> 10;									b1 = ((frac11 * (UBANDS(bottomPix, 255))) + (xFrac * (UBANDS(pix21, 255)))) >> 10;									result1 = ((r2 << 16 >>> 0) + (g1 << 8 >>> 0)) + b1;									if (result1 === 0) {										result1 = 1;									}									zzzTemp3 = result1;								}								bottomPix = zzzTemp3;							}							/* end interpolate:and:frac: */						}						/* begin interpolate:and:frac: */						if (topPix === 0) {							zzzTemp1 = bottomPix;						} else {							if (bottomPix === 0) {								zzzTemp4 = topPix;							} else {								frac12 = 1024 - yFrac;								r3 = ((frac12 * (UBANDS((topPix >>> 16), 255))) + (yFrac * (UBANDS((bottomPix >>> 16), 255)))) >> 10;								g2 = ((frac12 * (UBANDS((topPix >>> 8), 255))) + (yFrac * (UBANDS((bottomPix >>> 8), 255)))) >> 10;								b2 = ((frac12 * (UBANDS(topPix, 255))) + (yFrac * (UBANDS(bottomPix, 255)))) >> 10;								result2 = ((r3 << 16 >>> 0) + (g2 << 8 >>> 0)) + b2;								if (result2 === 0) {									result2 = 1;								}								zzzTemp4 = result2;							}							zzzTemp1 = zzzTemp4;						}						/* end interpolate:and:frac: */					}					zzzTemp = zzzTemp1;				}				pix = zzzTemp;			}			/* end interpolatedFrom:x:y:width:height: */			out[(y * width) + x] = pix;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveHalfSizeAverage(oop, inW, inH, oop1, outW, outH, srcX, srcY, dstX, dstY, dstW, dstH) {	let b;	let dstIndex;	let g;	let in_;	let out;	let pixel;	let r;	let srcIndex;	let x;	let y;	/* begin checkedUnsignedIntPtrOf: */	if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = oop.words;	/* end checkedUnsignedIntPtrOf: */	((typeof inW === "number") ? inW : PrimitiveFailed.signal());	((typeof inH === "number") ? inH : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(oop1.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = oop1.words;	/* end checkedUnsignedIntPtrOf: */	((typeof outW === "number") ? outW : PrimitiveFailed.signal());	((typeof outH === "number") ? outH : PrimitiveFailed.signal());	((typeof srcX === "number") ? srcX : PrimitiveFailed.signal());	((typeof srcY === "number") ? srcY : PrimitiveFailed.signal());	((typeof dstX === "number") ? dstX : PrimitiveFailed.signal());	((typeof dstY === "number") ? dstY : PrimitiveFailed.signal());	((typeof dstW === "number") ? dstW : PrimitiveFailed.signal());	((typeof dstH === "number") ? dstH : PrimitiveFailed.signal());	if (!((srcX >= 0) && (srcY >= 0))) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((srcX + (2 * dstW)) <= inW)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((srcY + (2 * dstH)) <= inH)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstX >= 0) && (dstY >= 0))) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstX + dstW) <= outW)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstY + dstH) <= outH)) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (y = 0; y < dstH; y++) {		srcIndex = (inW * (srcY + (2 * y))) + srcX;		dstIndex = (outW * (dstY + y)) + dstX;		for (x = 0; x < dstW; x++) {			pixel = in_[srcIndex];			r = UBANDS(pixel, 16711680);			g = UBANDS(pixel, 65280);			b = UBANDS(pixel, 255);			pixel = in_[srcIndex + 1];			r += UBANDS(pixel, 16711680);			g += UBANDS(pixel, 65280);			b += UBANDS(pixel, 255);			pixel = in_[srcIndex + inW];			r += UBANDS(pixel, 16711680);			g += UBANDS(pixel, 65280);			b += UBANDS(pixel, 255);			pixel = in_[(srcIndex + inW) + 1];			r += UBANDS(pixel, 16711680);			g += UBANDS(pixel, 65280);			/* store combined RGB into target bitmap */			b += UBANDS(pixel, 255);			out[dstIndex] = (UBOR((UBANDS((r >>> 2), 16711680)), (UBOR((UBANDS((g >>> 2), 65280)), (b >>> 2)))));			srcIndex += 2;			++dstIndex;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveHalfSizeDiagonal(oop, inW, inH, oop1, outW, outH, srcX, srcY, dstX, dstY, dstW, dstH) {	let b;	let dstIndex;	let g;	let in_;	let out;	let p1;	let p2;	let r;	let srcIndex;	let x;	let y;	/* begin checkedUnsignedIntPtrOf: */	if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = oop.words;	/* end checkedUnsignedIntPtrOf: */	((typeof inW === "number") ? inW : PrimitiveFailed.signal());	((typeof inH === "number") ? inH : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(oop1.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = oop1.words;	/* end checkedUnsignedIntPtrOf: */	((typeof outW === "number") ? outW : PrimitiveFailed.signal());	((typeof outH === "number") ? outH : PrimitiveFailed.signal());	((typeof srcX === "number") ? srcX : PrimitiveFailed.signal());	((typeof srcY === "number") ? srcY : PrimitiveFailed.signal());	((typeof dstX === "number") ? dstX : PrimitiveFailed.signal());	((typeof dstY === "number") ? dstY : PrimitiveFailed.signal());	((typeof dstW === "number") ? dstW : PrimitiveFailed.signal());	((typeof dstH === "number") ? dstH : PrimitiveFailed.signal());	if (!((srcX >= 0) && (srcY >= 0))) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((srcX + (2 * dstW)) <= inW)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((srcY + (2 * dstH)) <= inH)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstX >= 0) && (dstY >= 0))) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstX + dstW) <= outW)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!((dstY + dstH) <= outH)) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (y = 0; y < dstH; y++) {		srcIndex = (inW * (srcY + (2 * y))) + srcX;		dstIndex = (outW * (dstY + y)) + dstX;		for (x = 0; x < dstW; x++) {			p1 = in_[srcIndex];			p2 = in_[(srcIndex + inW) + 1];			r = UBANDS((((UBANDS(p1, 16711680)) + (UBANDS(p2, 16711680))) >>> 1), 16711680);			g = UBANDS((((UBANDS(p1, 65280)) + (UBANDS(p2, 65280))) >>> 1), 65280);			/* store combined RGB into target bitmap */			b = ((UBANDS(p1, 255)) + (UBANDS(p2, 255))) >>> 1;			out[dstIndex] = (UBOR(r, (UBOR(g, b))));			srcIndex += 2;			++dstIndex;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveHueShift(inOop, outOop, shift) {	let b;	let brightness;	let g;	let hue;	let i;	let in_;	let max;	let min;	let out;	let pix;	let r;	let saturation;	let sz;	let hF;	let hI;	let outPix;	let p;	let q;	let t;	let v;	((typeof shift === "number") ? shift : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (i = 0; i < sz; i++) {		pix = UBANDS(in_[i], 16777215);		if (pix !== 0) {			/* skip pixel values of 0 (transparent) */			r = UBANDS((pix >>> 16), 255);			g = UBANDS((pix >>> 8), 255);			/* find min and max color components */			b = UBANDS(pix, 255);			max = (min = r);			if (g > max) {				max = g;			}			if (b > max) {				max = b;			}			if (g < min) {				min = g;			}			if (b < min) {				min = b;			}			brightness = Math.trunc((max * 1000) / 255);			saturation = (max === 0) ? 0 : (Math.trunc(((max - min) * 1000) / max));			if (brightness < 110) {				/* force black to a very dark, saturated gray */				brightness = 110;				saturation = 1000;			}			if (saturation < 90) {				saturation = 90;			}			hue = ((brightness === 110) || (saturation === 90)) ? 0 : ScratchPlugin.hueFromRGBminmax(r, g, b, min, max);			/* compute new hue */			hue = MOD(((hue + shift) + 360000000), 360);			/* begin bitmap:at:putH:s:v: */			hI = Math.trunc(hue / 60);			hF = MOD(hue, 60);			p = (1000 - saturation) * brightness;			q = (1000 - (Math.trunc((saturation * hF) / 60))) * brightness;			t = (1000 - (Math.trunc((saturation * (60 - hF)) / 60))) * brightness;			v = Math.trunc((brightness * 1000) / 3922);			p = Math.trunc(p / 3922);			q = Math.trunc(q / 3922);			t = Math.trunc(t / 3922);						switch (hI) {			case 0:								outPix = ((v << 16 >>> 0) + (t << 8 >>> 0)) + p;				break;			case 1:								outPix = ((q << 16 >>> 0) + (v << 8 >>> 0)) + p;				break;			case 2:								outPix = ((p << 16 >>> 0) + (v << 8 >>> 0)) + t;				break;			case 3:								outPix = ((p << 16 >>> 0) + (q << 8 >>> 0)) + v;				break;			case 4:								outPix = ((t << 16 >>> 0) + (p << 8 >>> 0)) + v;				break;			case 5:								outPix = ((v << 16 >>> 0) + (p << 8 >>> 0)) + q;				break;			default:								null;			}			if (outPix === 0) {				outPix = 1;			}			out[i] = outPix;			/* end bitmap:at:putH:s:v: */		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveInterpolate(inOop, width, xFixed, yFixed) {	let in_;	let result;	let sz;	let h;	let bottomPix;	let index;	let topPix;	let x;	let xFrac;	let y;	let yFrac;	let zzzTemp;	let zzzTemp1;	let pix2;	let b;	let frac1;	let g;	let r;	let result1;	let zzzTemp2;	let pix21;	let b1;	let frac11;	let g1;	let r1;	let result2;	let zzzTemp3;	let b2;	let frac12;	let g2;	let r2;	let result3;	let zzzTemp4;	((typeof width === "number") ? width : PrimitiveFailed.signal());	((typeof xFixed === "number") ? xFixed : PrimitiveFailed.signal());	((typeof yFixed === "number") ? yFixed : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	;	/* begin interpolatedFrom:x:y:width:height: */	h = Math.trunc(sz / width);	x = xFixed >>> 10;	if ((x < -1) || (x >= width)) {		result = 0;	} else {		y = yFixed >>> 10;		if ((y < -1) || (y >= h)) {			zzzTemp = 0;		} else {			xFrac = UBANDS(xFixed, 1023);			if (x === -1) {				x = 0;				xFrac = 0;			}			if (x === (width - 1)) {				xFrac = 0;			}			yFrac = UBANDS(yFixed, 1023);			if (y === -1) {				y = 0;				yFrac = 0;			}			if (y === (h - 1)) {				yFrac = 0;			}			index = (y * width) + x;			topPix = UBANDS(in_[index], 16777215);			if (xFrac > 0) {				/* begin interpolate:and:frac: */				pix2 = UBANDS(in_[index + 1], 16777215);				if (topPix === 0) {					topPix = pix2;				} else {					if (pix2 === 0) {						zzzTemp2 = topPix;					} else {						frac1 = 1024 - xFrac;						r = ((frac1 * (UBANDS((topPix >>> 16), 255))) + (xFrac * (UBANDS((pix2 >>> 16), 255)))) >> 10;						g = ((frac1 * (UBANDS((topPix >>> 8), 255))) + (xFrac * (UBANDS((pix2 >>> 8), 255)))) >> 10;						b = ((frac1 * (UBANDS(topPix, 255))) + (xFrac * (UBANDS(pix2, 255)))) >> 10;						result1 = ((r << 16 >>> 0) + (g << 8 >>> 0)) + b;						if (result1 === 0) {							result1 = 1;						}						zzzTemp2 = result1;					}					topPix = zzzTemp2;				}				/* end interpolate:and:frac: */			}			if (yFrac === 0) {				zzzTemp1 = topPix;			} else {				index = ((y + 1) * width) + x;				bottomPix = UBANDS(in_[index], 16777215);				if (xFrac > 0) {					/* begin interpolate:and:frac: */					pix21 = UBANDS(in_[index + 1], 16777215);					if (bottomPix === 0) {						bottomPix = pix21;					} else {						if (pix21 === 0) {							zzzTemp3 = bottomPix;						} else {							frac11 = 1024 - xFrac;							r1 = ((frac11 * (UBANDS((bottomPix >>> 16), 255))) + (xFrac * (UBANDS((pix21 >>> 16), 255)))) >> 10;							g1 = ((frac11 * (UBANDS((bottomPix >>> 8), 255))) + (xFrac * (UBANDS((pix21 >>> 8), 255)))) >> 10;							b1 = ((frac11 * (UBANDS(bottomPix, 255))) + (xFrac * (UBANDS(pix21, 255)))) >> 10;							result2 = ((r1 << 16 >>> 0) + (g1 << 8 >>> 0)) + b1;							if (result2 === 0) {								result2 = 1;							}							zzzTemp3 = result2;						}						bottomPix = zzzTemp3;					}					/* end interpolate:and:frac: */				}				/* begin interpolate:and:frac: */				if (topPix === 0) {					zzzTemp1 = bottomPix;				} else {					if (bottomPix === 0) {						zzzTemp4 = topPix;					} else {						frac12 = 1024 - yFrac;						r2 = ((frac12 * (UBANDS((topPix >>> 16), 255))) + (yFrac * (UBANDS((bottomPix >>> 16), 255)))) >> 10;						g2 = ((frac12 * (UBANDS((topPix >>> 8), 255))) + (yFrac * (UBANDS((bottomPix >>> 8), 255)))) >> 10;						b2 = ((frac12 * (UBANDS(topPix, 255))) + (yFrac * (UBANDS(bottomPix, 255)))) >> 10;						result3 = ((r2 << 16 >>> 0) + (g2 << 8 >>> 0)) + b2;						if (result3 === 0) {							result3 = 1;						}						zzzTemp4 = result3;					}					zzzTemp1 = zzzTemp4;				}				/* end interpolate:and:frac: */			}			zzzTemp = zzzTemp1;		}		result = zzzTemp;	}	/* end interpolatedFrom:x:y:width:height: */	throw Object.create(PrimitiveReturn).setPayload(((typeof result === "number") ? result : PrimitiveFailed.signal()));	return 0;}, primitiveSaturationShift(inOop, outOop, shift) {	let b;	let brightness;	let g;	let hue;	let i;	let in_;	let max;	let min;	let out;	let pix;	let r;	let saturation;	let sz;	let result;	let span;	let hF;	let hI;	let outPix;	let p;	let q;	let t;	let v;	((typeof shift === "number") ? shift : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	for (i = 0; i < sz; i++) {		pix = UBANDS(in_[i], 16777215);		if (!(pix < 2)) {			/* skip pixel values of 0 (transparent) and 1 (black) */			r = UBANDS((pix >>> 16), 255);			g = UBANDS((pix >>> 8), 255);			/* find min and max color components */			b = UBANDS(pix, 255);			max = (min = r);			if (g > max) {				max = g;			}			if (b > max) {				max = b;			}			if (g < min) {				min = g;			}			if (b < min) {				min = b;			}			brightness = Math.trunc((max * 1000) / 255);			saturation = (max === 0) ? 0 : (Math.trunc(((max - min) * 1000) / max));			if (saturation > 0) {				/* do nothing if pixel is unsaturated (gray) */				/* begin hueFromR:G:B:min:max: */				span = max - min;				if (span === 0) {					hue = 0;				} else {					result = (r === max) ? (Math.trunc((60 * (g - b)) / span)) : ((g === max) ? (120 + (Math.trunc((60 * (b - r)) / span))) : (240 + (Math.trunc((60 * (r - g)) / span))));					hue = (result < 0) ? (result + 360) : result;				}				/* end hueFromR:G:B:min:max: */				saturation += shift * 10;				if (saturation > 1000) {					saturation = 1000;				}				if (saturation < 0) {					saturation = 0;				}				/* begin bitmap:at:putH:s:v: */				hI = Math.trunc(hue / 60);				hF = MOD(hue, 60);				p = (1000 - saturation) * brightness;				q = (1000 - (Math.trunc((saturation * hF) / 60))) * brightness;				t = (1000 - (Math.trunc((saturation * (60 - hF)) / 60))) * brightness;				v = Math.trunc((brightness * 1000) / 3922);				p = Math.trunc(p / 3922);				q = Math.trunc(q / 3922);				t = Math.trunc(t / 3922);								switch (hI) {				case 0:										outPix = ((v << 16 >>> 0) + (t << 8 >>> 0)) + p;					break;				case 1:										outPix = ((q << 16 >>> 0) + (v << 8 >>> 0)) + p;					break;				case 2:										outPix = ((p << 16 >>> 0) + (v << 8 >>> 0)) + t;					break;				case 3:										outPix = ((p << 16 >>> 0) + (q << 8 >>> 0)) + v;					break;				case 4:										outPix = ((t << 16 >>> 0) + (p << 8 >>> 0)) + v;					break;				case 5:										outPix = ((v << 16 >>> 0) + (p << 8 >>> 0)) + q;					break;				default:										null;				}				if (outPix === 0) {					outPix = 1;				}				out[i] = outPix;				/* end bitmap:at:putH:s:v: */			}		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Scale using bilinear interpolation. *//*	This version isn't really able to do much with full ARGB based images; the A channel will be ignored and only fully transparent pixels will be treated as transparent. The output pixel will be either fully transparent or fully opaque. */primitiveScale(inOop, inW, inH, outOop, outW, outH) {	let in_;	let inX;	let inY;	let out;	let outPix;	let outX;	let outY;	let p1;	let p2;	let p3;	let p4;	let t;	let tWeight;	let w1;	let w2;	let w3;	let w4;	let xIncr;	let yIncr;	((typeof inW === "number") ? inW : PrimitiveFailed.signal());	((typeof inH === "number") ? inH : PrimitiveFailed.signal());	((typeof outW === "number") ? outW : PrimitiveFailed.signal());	((typeof outH === "number") ? outH : PrimitiveFailed.signal());	if (SIZEOF(inOop) !== (inW * inH)) throw Object.create(PrimitiveFailed).setPayload(1);	if (SIZEOF(outOop) !== (outW * outH)) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	;	/* source x and y, scaled by 1024 */	inX = (inY = 0);	/* source x increment, scaled by 1024 */	xIncr = Math.trunc((inW * 1024) / outW);	/* source y increment, scaled by 1024 */	yIncr = Math.trunc((inH * 1024) / outH);	for (outY = 0; outY < outH; outY++) {		inX = 0;		for (outX = 0; outX < outW; outX++) {			/* compute weights, scaled by 2^20 */			w1 = (1024 - (UBANDS(inX, 1023))) * (1024 - (UBANDS(inY, 1023)));			w2 = (UBANDS(inX, 1023)) * (1024 - (UBANDS(inY, 1023)));			w3 = (1024 - (UBANDS(inX, 1023))) * (UBANDS(inY, 1023));			/* get source pixels */			w4 = (UBANDS(inX, 1023)) * (UBANDS(inY, 1023));			t = ((inY >>> 10) * inW) + (inX >>> 10);			p1 = in_[t];			p2 = ((inX >>> 10) < (inW - 1)) ? in_[t + 1] : p1;			if ((inY >>> 10) < (inH - 1)) {				t += inW;			}			p3 = in_[t];			/* deal with transparent pixels */			/* Note as above - only transparent not translucent */			p4 = ((inX >>> 10) < (inW - 1)) ? in_[t + 1] : p3;			tWeight = 0;			if (p1 === 0) {				p1 = p2;				tWeight += w1;			}			if (p2 === 0) {				p2 = p1;				tWeight += w2;			}			if (p3 === 0) {				p3 = p4;				tWeight += w3;			}			if (p4 === 0) {				p4 = p3;				tWeight += w4;			}			if (p1 === 0) {				p1 = p3;				p2 = p4;			}			if (p3 === 0) {				p3 = p1;				p4 = p2;			}			outPix = 0;			if (tWeight < 500000) {				/* compute an (opaque) output pixel if less than 50% transparent */				t = (((w1 * (UBANDS((p1 >>> 16), 255))) + (w2 * (UBANDS((p2 >>> 16), 255)))) + (w3 * (UBANDS((p3 >>> 16), 255)))) + (w4 * (UBANDS((p4 >>> 16), 255)));				outPix = (UBANDS((t >>> 20), 255)) << 16 >>> 0;				t = (((w1 * (UBANDS((p1 >>> 8), 255))) + (w2 * (UBANDS((p2 >>> 8), 255)))) + (w3 * (UBANDS((p3 >>> 8), 255)))) + (w4 * (UBANDS((p4 >>> 8), 255)));				outPix = UBOR(outPix, ((UBANDS((t >>> 20), 255)) << 8 >>> 0));				t = (((w1 * (UBANDS(p1, 255))) + (w2 * (UBANDS(p2, 255)))) + (w3 * (UBANDS(p3, 255)))) + (w4 * (UBANDS(p4, 255)));				/* If the result is black, remember to make it Squeak-standard-fake-black */				outPix = UBOR(outPix, (UBANDS((t >>> 20), 255)));				if (outPix === 0) {					outPix = 1;				}				outPix = UBORM(outPix, 2130706432);			}			out[(outY * outW) + outX] = outPix;			inX += xIncr;		}		inY += yIncr;	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveWaterRipples1(inOop, outOop, width, ripply, aArOop, bArOop) {	let aArray;	let allPix;	let bArray;	let blops;	let d;	let dist;	let dx;	let dx2;	let dy;	let dy2;	let f;	let g;	let h;	let height;	let i;	let in_;	let j;	let newLoc;	let out;	let pix;	let power;	let q;	let t;	let t1;	let temp;	let val;	let val2;	let x;	let y;	((typeof width === "number") ? width : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	allPix = SIZEOF(inOop);	((typeof ripply === "number") ? ripply : PrimitiveFailed.signal());	/* begin checkedFloatPtrOf: */	if (!(["words", "bytes"].indexOf(aArOop.storageType) !== -1)) throw Object.create(PrimitiveFailed).setPayload(1);	aArray = aArOop.wordsAsFloat64Array();	/* end checkedFloatPtrOf: */	/* begin checkedFloatPtrOf: */	if (!(["words", "bytes"].indexOf(bArOop.storageType) !== -1)) throw Object.create(PrimitiveFailed).setPayload(1);	bArray = bArOop.wordsAsFloat64Array();	/* end checkedFloatPtrOf: */	if (SIZEOF(outOop) !== allPix) throw Object.create(PrimitiveFailed).setPayload(1);	;	height = Math.trunc(allPix / width);	t1 = Math.random();	blops = (MOD(t1, ripply)) - 1;	const tLimiT = blops / 2;	for (t = 0; t < tLimiT; t++) {		t1 = Math.random();		x = MOD(t1, width);		t1 = Math.random();		y = MOD(t1, height);		t1 = Math.random();		power = MOD(t1, 8);		for (g = -4; g <= 4; g++) {			for (h = -4; h <= 4; h++) {				dist = ((g * g) + (h * h));				if ((dist < 25) && (dist > 0)) {					dx = ((x + g) | 0);					dy = ((y + h) | 0);					if ((dx > 0) && ((dy > 0) && ((dy < height) && (dx < width)))) {						aArray[(dy * width) + dx] = (power * (1.0 - (dist / 25.0)));					}				}			}		}	}	const fLimiT = width - 2;	for (f = 1; f <= fLimiT; f++) {		const dLimiT = height - 2;		for (d = 1; d <= dLimiT; d++) {			val = (d * width) + f;			aArray[val] = (((((((((bArray[val + 1] + bArray[val - 1]) + bArray[val + width]) + bArray[val - width]) + (bArray[(val - 1) - width] / 2)) + (bArray[(val - 1) + width] / 2)) + (bArray[(val + 1) - width] / 2)) + (bArray[(val + 1) + width] / 2)) / 4) - aArray[val]);			aArray[val] = (aArray[val] * 0.9);		}	}	const qLimiT = width * height;	for (q = 0; q <= qLimiT; q++) {		temp = bArray[q];		bArray[q] = aArray[q];		aArray[q] = temp;	}	for (j = 0; j < height; j++) {		for (i = 0; i < width; i++) {			if ((i > 1) && ((i < (width - 1)) && ((j > 1) && (j < (height - 1))))) {				val2 = (j * width) + i;				dx2 = (((aArray[val2] - aArray[val2 - 1]) + (aArray[val2 + 1] - aArray[val2])) * 64);				dy2 = (((aArray[val2] - aArray[val2 - width]) + (aArray[val2 + width] - aArray[val2])) / 64);				if (dx2 < -2) {					dx2 = -2;				}				if (dx2 > 2) {					dx2 = 2;				}				if (dy2 < -2) {					dy2 = -2;				}				if (dy2 > 2) {					dy2 = 2;				}				newLoc = ((((j + dy2) * width) + (i + dx2)) | 0);				pix = ((newLoc < (width * height)) && (newLoc >= 0)) ? in_[newLoc] : in_[i + (j * width)];			} else {				pix = in_[i + (j * width)];			}			out[i + (j * width)] = pix;		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveWhirl(inOop, outOop, width, degrees) {	let ang;	let centerX;	let centerY;	let cosa;	let d;	let dx;	let dy;	let factor;	let height;	let in_;	let out;	let pix;	let radius;	let radiusSquared;	let scaleX;	let scaleY;	let sina;	let sz;	let whirlRadians;	let x;	let y;	let xFixed;	let yFixed;	let bottomPix;	let index;	let topPix;	let x1;	let xFrac;	let y1;	let yFrac;	let zzzTemp;	let zzzTemp1;	let pix2;	let b;	let frac1;	let g;	let r;	let result;	let zzzTemp2;	let pix21;	let b1;	let frac11;	let g1;	let r1;	let result1;	let zzzTemp3;	let b2;	let frac12;	let g2;	let r2;	let result2;	let zzzTemp4;	((typeof width === "number") ? width : PrimitiveFailed.signal());	((typeof degrees === "number") ? degrees : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(inOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	in_ = inOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(outOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	out = outOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(inOop);	if (SIZEOF(outOop) !== sz) throw Object.create(PrimitiveFailed).setPayload(1);	;	height = Math.trunc(sz / width);	centerX = width >> 1;	centerY = height >> 1;	if (centerX < centerY) {		radius = centerX;		scaleX = centerY / centerX;		scaleY = 1.0;	} else {		radius = centerY;		scaleX = 1.0;		scaleY = (centerY < centerX) ? (centerX / centerY) : 1.0;	}	whirlRadians = (-3.141592653589793 * degrees) / 180.0;	radiusSquared = (radius * radius);	for (x = 0; x < width; x++) {		for (y = 0; y < height; y++) {			dx = scaleX * (x - centerX);			dy = scaleY * (y - centerY);			d = (dx * dx) + (dy * dy);			if (d < radiusSquared) {				/* inside the whirl circle */				factor = 1.0 - (Math.sqrt(d) / radius);				ang = whirlRadians * (factor * factor);				sina = Math.sin(ang);				cosa = Math.cos(ang);				/* begin interpolatedFrom:x:y:width:height: */				xFixed = ((1024.0 * ((((cosa * dx) - (sina * dy)) / scaleX) + centerX)) | 0);				yFixed = ((1024.0 * ((((sina * dx) + (cosa * dy)) / scaleY) + centerY)) | 0);				x1 = xFixed >>> 10;				if ((x1 < -1) || (x1 >= width)) {					pix = 0;				} else {					y1 = yFixed >>> 10;					if ((y1 < -1) || (y1 >= height)) {						zzzTemp = 0;					} else {						xFrac = UBANDS(xFixed, 1023);						if (x1 === -1) {							x1 = 0;							xFrac = 0;						}						if (x1 === (width - 1)) {							xFrac = 0;						}						yFrac = UBANDS(yFixed, 1023);						if (y1 === -1) {							y1 = 0;							yFrac = 0;						}						if (y1 === (height - 1)) {							yFrac = 0;						}						index = (y1 * width) + x1;						topPix = UBANDS(in_[index], 16777215);						if (xFrac > 0) {							/* begin interpolate:and:frac: */							pix2 = UBANDS(in_[index + 1], 16777215);							if (topPix === 0) {								topPix = pix2;							} else {								if (pix2 === 0) {									zzzTemp2 = topPix;								} else {									frac1 = 1024 - xFrac;									r = ((frac1 * (UBANDS((topPix >>> 16), 255))) + (xFrac * (UBANDS((pix2 >>> 16), 255)))) >> 10;									g = ((frac1 * (UBANDS((topPix >>> 8), 255))) + (xFrac * (UBANDS((pix2 >>> 8), 255)))) >> 10;									b = ((frac1 * (UBANDS(topPix, 255))) + (xFrac * (UBANDS(pix2, 255)))) >> 10;									result = ((r << 16 >>> 0) + (g << 8 >>> 0)) + b;									if (result === 0) {										result = 1;									}									zzzTemp2 = result;								}								topPix = zzzTemp2;							}							/* end interpolate:and:frac: */						}						if (yFrac === 0) {							zzzTemp1 = topPix;						} else {							index = ((y1 + 1) * width) + x1;							bottomPix = UBANDS(in_[index], 16777215);							if (xFrac > 0) {								/* begin interpolate:and:frac: */								pix21 = UBANDS(in_[index + 1], 16777215);								if (bottomPix === 0) {									bottomPix = pix21;								} else {									if (pix21 === 0) {										zzzTemp3 = bottomPix;									} else {										frac11 = 1024 - xFrac;										r1 = ((frac11 * (UBANDS((bottomPix >>> 16), 255))) + (xFrac * (UBANDS((pix21 >>> 16), 255)))) >> 10;										g1 = ((frac11 * (UBANDS((bottomPix >>> 8), 255))) + (xFrac * (UBANDS((pix21 >>> 8), 255)))) >> 10;										b1 = ((frac11 * (UBANDS(bottomPix, 255))) + (xFrac * (UBANDS(pix21, 255)))) >> 10;										result1 = ((r1 << 16 >>> 0) + (g1 << 8 >>> 0)) + b1;										if (result1 === 0) {											result1 = 1;										}										zzzTemp3 = result1;									}									bottomPix = zzzTemp3;								}								/* end interpolate:and:frac: */							}							/* begin interpolate:and:frac: */							if (topPix === 0) {								zzzTemp1 = bottomPix;							} else {								if (bottomPix === 0) {									zzzTemp4 = topPix;								} else {									frac12 = 1024 - yFrac;									r2 = ((frac12 * (UBANDS((topPix >>> 16), 255))) + (yFrac * (UBANDS((bottomPix >>> 16), 255)))) >> 10;									g2 = ((frac12 * (UBANDS((topPix >>> 8), 255))) + (yFrac * (UBANDS((bottomPix >>> 8), 255)))) >> 10;									b2 = ((frac12 * (UBANDS(topPix, 255))) + (yFrac * (UBANDS(bottomPix, 255)))) >> 10;									result2 = ((r2 << 16 >>> 0) + (g2 << 8 >>> 0)) + b2;									if (result2 === 0) {										result2 = 1;									}									zzzTemp4 = result2;								}								zzzTemp1 = zzzTemp4;							}							/* end interpolate:and:frac: */						}						zzzTemp = zzzTemp1;					}					pix = zzzTemp;				}				/* end interpolatedFrom:x:y:width:height: */				out[(width * y) + x] = pix;			}		}	}	return 0;	throw Object.create(PrimitiveReturn).setPayload(this);}, }