/* * Copyright (c) 2021  Florin Mateoc * * This file is part of JsSqueak. * * JsSqueak is free software: you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JsSqueak is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with JsSqueak.  If not, see <https://www.gnu.org/licenses/>. *//* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 11 May 2021 6:40:39 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	FilePlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */const VM_PROXY_MAJOR = 1const VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) / 2 * 4 : 0 }function DIV(a, b) { return Math.trunc(a / b) | 0 }   // integer divisionfunction MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulusfunction SHL(a, b) { return b > 31 ? 0 : a << b }function SHR(a, b) { return b > 31 ? 0 : a >>> b }function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? 0 : a << b) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Constants ***/const DirBadPath = 2;const DirNoMoreEntries = 1;const PrimErrBadArgument = 3;const PrimErrBadIndex = 4;const PrimErrNoMemory = 9;const PrimErrObjectMayMove = 14;const PrimErrUnsupported = 7;const PrimNoErr = 0;/*** Variables ***/let interpreterProxy;let moduleName = "FilePlugin 11 May 2021 (e)";let sCCPfn;let sCDFfn;let sCDPfn;let sCGFTfn;let sCLPfn;let sCOFfn;let sCRFfn;let sCSFTfn;let sDFAfn;let sHFAfn;Squeak.bytesAsString = function (bytes) {	const stString = new SmalltalkGlobals._ByteString();	stString.bytes = bytes;	stString.recreateCacheFromStorage();	return stString.string;}globalThis.FilePlugin = {primitiveDirectoryCreate(dirName) {	if (!(dirName.storageType() === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!Squeak.dirCreate(dirName.string)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDirectoryDelete(dirName) {	if (!(dirName.storageType() === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!Squeak.dirDelete(dirName.string)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDirectoryDelimitor() {	throw Object.create(PrimitiveReturn).setPayload('/');},primitiveDirectoryEntry: function(dirNameObj, fileNameObj) {	const fileName = FilePlugin.filenameFromSqueak(fileNameObj.string);	const dirName = FilePlugin.filenameFromSqueak(dirNameObj.string);	const entries = Squeak.dirList(dirName, true);	if (!entries) {		const path = Squeak.splitFilePath(dirName);		console.log("Directory not found: " + path.fullname);		throw Object.create(PrimitiveFailed).setPayload(1);	}	const entry = entries[fileName];	if (entry)		throw Object.create(PrimitiveReturn).setPayload(SmalltalkGlobals._Array.from(entry));	else		throw Object.create(PrimitiveReturn).setPayload(nil);},primitiveDirectoryLookup(pathName, index) {	!Number.isSafeInteger(index.valueOf()) ? PrimitiveFailed.signal() : index;	if (!(pathName.storageType() === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const sqDirName = pathName.string;	const dirName = FilePlugin.filenameFromSqueak(sqDirName);	const entries = Squeak.dirList(dirName, true);	if (!entries) {		const path = Squeak.splitFilePath(dirName);		console.log("Directory not found: " + path.fullname);		throw Object.create(PrimitiveFailed).setPayload(1);	}	let keys = Object.keys(entries).sort(),		entry = entries[keys[index - 1]];	if (sqDirName === "/") { // fake top-level dir		if (index === 1) {			if (!entry) entry = [0, 0, 0, 0, 0];			entry[0] = "JsSqueak";			entry[3] = true;		}		else entry = null;	}	if (entry)		throw Object.create(PrimitiveReturn).setPayload(SmalltalkGlobals._Array.from(entry));	else		throw Object.create(PrimitiveReturn).setPayload(nil);}, /*	If the security plugin can be loaded, use it to turn off file access	 If not, assume it's ok */primitiveDisableFileAccess() {	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileAtEnd(handle) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.filePos >= handle.file.size);}, primitiveFileClose(handle) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof handle.file === "string") {		FilePlugin.fileConsoleFlush(handle.file);	} else {		const file = handle.file;		Squeak.flushFile(file);		if (--file.refCount === 0)			delete SqueakFiles[file.name];		handle.file = null;		throw Object.create(PrimitiveYield).setPayload({completed: true, value: this});     // return to JS asap so async file handler can run	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileDelete(namePointer) {	if (!(namePointer.storageType() === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const fileName = FilePlugin.filenameFromSqueak(namePointer.string);	if (!Squeak.fileDelete(fileName)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveYield).setPayload({completed: true, value: this});     // return to JS asap so async file handler can run}, primitiveFileFlush(handle) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof handle.file === "string") {		FilePlugin.fileConsoleFlush(handle.file);	} else {		Squeak.flushFile(handle.file);		throw Object.create(PrimitiveYield).setPayload({completed: true, value: this});     // return to JS asap so async file handler can run	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileGetPosition(handle) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.filePos);},	makeFileHandle: function(filename, file, writeFlag) {		const handle = SmalltalkGlobals._ByteString.from("squeakjs:" + filename);		handle.file = file;             // shared between handles		handle.fileWrite = writeFlag;   // specific to this handle		handle.filePos = 0;             // specific to this handle		return handle;	},primitiveFileOpen(namePointer, _arg2) {	const writeFlag = typeof _arg2.valueOf() !== "boolean" ? PrimitiveFailed.signal() : _arg2;	if (!(namePointer.storageType() === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	let filepath = FilePlugin.filenameFromSqueak(namePointer.string);	// if a file is opened for read and write at the same time,	// they must share the contents. That's why all open files	// are held in the ref-counted global SqueakFiles	if (typeof SqueakFiles == 'undefined')		window.SqueakFiles = {};	if (filepath[0] !== '/') filepath = '/' + filepath;	filepath = filepath.replace(/\/\//g, '/');      // replace double-slashes	const matches = filepath.match(/(.*)\/(.*)/),		dirname = matches[1] ? matches[1] : '/',		basename = matches[2] ? matches[2] : null,		path = {fullname: filepath, dirname: dirname, basename: basename};	if (!path.basename)	    // malformed filename		throw Object.create(PrimitiveFailed).setPayload(1);	// fetch or create directory entry	const directory = Squeak.dirList(path.dirname, true);	if (!directory)		throw Object.create(PrimitiveFailed).setPayload(1);	let entry = directory[path.basename],		contents = null,		file;	if (entry) {		// if it is open already, return it		file = SqueakFiles[path.fullname];		if (file) {			++file.refCount;		} else {			// make the file object			file = {				name: path.fullname,				size: entry[4],         // actual file size, may differ from contents.length				contents: contents,     // possibly null, fetched when needed				modified: false,				refCount: 1			};			SqueakFiles[file.name] = file;		}		const handle = FilePlugin.makeFileHandle(file.name, file, writeFlag);		throw Object.create(PrimitiveReturn).setPayload(handle);	} else {		if (!writeFlag) {			console.log("File not found: " + path.fullname);			throw Object.create(PrimitiveFailed).setPayload(1);		}		contents = new Uint8Array();		const holder = {completed: false};		entry = Squeak.filePut(path.fullname, contents.buffer, function () {			holder.completed = true;		});		if (!entry) {			console.log("Cannot create file: " + path.fullname);			throw Object.create(PrimitiveFailed).setPayload(1);		}		// make the file object		file = {			name: path.fullname,			size: entry[4],         // actual file size, may differ from contents.length			contents: contents,     // possibly null, fetched when needed			modified: false,			refCount: 1		};		SqueakFiles[file.name] = file;		holder.value = FilePlugin.makeFileHandle(file.name, file, writeFlag);		throw Object.create(PrimitiveYield).setPayload(holder);     // return to JS asap so async file handler can run	}},primitiveFileRead(handle, array, _arg3, _arg4) {	let count = Number.isSafeInteger(_arg4.valueOf()) && _arg4 >= 0 ? _arg4 : PrimitiveFailed.signal();	const startIndex = Number.isSafeInteger(_arg3.valueOf()) && _arg3 >= 0 ? _arg3 - 1 : PrimitiveFailed.signal();	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(["words", "bytes"].indexOf(array.storageType()) !== -1)) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadArgument);	}	if (count === 0)		throw Object.create(PrimitiveReturn).setPayload(0);	const size = (array.storageType() === "words") ? array.words.length : array.bytes.length;	if (startIndex < 0 || startIndex + count > size) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadIndex);	}	if (typeof handle.file === "string") {		//this.fileConsoleRead(handle.file, array, startIndex, count);		throw Object.create(PrimitiveReturn).setPayload(0);	}	const holder = {completed: false};	FilePlugin.fileContentsDo(handle.file, function(file) {		if (!file.contents)			throw Object.create(PrimitiveReturn).setPayload(0);		let srcArray, dstArray;		if (array.storageType() === "words") {			srcArray = new Uint32Array(file.contents.buffer);			dstArray = array.words;			count = Math.min(count, (file.size - handle.filePos) >>> 2);			for (let i = 0; i < count; i++)				dstArray[startIndex + i] = srcArray[handle.filePos + i];			handle.filePos += count << 2;		} else {			srcArray = file.contents;			dstArray = array.bytes;			count = Math.min(count, file.size - handle.filePos);			for (let i = 0; i < count; i++)				dstArray[startIndex + i] = srcArray[handle.filePos++];		}		holder.value = Math.max(0, count);		holder.completed = true;	}.bind(this));	throw Object.create(PrimitiveYield).setPayload(holder);},primitiveFileRename(oldNamePointer, newNamePointer) {	if (!((newNamePointer.storageType() === "bytes") && ((oldNamePointer.storageType() === "bytes")))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	const oldName = FilePlugin.filenameFromSqueak(oldNamePointer.string),		newName = FilePlugin.filenameFromSqueak(newNamePointer.string);	if (!Squeak.fileRename(oldName, newName)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveYield).setPayload({completed: true, value: this});     // return to JS asap so async file handler can run}, primitiveFileSetPosition(handle, _arg1) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(typeof _arg1.valueOf() === "number" && Number.isSafeInteger(_arg1.valueOf()) && _arg1 >= 0)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	handle.filePos = _arg1.valueOf();	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileSize(handle) {	if (!handle.file) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	throw Object.create(PrimitiveReturn).setPayload(handle.file.size);}, /*	Answer an Array of file handles for standard in, standard out and standard error,	 with nil in entries that are unvailable, e.g. because the platform does not provide	 standard error, etc.  Fail if there are no standard i/o facilities on the platform or	 if the security plugin denies access or if memory runs out. */primitiveFileStdioHandles() {	const handles = [		null, // stdin		FilePlugin.makeFileHandle('console.log', 'log', true),		FilePlugin.makeFileHandle('console.error', 'error', true),	];	const result = SmalltalkGlobals._Array.from(handles);	if (!result) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrNoMemory);	}	throw Object.create(PrimitiveReturn).setPayload(result);},/*	ftruncate is not an ansi function so we have a macro to point to a suitable platform implementation */primitiveFileTruncate(handle, _arg1) {	if (!handle.file || !handle.fileWrite) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(typeof _arg1.valueOf() === "number" && Number.isSafeInteger(_arg1.valueOf()))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (handle.file.size > _arg1) {		handle.file.size = _arg1;		handle.file.modified = true;		if (handle.filePos > handle.file.size) handle.filePos = handle.file.size;	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFileWrite(handle, array, _arg3, _arg4) {	let count;	let elementSize;	let startIndex;	count = Number.isSafeInteger(_arg4.valueOf()) && _arg4 >= 0 ? _arg4 : PrimitiveFailed.signal();	startIndex = Number.isSafeInteger(_arg3.valueOf()) && _arg3 > 0 ? _arg3 - 1 : PrimitiveFailed.signal();	if (!handle.file || !handle.fileWrite) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (count === 0)		throw Object.create(PrimitiveReturn).setPayload(0);	if (!(["words", "bytes"].indexOf(array.storageType()) !== -1)) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadArgument);	}	elementSize = (array.storageType() === "words") ? 4 : 1;	if (!((startIndex >= 0) && (startIndex + count <= SIZEOF(array)))) {		throw Object.create(PrimitiveFailed).setPayload(PrimErrBadIndex);	}	const bytes = array.bytes || new Uint8Array(array.words.buffer, 0, array.words.length * elementSize);	const byteCount = count * elementSize, byteStartIndex = startIndex * elementSize;	if (typeof handle.file === "string") {		FilePlugin.fileConsoleWrite(handle.file, bytes, byteStartIndex, byteCount);		throw Object.create(PrimitiveReturn).setPayload(count);	}	const holder = {completed: false};	FilePlugin.fileContentsDo(handle.file, function(file) {		let dstArray = file.contents || [];		if (handle.filePos + byteCount > dstArray.length) {			const newSize = dstArray.length === 0 ? handle.filePos + byteCount :				Math.max(handle.filePos + byteCount, dstArray.length + 10000);			file.contents = new Uint8Array(newSize);			file.contents.set(dstArray);			dstArray = file.contents;		}		for (let i = 0; i < byteCount; i++)			dstArray[handle.filePos++] = bytes[byteStartIndex + i];		if (handle.filePos > file.size) file.size = handle.filePos;		file.modified = true;		holder.value = count;		holder.completed = true;	}.bind(this));	throw Object.create(PrimitiveYield).setPayload(holder);}, primitiveHasFileAccess() {	throw Object.create(PrimitiveReturn).setPayload(true);},	asUint8Array: function(buffer) {		// A direct test of the buffer's constructor doesn't work on Safari 10.0.		if (buffer.constructor.name === "Uint8Array") return buffer;		if (buffer.constructor.name === "ArrayBuffer") return new Uint8Array(buffer);		if (typeof buffer === "string") {			const bytes = new Uint8Array(buffer.length);			let p = 0;			for (const c of buffer) {				const codePoint = c.codePointAt(0);				if (codePoint >= 256)					return SmalltalkGlobals._WideSymbol.from(buffer).wordsAsUint8Array();				bytes[p++] = codePoint;			}			return bytes;		}		throw Error("unknown buffer type");	},	fileContentsDo: function(file, func) {		if (file.contents) {			func(file);		} else {			if (file.contents === false) // failed to get contents before				throw Object.create(PrimitiveFailed).setPayload(1);			Squeak.fileGet(file.name,				function success(contents) {					if (contents == null) return error(file.name);					file.contents = FilePlugin.asUint8Array(contents);					func(file);				}.bind(this),				function error(msg) {					console.log("File get failed: " + msg);					file.contents = false;					func(file);				}.bind(this));		}	},	fileConsoleBuffer: {		log: '',		error: ''	},	fileConsoleWrite: function(logOrError, array, startIndex, count) {		// buffer until there is a newline		const bytes = array.subarray(startIndex, startIndex + count);		let buffer = FilePlugin.fileConsoleBuffer[logOrError] + Squeak.bytesAsString(bytes);		const lines = buffer.match('([^]*)\n(.*)');		if (lines) {			console[logOrError](lines[1]);  // up to last newline			buffer = lines[2];              // after last newline		}		FilePlugin.fileConsoleBuffer[logOrError] = buffer;	},	fileConsoleFlush: function(logOrError) {		const buffer = FilePlugin.fileConsoleBuffer[logOrError];		if (buffer) {			console[logOrError](buffer);			FilePlugin.fileConsoleBuffer[logOrError] = '';		}	},	filenameToSqueak: function(unixpath) {		return "/JsSqueak" + ((unixpath && unixpath[0]) === "/" ? "" : "/") + unixpath;                      // add JsSqueak	},	filenameFromSqueak: function(filepath) {		return filepath.replace(/^\/*JsSqueak\/?/, "/") || "/";            // strip JsSqueak /**/	},}