/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:19 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	KedamaPlugin2 Kedama-Plugins-yo.1 uuid: 3fc7d691-0149-ba4d-a339-5d27cd44a2f8 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let kedamaRandomSeed = 0;let randA = 0;let randM = 0;let randQ = 0;let randR = 0;globalThis.KedamaPlugin2 = {drawTurtlesInArray(destOop, destWidth, destHeight, xOop, yOop, colorOop, visibleOop) {	let bitsIndex;	let colorArray;	let destBits;	let i;	let size;	let visible;	let visibleArray;	let x;	let xArray;	let y;	let yArray;	if (!(typeof destHeight === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((destOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((colorOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((visibleOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((destHeight * destWidth) !== SIZEOF(destOop)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(xOop);	if (SIZEOF(yOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(colorOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(visibleOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	xArray = xOop.wordsAsFloat32Array();	yArray = yOop.wordsAsFloat32Array();	colorArray = colorOop.words;	visibleArray = BYTESOF(visibleOop);	destBits = destOop.words;	for (i = 0; i < size; i++) {		x = (xArray[i]|0);		y = (yArray[i]|0);		visible = visibleArray[i];		if ((visible !== 0) && (((x >= 0) && (y >= 0)) && ((x < destWidth) && (y < destHeight)))) {			bitsIndex = (y * destWidth) + x;			destBits[bitsIndex] = colorArray[i];		}	}}, getHeadingArrayInto(headingOop, resultOop) {	let heading;	let headingArray;	let i;	let resultArray;	let size;	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((resultOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(headingOop);	if (SIZEOF(resultOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	headingArray = headingOop.wordsAsFloat32Array();	resultArray = resultOop.wordsAsFloat32Array();	for (i = 0; i < size; i++) {		heading = headingArray[i];		heading = heading / 0.0174532925199433;		heading = 90.0 - heading;		if (heading <= 0.0) {			heading += 360.0;		}		resultArray[i] = heading;	}}, getScalarHeading(index, headingOop) {	let heading;	let headingArray;	let deg;	let degrees;	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) < index) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	headingArray = headingOop.wordsAsFloat32Array();	heading = headingArray[index - 1];	/* begin radiansToDegrees: */	degrees = heading / 0.0174532925199433;	deg = 90.0 - degrees;	if (deg <= 0.0) {		deg += 360.0;	}	heading = deg;	/* end radiansToDegrees: */	throw Object.create(PrimitiveReturn).setPayload(typeof heading.valueOf() !== "number" ? PrimitiveFailed.signal() : ((heading.valueOf() | 0 === heading.valueOf()) || Number.isSafeInteger(heading) ? new Float(heading) : heading.valueOf()));}, initialiseModule() {	kedamaRandomSeed = 17;	/*  magic constant =      16807  */	randA = 16807;	/*  magic constant = 2147483647  */	randM = 2147483647;	randQ = Math.trunc(randM / randA);	randR = MOD(randM, randA);}, kedamaRandom2(range) {	let hi;	let lo;	let r;	let v;	let val;	r = (range < 0) ? (0 - range) : range;	hi = Math.trunc(kedamaRandomSeed / randQ);	lo = MOD(kedamaRandomSeed, randQ);	kedamaRandomSeed = (randA * lo) - (randR * hi);	v = UBANDS(kedamaRandomSeed, 65535);	val = (v * (r + 1)) >>> 16;	return (range < 0) ? (0 - val) : val;}, kedamaSetRandomSeed(seed) {	if (!(typeof seed === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	kedamaRandomSeed = UBANDS(seed, 65536);}, makeMask(dataBits, maskBits, pixel, shiftAmount) {	let alpha;	let dOrigin;	let data;	let dataSize;	let highMask;	let i;	let mOrigin;	let maskSize;	if (!(typeof shiftAmount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof pixel === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	dataSize = SIZEOF(dataBits);	maskSize = SIZEOF(maskBits);	if (dataSize !== maskSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (shiftAmount < -32) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (shiftAmount > 8) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	dOrigin = dataBits.words;	mOrigin = maskBits.words;	highMask = 4278190080;	for (i = 0; i < dataSize; i++) {		data = dOrigin[i];		alpha = SHIFT(data, shiftAmount);		if (alpha > 255) {			alpha = 255;		}		if (alpha < 0) {			alpha = 0;		}		mOrigin[i] = (UBOR((UBAND((alpha << 24 >>> 0), highMask)), pixel));	}}, makeMaskLog(dataBits, maskBits, pixel, maxOop) {	let alpha;	let dOrigin;	let data;	let dataSize;	let highMask;	let i;	let mOrigin;	let maskSize;	let max;	let maxFirst;	let maxLog;	if (!(typeof pixel === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	maxFirst = maxOop.words;	max = maxFirst[0];	maxLog = Math.log(max);	dataSize = SIZEOF(dataBits);	maskSize = SIZEOF(maskBits);	if (dataSize !== maskSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	dOrigin = dataBits.words;	mOrigin = maskBits.words;	highMask = 4278190080;	for (i = 0; i < dataSize; i++) {		data = dOrigin[i];		alpha = (data === 0) ? 0 : (((255.0 / maxLog) * Math.log(data)) | 0);		if (alpha > 255) {			alpha = 255;		}		mOrigin[i] = (UBOR((UBAND((alpha << 24 >>> 0), highMask)), pixel));	}}, makeTurtlesMap(mapOop, whoOop, xOop, yOop, width, height) {	let index;	let index1;	let map;	let mapIndex;	let size;	let whoArray;	let x;	let xArray;	let y;	let yArray;	if (!(typeof height === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof width === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((whoOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((mapOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(whoOop);	if (SIZEOF(xOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(yOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(mapOop) !== (height * width)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	xArray = xOop.wordsAsFloat32Array();	yArray = yOop.wordsAsFloat32Array();	whoArray = whoOop.words;	map = mapOop.words;	const indexLimiT = height * width;	for (index = 0; index < indexLimiT; index++) {		map[index] = 0;	}	for (index1 = 0; index1 < size; index1++) {		x = xArray[index1];		y = yArray[index1];		mapIndex = (width * y) + x;		if ((mapIndex >= 0) && (mapIndex < (height * width))) {			map[mapIndex] = whoArray[index1];		}	}}, primPixelAtXY(bitsOop, xPos, yPos, width, height) {	let bits;	let index;	let ret;	let x;	let y;	if (!(typeof height === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof width === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof yPos === "number" && (yPos | 0) !== yPos && !Number.isSafeInteger(yPos) || yPos._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof xPos === "number" && (xPos | 0) !== xPos && !Number.isSafeInteger(xPos) || xPos._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((bitsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(bitsOop) !== (height * width)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	x = xPos|0;	y = yPos|0;	bits = bitsOop.words;	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {		index = (y * width) + x;		ret = bits[index];	} else {		ret = 0;	}	throw Object.create(PrimitiveReturn).setPayload(((typeof ret === "number") ? ret : PrimitiveFailed.signal()));}, primPixelAtXYPut(bitsOop, xPos, yPos, value, width, height) {	let bits;	let index;	let v;	let x;	let y;	if (!(typeof height === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof width === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof value === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof yPos === "number" && (yPos | 0) !== yPos && !Number.isSafeInteger(yPos) || yPos._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof xPos === "number" && (xPos | 0) !== xPos && !Number.isSafeInteger(xPos) || xPos._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((bitsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(bitsOop) !== (height * width)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	x = xPos|0;	y = yPos|0;	v = value;	if (v > 1073741823) {		v = 1073741823;	}	if (v < 0) {		v = 0;	}	bits = bitsOop.words;	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {		index = (y * width) + x;		bits[index] = v;	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primPixelsAtXY(xArrayOop, yArrayOop, bitsOop, bitsWidth, bitsHeight, destWordsOop) {	let bits;	let bitsIndex;	let destWords;	let i;	let size;	let x;	let xArray;	let y;	let yArray;	if (!(typeof bitsHeight === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof bitsWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((destWordsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((bitsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(xArrayOop);	if (SIZEOF(yArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(destWordsOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	xArray = xArrayOop.wordsAsFloat32Array();	yArray = yArrayOop.wordsAsFloat32Array();	destWords = destWordsOop.words;	bits = bitsOop.words;	for (i = 0; i < size; i++) {		x = (xArray[i]|0);		y = (yArray[i]|0);		if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {			bitsIndex = (y * bitsWidth) + x;			destWords[i] = bits[bitsIndex];		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primScalarForward(index, xOop, yOop, headingOop, val, destWidth, destHeight, leftEdgeMode, rightEdgeMode, topEdgeMode, bottomEdgeMode) {	let dist;	let headingArray;	let i;	let newX;	let newY;	let size;	let xArray;	let yArray;	let headingRadians;	let newX1;	let newY1;	if (!(typeof bottomEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof topEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof rightEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof leftEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destHeight === "number" && (destHeight | 0) !== destHeight && !Number.isSafeInteger(destHeight) || destHeight._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destWidth === "number" && (destWidth | 0) !== destWidth && !Number.isSafeInteger(destWidth) || destWidth._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof val === "number" && (val | 0) !== val && !Number.isSafeInteger(val) || val._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(xOop);	if (SIZEOF(yOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	xArray = xOop.wordsAsFloat32Array();	yArray = yOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	dist = val;	i = index - 1;	newX = xArray[i] + (dist * Math.cos(headingArray[i]));	newY = yArray[i] - (dist * Math.sin(headingArray[i]));	/* begin scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */	newX1 = newX;	if (newX1 < 0.0) {				switch (leftEdgeMode) {		case 1:						/* wrap */			newX1 += destWidth;			break;		case 2:						/* stick */			newX1 = 0.0;			break;		case 3:						/* bounce */			newX1 = 0.0 - newX1;			headingRadians = headingArray[i];			if (headingRadians < 3.141592653589793) {				headingArray[i] = (3.141592653589793 - headingRadians);			} else {				headingArray[i] = (9.42477796076938 - headingRadians);			}			break;		default:					}	}	if (newX1 >= destWidth) {				switch (rightEdgeMode) {		case 1:						newX1 -= destWidth;			break;		case 2:						newX1 = destWidth - 1.0e-6;			break;		case 3:						newX1 = destWidth - 1.0e-6 - (newX1 - destWidth);			headingRadians = headingArray[i];			if (headingRadians < 3.141592653589793) {				headingArray[i] = (3.141592653589793 - headingRadians);			} else {				headingArray[i] = (9.42477796076938 - headingRadians);			}			break;		default:					}	}	xArray[i] = newX1;	/* end scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */	/* begin scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */	newY1 = newY;	if (newY1 < 0.0) {				switch (topEdgeMode) {		case 1:						/* wrap */			newY1 += destHeight;			break;		case 2:						/* stick */			newY1 = 0.0;			break;		case 3:						/* bounce */			newY1 = 0.0 - newY1;			headingArray[i] = (6.283185307179586 - headingArray[i]);			break;		default:					}	}	if (newY1 >= destHeight) {				switch (bottomEdgeMode) {		case 1:						newY1 -= destHeight;			break;		case 2:						newY1 = destHeight - 1.0e-6;			break;		case 3:						newY1 = destHeight - 1.0e-6 - (newY1 - destHeight);			headingArray[i] = (6.283185307179586 - headingArray[i]);			break;		default:					}	}	yArray[i] = newY1;	/* end scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primSetPixelsAtXY(pArrayOop, xArrayOop, yArrayOop, bitsOop, bitsWidth, bitsHeight, valueOop) {	let bits;	let bitsIndex;	let floatsValue;	let fv;	let i;	let intValue;	let isValueInt;	let isValueWordArray;	let pArray;	let size;	let value;	let wordsValue;	let x;	let xArray;	let y;	let yArray;	if (!(typeof bitsHeight === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof bitsWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((pArrayOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((bitsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(xArrayOop);	if (SIZEOF(pArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(yArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	pArray = BYTESOF(pArrayOop);	xArray = xArrayOop.wordsAsFloat32Array();	yArray = yArrayOop.wordsAsFloat32Array();	isValueInt = (typeof valueOop === "number");	if (isValueInt) {		intValue = valueOop;		value = intValue;	} else {		if (SIZEOF(valueOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		isValueWordArray = (valueOop._class() === SmalltalkGlobals._WordArray);		if (isValueWordArray) {			wordsValue = valueOop.words;		} else {			floatsValue = valueOop.wordsAsFloat32Array();		}	}	bits = bitsOop.words;	for (i = 0; i < size; i++) {		if (pArray[i] === 1) {			x = (xArray[i]|0);			y = (yArray[i]|0);			if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {				bitsIndex = (y * bitsWidth) + x;				if (isValueInt) {					bits[bitsIndex] = value;				} else {					if (isValueWordArray) {						bits[bitsIndex] = wordsValue[i];					} else {						fv = floatsValue[i];						bits[bitsIndex] = fv;					}				}			}		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primTurtlesForward(pOop, xOop, yOop, headingOop, valOop, destWidth, destHeight, leftEdgeMode, rightEdgeMode, topEdgeMode, bottomEdgeMode) {	let dist;	let headingArray;	let i;	let isValVector;	let newX;	let newY;	let pArray;	let size;	let val;	let valArray;	let xArray;	let yArray;	let headingRadians;	let newX1;	let newY1;	if (!(typeof bottomEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof topEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof rightEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof leftEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destHeight === "number" && (destHeight | 0) !== destHeight && !Number.isSafeInteger(destHeight) || destHeight._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destWidth === "number" && (destWidth | 0) !== destWidth && !Number.isSafeInteger(destWidth) || destWidth._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((pOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float)) {		isValVector = false;	} else {		if ((valOop.storageType === "words")) {			isValVector = true;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	size = SIZEOF(xOop);	if (SIZEOF(yOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(pOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (isValVector) {		if (SIZEOF(valOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	pArray = BYTESOF(pOop);	xArray = xOop.wordsAsFloat32Array();	yArray = yOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	if (isValVector) {		valArray = valOop.wordsAsFloat32Array();	} else {		val = ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float) ? valOop.valueOf() : PrimitiveFailed.signal());	}	for (i = 0; i < size; i++) {		if (pArray[i] === 1) {			dist = isValVector ? valArray[i] : val;			newX = xArray[i] + (dist * Math.cos(headingArray[i]));			newY = yArray[i] - (dist * Math.sin(headingArray[i]));			/* begin scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */			newX1 = newX;			if (newX1 < 0.0) {								switch (leftEdgeMode) {				case 1:										/* wrap */					newX1 += destWidth;					break;				case 2:										/* stick */					newX1 = 0.0;					break;				case 3:										/* bounce */					newX1 = 0.0 - newX1;					headingRadians = headingArray[i];					if (headingRadians < 3.141592653589793) {						headingArray[i] = (3.141592653589793 - headingRadians);					} else {						headingArray[i] = (9.42477796076938 - headingRadians);					}					break;				default:									}			}			if (newX1 >= destWidth) {								switch (rightEdgeMode) {				case 1:										newX1 -= destWidth;					break;				case 2:										newX1 = destWidth - 1.0e-6;					break;				case 3:										newX1 = destWidth - 1.0e-6 - (newX1 - destWidth);					headingRadians = headingArray[i];					if (headingRadians < 3.141592653589793) {						headingArray[i] = (3.141592653589793 - headingRadians);					} else {						headingArray[i] = (9.42477796076938 - headingRadians);					}					break;				default:									}			}			xArray[i] = newX1;			/* end scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */			/* begin scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */			newY1 = newY;			if (newY1 < 0.0) {								switch (topEdgeMode) {				case 1:										/* wrap */					newY1 += destHeight;					break;				case 2:										/* stick */					newY1 = 0.0;					break;				case 3:										/* bounce */					newY1 = 0.0 - newY1;					headingArray[i] = (6.283185307179586 - headingArray[i]);					break;				default:									}			}			if (newY1 >= destHeight) {								switch (bottomEdgeMode) {				case 1:										newY1 -= destHeight;					break;				case 2:										newY1 = destHeight - 1.0e-6;					break;				case 3:										newY1 = destHeight - 1.0e-6 - (newY1 - destHeight);					headingArray[i] = (6.283185307179586 - headingArray[i]);					break;				default:									}			}			yArray[i] = newY1;			/* end scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primUpHill(tX, tY, tH, bitsOop, width, height, sniffRange) {	let bits;	let endX;	let endY;	let maxVal;	let maxValX;	let maxValY;	let ret;	let rowOffset;	let startX;	let startY;	let thisVal;	let turtleX;	let turtleY;	let x;	let y;	let x1;	let y1;	let tanVal;	let theta;	let deg;	let degrees;	if (!(typeof sniffRange === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof height === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof width === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof tH === "number" && (tH | 0) !== tH && !Number.isSafeInteger(tH) || tH._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof tY === "number" && (tY | 0) !== tY && !Number.isSafeInteger(tY) || tY._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof tX === "number" && (tX | 0) !== tX && !Number.isSafeInteger(tX) || tX._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((bitsOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(bitsOop) !== (height * width)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	bits = bitsOop.words;	turtleX = tX;	turtleY = tY;	turtleX = Math.max(turtleX, 0);	turtleY = Math.max(turtleY, 0);	turtleX = Math.min(turtleX, (width - 1));	turtleY = Math.min(turtleY, (height - 1));	startX = Math.max((turtleX - sniffRange), 0);	endX = Math.min((turtleX + sniffRange), (width - 1));	startY = Math.max((turtleY - sniffRange), 0);	endY = Math.min((turtleY + sniffRange), (height - 1));	maxVal = bits[(turtleY * width) + turtleX];	maxValX = -1;	for (y = startY; y <= endY; y++) {		rowOffset = y * width;		for (x = startX; x <= endX; x++) {			thisVal = bits[rowOffset + x];			if (thisVal > maxVal) {				maxValX = x;				maxValY = y;				maxVal = thisVal;			}		}	}	if (-1 === maxValX) {		/* begin radiansToDegrees: */		degrees = tH / 0.0174532925199433;		deg = 90.0 - degrees;		if (deg <= 0.0) {			deg += 360.0;		}		ret = deg;		/* end radiansToDegrees: */	} else {		/* begin degreesFromX:y: */		x1 = (maxValX - turtleX);		y1 = (maxValY - turtleY);		if (x1 === 0.0) {			ret = ((y1 >= 0.0) ? 90.0 : 270.0) + 90.0;		} else {			tanVal = y1 / x1;			theta = Math.atan(tanVal);			ret = ((x1 >= 0.0) ? ((y1 >= 0.0) ? (theta / 0.0174532925199433) : ((theta / 0.0174532925199433) + 360.0)) : ((theta / 0.0174532925199433) + 180.0)) + 90.0;		}		/* end degreesFromX:y: */	}	throw Object.create(PrimitiveReturn).setPayload(typeof ret.valueOf() !== "number" ? PrimitiveFailed.signal() : ((ret.valueOf() | 0 === ret.valueOf()) || Number.isSafeInteger(ret) ? new Float(ret) : ret.valueOf()));}, primitiveAddArrays(rcvrOop, argOop, resultOop) {	let floatsArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgWords && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] + wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] + floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] + wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] + floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveAddScalar(rcvrOop, argOop, resultOop) {	let floatArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgInt && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] + intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] + floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] + intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] + floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveAndByteArray(rcvrOop, otherOop) {	let i;	let length;	let length1;	let length2;	let otherArray;	let rcvrArray;	if (typeof otherOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((otherOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length1 = SIZEOF(rcvrOop);	length2 = SIZEOF(otherOop);	length = length1;	if (length1 > length2) {		length = length2;	}	otherArray = BYTESOF(otherOop);	rcvrArray = BYTESOF(rcvrOop);	for (i = 0; i < length; i++) {		rcvrArray[i] = ((rcvrArray[i] + otherArray[i]) === 2);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDivArrays(rcvrOop, argOop, resultOop) {	let floatsArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgWords && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] / wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] / floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] / wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] / floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveDivScalar(rcvrOop, argOop, resultOop) {	let floatArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgInt && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (Math.trunc(wordsRcvr[i] / intArg));			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] / floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] / intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] / floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveEQArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] === wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] === floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] === wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] === floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveEQScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] === intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] === floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] === intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] === floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveGEArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] >= wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] >= floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] >= wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] >= floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveGEScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] >= intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] >= floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] >= intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] >= floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveGTArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] > wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] > floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] > wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] > floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveGTScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] > intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] > floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] > intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] > floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveLEArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] <= wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] <= floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] <= wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] <= floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveLEScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] <= intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] <= floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] <= intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] <= floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveLTArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] < wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] < floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] < wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] < floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveLTScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] < intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] < floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] < intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] < floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveMulArrays(rcvrOop, argOop, resultOop) {	let floatsArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgWords && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] * wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] * floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] * wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] * floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveMulScalar(rcvrOop, argOop, resultOop) {	let floatArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgInt && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] * intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] * floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] * intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] * floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveNEArrays(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatsArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] !== wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] !== floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] !== wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] !== floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveNEScalar(rcvrOop, argOop, resultOop) {	let bytesResult;	let floatArg;	let floatsRcvr;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i = 0; i < length; i++) {				bytesResult[i] = (wordsRcvr[i] !== intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i1 = 0; i1 < length; i1++) {				bytesResult[i1] = (wordsRcvr[i1] !== floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			bytesResult = BYTESOF(resultOop);			for (i11 = 0; i11 < length; i11++) {				bytesResult[i11] = (floatsRcvr[i11] !== intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			bytesResult = BYTESOF(resultOop);			for (i2 = 0; i2 < length; i2++) {				bytesResult[i2] = (floatsRcvr[i2] !== floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveNotByteArray(rcvrOop) {	let i;	let length;	let rcvrArray;	if ((rcvrOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	rcvrArray = BYTESOF(rcvrOop);	for (i = 0; i < length; i++) {		if (rcvrArray[i] === 0) {			rcvrArray[i] = 1;		} else {			rcvrArray[i] = 0;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveOrByteArray(rcvrOop, otherOop) {	let i;	let length;	let length1;	let length2;	let otherArray;	let rcvrArray;	if (typeof otherOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((otherOop.storageType !== "bytes")) throw Object.create(PrimitiveFailed).setPayload(1);	length1 = SIZEOF(rcvrOop);	length2 = SIZEOF(otherOop);	length = length1;	if (length1 > length2) {		length = length2;	}	otherArray = BYTESOF(otherOop);	rcvrArray = BYTESOF(rcvrOop);	for (i = 0; i < length; i++) {		rcvrArray[i] = ((rcvrArray[i] + otherArray[i]) > 0);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateAtAllPutBoolean(rcvrOop, valOop) {	let i;	let predicates;	let predicatesOop;	let val;	let values;	let valuesOop;	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	val = (typeof valOop === "number") ? valOop : (typeof valOop === "boolean" ? valOop : PrimitiveFailed.signal());	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((valuesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	values = BYTESOF(valuesOop);	predicates = BYTESOF(predicatesOop);	const iLimiT = SIZEOF(valuesOop);	for (i = 0; i < iLimiT; i++) {		if (predicates[i] === 1) {			values[i] = val;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateAtAllPutColor(rcvrOop, val) {	let i;	let predicates;	let predicatesOop;	let values;	let valuesOop;	if (!(typeof val === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	val = UBORM(val, 2130706432);	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((valuesOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	values = valuesOop.words;	predicates = BYTESOF(predicatesOop);	const iLimiT = SIZEOF(valuesOop);	for (i = 0; i < iLimiT; i++) {		if (predicates[i] === 1) {			values[i] = val;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateAtAllPutNumber(rcvrOop, val) {	let i;	let predicates;	let predicatesOop;	let values;	let valuesOop;	if (!(typeof val === "number" && (val | 0) !== val && !Number.isSafeInteger(val) || val._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((valuesOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	values = valuesOop.wordsAsFloat32Array();	predicates = BYTESOF(predicatesOop);	const iLimiT = SIZEOF(valuesOop);	for (i = 0; i < iLimiT; i++) {		if (predicates[i] === 1) {			values[i] = val;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateAtAllPutObject(rcvrOop, valOop) {	let i;	let predicates;	let predicatesOop;	let values;	let valuesOop;	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((valuesOop.storageType !== "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	values = valuesOop.wordsAsInt32Array();	predicates = BYTESOF(predicatesOop);	const iLimiT = SIZEOF(valuesOop);	for (i = 0; i < iLimiT; i++) {		if (predicates[i] === 1) {			values[i] = valOop;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateReplaceBytes(rcvrOop, start, stop, repOop, repStart) {	let i;	let predicates;	let predicatesOop;	let predicatesSize;	let replacement;	let replacementSize;	let values;	let valuesOop;	let valuesSize;	if (!(typeof repStart === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof repOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof stop === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((valuesOop.storageType === "bytes") && ((repOop.storageType === "bytes")))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	values = BYTESOF(valuesOop);	predicates = BYTESOF(predicatesOop);	replacement = BYTESOF(repOop);	valuesSize = SIZEOF(valuesOop);	predicatesSize = SIZEOF(predicatesOop);	replacementSize = SIZEOF(repOop);	if (start > stop) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start < 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start > valuesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start > predicatesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (stop > valuesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (stop > predicatesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (repStart < 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (repStart > replacementSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (((replacementSize - repStart) + 1) < ((stop - start) + 1)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	for (i = start - 1; i < stop; i++) {		if (predicates[i] === 1) {			values[i] = replacement[(repStart + i) - start];		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitivePredicateReplaceWords(rcvrOop, start, stop, repOop, repStart) {	let floatReplacement;	let floatValues;	let fv;	let i;	let i1;	let i11;	let i2;	let predicates;	let predicatesOop;	let predicatesSize;	let rIsFloat;	let replacement;	let replacementSize;	let vIsFloat;	let values;	let valuesOop;	let valuesSize;	if (!(typeof repStart === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof repOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof stop === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	valuesOop = rcvrOop.pointers[1];	predicatesOop = rcvrOop.pointers[0];	if ((predicatesOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(((valuesOop.storageType === "words") && ((repOop.storageType === "words"))) || ((valuesOop.storageType === "pointers") && ((repOop.storageType === "pointers"))))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	predicates = BYTESOF(predicatesOop);	valuesSize = SIZEOF(valuesOop);	predicatesSize = SIZEOF(predicatesOop);	replacementSize = SIZEOF(repOop);	if (start > stop) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start < 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start > valuesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (start > predicatesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (stop > valuesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (stop > predicatesSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (repStart < 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (repStart > replacementSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (((replacementSize - repStart) + 1) < ((stop - start) + 1)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	vIsFloat = (valuesOop._class() === SmalltalkGlobals._KedamaFloatArray);	rIsFloat = (repOop._class() === SmalltalkGlobals._KedamaFloatArray);	if (vIsFloat && (rIsFloat)) {		floatValues = valuesOop.wordsAsFloat32Array();		floatReplacement = repOop.wordsAsFloat32Array();		for (i = start - 1; i < stop; i++) {			if (predicates[i] === 1) {				floatValues[i] = floatReplacement[(repStart + i) - start];			}		}	}	if (vIsFloat && (!rIsFloat)) {		floatValues = valuesOop.wordsAsFloat32Array();		replacement = repOop.words;		for (i1 = start - 1; i1 < stop; i1++) {			if (predicates[i1] === 1) {				floatValues[i1] = replacement[(repStart + i1) - start];			}		}	}	if (!vIsFloat && (rIsFloat)) {		values = valuesOop.words;		floatReplacement = repOop.wordsAsFloat32Array();		for (i11 = start - 1; i11 < stop; i11++) {			if (predicates[i11] === 1) {				fv = (floatReplacement[(repStart + i11) - start]>>>0);				values[i11] = fv;			}		}	}	if (!vIsFloat && (!rIsFloat)) {		values = valuesOop.words;		replacement = repOop.words;		for (i2 = start - 1; i2 < stop; i2++) {			if (predicates[i2] === 1) {				values[i2] = replacement[(repStart + i2) - start];			}		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveRemArrays(rcvrOop, argOop, resultOop) {	let floatArg;	let floatRcvr;	let floatResult;	let floatsArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordArg;	let wordRcvr;	let wordResult;	let wordsArg;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgWords && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordRcvr = wordsRcvr[i];				wordArg = wordsArg[i];				/* In this primitive, words are supposed to be unsigned. */				wordResult = MOD(wordRcvr, wordArg);				wordsResult[i] = wordResult;			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				wordRcvr = wordsRcvr[i1];				floatArg = floatsArg[i1];				floatResult = wordRcvr / floatArg;				floatResult = Math.floor(floatResult);				floatsResult[i1] = (wordRcvr - (floatResult * floatArg));			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatRcvr = floatsRcvr[i11];				wordArg = wordsArg[i11];				floatResult = floatRcvr / wordArg;				floatResult = Math.floor(floatResult);				floatsResult[i11] = (floatRcvr - (floatResult * wordArg));			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatRcvr = floatsRcvr[i2];				floatArg = floatsArg[i2];				floatResult = floatRcvr / floatArg;				floatResult = Math.floor(floatResult);				floatsResult[i2] = (floatRcvr - (floatResult * floatArg));			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveRemScalar(rcvrOop, argOop, resultOop) {	let floatArg;	let floatRcvr;	let floatResult;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordRcvr;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgInt && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (MOD(wordsRcvr[i], intArg));			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				wordRcvr = wordsRcvr[i1];				floatResult = wordRcvr / floatArg;				floatResult = Math.floor(floatResult);				floatsResult[i1] = (wordRcvr - (floatResult * floatArg));			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatRcvr = floatsRcvr[i11];				floatResult = floatRcvr / intArg;				floatResult = Math.floor(floatResult);				floatsResult[i11] = (floatRcvr - (floatResult * intArg));			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatRcvr = floatsRcvr[i2];				floatResult = floatRcvr / floatArg;				floatResult = Math.floor(floatResult);				floatsResult[i2] = (floatRcvr - (floatResult * floatArg));			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveSubArrays(rcvrOop, argOop, resultOop) {	let floatsArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let isArgWords;	let isRcvrWords;	let length;	let wordsArg;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof argOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((argOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(argOop);	if (length !== SIZEOF(rcvrOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgWords = (argOop._class() === SmalltalkGlobals._WordArray);	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgWords && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgWords) {			wordsRcvr = rcvrOop.words;			wordsArg = argOop.words;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] - wordsArg[i]);			}		} else {			wordsRcvr = rcvrOop.words;			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] - floatsArg[i1]);			}		}	} else {		if (isArgWords) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			wordsArg = argOop.words;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] - wordsArg[i11]);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatsArg = argOop.wordsAsFloat32Array();			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] - floatsArg[i2]);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, primitiveSubScalar(rcvrOop, argOop, resultOop) {	let floatArg;	let floatsRcvr;	let floatsResult;	let i;	let i1;	let i11;	let i2;	let intArg;	let isArgInt;	let isRcvrWords;	let length;	let wordsRcvr;	let wordsResult;	if (typeof resultOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rcvrOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((rcvrOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((resultOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	length = SIZEOF(rcvrOop);	if (length !== SIZEOF(resultOop)) throw Object.create(PrimitiveFailed).setPayload(1);	isArgInt = (typeof argOop === "number");	isRcvrWords = (rcvrOop._class() === SmalltalkGlobals._WordArray);	if (isArgInt && isRcvrWords) {		if (!(resultOop._class() === SmalltalkGlobals._WordArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if (!(resultOop._class() === SmalltalkGlobals._KedamaFloatArray)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (isRcvrWords) {		if (isArgInt) {			wordsRcvr = rcvrOop.words;			intArg = argOop;			wordsResult = resultOop.words;			for (i = 0; i < length; i++) {				wordsResult[i] = (wordsRcvr[i] - intArg);			}		} else {			wordsRcvr = rcvrOop.words;			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i1 = 0; i1 < length; i1++) {				floatsResult[i1] = (wordsRcvr[i1] - floatArg);			}		}	} else {		if (isArgInt) {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			intArg = argOop;			floatsResult = resultOop.wordsAsFloat32Array();			for (i11 = 0; i11 < length; i11++) {				floatsResult[i11] = (floatsRcvr[i11] - intArg);			}		} else {			floatsRcvr = rcvrOop.wordsAsFloat32Array();			floatArg = ((typeof argOop === "number" && (argOop | 0) !== argOop && !Number.isSafeInteger(argOop) || argOop._class() === SmalltalkGlobals._Float) ? argOop.valueOf() : PrimitiveFailed.signal());			floatsResult = resultOop.wordsAsFloat32Array();			for (i2 = 0; i2 < length; i2++) {				floatsResult[i2] = (floatsRcvr[i2] - floatArg);			}		}	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, randomIntoFloatArray(range, from, to, floatArrayOop, factor) {	let floatArray;	let index;	let size;	if (!(typeof factor === "number" && (factor | 0) !== factor && !Number.isSafeInteger(factor) || factor._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof to === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof from === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof range === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((floatArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(floatArrayOop);	if (!((size >= to) && ((from >= 1) && (to >= from)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	floatArray = floatArrayOop.wordsAsFloat32Array();	for (index = from; index <= to; index++) {		floatArray[index - 1] = (KedamaPlugin2.kedamaRandom2(range) * factor);	}}, randomIntoIntegerArray(range, from, to, integerArrayOop, factor) {	let index;	let integerArray;	let size;	if (!(typeof factor === "number" && (factor | 0) !== factor && !Number.isSafeInteger(factor) || factor._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof to === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof from === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof range === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((integerArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(integerArrayOop);	if (!((size >= to) && ((from >= 1) && (to >= from)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	integerArray = integerArrayOop.words;	for (index = from; index <= to; index++) {		integerArray[index - 1] = ((KedamaPlugin2.kedamaRandom2(range) * factor)|0);	}}, randomRange(range) {	let ret;	let hi;	let lo;	let r;	let v;	let val;	if (!(typeof range === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin kedamaRandom2: */	r = (range < 0) ? (0 - range) : range;	hi = Math.trunc(kedamaRandomSeed / randQ);	lo = MOD(kedamaRandomSeed, randQ);	kedamaRandomSeed = (randA * lo) - (randR * hi);	v = UBANDS(kedamaRandomSeed, 65535);	val = (v * (r + 1)) >>> 16;	ret = (range < 0) ? (0 - val) : val;	/* end kedamaRandom2: */	throw Object.create(PrimitiveReturn).setPayload(((typeof ret === "number") ? ret : PrimitiveFailed.signal()));}, scalarGetAngleTo(toX, toY, fromX, fromY) {	let r;	let x;	let y;	let tanVal;	let theta;	if (!(typeof fromY === "number" && (fromY | 0) !== fromY && !Number.isSafeInteger(fromY) || fromY._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof fromX === "number" && (fromX | 0) !== fromX && !Number.isSafeInteger(fromX) || fromX._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof toY === "number" && (toY | 0) !== toY && !Number.isSafeInteger(toY) || toY._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof toX === "number" && (toX | 0) !== toX && !Number.isSafeInteger(toX) || toX._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	x = toX - fromX;	y = toY - fromY;	/* begin degreesFromX:y: */	if (x === 0.0) {		r = (y >= 0.0) ? 90.0 : 270.0;	} else {		tanVal = y / x;		theta = Math.atan(tanVal);		r = (x >= 0.0) ? ((y >= 0.0) ? (theta / 0.0174532925199433) : ((theta / 0.0174532925199433) + 360.0)) : ((theta / 0.0174532925199433) + 180.0);	}	/* end degreesFromX:y: */	r += 90.0;	if (r > 360.0) {		r -= 360.0;	}	throw Object.create(PrimitiveReturn).setPayload(typeof r.valueOf() !== "number" ? PrimitiveFailed.signal() : ((r.valueOf() | 0 === r.valueOf()) || Number.isSafeInteger(r) ? new Float(r) : r.valueOf()));}, scalarGetDistanceTo(toX, toY, fromX, fromY) {	let r;	let x;	let y;	if (!(typeof fromY === "number" && (fromY | 0) !== fromY && !Number.isSafeInteger(fromY) || fromY._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof fromX === "number" && (fromX | 0) !== fromX && !Number.isSafeInteger(fromX) || fromX._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof toY === "number" && (toY | 0) !== toY && !Number.isSafeInteger(toY) || toY._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof toX === "number" && (toX | 0) !== toX && !Number.isSafeInteger(toX) || toX._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	x = fromX - toX;	y = fromY - toY;	r = Math.sqrt((x * x) + (y * y));	throw Object.create(PrimitiveReturn).setPayload(typeof r.valueOf() !== "number" ? PrimitiveFailed.signal() : ((r.valueOf() | 0 === r.valueOf()) || Number.isSafeInteger(r) ? new Float(r) : r.valueOf()));}, setHeadingArrayFrom(pOop, headingOop, resultOop) {	let heading;	let headingArray;	let i;	let isValVector;	let pArray;	let resultArray;	let size;	let deg;	let headingRadians;	let q;	let deg1;	let headingRadians1;	let q1;	if ((pOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(headingOop);	if ((typeof resultOop === "number" && (resultOop | 0) !== resultOop && !Number.isSafeInteger(resultOop) || resultOop._class() === SmalltalkGlobals._Float)) {		isValVector = false;	} else {		if ((resultOop.storageType === "words")) {			if (SIZEOF(resultOop) !== size) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			isValVector = true;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	pArray = BYTESOF(pOop);	headingArray = headingOop.wordsAsFloat32Array();	if (isValVector) {		resultArray = resultOop.wordsAsFloat32Array();	} else {		heading = ((typeof resultOop === "number" && (resultOop | 0) !== resultOop && !Number.isSafeInteger(resultOop) || resultOop._class() === SmalltalkGlobals._Float) ? resultOop.valueOf() : PrimitiveFailed.signal());		/* begin degreesToRadians: */		deg = 90.0 - heading;		q = deg / 360.0|0;		if (deg < 0.0) {			--q;		}		headingRadians = (deg - (q * 360.0)) * 0.0174532925199433;		heading = headingRadians;		/* end degreesToRadians: */	}	for (i = 0; i < size; i++) {		if (pArray[i] === 1) {			if (isValVector) {				heading = resultArray[i];				/* begin degreesToRadians: */				deg1 = 90.0 - heading;				q1 = deg1 / 360.0|0;				if (deg1 < 0.0) {					--q1;				}				headingRadians1 = (deg1 - (q1 * 360.0)) * 0.0174532925199433;				heading = headingRadians1;				/* end degreesToRadians: */			}			headingArray[i] = heading;		}	}}, setScalarHeading(index, headingOop, heading) {	let headingArray;	let arg11;	let arg21;	let deg;	let headingRadians;	let q;	if (!(typeof heading === "number" && (heading | 0) !== heading && !Number.isSafeInteger(heading) || heading._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) < index) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	headingArray = headingOop.wordsAsFloat32Array();	arg11 = index - 1;	/* begin degreesToRadians: */	deg = 90.0 - heading;	q = deg / 360.0|0;	if (deg < 0.0) {		--q;	}	headingRadians = (deg - (q * 360.0)) * 0.0174532925199433;	arg21 = headingRadians;	/* end degreesToRadians: */	headingArray[arg11] = arg21;}, shutdownModule() {	return true;}, turtleScalarSetX(xOop, xIndex, headingOop, val, destWidth, leftEdgeMode, rightEdgeMode) {	let headingArray;	let size;	let xArray;	let index;	let headingRadians;	let newX;	if (!(typeof rightEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof leftEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destWidth === "number" && (destWidth | 0) !== destWidth && !Number.isSafeInteger(destWidth) || destWidth._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof val === "number" && (val | 0) !== val && !Number.isSafeInteger(val) || val._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof xIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(xOop);	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	xArray = xOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	/* begin scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */	index = xIndex - 1;	newX = val;	if (newX < 0.0) {				switch (leftEdgeMode) {		case 1:						/* wrap */			newX1 += destWidth;			break;		case 2:						/* stick */			newX1 = 0.0|0;			break;		case 3:						/* bounce */			newX1 = 0.0 - newX1|0;			headingRadians = headingArray[i];			if (headingRadians < 3.141592653589793) {				headingArray[i] = (3.141592653589793 - headingRadians);			} else {				headingArray[i] = (9.42477796076938 - headingRadians);			}			break;		default:					}	}	if (newX >= destWidth) {				switch (rightEdgeMode) {		case 1:						newX1 -= destWidth;			break;		case 2:						newX1 = destWidth - 1.0e-6|0;			break;		case 3:						newX1 = destWidth - 1.0e-6 - (newX1 - destWidth)|0;			headingRadians = headingArray[i];			if (headingRadians < 3.141592653589793) {				headingArray[i] = (3.141592653589793 - headingRadians);			} else {				headingArray[i] = (9.42477796076938 - headingRadians);			}			break;		default:					}	}	xArray[index] = newX;	/* end scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */}, turtleScalarSetY(yOop, yIndex, headingOop, val, destHeight, topEdgeMode, bottomEdgeMode) {	let headingArray;	let size;	let yArray;	let index;	let newY;	if (!(typeof bottomEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof topEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destHeight === "number" && (destHeight | 0) !== destHeight && !Number.isSafeInteger(destHeight) || destHeight._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof val === "number" && (val | 0) !== val && !Number.isSafeInteger(val) || val._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof yIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(yOop);	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	yArray = yOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	/* begin scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */	index = yIndex - 1;	newY = val;	if (newY < 0.0) {				switch (topEdgeMode) {		case 1:						/* wrap */			newY1 += destHeight;			break;		case 2:						/* stick */			newY1 = 0.0|0;			break;		case 3:						/* bounce */			newY1 = 0.0 - newY1|0;			headingArray[i] = (6.283185307179586 - headingArray[i]);			break;		default:					}	}	if (newY >= destHeight) {				switch (bottomEdgeMode) {		case 1:						newY1 -= destHeight;			break;		case 2:						newY1 = destHeight - 1.0e-6|0;			break;		case 3:						newY1 = destHeight - 1.0e-6 - (newY1 - destHeight)|0;			headingArray[i] = (6.283185307179586 - headingArray[i]);			break;		default:					}	}	yArray[index] = newY;	/* end scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */}, turtlesSetX(pOop, xOop, headingOop, valOop, destWidth, leftEdgeMode, rightEdgeMode) {	let headingArray;	let i;	let isValVector;	let isWordVector;	let newX;	let pArray;	let size;	let val;	let valArray;	let wordValArray;	let xArray;	let headingRadians;	let newX1;	if (!(typeof rightEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof leftEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destWidth === "number" && (destWidth | 0) !== destWidth && !Number.isSafeInteger(destWidth) || destWidth._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((pOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float)) {		isValVector = false;	} else {		if ((valOop.storageType === "words")) {			isValVector = true;			isWordVector = (valOop._class() === SmalltalkGlobals._WordArray);		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	size = SIZEOF(xOop);	if (SIZEOF(pOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (isValVector) {		if (SIZEOF(valOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	pArray = BYTESOF(pOop);	xArray = xOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	if (isValVector) {		if (isWordVector) {			wordValArray = valOop.words;		} else {			valArray = valOop.wordsAsFloat32Array();		}	} else {		val = ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float) ? valOop.valueOf() : PrimitiveFailed.signal());	}	for (i = 0; i < size; i++) {		if (pArray[i] === 1) {			if (isValVector) {				if (isWordVector) {					newX = wordValArray[i];				} else {					newX = valArray[i];				}			} else {				newX = val;			}			/* begin scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */			newX1 = newX;			if (newX1 < 0.0) {								switch (leftEdgeMode) {				case 1:										/* wrap */					newX1 += destWidth;					break;				case 2:										/* stick */					newX1 = 0.0;					break;				case 3:										/* bounce */					newX1 = 0.0 - newX1;					headingRadians = headingArray[i];					if (headingRadians < 3.141592653589793) {						headingArray[i] = (3.141592653589793 - headingRadians);					} else {						headingArray[i] = (9.42477796076938 - headingRadians);					}					break;				default:									}			}			if (newX1 >= destWidth) {								switch (rightEdgeMode) {				case 1:										newX1 -= destWidth;					break;				case 2:										newX1 = destWidth - 1.0e-6;					break;				case 3:										newX1 = destWidth - 1.0e-6 - (newX1 - destWidth);					headingRadians = headingArray[i];					if (headingRadians < 3.141592653589793) {						headingArray[i] = (3.141592653589793 - headingRadians);					} else {						headingArray[i] = (9.42477796076938 - headingRadians);					}					break;				default:									}			}			xArray[i] = newX1;			/* end scalarXAt:xArray:headingArray:value:destWidth:leftEdgeMode:rightEdgeMode: */		}	}}, turtlesSetY(pOop, yOop, headingOop, valOop, destHeight, topEdgeMode, bottomEdgeMode) {	let headingArray;	let i;	let isValVector;	let isWordVector;	let newY;	let pArray;	let size;	let val;	let valArray;	let wordValArray;	let yArray;	let newY1;	if (!(typeof bottomEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof topEdgeMode === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof destHeight === "number" && (destHeight | 0) !== destHeight && !Number.isSafeInteger(destHeight) || destHeight._class() === SmalltalkGlobals._Float)) throw Object.create(PrimitiveFailed).setPayload(1);	if ((pOop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((headingOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float)) {		isValVector = false;	} else {		if ((valOop.storageType === "words")) {			isValVector = true;			isWordVector = (valOop._class() === SmalltalkGlobals._WordArray);		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	size = SIZEOF(yOop);	if (SIZEOF(pOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(headingOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (isValVector) {		if (SIZEOF(valOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	pArray = BYTESOF(pOop);	yArray = yOop.wordsAsFloat32Array();	headingArray = headingOop.wordsAsFloat32Array();	if (isValVector) {		if (isWordVector) {			wordValArray = valOop.words;		} else {			valArray = valOop.wordsAsFloat32Array();		}	} else {		val = ((typeof valOop === "number" && (valOop | 0) !== valOop && !Number.isSafeInteger(valOop) || valOop._class() === SmalltalkGlobals._Float) ? valOop.valueOf() : PrimitiveFailed.signal());	}	for (i = 0; i < size; i++) {		if (pArray[i] === 1) {			if (isValVector) {				if (isWordVector) {					newY = wordValArray[i];				} else {					newY = valArray[i];				}			} else {				newY = val;			}			/* begin scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */			newY1 = newY;			if (newY1 < 0.0) {								switch (topEdgeMode) {				case 1:										/* wrap */					newY1 += destHeight;					break;				case 2:										/* stick */					newY1 = 0.0;					break;				case 3:										/* bounce */					newY1 = 0.0 - newY1;					headingArray[i] = (6.283185307179586 - headingArray[i]);					break;				default:									}			}			if (newY1 >= destHeight) {								switch (bottomEdgeMode) {				case 1:										newY1 -= destHeight;					break;				case 2:										newY1 = destHeight - 1.0e-6;					break;				case 3:										newY1 = destHeight - 1.0e-6 - (newY1 - destHeight);					headingArray[i] = (6.283185307179586 - headingArray[i]);					break;				default:									}			}			yArray[i] = newY1;			/* end scalarYAt:yArray:headingArray:value:destHeight:topEdgeMode:bottomEdgeMode: */		}	}}, vectorGetAngleTo(pXOop, pYOop, xArrayOop, yArrayOop, resultOop) {	let index;	let isVector;	let pX;	let pY;	let ppx;	let ppy;	let r;	let result;	let size;	let x;	let xArray;	let y;	let yArray;	let tanVal;	let theta;	if ((resultOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(resultOop);	if (size < 0) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(xArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(yArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof pXOop === "number" && (pXOop | 0) !== pXOop && !Number.isSafeInteger(pXOop) || pXOop._class() === SmalltalkGlobals._Float)) {		if ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float)) {			isVector = false;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float)) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			isVector = true;		}	}	if (isVector) {		if (SIZEOF(pXOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		if (SIZEOF(pYOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	result = resultOop.wordsAsFloat32Array();	xArray = xArrayOop.wordsAsFloat32Array();	yArray = yArrayOop.wordsAsFloat32Array();	if (isVector) {		pX = pXOop.wordsAsFloat32Array();		pY = pYOop.wordsAsFloat32Array();	}	if (!isVector) {		ppx = ((typeof pXOop === "number" && (pXOop | 0) !== pXOop && !Number.isSafeInteger(pXOop) || pXOop._class() === SmalltalkGlobals._Float) ? pXOop.valueOf() : PrimitiveFailed.signal());		ppy = ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float) ? pYOop.valueOf() : PrimitiveFailed.signal());	}	for (index = 0; index < size; index++) {		if (isVector) {			ppx = pX[index];			ppy = pY[index];		}		x = ppx - xArray[index];		y = ppy - yArray[index];		/* begin degreesFromX:y: */		if (x === 0.0) {			r = (y >= 0.0) ? 90.0 : 270.0;		} else {			tanVal = y / x;			theta = Math.atan(tanVal);			r = (x >= 0.0) ? ((y >= 0.0) ? (theta / 0.0174532925199433) : ((theta / 0.0174532925199433) + 360.0)) : ((theta / 0.0174532925199433) + 180.0);		}		/* end degreesFromX:y: */		r += 90.0;		if (r > 360.0) {			r -= 360.0;		}		result[index] = r;	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, vectorGetDistanceTo(pXOop, pYOop, xArrayOop, yArrayOop, resultOop) {	let index;	let isVector;	let pX;	let pY;	let ppx;	let ppy;	let result;	let size;	let x;	let xArray;	let y;	let yArray;	if ((resultOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((xArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((yArrayOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	size = SIZEOF(resultOop);	if (size < 0) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(xArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(yArrayOop) !== size) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof pXOop === "number" && (pXOop | 0) !== pXOop && !Number.isSafeInteger(pXOop) || pXOop._class() === SmalltalkGlobals._Float)) {		if ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float)) {			isVector = false;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		if ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float)) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			isVector = true;		}	}	if (isVector) {		if (SIZEOF(pXOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		if (SIZEOF(pYOop) !== size) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	result = resultOop.wordsAsFloat32Array();	xArray = xArrayOop.wordsAsFloat32Array();	yArray = yArrayOop.wordsAsFloat32Array();	if (isVector) {		pX = pXOop.wordsAsFloat32Array();		pY = pYOop.wordsAsFloat32Array();	}	if (!isVector) {		ppx = ((typeof pXOop === "number" && (pXOop | 0) !== pXOop && !Number.isSafeInteger(pXOop) || pXOop._class() === SmalltalkGlobals._Float) ? pXOop.valueOf() : PrimitiveFailed.signal());		ppy = ((typeof pYOop === "number" && (pYOop | 0) !== pYOop && !Number.isSafeInteger(pYOop) || pYOop._class() === SmalltalkGlobals._Float) ? pYOop.valueOf() : PrimitiveFailed.signal());	}	for (index = 0; index < size; index++) {		if (isVector) {			ppx = pX[index];			ppy = pY[index];		}		x = ppx - xArray[index];		y = ppy - yArray[index];		result[index] = Math.sqrt((x * x) + (y * y));	}	throw Object.create(PrimitiveReturn).setPayload(resultOop);}, zoomBitmap(src, dst, sWidth, sHeight, xFactor, yFactor) {	let bit;	let dOrigin;	let dstIndex;	let dstSize;	let dummy;	let sOrigin;	let srcIndex;	let srcOrigin;	let srcSize;	let sx;	let sy;	let y;	if (!(typeof yFactor === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof xFactor === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof sHeight === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof sWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	srcSize = SIZEOF(src);	dstSize = SIZEOF(dst);	if ((sWidth * sHeight) !== srcSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (((srcSize * xFactor) * yFactor) !== dstSize) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	sOrigin = src.words;	dOrigin = dst.words;	srcIndex = 0;	srcOrigin = 0;	dstIndex = 0;	for (sy = 0; sy < sHeight; sy++) {		for (y = 0; y < yFactor; y++) {			for (sx = 0; sx < sWidth; sx++) {				bit = sOrigin[srcIndex];				++srcIndex;				for (dummy = 0; dummy < xFactor; dummy++) {					dOrigin[dstIndex] = bit;					++dstIndex;				}			}			srcIndex = srcOrigin;		}		srcOrigin += sWidth;		srcIndex = srcOrigin;	}}, }