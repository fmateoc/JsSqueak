/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 26 July 2023 12:01:55 am *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	DSAPlugin CryptographyPlugins-eem.12 uuid: 2945c878-6a44-4c6a-8374-b56aa6175d0f */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let divisorDigitCount = 0;let dsaDivisor;let dsaQuotient;let dsaRemainder;let remainderDigitCount = 0;globalThis.DSAPrims = {/*	Rotate the given 32-bit integer left by the given number of bits and answer the result. */leftRotateby(anInteger, bits) {	return UBOR((SHL(anInteger, bits)), (SHR(anInteger, (32 - bits))));}, /*	Called with three LargePositiveInteger arguments, rem, div, quo. Divide div into rem and store the quotient into quo, leaving the remainder in rem. *//*	Assume: quo starts out filled with zeros. */primitiveBigDivide(rem, div, quo) {	let clpi;	let d1;	let d2;	let digitShift;	let firstDigit;	let firstTwoDigits;	let j;	let q;	let qTooBig;	let thirdDigit;	let carry;	let i;	let rIndex;	let sum;	let borrow;	let i1;	let prod;	let rIndex1;	let resultDigit;	clpi = SmalltalkGlobals._LargePositiveInteger;	if (!((rem._class() === clpi) && ((div._class() === clpi) && (quo._class() === clpi)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	dsaRemainder = BYTESOF(rem);	dsaDivisor = BYTESOF(div);	dsaQuotient = BYTESOF(quo);	divisorDigitCount = SIZEOF(div);	/* adjust pointers for base-1 indexing */	remainderDigitCount = SIZEOF(rem);	dsaRemainder = CPTR_SUB(dsaRemainder, 1);	dsaDivisor = CPTR_SUB(dsaDivisor, 1);	dsaQuotient = CPTR_SUB(dsaQuotient, 1);	/* begin bigDivideLoop */	d1 = dsaDivisor[divisorDigitCount];	d2 = dsaDivisor[divisorDigitCount - 1];	for (j = remainderDigitCount; j > divisorDigitCount; j--) {		firstDigit = dsaRemainder[j];		firstTwoDigits = (firstDigit << 8 >>> 0) + dsaRemainder[j - 1];		thirdDigit = dsaRemainder[j - 2];		q = (firstDigit === d1) ? 255 : (Math.trunc(firstTwoDigits / d1));		if ((d2 * q) > (((firstTwoDigits - (q * d1)) << 8 >>> 0) + thirdDigit)) {			--q;			if ((d2 * q) > (((firstTwoDigits - (q * d1)) << 8 >>> 0) + thirdDigit)) {				--q;			}		}		digitShift = (j - divisorDigitCount) - 1;		if (q > 0) {			/* begin subtractDivisorMultipliedByDigit:digitShift: */			borrow = 0;			rIndex1 = digitShift + 1;			for (i1 = 1; i1 <= divisorDigitCount; i1++) {				prod = (dsaDivisor[i1] * q) + borrow;				borrow = prod >>> 8;				resultDigit = dsaRemainder[rIndex1] - (UBANDS(prod, 255));				if (resultDigit < 0) {					resultDigit += 256;					++borrow;				}				dsaRemainder[rIndex1] = resultDigit;				++rIndex1;			}			if (borrow === 0) {				qTooBig = false;			} else {				resultDigit = dsaRemainder[rIndex1] - borrow;				if (resultDigit < 0) {					dsaRemainder[rIndex1] = (resultDigit + 256);					qTooBig = true;				} else {					dsaRemainder[rIndex1] = resultDigit;					qTooBig = false;				}			}			/* end subtractDivisorMultipliedByDigit:digitShift: */			if (qTooBig) {				/* begin addBackDivisorDigitShift: */				carry = 0;				rIndex = digitShift + 1;				for (i = 1; i <= divisorDigitCount; i++) {					sum = (dsaRemainder[rIndex] + dsaDivisor[i]) + carry;					dsaRemainder[rIndex] = (UBANDS(sum, 255));					carry = sum >>> 8;					++rIndex;				}				sum = dsaRemainder[rIndex] + carry;				dsaRemainder[rIndex] = (UBANDS(sum, 255));				/* end addBackDivisorDigitShift: */				--q;			}		}		dsaQuotient[digitShift + 1] = q;	}	/* end bigDivideLoop */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Multiple f1 by f2, placing the result into prod. f1, f2, and prod must be LargePositiveIntegers, and the length of prod must be the sum of the lengths of f1 and f2. *//*	Assume: prod starts out filled with zeros */primitiveBigMultiply(f1, f2, prod) {	let carry;	let clpi;	let digit;	let f1Len;	let f1Ptr;	let f2Len;	let f2Ptr;	let i;	let j;	let k;	let prodLen;	let prodPtr;	let sum;	clpi = SmalltalkGlobals._LargePositiveInteger;	if (!((prod._class() === clpi) && ((f2._class() === clpi) && (f1._class() === clpi)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	prodLen = SIZEOF(prod);	f1Len = SIZEOF(f1);	f2Len = SIZEOF(f2);	if (prodLen !== (f1Len + f2Len)) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	prodPtr = BYTESOF(prod);	f2Ptr = BYTESOF(f2);	f1Ptr = BYTESOF(f1);	for (i = 0; i < f1Len; i++) {		if (((digit = f1Ptr[i])) !== 0) {			carry = 0;			/* Loop invariants: 0 <= carry <= 16rFF, k = i + j - 1 */			k = i;			for (j = 0; j < f2Len; j++) {				sum = ((f2Ptr[j] * digit) + prodPtr[k]) + carry;				carry = sum >>> 8;				prodPtr[k] = (UBANDS(sum, 255));				++k;			}			prodPtr[k] = carry;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Expand a 64 byte ByteArray (the first argument) into and an Bitmap of 80 32-bit words (the second argument). When reading a 32-bit integer from the ByteArray, consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering). */primitiveExpandBlock(buf, expanded) {	let bytePtr;	let i;	let i1;	let src;	let v;	let wordPtr;	if (!((expanded.storageType === "words") && ((buf.storageType === "bytes") && ((SIZEOF(expanded) === 80) && (SIZEOF(buf) === 64))))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	wordPtr = expanded.words;	bytePtr = BYTESOF(buf);	src = 0;	for (i = 0; i <= 15; i++) {		v = (((bytePtr[src] << 24 >>> 0) + (bytePtr[src + 1] << 16 >>> 0)) + (bytePtr[src + 2] << 8 >>> 0)) + bytePtr[src + 3];		wordPtr[i] = v;		src += 4;	}	for (i1 = 16; i1 <= 79; i1++) {		v = UBXOR((UBXOR((UBXOR(wordPtr[i1 - 3], wordPtr[i1 - 8])), wordPtr[i1 - 14])), wordPtr[i1 - 16]);		v = DSAPrims.leftRotateby(v, 1);		wordPtr[i1] = v;	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Answer true if the secure hash primitive is implemented. */primitiveHasSecureHashPrimitive() {	throw Object.create(PrimitiveReturn).setPayload(CHECKEDBOOLEAN(true));}, /*	Hash a Bitmap of 80 32-bit words (the first argument), using the given state (the second argument). */primitiveHashBlock(buf, state) {	let a;	let b;	let bufPtr;	let c;	let d;	let e;	let i;	let i1;	let i11;	let i2;	let statePtr;	let tmp;	if (!((state.storageType === "words") && ((buf.storageType === "words") && ((SIZEOF(state) === 5) && (SIZEOF(buf) === 80))))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	statePtr = state.words;	bufPtr = buf.words;	a = statePtr[0];	b = statePtr[1];	c = statePtr[2];	d = statePtr[3];	e = statePtr[4];	for (i = 0; i <= 19; i++) {		tmp = (((1518500249 + (UBOR((UBAND(b, c)), (UBAND((~(b) >>> 0), d))))) + DSAPrims.leftRotateby(a, 5)) + e) + bufPtr[i];		e = d;		d = c;		c = DSAPrims.leftRotateby(b, 30);		b = a;		a = tmp;	}	for (i1 = 20; i1 <= 39; i1++) {		tmp = (((1859775393 + (UBXOR((UBXOR(b, c)), d))) + DSAPrims.leftRotateby(a, 5)) + e) + bufPtr[i1];		e = d;		d = c;		c = DSAPrims.leftRotateby(b, 30);		b = a;		a = tmp;	}	for (i11 = 40; i11 <= 59; i11++) {		tmp = (((2400959708 + (UBOR((UBOR((UBAND(b, c)), (UBAND(b, d)))), (UBAND(c, d))))) + DSAPrims.leftRotateby(a, 5)) + e) + bufPtr[i11];		e = d;		d = c;		c = DSAPrims.leftRotateby(b, 30);		b = a;		a = tmp;	}	for (i2 = 60; i2 <= 79; i2++) {		tmp = (((3395469782 + (UBXOR((UBXOR(b, c)), d))) + DSAPrims.leftRotateby(a, 5)) + e) + bufPtr[i2];		e = d;		d = c;		c = DSAPrims.leftRotateby(b, 30);		b = a;		a = tmp;	}	statePtr[0] = (statePtr[0] + a);	statePtr[1] = (statePtr[1] + b);	statePtr[2] = (statePtr[2] + c);	statePtr[3] = (statePtr[3] + d);	statePtr[4] = (statePtr[4] + e);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Called with one LargePositiveInteger argument. Answer the index of the top-most non-zero digit. */primitiveHighestNonZeroDigitIndex(arg) {	let bigIntPtr;	let i;	if (arg._class() !== SmalltalkGlobals._LargePositiveInteger) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	bigIntPtr = BYTESOF(arg);	i = SIZEOF(arg);	while ((i > 0) && (bigIntPtr[(--i)] === 0)) {	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER((i + 1)));}, }