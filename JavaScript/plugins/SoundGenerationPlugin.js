/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 26 July 2023 12:02:08 am */
/* Automatically generated by
	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4
   from
	SoundGenerationPlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787
 */
var VM_PROXY_MAJOR = 1
var VM_PROXY_MINOR = 11


/*** Functions ***/
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }
function BYTESOF(obj) {
	if (obj.bytes) return obj.bytes;
	if (typeof obj === "bigint") {
		let asString = (obj >= 0 ? obj : -obj).toString(16);
		const length = (asString.length + 1) >>> 1;
		asString = asString.padStart(length << 1, "0");
		const bytes = new Uint8Array(length);
		for (let i = length - 1, j = 0; i >= 0; i--)
			bytes[i] = parseInt(asString.slice(j, j += 2), 16);
		return bytes;
	}}
function CHECKEDINTEGER(val) {
	return typeof val === "number" ? val : PrimitiveFailed.signal()
}
function CHECKEDBOOLEAN(val) {
	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()
}
function UBOR(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a | b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :
		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);
	}	//unsigned bit or
function UBORM(a, maskedB) {
	a = a >>> 0;
	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;
	}	//unsigned bit or
function UBORS(a, smallB) {
	if ((a | 0) === a)
		return a | smallB;
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;
	}	//unsigned bit or

function UBAND(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a & b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :
		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);
	}	//unsigned bit and
function UBANDM(a, maskedB) {
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;
	}	//unsigned bit and
function UBANDS(a, smallB) {
	if ((a | 0) === a)
		return a & smallB;
	a = a >>> 0;
	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;
	}	//unsigned bit and

function UBXOR(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a ^ b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :
		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);
	}	//unsigned bit xor
function UBXORM(a, maskedB) {
	a = a >>> 0;
	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;
	}	//unsigned bit xor
function UBXORS(a, smallB) {
	if ((a | 0) === a)
		return a ^ smallB;
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;
	}	//unsigned bit xor

function MOD(a, b) {
	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulus
function SHL(a, b) {
	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }
function SHR(a, b) {
	return b > 31 ? 0 : a >>> b }
function SHIFT(a, b) {
	b = b | 0;
	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }
function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }
function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }
function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }
function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }
function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }
function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }
function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }

/*** Variables ***/



globalThis.SoundGenerationPlugin = {
primitiveApplyReverb(aSoundBufferOop, startIndex, n) {
	let delayedLeft;
	let delayedRight;
	let i;
	let j;
	let out;
	let sliceIndex;
	let tapGain;
	let tapIndex;
	let aSoundBuffer;
	let tapDelays;
	let tapGains;
	let tapCount;
	let bufferSize;
	let bufferIndex;
	let leftBuffer;
	let rightBuffer;


	/* primitiveExternalCall */

	aSoundBuffer = aSoundBufferOop.storageType === "words" ? aSoundBufferOop.wordsAsInt16Array() : PrimitiveFailed.signal();
	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof n === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	tapDelays = this.pointers[7].storageType === "words" ? this.pointers[7].wordsAsInt32Array() : PrimitiveFailed.signal();
	tapGains = this.pointers[8].storageType === "words" ? this.pointers[8].wordsAsInt32Array() : PrimitiveFailed.signal();
	tapCount = this.pointers[9];
	if (!(typeof tapCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	bufferSize = this.pointers[10];
	if (!(typeof bufferSize === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	bufferIndex = this.pointers[11];
	if (!(typeof bufferIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	leftBuffer = this.pointers[12].storageType === "words" ? this.pointers[12].wordsAsInt16Array() : PrimitiveFailed.signal();
	rightBuffer = this.pointers[13].storageType === "words" ? this.pointers[13].wordsAsInt16Array() : PrimitiveFailed.signal();
	sliceIndex = startIndex;
	const sliceIndexLimiT = startIndex + n;
	for (; sliceIndex < sliceIndexLimiT; sliceIndex++) {
		delayedLeft = (delayedRight = 0);
		for (tapIndex = 1; tapIndex <= tapCount; tapIndex++) {
			i = bufferIndex - tapDelays[tapIndex - 1];
			if (i < 1) {
				i += bufferSize;
			}
			tapGain = tapGains[tapIndex - 1];
			delayedLeft += tapGain * leftBuffer[i - 1];
			delayedRight += tapGain * rightBuffer[i - 1];
		}
		j = (2 * sliceIndex) - 1;
		out = aSoundBuffer[j - 1] + (delayedLeft >> 15);
		if (out > 32767) {
			out = 32767;
		}
		if (out < -32767) {
			out = -32767;
		}
		aSoundBuffer[j - 1] = out;
		leftBuffer[bufferIndex - 1] = out;
		++j;
		out = aSoundBuffer[j - 1] + (delayedRight >> 15);
		if (out > 32767) {
			out = 32767;
		}
		if (out < -32767) {
			out = -32767;
		}
		aSoundBuffer[j - 1] = out;
		rightBuffer[bufferIndex - 1] = out;
		bufferIndex = (MOD(bufferIndex, bufferSize)) + 1;
	}
	this.pointers[11] = bufferIndex;
}
, 

/*	Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy. */
/*	(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play */

primitiveMixFMSound(n, aSoundBufferOop, startIndex, leftVol, rightVol) {
	let doingFM;
	let i;
	let lastIndex;
	let offset;
	let s;
	let sample;
	let sliceIndex;
	let aSoundBuffer;
	let scaledVol;
	let scaledVolIncr;
	let scaledVolLimit;
	let count;
	let waveTable;
	let scaledWaveTableSize;
	let scaledIndex;
	let scaledIndexIncr;
	let normalizedModulation;
	let scaledOffsetIndex;
	let scaledOffsetIndexIncr;


	/* primitiveExternalCall */

	if (!(typeof n === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	aSoundBuffer = aSoundBufferOop.storageType === "words" ? aSoundBufferOop.wordsAsInt16Array() : PrimitiveFailed.signal();
	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof leftVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof rightVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVol = this.pointers[3];
	if (!(typeof scaledVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolIncr = this.pointers[4];
	if (!(typeof scaledVolIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolLimit = this.pointers[5];
	if (!(typeof scaledVolLimit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	count = this.pointers[7];
	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	waveTable = this.pointers[8].storageType === "words" ? this.pointers[8].wordsAsInt16Array() : PrimitiveFailed.signal();
	scaledWaveTableSize = this.pointers[9];
	if (!(typeof scaledWaveTableSize === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndex = this.pointers[10];
	if (!(typeof scaledIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndexIncr = this.pointers[11];
	if (!(typeof scaledIndexIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	normalizedModulation = this.pointers[14];
	if (!(typeof normalizedModulation === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledOffsetIndex = this.pointers[15];
	if (!(typeof scaledOffsetIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledOffsetIndexIncr = this.pointers[16];
	if (!(typeof scaledOffsetIndexIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	doingFM = (normalizedModulation !== 0) && (scaledOffsetIndexIncr !== 0);
	lastIndex = (startIndex + n) - 1;
	for (sliceIndex = startIndex; sliceIndex <= lastIndex; sliceIndex++) {
		sample = (scaledVol * waveTable[scaledIndex >> 15]) >> 15;
		if (doingFM) {
			offset = normalizedModulation * waveTable[scaledOffsetIndex >> 15];
			scaledOffsetIndex = MOD((scaledOffsetIndex + scaledOffsetIndexIncr), scaledWaveTableSize);
			if (scaledOffsetIndex < 0) {
				scaledOffsetIndex += scaledWaveTableSize;
			}
			scaledIndex = MOD(((scaledIndex + scaledIndexIncr) + offset), scaledWaveTableSize);
			if (scaledIndex < 0) {
				scaledIndex += scaledWaveTableSize;
			}
		} else {
			scaledIndex = MOD((scaledIndex + scaledIndexIncr), scaledWaveTableSize);
		}
		if (leftVol > 0) {
			i = (2 * sliceIndex) - 1;
			s = aSoundBuffer[i - 1] + ((sample * leftVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (rightVol > 0) {
			i = 2 * sliceIndex;
			s = aSoundBuffer[i - 1] + ((sample * rightVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (scaledVolIncr !== 0) {
			scaledVol += scaledVolIncr;
			if (((scaledVolIncr > 0) && (scaledVol >= scaledVolLimit)) || ((scaledVolIncr < 0) && (scaledVol <= scaledVolLimit))) {

				/* reached the limit; stop incrementing */

				scaledVol = scaledVolLimit;
				scaledVolIncr = 0;
			}
		}
	}
	count -= n;
	this.pointers[3] = scaledVol;
	this.pointers[4] = scaledVolIncr;
	this.pointers[7] = count;
	this.pointers[10] = scaledIndex;
	this.pointers[15] = scaledOffsetIndex;
}
, 

/*	Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely. */
/*	(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play */

primitiveMixLoopedSampledSound(n, aSoundBufferOop, startIndex, leftVol, rightVol) {
	let compositeLeftVol;
	let compositeRightVol;
	let i;
	let isInStereo;
	let lastIndex;
	let leftVal;
	let m;
	let nextSampleIndex;
	let rightVal;
	let s;
	let sampleIndex;
	let sliceIndex;
	let aSoundBuffer;
	let scaledVol;
	let scaledVolIncr;
	let scaledVolLimit;
	let count;
	let releaseCount;
	let leftSamples;
	let rightSamples;
	let lastSample;
	let loopEnd;
	let scaledLoopLength;
	let scaledIndex;
	let scaledIndexIncr;


	/* primitiveExternalCall */

	if (!(typeof n === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	aSoundBuffer = aSoundBufferOop.storageType === "words" ? aSoundBufferOop.wordsAsInt16Array() : PrimitiveFailed.signal();
	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof leftVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof rightVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVol = this.pointers[3];
	if (!(typeof scaledVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolIncr = this.pointers[4];
	if (!(typeof scaledVolIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolLimit = this.pointers[5];
	if (!(typeof scaledVolLimit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	count = this.pointers[7];
	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	releaseCount = this.pointers[8];
	if (!(typeof releaseCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	leftSamples = this.pointers[10].storageType === "words" ? this.pointers[10].wordsAsInt16Array() : PrimitiveFailed.signal();
	rightSamples = this.pointers[11].storageType === "words" ? this.pointers[11].wordsAsInt16Array() : PrimitiveFailed.signal();
	lastSample = this.pointers[16];
	if (!(typeof lastSample === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	loopEnd = this.pointers[17];
	if (!(typeof loopEnd === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledLoopLength = this.pointers[18];
	if (!(typeof scaledLoopLength === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndex = this.pointers[19];
	if (!(typeof scaledIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndexIncr = this.pointers[20];
	if (!(typeof scaledIndexIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	isInStereo = leftSamples !== rightSamples;
	compositeLeftVol = (leftVol * scaledVol) >> 15;
	compositeRightVol = (rightVol * scaledVol) >> 15;
	i = (2 * startIndex) - 1;
	lastIndex = (startIndex + n) - 1;
	for (sliceIndex = startIndex; sliceIndex <= lastIndex; sliceIndex++) {
		sampleIndex = ((scaledIndex += scaledIndexIncr)) >> 9;
		if ((sampleIndex > loopEnd) && (count > releaseCount)) {

			/* loop back if not within releaseCount of the note end */
			/* note: unlooped sounds will have loopEnd = lastSample */

			sampleIndex = ((scaledIndex -= scaledLoopLength)) >> 9;
		}
		if (((nextSampleIndex = sampleIndex + 1)) > lastSample) {
			if (sampleIndex > lastSample) {
				count = 0;
				this.pointers[3] = scaledVol;
				this.pointers[4] = scaledVolIncr;
				this.pointers[7] = count;
				this.pointers[19] = scaledIndex;
				throw Object.create(PrimitiveReturn).setPayload(null);
				return null;
			}
			nextSampleIndex = (scaledLoopLength === 0) ? sampleIndex : (((scaledIndex - scaledLoopLength) >> 9) + 1);
		}
		m = UBANDS(scaledIndex, 511);
		rightVal = (leftVal = ((leftSamples[sampleIndex - 1] * (512 - m)) + (leftSamples[nextSampleIndex - 1] * m)) >> 9);
		if (isInStereo) {
			rightVal = ((rightSamples[sampleIndex - 1] * (512 - m)) + (rightSamples[nextSampleIndex - 1] * m)) >> 9;
		}
		if (leftVol > 0) {
			s = aSoundBuffer[i - 1] + ((compositeLeftVol * leftVal) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		++i;
		if (rightVol > 0) {
			s = aSoundBuffer[i - 1] + ((compositeRightVol * rightVal) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		++i;
		if (scaledVolIncr !== 0) {

			/* update volume envelope if it is changing */

			scaledVol += scaledVolIncr;
			if (((scaledVolIncr > 0) && (scaledVol >= scaledVolLimit)) || ((scaledVolIncr < 0) && (scaledVol <= scaledVolLimit))) {

				/* reached the limit; stop incrementing */

				scaledVol = scaledVolLimit;
				scaledVolIncr = 0;
			}
			compositeLeftVol = (leftVol * scaledVol) >> 15;
			compositeRightVol = (rightVol * scaledVol) >> 15;
		}
	}
	count -= n;
	this.pointers[3] = scaledVol;
	this.pointers[4] = scaledVolIncr;
	this.pointers[7] = count;
	this.pointers[19] = scaledIndex;
}
, 

/*	The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. */
/*	(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play */

primitiveMixPluckedSound(n, aSoundBufferOop, startIndex, leftVol, rightVol) {
	let average;
	let i;
	let lastIndex;
	let s;
	let sample;
	let scaledNextIndex;
	let scaledThisIndex;
	let sliceIndex;
	let aSoundBuffer;
	let scaledVol;
	let scaledVolIncr;
	let scaledVolLimit;
	let count;
	let ring;
	let scaledIndex;
	let scaledIndexIncr;
	let scaledIndexLimit;


	/* primitiveExternalCall */

	if (!(typeof n === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	aSoundBuffer = aSoundBufferOop.storageType === "words" ? aSoundBufferOop.wordsAsInt16Array() : PrimitiveFailed.signal();
	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof leftVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof rightVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVol = this.pointers[3];
	if (!(typeof scaledVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolIncr = this.pointers[4];
	if (!(typeof scaledVolIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolLimit = this.pointers[5];
	if (!(typeof scaledVolLimit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	count = this.pointers[7];
	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	ring = this.pointers[8].storageType === "words" ? this.pointers[8].wordsAsInt16Array() : PrimitiveFailed.signal();
	scaledIndex = this.pointers[9];
	if (!(typeof scaledIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndexIncr = this.pointers[10];
	if (!(typeof scaledIndexIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndexLimit = this.pointers[11];
	if (!(typeof scaledIndexLimit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	lastIndex = (startIndex + n) - 1;
	scaledThisIndex = (scaledNextIndex = scaledIndex);
	for (sliceIndex = startIndex; sliceIndex <= lastIndex; sliceIndex++) {
		scaledNextIndex = scaledThisIndex + scaledIndexIncr;
		if (scaledNextIndex >= scaledIndexLimit) {
			scaledNextIndex = 32768 + (scaledNextIndex - scaledIndexLimit);
		}
		average = (ring[(scaledThisIndex >> 15) - 1] + ring[(scaledNextIndex >> 15) - 1]) >> 1;
		ring[(scaledThisIndex >> 15) - 1] = average;

		/* scale by volume */

		sample = (average * scaledVol) >> 15;
		scaledThisIndex = scaledNextIndex;
		if (leftVol > 0) {
			i = (2 * sliceIndex) - 1;
			s = aSoundBuffer[i - 1] + ((sample * leftVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (rightVol > 0) {
			i = 2 * sliceIndex;
			s = aSoundBuffer[i - 1] + ((sample * rightVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (scaledVolIncr !== 0) {
			scaledVol += scaledVolIncr;
			if (((scaledVolIncr > 0) && (scaledVol >= scaledVolLimit)) || ((scaledVolIncr < 0) && (scaledVol <= scaledVolLimit))) {

				/* reached the limit; stop incrementing */

				scaledVol = scaledVolLimit;
				scaledVolIncr = 0;
			}
		}
	}
	scaledIndex = scaledNextIndex;
	count -= n;
	this.pointers[3] = scaledVol;
	this.pointers[4] = scaledVolIncr;
	this.pointers[7] = count;
	this.pointers[9] = scaledIndex;
}
, 

/*	Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. */

primitiveMixSampledSound(n, aSoundBufferOop, startIndex, leftVol, rightVol) {
	let i;
	let lastIndex;
	let outIndex;
	let overflow;
	let s;
	let sample;
	let sampleIndex;
	let aSoundBuffer;
	let scaledVol;
	let scaledVolIncr;
	let scaledVolLimit;
	let count;
	let samples;
	let samplesSize;
	let scaledIndex;
	let indexHighBits;
	let scaledIncrement;


	/* primitiveExternalCall */

	if (!(typeof n === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	aSoundBuffer = aSoundBufferOop.storageType === "words" ? aSoundBufferOop.wordsAsInt16Array() : PrimitiveFailed.signal();
	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof leftVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof rightVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVol = this.pointers[3];
	if (!(typeof scaledVol === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolIncr = this.pointers[4];
	if (!(typeof scaledVolIncr === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledVolLimit = this.pointers[5];
	if (!(typeof scaledVolLimit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	count = this.pointers[7];
	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	samples = this.pointers[8].storageType === "words" ? this.pointers[8].wordsAsInt16Array() : PrimitiveFailed.signal();
	samplesSize = this.pointers[10];
	if (!(typeof samplesSize === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIndex = this.pointers[11];
	if (!(typeof scaledIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	indexHighBits = this.pointers[12];
	if (!(typeof indexHighBits === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	scaledIncrement = this.pointers[13];
	if (!(typeof scaledIncrement === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	lastIndex = (startIndex + n) - 1;

	/* index of next stereo output sample pair */

	outIndex = startIndex;
	sampleIndex = indexHighBits + (scaledIndex >>> 16);
	while ((sampleIndex <= samplesSize) && (outIndex <= lastIndex)) {
		sample = (samples[sampleIndex - 1] * scaledVol) >> 15;
		if (leftVol > 0) {
			i = (2 * outIndex) - 1;
			s = aSoundBuffer[i - 1] + ((sample * leftVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (rightVol > 0) {
			i = 2 * outIndex;
			s = aSoundBuffer[i - 1] + ((sample * rightVol) >> 15);
			if (s > 32767) {
				s = 32767;
			}
			if (s < -32767) {
				s = -32767;
			}
			aSoundBuffer[i - 1] = s;
		}
		if (scaledVolIncr !== 0) {
			scaledVol += scaledVolIncr;
			if (((scaledVolIncr > 0) && (scaledVol >= scaledVolLimit)) || ((scaledVolIncr < 0) && (scaledVol <= scaledVolLimit))) {

				/* reached the limit; stop incrementing */

				scaledVol = scaledVolLimit;
				scaledVolIncr = 0;
			}
		}
		scaledIndex += scaledIncrement;
		if (scaledIndex >= 536870912) {
			overflow = scaledIndex >>> 16;
			indexHighBits += overflow;
			scaledIndex -= overflow << 16 >>> 0;
		}
		sampleIndex = indexHighBits + (scaledIndex >>> 16);
		++outIndex;
	}
	count -= n;
	this.pointers[3] = scaledVol;
	this.pointers[4] = scaledVolIncr;
	this.pointers[7] = count;
	this.pointers[11] = scaledIndex;
	this.pointers[12] = indexHighBits;
}
, 
}