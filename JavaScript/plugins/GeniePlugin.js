/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:33 pm *//* Automatically generated by	JSSmartSyntaxPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	GeniePlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let interpreterProxy;let moduleName = "GeniePlugin v2.0 7 February 2022 (e)";let simulator = 0;globalThis.GeniePlugin = {/*	arguments are pointer to ints paired as x,y coordinates of points */cSquaredDistanceFromto(aPoint, bPoint) {	let yDiff;	let aPointX;	let bPointX;	let aPointY;	let bPointY;	let xDiff;	aPointX = aPoint[0];	aPointY = aPoint[1];	bPointX = bPoint[0];	bPointY = bPoint[1];	xDiff = bPointX - aPointX;	yDiff = bPointY - aPointY;	return (xDiff * xDiff) + (yDiff * yDiff);}, cSubstAngleFactorFromto(startDegreeNumber, endDegreeNumber) {	let absDiff;	absDiff = Math.abs(endDegreeNumber - startDegreeNumber);	if (absDiff > 180) {		absDiff = 360 - absDiff;	}	return (absDiff * absDiff) >>> 6;}, primSameClassAbsoluteStrokeDistanceMyPoints_otherPoints_myVectors_otherVectors_mySquaredLengths_otherSquaredLengths_myAngles_otherAngles_maxSizeAndReferenceFlag_rowBase_rowInsertRemove_rowInsertRemoveCount(myPointsOop, otherPointsOop, myVectorsOop, otherVectorsOop, mySquaredLengthsOop, otherSquaredLengthsOop, myAnglesOop, otherAnglesOop, maxSizeAndRefFlag, rowBaseOop, rowInsertRemoveOop, rowInsertRemoveCountOop) {	let otherAngles;	let otherSquaredLengthsSize;	let forReference;	let jM1;	let iM1;	let jM1T2;	let base;	let insert;	let otherVectors;	let otherVectorsSize;	let otherSquaredLengths;	let rowBaseSize;	let myPoints;	let jLimiT;	let mySquaredLengths;	let additionalMultiInsertRemoveCost;	let remove;	let otherPoints;	let otherPointsSize;	let myVectors;	let rowInsertRemoveCount;	let rowBase;	let maxDist;	let iM1T2;	let j;	let insertRemove;	let i;	let myVectorsSize;	let subst;	let maxSize;	let removeBase;	let substBase;	let myAngles;	let insertRemoveCount;	let rowInsertRemove;	let insertBase;	if (!(typeof maxSizeAndRefFlag === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	if (!(((((((((((myPointsOop.storageType === "words") && (otherPointsOop.storageType === "words")) && (myVectorsOop.storageType === "words")) && (otherVectorsOop.storageType === "words")) && (mySquaredLengthsOop.storageType === "words")) && (otherSquaredLengthsOop.storageType === "words")) && (myAnglesOop.storageType === "words")) && (otherAnglesOop.storageType === "words")) && (rowBaseOop.storageType === "words")) && (rowInsertRemoveOop.storageType === "words")) && (rowInsertRemoveCountOop.storageType === "words"))) throw Object.create(PrimitiveFailed).setPayload(1);	;	if (!((myPointsOop._class() === SmalltalkGlobals._PointArray) && (otherPointsOop._class() === SmalltalkGlobals._PointArray))) throw Object.create(PrimitiveFailed).setPayload(1);	;	myPoints = myPointsOop.wordsAsInt32Array();	otherPoints = otherPointsOop.wordsAsInt32Array();	myVectors = myVectorsOop.wordsAsInt32Array();	otherVectors = otherVectorsOop.wordsAsInt32Array();	mySquaredLengths = mySquaredLengthsOop.wordsAsInt32Array();	otherSquaredLengths = otherSquaredLengthsOop.wordsAsInt32Array();	myAngles = myAnglesOop.wordsAsInt32Array();	otherAngles = otherAnglesOop.wordsAsInt32Array();	rowBase = rowBaseOop.wordsAsInt32Array();	rowInsertRemove = rowInsertRemoveOop.wordsAsInt32Array();	/* Note: myPointsSize and mySquaredLengthsSize variables eliminated to reduce	method temporary variable count for closure-enabled images */	/* PointArrays */	/* myPointsSize := (interpreterProxy stSizeOf: myPointsOop) bitShift: -1. */	rowInsertRemoveCount = rowInsertRemoveCountOop.wordsAsInt32Array();	otherPointsSize = SIZEOF(otherPointsOop) >>> 1;	myVectorsSize = SIZEOF(myVectorsOop) >>> 1;	/* IntegerArrays */	/* mySquaredLengthsSize := interpreterProxy stSizeOf: mySquaredLengthsOop. */	otherVectorsSize = SIZEOF(otherVectorsOop) >>> 1;	otherSquaredLengthsSize = SIZEOF(otherSquaredLengthsOop);	rowBaseSize = SIZEOF(rowBaseOop);	if (!(((rowBaseSize === SIZEOF(rowInsertRemoveOop)) && (rowBaseSize === SIZEOF(rowInsertRemoveCountOop))) && (rowBaseSize > otherVectorsSize))) throw Object.create(PrimitiveFailed).setPayload(1);	;	if (!((((((SIZEOF(mySquaredLengthsOop) >= (myVectorsSize - 1)) && ((SIZEOF(myPointsOop) >>> 1) >= myVectorsSize)) && (otherSquaredLengthsSize >= (otherVectorsSize - 1))) && (otherPointsSize >= otherVectorsSize)) && (SIZEOF(myAnglesOop) >= (myVectorsSize - 1))) && (SIZEOF(otherAnglesOop) >= (otherVectorsSize - 1)))) throw Object.create(PrimitiveFailed).setPayload(1);	;	forReference = UBANDS(maxSizeAndRefFlag, 1);	maxSize = maxSizeAndRefFlag >>> 1;	maxDist = 536870912;	/* C indices!! */	additionalMultiInsertRemoveCost = forReference ? 0 : ((maxSize * maxSize) >>> 10);	rowBase[0] = 0;	rowInsertRemove[0] = 0;	rowInsertRemoveCount[0] = 2;	insertRemove = 0 - additionalMultiInsertRemoveCost;	jLimiT = otherVectorsSize;	if (!((otherPointsSize >= (jLimiT - 1)) && (otherSquaredLengthsSize >= (jLimiT - 1)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	for (j = 1; j <= jLimiT; j++) {		jM1 = j - 1;		insertRemove = (insertRemove + ((otherSquaredLengths[jM1] + GeniePlugin.cSquaredDistanceFromto(PTR_ADD(otherPoints, (jM1 << 1 >>> 0)), myPoints)) >>> 7)) + additionalMultiInsertRemoveCost;		rowInsertRemove[j] = insertRemove;		rowBase[j] = (insertRemove * j);		rowInsertRemoveCount[j] = (j + 1);	}	insertRemove = rowInsertRemove[0] - additionalMultiInsertRemoveCost;	for (i = 1; i <= myVectorsSize; i++) {		iM1 = i - 1;		iM1T2 = iM1 << 1 >>> 0;		substBase = rowBase[0];		insertRemove = (insertRemove + ((mySquaredLengths[iM1] + GeniePlugin.cSquaredDistanceFromto(PTR_ADD(myPoints, iM1T2), otherPoints)) >>> 7)) + additionalMultiInsertRemoveCost;		rowInsertRemove[0] = insertRemove;		rowBase[0] = (insertRemove * i);		rowInsertRemoveCount[0] = (i + 1);		jLimiT = otherVectorsSize;		for (j = 1; j <= jLimiT; j++) {			jM1 = j - 1;			jM1T2 = jM1 << 1 >>> 0;			removeBase = rowBase[j];			insertBase = rowBase[jM1];			remove = (mySquaredLengths[iM1] + GeniePlugin.cSquaredDistanceFromto(PTR_ADD(myPoints, iM1T2), PTR_ADD(otherPoints, (j << 1 >>> 0)))) >>> 7;			if (((insertRemove = rowInsertRemove[j])) === 0) {				removeBase += remove;			} else {				removeBase = (removeBase + insertRemove) + (remove * rowInsertRemoveCount[j]);				remove += insertRemove;			}			insert = (otherSquaredLengths[jM1] + GeniePlugin.cSquaredDistanceFromto(PTR_ADD(otherPoints, jM1T2), PTR_ADD(myPoints, (i << 1 >>> 0)))) >>> 7;			if (((insertRemove = rowInsertRemove[jM1])) === 0) {				insertBase += insert;			} else {				insertBase = (insertBase + insertRemove) + (insert * rowInsertRemoveCount[jM1]);				insert += insertRemove;			}			if (forReference) {				substBase = maxDist;			} else {				subst = ((GeniePlugin.cSquaredDistanceFromto(PTR_ADD(otherVectors, jM1T2), PTR_ADD(myVectors, iM1T2)) + GeniePlugin.cSquaredDistanceFromto(PTR_ADD(otherPoints, jM1T2), PTR_ADD(myPoints, iM1T2))) * (16 + GeniePlugin.cSubstAngleFactorFromto(otherAngles[jM1], myAngles[iM1]))) >>> 11;				substBase += subst;			}			if ((substBase <= removeBase) && (substBase <= insertBase)) {				base = substBase;				insertRemove = 0;				insertRemoveCount = 1;			} else {				if (removeBase <= insertBase) {					base = removeBase;					insertRemove = remove + additionalMultiInsertRemoveCost;					insertRemoveCount = rowInsertRemoveCount[j] + 1;				} else {					base = insertBase;					insertRemove = insert + additionalMultiInsertRemoveCost;					insertRemoveCount = rowInsertRemoveCount[jM1] + 1;				}			}			substBase = rowBase[j];			rowBase[j] = Math.min(base, maxDist);			rowInsertRemove[j] = Math.min(insertRemove, maxDist);			rowInsertRemoveCount[j] = insertRemoveCount;		}		insertRemove = rowInsertRemove[0];	}	throw Object.create(PrimitiveReturn).setPayload(base);}, /*	majorNO * 1000 + minorNO */primVersionNO() {	throw Object.create(PrimitiveReturn).setPayload((2000));}, }