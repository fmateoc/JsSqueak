/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:33 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	FFTPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let fftSize = 0;let imagData;let imagDataSize = 0;let interpreterProxy;let moduleName = "FFTPlugin 7 February 2022 (e)";let nu = 0;let permTable;let permTableSize = 0;let realData;let realDataSize = 0;let sinTable;let sinTableSize = 0;globalThis.FFTPlugin = {loadFFTFrom(fftOop) {	let oop;	if (!(SIZEOF(fftOop) >= 6)) throw Object.create(PrimitiveFailed).setPayload(1);	nu = fftOop.pointers[0];fftSize = fftOop.pointers[1];oop = fftOop.pointers[2];sinTableSize = SIZEOF(oop);/* begin checkedFloatPtrOf: */if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);sinTable = oop.wordsAsFloat32Array();/* end checkedFloatPtrOf: */oop = fftOop.pointers[3];permTableSize = SIZEOF(oop);/* begin checkedWordPtrOf: */if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);permTable = oop.words;/* end checkedWordPtrOf: */oop = fftOop.pointers[4];realDataSize = SIZEOF(oop);/* begin checkedFloatPtrOf: */if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);realData = oop.wordsAsFloat32Array();/* end checkedFloatPtrOf: */oop = fftOop.pointers[5];imagDataSize = SIZEOF(oop);/* begin checkedFloatPtrOf: */if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);imagData = oop.wordsAsFloat32Array();/* end checkedFloatPtrOf: */if (!((((((SHL(1, nu)) === fftSize) && (((fftSize >> 2) + 1) === sinTableSize)) && (fftSize === realDataSize)) && (fftSize === imagDataSize)) && (realDataSize === imagDataSize))) throw Object.create(PrimitiveFailed).setPayload(1);return false === false;}, permuteData() {	let a;	let b;	let end;	let i;	let tmp;	i = 0;	end = permTableSize;	while (i < end) {		a = permTable[i] - 1;		b = permTable[i + 1] - 1;		if ((a < realDataSize) && (b < realDataSize)) {			tmp = realData[a];			realData[a] = realData[b];			realData[b] = tmp;			tmp = imagData[a];			imagData[a] = imagData[b];			imagData[b] = tmp;			i += 2;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}}, primitiveFFTPermuteData() {	((typeof this === "number") ? PrimitiveFailed.signal() : this);	if (!FFTPlugin.loadFFTFrom(this)) {		return null;	}	FFTPlugin.permuteData.apply(this, arguments);	;	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFFTScaleData() {	((typeof this === "number") ? PrimitiveFailed.signal() : this);	if (!FFTPlugin.loadFFTFrom(this)) {		return null;	}	FFTPlugin.scaleData.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFFTTransformData(_arg1) {	let forward;	forward = (typeof _arg1 === "boolean" ? _arg1 : PrimitiveFailed.signal());	((typeof this === "number") ? PrimitiveFailed.signal() : this);	if (!FFTPlugin.loadFFTFrom(this)) {		return null;	}	/* begin transformData: */	FFTPlugin.permuteData.apply(this, arguments);	FFTPlugin.transformForward(forward);if (!forward) {	FFTPlugin.scaleData.apply(this, arguments);}	/* end transformData: */	;	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Scale all elements by 1/n when doing inverse */scaleData() {	let i;	let realN;	if (fftSize <= 1) {		return null;	} else {		realN = (1.0 / fftSize);		for (i = 0; i <= (fftSize - 1); i++) {			realData[i] = (realData[i] * realN);			imagData[i] = (imagData[i] * realN);		}	}}, transformForward(forward) {	let fftScale;	let fftSize2;	let fftSize4;	let i;	let ii;	let imagT;	let imagU;	let ip;	let j;	let lev;	let lev1;	let level;	let realT;	let realU;	let theta;	fftSize2 = fftSize >> 1;	fftSize4 = fftSize >> 2;	for (level = 1; level <= nu; level++) {		lev = SHL(1, level);		lev1 = lev >> 1;		fftScale = Math.trunc(fftSize / lev);		for (j = 1; j <= lev1; j++) {			/* pi * (j-1) / lev1 mapped onto 0..n/2 */			theta = (j - 1) * fftScale;			if (theta < fftSize4) {				/* Compute U, the complex multiplier for each level */				realU = sinTable[(sinTableSize - theta) - 1];				imagU = sinTable[theta];			} else {				realU = 0.0 - sinTable[theta - fftSize4];				imagU = sinTable[fftSize2 - theta];			}			if (!forward) {				imagU = 0.0 - imagU;			}			i = j;			while (i <= fftSize) {				ip = (i + lev1) - 1;				ii = i - 1;				realT = (realData[ip] * realU) - (imagData[ip] * imagU);				imagT = (realData[ip] * imagU) + (imagData[ip] * realU);				realData[ip] = (realData[ii] - realT);				imagData[ip] = (imagData[ii] - imagT);				realData[ii] = (realData[ii] + realT);				imagData[ii] = (imagData[ii] + imagT);				i += lev;			}		}	}}, }