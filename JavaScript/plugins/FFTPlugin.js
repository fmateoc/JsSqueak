/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:16 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	FFTPlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let fftSize = 0;let imagData;let imagDataSize = 0;let nu = 0;let permTable;let permTableSize = 0;let realData;let realDataSize = 0;let sinTable;let sinTableSize = 0;globalThis.FFTPlugin = {primitiveFFTPermuteData() {	let a;	let b;	let end;	let i;	let tmp;	let returnValueFromLoop_permuteData_2174;	let a1;	let b1;	let end1;	let i1;	let tmp1;	if (typeof this === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadFFTFrom: */	if (SIZEOF(this) < 6) throw Object.create(PrimitiveFailed).setPayload(1);	/* end loadFFTFrom: */	/* begin permuteData */	i1 = 0;	end1 = permTableSize;	while (i1 < end1) {		a1 = permTable[i1] - 1;		b1 = permTable[i1 + 1] - 1;		if ((a1 < realDataSize) && (b1 < realDataSize)) {			tmp1 = realData[a1];			realData[a1] = realData[b1];			realData[b1] = tmp1;			tmp1 = imagData[a1];			imagData[a1] = imagData[b1];			imagData[b1] = tmp1;			i1 += 2;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);			break;		}	}	/* end permuteData */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFFTScaleData() {	let i;	let realN;	if (typeof this === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadFFTFrom: */	if (SIZEOF(this) < 6) throw Object.create(PrimitiveFailed).setPayload(1);	/* end loadFFTFrom: */	/* begin scaleData */	if (fftSize > 1) {		realN = (1.0 / fftSize);		for (i = 0; i < fftSize; i++) {			realData[i] = (realData[i] * realN);			imagData[i] = (imagData[i] * realN);		}	}	/* end scaleData */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFFTTransformData(_arg1) {	let forward;	let a;	let b;	let end;	let i;	let tmp;	let i1;	let realN;	let a1;	let b1;	let end1;	let i2;	let tmp1;	let fftScale;	let fftSize2;	let fftSize4;	let i3;	let ii;	let imagT;	let imagU;	let ip;	let j;	let lev;	let lev1;	let level;	let realT;	let realU;	let theta;	forward = (typeof _arg1 === "boolean" ? _arg1 : PrimitiveFailed.signal());	if (typeof this === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadFFTFrom: */	if (SIZEOF(this) < 6) throw Object.create(PrimitiveFailed).setPayload(1);	/* end loadFFTFrom: */	/* begin transformData: */	/* begin permuteData */	i2 = 0;	end1 = permTableSize;	while (i2 < end1) {		a1 = permTable[i2] - 1;		b1 = permTable[i2 + 1] - 1;		if ((a1 < realDataSize) && (b1 < realDataSize)) {			tmp1 = realData[a1];			realData[a1] = realData[b1];			realData[b1] = tmp1;			tmp1 = imagData[a1];			imagData[a1] = imagData[b1];			imagData[b1] = tmp1;			i2 += 2;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);			break;		}	}	/* end permuteData */	/* begin transformForward: */fftSize2 = fftSize >> 1;fftSize4 = fftSize >> 2;for (level = 1; level <= nu; level++) {	lev = SHL(1, level);	lev1 = lev >> 1;	fftScale = Math.trunc(fftSize / lev);	for (j = 1; j <= lev1; j++) {		theta = (j - 1) * fftScale;		if (theta < fftSize4) {			realU = sinTable[(sinTableSize - theta) - 1];			imagU = sinTable[theta];		} else {			realU = 0.0 - sinTable[theta - fftSize4];			imagU = sinTable[fftSize2 - theta];		}		if (!forward) {			imagU = 0.0 - imagU;		}		i3 = j;		while (i3 <= fftSize) {			ip = (i3 + lev1) - 1;			ii = i3 - 1;			realT = (realData[ip] * realU) - (imagData[ip] * imagU);			imagT = (realData[ip] * imagU) + (imagData[ip] * realU);			realData[ip] = (realData[ii] - realT);			imagData[ip] = (imagData[ii] - imagT);			realData[ii] += realT;			imagData[ii] += imagT;			i3 += lev;		}	}}/* end transformForward: */if (!forward) {	/* begin scaleData */	if (fftSize > 1) {		realN = (1.0 / fftSize);		for (i1 = 0; i1 < fftSize; i1++) {			realData[i1] = (realData[i1] * realN);			imagData[i1] = (imagData[i1] * realN);		}	}	/* end scaleData */}	/* end transformData: */	throw Object.create(PrimitiveReturn).setPayload(this);}, }