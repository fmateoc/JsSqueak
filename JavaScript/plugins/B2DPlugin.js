/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:26 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	BalloonEnginePlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let aetBuffer;let bbPluginName = "BitBltPlugin";let copyBitsFn;let dispatchReturnValue = 0;let dispatchedValue = 0;let doProfileStats = 0;let engine = 0;let engineStopped = 0;let formArray = 0;let geProfileTime = 0;let getBuffer;let interpreterProxy;let loadBBFn;let moduleName = "B2DPlugin 7 February 2022 (e)";let objBuffer;let objUsed = 0;let spanBuffer;let workBuffer;globalThis.B2DPlugin = {/*	Return the accurate length of the vector described by deltaX and deltaY */accurateLengthOfwith(deltaX, deltaY) {	let length2;	if (deltaX === 0) {		return (deltaY < 0) ? (0 - deltaY) : deltaY;	} else {		if (deltaY === 0) {			return (deltaX < 0) ? (0 - deltaX) : deltaX;		} else {			length2 = (deltaX * deltaX) + (deltaY * deltaY);			return (length2 < 32) ? B2DPlugin.smallSqrtTable.apply(this, arguments)[length2] : ((Math.sqrt(length2) + 0.5) | 0);		}	}}, addEdgeToGET(edge) {	if (!B2DPlugin.allocateGETEntry(1)) {		return 0;	}	getBuffer[workBuffer[12]] = edge;	workBuffer[12]++;}, /*	Adjust the wide bezier curve (dx < 0) to start/end at the right point */adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX) {	let lastX;	let lastY;	(PTR_ADD(objBuffer, bezier + 10))[0] = ((PTR_ADD(objBuffer, bezier + 10))[0] - (lineOffset * 256));	lastX = (PTR_ADD(objBuffer, bezier + 22))[0];	(PTR_ADD(objBuffer, bezier + 22))[0] = (lastX + ((lineWidth - lineOffset) * 256));	lastY = (PTR_ADD(objBuffer, bezier + 22))[1];	(PTR_ADD(objBuffer, bezier + 22))[1] = (lastY + (lineWidth * 256));	objBuffer[bezier + 21] = (endX - lineOffset);}, /*	Adjust the wide bezier curve (dx >= 0) to start/end at the right point */adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX) {	let lastX;	let lastY;	(PTR_ADD(objBuffer, bezier + 10))[0] = ((PTR_ADD(objBuffer, bezier + 10))[0] + (lineOffset * 256));	lastX = (PTR_ADD(objBuffer, bezier + 22))[0];	(PTR_ADD(objBuffer, bezier + 22))[0] = (lastX - ((lineWidth - lineOffset) * 256));	/* Set lineWidth pixels down */	lastY = (PTR_ADD(objBuffer, bezier + 22))[1];	(PTR_ADD(objBuffer, bezier + 22))[1] = (lastY + (lineWidth * 256));	objBuffer[bezier + 21] = ((endX - lineOffset) + lineWidth);}, /*	Adjust the wide line after it has been stepped from lastX to nextX.	Special adjustments of line width and start position are made here	to simulate a rectangular brush */adjustWideLineafterSteppingFromto(line, lastX, nextX) {	let baseWidth;	let deltaX;	let lineOffset;	let lineWidth;	let xDir;	let yEntry;	let yExit;	/* Don't inline this */	/* Fetch the values the adjustment decisions are based on */	yEntry = objBuffer[line + 18];	yExit = objBuffer[line + 19];	baseWidth = objBuffer[line + 20];	lineOffset = baseWidth >> 1;	lineWidth = objBuffer[line + 17];	xDir = objBuffer[line + 10];	/* Adjust the start of the line to fill an entire rectangle */	deltaX = nextX - lastX;	if (yEntry < baseWidth) {		if (xDir < 0) {			/* effectively adding */			lineWidth -= deltaX;		} else {			lineWidth += deltaX;			objBuffer[line + 4] = lastX;		}	}	if ((yExit + lineOffset) === 0) {		if (xDir > 0) {			lineWidth -= objBuffer[line + 12];		} else {			/* effectively subtracting */			lineWidth += objBuffer[line + 12];			objBuffer[line + 4] = lastX;		}	}	if ((yExit + lineOffset) > 0) {		if (xDir < 0) {			/* effectively subtracting */			lineWidth += deltaX;			objBuffer[line + 4] = lastX;		} else {			lineWidth -= deltaX;		}	}	objBuffer[line + 17] = lineWidth;}, allocateBezier() {	let bezier;	if (B2DPlugin.allocateObjEntry(16)) {		bezier = objUsed;		objUsed = bezier + 16;		objBuffer[bezier + 0] = 6;		objBuffer[bezier + 2] = 0;		objBuffer[bezier + 1] = 16;		return bezier;	} else {		return 0;	}}, allocateBitmapFillcolormap(cmSize, cmBits) {	let cm;	let fill;	let fillSize;	let i;	fillSize = 18 + cmSize;	if (B2DPlugin.allocateObjEntry(fillSize)) {		fill = objUsed;		objUsed = fill + fillSize;		objBuffer[fill + 0] = 1024;		objBuffer[fill + 2] = 0;		objBuffer[fill + 1] = fillSize;		cm = PTR_ADD(objBuffer, fill + 18);		if (workBuffer[17] !== 0) {			for (i = 0; i <= (cmSize - 1); i++) {				cm[i] = B2DPlugin.transformColor(cmBits[i]);			}		} else {			for (i = 0; i <= (cmSize - 1); i++) {				cm[i] = cmBits[i];			}		}		objBuffer[fill + 15] = cmSize;		return fill;	} else {		return 0;	}}, /*	Allocate n slots in the global edge table */allocateGETEntry(nSlots) {	let dstIndex;	let i;	let srcIndex;	let iLimiT;	/* First allocate nSlots in the AET */	if (!B2DPlugin.needAvailableSpace(nSlots)) {		return false;	}	if (workBuffer[14] !== 0) {		/* Then move the AET upwards */		srcIndex = workBuffer[14];		dstIndex = workBuffer[14] + nSlots;		for (i = 1, iLimiT = workBuffer[14]; i <= iLimiT; i++) {			aetBuffer[(--dstIndex)] = aetBuffer[(--srcIndex)];		}	}	aetBuffer = PTR_ADD(aetBuffer, nSlots);	return true;}, allocateGradientFillrampWidthisRadial(ramp, rampWidth, isRadial) {	let fill;	let fillSize;	let i;	let rampPtr;	fillSize = 12 + rampWidth;	if (B2DPlugin.allocateObjEntry(fillSize)) {		fill = objUsed;		objUsed = fill + fillSize;		if (isRadial) {			objBuffer[fill + 0] = 768;		} else {			objBuffer[fill + 0] = 512;		}		objBuffer[fill + 2] = 0;		objBuffer[fill + 1] = fillSize;		rampPtr = PTR_ADD(objBuffer, fill + 12);		if (workBuffer[17] !== 0) {			for (i = 0; i <= (rampWidth - 1); i++) {				rampPtr[i] = B2DPlugin.transformColor(ramp[i]);			}		} else {			for (i = 0; i <= (rampWidth - 1); i++) {				rampPtr[i] = ramp[i];			}		}		objBuffer[fill + 10] = rampWidth;		return fill;	} else {		return 0;	}}, /*	Allocate n slots in the object buffer */allocateObjEntry(nSlots) {	let dstIndex;	let i;	let srcIndex;	let iLimiT;	/* First allocate nSlots in the GET */	if (!B2DPlugin.allocateGETEntry(nSlots)) {		return false;	}	if (workBuffer[12] !== 0) {		/* Then move the GET upwards */		srcIndex = workBuffer[12];		dstIndex = workBuffer[12] + nSlots;		for (i = 1, iLimiT = workBuffer[12]; i <= iLimiT; i++) {			getBuffer[(--dstIndex)] = getBuffer[(--srcIndex)];		}	}	getBuffer = PTR_ADD(getBuffer, nSlots);	return true;}, allocateWideBezier() {	let bezier;	if (B2DPlugin.allocateObjEntry(28)) {		bezier = objUsed;		objUsed = bezier + 28;		objBuffer[bezier + 0] = 7;		objBuffer[bezier + 2] = 0;		objBuffer[bezier + 1] = 28;		return bezier;	} else {		return 0;	}}, /*	Check the fill indexes in the run-length encoded fillList */checkCompressedFillIndexListmaxsegments(fillList, maxIndex, nSegs) {	let fillPtr;	let i;	let length;	let nFills;	let runLength;	let runValue;	length = SIZEOF(fillList);	fillPtr = fillList.wordsAsInt32Array();	nFills = 0;	for (i = 0; i <= (length - 1); i++) {		runLength = (fillPtr[i]|0) >>> 16;		runValue = UBANDS((fillPtr[i]|0), 65535);		if (!((runValue >= 0) && (runValue <= maxIndex))) {			return false;		}		nFills += runLength;	}	return nFills === nSegs;}, /*	Check if the indexList (containing fill handles) is okay. */checkCompressedFills(indexList) {	let fillIndex;	let fillPtr;	let i;	let length;	/* First check if the oops have the right format */	if (!(indexList.storageType === "words")) {		return false;	}	length = SIZEOF(indexList);	fillPtr = indexList.wordsAsInt32Array();	for (i = 0; i <= (length - 1); i++) {		/* Make sure the fill is okay */		fillIndex = fillPtr[i];		if (!B2DPlugin.isFillOkay(fillIndex)) {			return false;		}	}	return true;}, /*	Check the run-length encoded lineWidthList matches nSegments */checkCompressedLineWidthssegments(lineWidthList, nSegments) {	let i;	let length;	let nItems;	let ptr;	let runLength;	length = SIZEOF(lineWidthList);	ptr = lineWidthList.wordsAsInt32Array();	nItems = 0;	for (i = 0; i <= (length - 1); i++) {		runLength = (ptr[i]|0) >>> 16;		nItems += runLength;	}	return nItems === nSegments;}, /*	Check if the given point array can be handled by the engine. */checkCompressedPointssegments(points, nSegments) {	let pSize;	if (!(points.storageType === "words")) {		return false;	}	/* The points must be either in PointArray format or ShortPointArray format.	Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either		pSize = nSegments * 3,		for ShortPointArrays or,		pSize = nSegments * 6,		for PointArrays */	pSize = SIZEOF(points);	/* Can't handle this */	return ((pSize === (nSegments * 3)) || (pSize === (nSegments * 6))) ? true : false;}, /*	Check if the given shape can be handled by the engine. 	Since there are a number of requirements this is an extra method. */checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList) {	let maxFillIndex;	if (!B2DPlugin.checkCompressedPointssegments(points, nSegments)) {		return false;	}	if (!B2DPlugin.checkCompressedFills(fillIndexList)) {		return false;	}	maxFillIndex = SIZEOF(fillIndexList);	return B2DPlugin.checkCompressedFillIndexListmaxsegments(leftFills, maxFillIndex, nSegments) ? (B2DPlugin.checkCompressedFillIndexListmaxsegments(rightFills, maxFillIndex, nSegments) ? (B2DPlugin.checkCompressedFillIndexListmaxsegments(lineFills, maxFillIndex, nSegments) ? (B2DPlugin.checkCompressedLineWidthssegments(lineWidths, nSegments) ? true : false) : false) : false) : false;}, circleCosTable() {	let theTable =		[1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,		1.0 ];	return theTable;}, circleSinTable() {	let theTable =		[0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		 0.0 ];	return theTable;}, /*	Clear the current span buffer.	The span buffer is only cleared in the area that has been used by the previous scan line. */clearSpanBuffer() {	let x0;	let x1;	x0 = SHR(workBuffer[32], workBuffer[49]);	x1 = (SHR(workBuffer[34], workBuffer[49])) + 1;	if (x0 < 0) {		x0 = 0;	}	if (x1 > workBuffer[33]) {		x1 = workBuffer[33];	}	while (x0 < x1) {		spanBuffer[x0] = 0;		++x0;	}	workBuffer[32] = workBuffer[33];	workBuffer[34] = 0;}, /*	There is a special hack for this method in JSMethod>>#emitJSSpecialOn:level:generator: */colorTransform() {	return FPTR_ADD(workBuffer, 24);}, /*	Split the bezier curve at the given parametric value.	Note: Since this method is only invoked to make non-monoton		beziers monoton we must check for the resulting y values		to be *really* between the start and end value. */computeBeziersplitAt(index, param) {	let endX;	let endY;	let leftViaX;	let leftViaY;	let newIndex;	let rightViaX;	let rightViaY;	let sharedX;	let sharedY;	let startX;	let startY;	let viaX;	let viaY;	leftViaX = (startX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)]);	leftViaY = (startY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)]);	rightViaX = (viaX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)]);	rightViaY = (viaY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)]);	endX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];	/* Compute intermediate points */	endY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)];	sharedX = (leftViaX += (((viaX - startX) * param) | 0));	sharedY = (leftViaY += (((viaY - startY) * param) | 0));	rightViaX += (((endX - viaX) * param) | 0);	/* Compute new shared point */	rightViaY += (((endY - viaY) * param) | 0);	sharedX += (((rightViaX - leftViaX) * param) | 0);	/* Check the new via points */	sharedY += (((rightViaY - leftViaY) * param) | 0);	leftViaY = (startY > sharedY) ? ((leftViaY > startY) ? startY : ((leftViaY < sharedY) ? sharedY : leftViaY)) : ((leftViaY < startY) ? startY : ((leftViaY > sharedY) ? sharedY : leftViaY));	rightViaY = (sharedY > endY) ? ((rightViaY > sharedY) ? sharedY : ((rightViaY < endY) ? endY : rightViaY)) : ((rightViaY < sharedY) ? sharedY : ((rightViaY > endY) ? endY : rightViaY));	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	if (B2DPlugin.needAvailableSpace(6)) {		workBuffer[10] = (workBuffer[10] - 6);	} else {	}	/* end wbStackPush: */	newIndex = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)] = leftViaX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)] = leftViaY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)] = sharedX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)] = sharedY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 0)] = sharedX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 1)] = sharedY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 2)] = rightViaX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 3)] = rightViaY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 4)] = endX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 5)] = endY;	return newIndex;}, /*	Split the bezier curve at 0.5. */computeBezierSplitAtHalf(index) {	let endX;	let endY;	let leftViaX;	let leftViaY;	let newIndex;	let rightViaX;	let rightViaY;	let sharedX;	let sharedY;	let startX;	let startY;	let viaX;	let viaY;	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	if (B2DPlugin.needAvailableSpace(6)) {		workBuffer[10] = (workBuffer[10] - 6);	} else {	}	/* end wbStackPush: */	newIndex = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	leftViaX = (startX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)]);	leftViaY = (startY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)]);	rightViaX = (viaX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)]);	rightViaY = (viaY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)]);	endX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];	/* Compute intermediate points */	endY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)];	leftViaX += (viaX - startX) >> 1;	leftViaY += (viaY - startY) >> 1;	sharedX = (rightViaX += (endX - viaX) >> 1);	/* Compute new shared point */	sharedY = (rightViaY += (endY - viaY) >> 1);	sharedX += (leftViaX - rightViaX) >> 1;	/* Store the first part back */	sharedY += (leftViaY - rightViaY) >> 1;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)] = leftViaX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)] = leftViaY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)] = sharedX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)] = sharedY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 0)] = sharedX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 1)] = sharedY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 2)] = rightViaX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 3)] = rightViaY;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 4)] = endX;	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - newIndex) + 5)] = endY;	return newIndex;}, /*	Get both values from the two boundaries of the given bezier 	and compute the actual position/width of the line */computeFinalWideBezierValueswidth(bezier, lineWidth) {	let leftX;	let rightX;	let temp;	leftX = (PTR_ADD(objBuffer, bezier + 10))[0] >> 8;	rightX = (PTR_ADD(objBuffer, bezier + 22))[0] >> 8;	if (leftX > rightX) {		temp = leftX;		leftX = rightX;		rightX = temp;	}	objBuffer[bezier + 4] = leftX;	if ((rightX - leftX) > lineWidth) {		objBuffer[bezier + 17] = (rightX - leftX);	} else {		objBuffer[bezier + 17] = lineWidth;	}}, copyBitsFromtoat(x0, x1, yValue) {	return (!copyBitsFn) ? (B2DPlugin.initialiseModule.apply(this, arguments) ? copyBitsFn(x0, x1, yValue) : false) : copyBitsFn(x0, x1, yValue);}, /*	Create the global edge table */createGlobalEdgeTable() {	let end;	let object;	let lineWidth;	let lineWidth1;	object = 0;	end = objUsed;	while (object < end) {		/* Note: addEdgeToGET: may fail on insufficient space but that's not a problem here */		if (B2DPlugin.isEdge(object)) {			/* Check if the edge starts below fillMaxY. */			if (!(objBuffer[object + 5] >= workBuffer[39])) {				/* begin checkedAddEdgeToGET: */				if ((UBANDS((UBANDS(objBuffer[object + 0], 65535)), 254)) === 4) {					/* begin checkedAddLineToGET: */					lineWidth1 = ((UBANDS((UBANDS(objBuffer[object + 0], 65535)), 1)) !== 0) ? objBuffer[object + 20] : 0;					if ((objBuffer[object + 15] + lineWidth1) < workBuffer[38]) {					} else {						if (((objBuffer[object + 4] - lineWidth1) >= workBuffer[37]) && ((objBuffer[object + 14] - lineWidth1) >= workBuffer[37])) {						} else {							B2DPlugin.addEdgeToGET(object);						}					}					/* end checkedAddLineToGET: */				} else {					if ((UBANDS((UBANDS(objBuffer[object + 0], 65535)), 254)) === 6) {						/* begin checkedAddBezierToGET: */						lineWidth = ((UBANDS((UBANDS(objBuffer[object + 0], 65535)), 1)) !== 0) ? objBuffer[object + 20] : 0;						if ((objBuffer[object + 15] + lineWidth) < workBuffer[38]) {						} else {							if (((objBuffer[object + 4] - lineWidth) >= workBuffer[37]) && ((objBuffer[object + 14] - lineWidth) >= workBuffer[37])) {							} else {								B2DPlugin.addEdgeToGET(object);							}						}						/* end checkedAddBezierToGET: */					} else {						B2DPlugin.addEdgeToGET(object);					}				}				/* end checkedAddEdgeToGET: */			}		}		object += objBuffer[object + 1];	}}, /*	Display the span buffer at the current scan line. */displaySpanBufferAt(y) {	let targetX0;	let targetX1;	let targetY;	/* self aaLevelGet > 1 ifTrue:[self adjustAALevel]. */	targetX0 = SHR(workBuffer[32], workBuffer[49]);	if (targetX0 < workBuffer[42]) {		targetX0 = workBuffer[42];	}	targetX1 = SHR(((workBuffer[34] + workBuffer[48]) - 1), workBuffer[49]);	if (targetX1 > workBuffer[43]) {		targetX1 = workBuffer[43];	}	targetY = SHR(y, workBuffer[49]);	if ((targetY < workBuffer[44]) || ((targetY >= workBuffer[45]) || ((targetX1 < workBuffer[42]) || (targetX0 >= workBuffer[43])))) {		return 0;	}	B2DPlugin.copyBitsFromtoat(targetX0, targetX1, targetY);}, /*	There is a special hack for this method in JSMethod>>#emitJSSpecialOn:level:generator: */edgeTransform() {	return FPTR_ADD(workBuffer, 18);}, /*	Ignore dispatch errors when translating to C	(since we have no entry point for #error in the VM proxy) */errorWrongIndex() {	;}, /*	Fill the span buffer from leftX to rightX with the given fill. */fillAllFromto(leftX, rightX) {	let fill;	let startX;	let stopX;	fill = ((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)];	startX = leftX;	stopX = ((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)];	while (stopX < rightX) {		fill = (((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)]);		if (fill !== 0) {			if (B2DPlugin.fillSpanfromto(fill, startX, stopX)) {				return true;			}		}		/* begin quickRemoveInvalidFillsAt: */		if ((workBuffer[1] - workBuffer[10]) === 0) {		} else {			while ((((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)]) <= stopX) {				B2DPlugin.hideFilldepth(((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)], ((workBuffer[1] - workBuffer[10]) === 0) ? -1 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)]);				if ((workBuffer[1] - workBuffer[10]) === 0) {					break;				}			}		}		/* end quickRemoveInvalidFillsAt: */		startX = stopX;		stopX = ((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)];	}	fill = (((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)]);	return (fill === 0) ? false : B2DPlugin.fillSpanfromto(fill, startX, rightX);}, /*	Fill the span buffer between leftEdge and rightEdge using the given bits.	Note: We always start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those with depth 32) directly. */fillBitmapSpanfromto(bits, leftX, rightX) {	let baseShift;	let bitX;	let colorMask;	let colorShift;	let fillValue;	let x;	let x0;	let x1;	x0 = leftX;	x1 = rightX;	/* Hack for pre-increment */	bitX = -1;	if (workBuffer[48] === 1) {		/* Speedy version for no anti-aliasing */		while (x0 < x1) {			fillValue = (bits[(++bitX)]|0);			spanBuffer[x0] = fillValue;			++x0;		}	} else {		/* Generic version with anti-aliasing */		colorMask = workBuffer[51];		colorShift = workBuffer[50];		baseShift = workBuffer[49];		while (x0 < x1) {			x = SHR(x0, baseShift);			fillValue = (bits[(++bitX)]|0);			fillValue = SHR((UBAND(fillValue, colorMask)), colorShift);			spanBuffer[x] = (spanBuffer[x] + fillValue);			++x0;		}	}	if (x1 > workBuffer[34]) {		workBuffer[34] = x1;	}	if (x1 > workBuffer[35]) {		workBuffer[35] = x1;	}}, fillBitmapSpanfromtoat(bmFill, leftX, rightX, yValue) {	let bits;	let bmHeight;	let bmWidth;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let fillValue;	let tileFlag;	let x;	let x1;	let xp;	let yp;	let maxValue;	let newDelta;	let maxValue1;	let newDelta1;	let a;	let b;	let bmDepth;	let bmRaster;	let cMask;	let g;	let r;	let rShift;	let value;	if (workBuffer[48] !== 1) {		return B2DPlugin.fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue);	}	bits = B2DPlugin.loadBitsFrom(bmFill);	if (!bits) {		return null;	}	bmWidth = objBuffer[bmFill + 10];	bmHeight = objBuffer[bmFill + 11];	tileFlag = objBuffer[bmFill + 16] === 1;	deltaX = leftX - objBuffer[bmFill + 4];	deltaY = yValue - objBuffer[bmFill + 5];	dsX = objBuffer[bmFill + 6];	dtX = objBuffer[bmFill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[bmFill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[bmFill + 9]);	x = leftX;	x1 = rightX;	while (x < x1) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue = bmWidth << 16 >>> 0;			newDelta = ds;			while (newDelta < 0) {				newDelta += maxValue;			}			while (newDelta >= maxValue) {				newDelta -= maxValue;			}			ds = newDelta;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue1 = bmHeight << 16 >>> 0;			newDelta1 = dt;			while (newDelta1 < 0) {				newDelta1 += maxValue1;			}			while (newDelta1 >= maxValue1) {				newDelta1 -= maxValue1;			}			dt = newDelta1;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth = objBuffer[bmFill + 12];			bmRaster = objBuffer[bmFill + 14];			if (bmDepth === 32) {				value = (bits[(bmRaster * yp) + xp]|0);				if ((value !== 0) && ((UBANDM(value, 2130706432)) === 0)) {					value = UBORM(value, 2130706432);				}			} else {				rShift = B2DPlugin.rShiftTable.apply(this, arguments)[bmDepth];				value = bits[(bmRaster * yp) + (SHR(xp, rShift))];				cMask = (SHL(1, bmDepth)) - 1;				rShift = (32 - bmDepth) - ((UBAND(xp, ((SHL(1, rShift)) - 1))) * bmDepth);				value = UBAND((SHR(value, rShift)), cMask);				if (bmDepth === 16) {					if (value !== 0) {						b = (UBANDS(value, 31)) << 3 >>> 0;						b += b >>> 5;						g = (UBANDS((value >>> 5), 31)) << 3 >>> 0;						g += g >>> 5;						r = (UBANDS((value >>> 10), 31)) << 3 >>> 0;						r += r >>> 5;						a = 255;						value = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {					value = (objBuffer[bmFill + 15] === 0) ? 0 : (PTR_ADD(objBuffer, bmFill + 18))[value];				}			}			fillValue = B2DPlugin.uncheckedTransformColor(value);			/* end bitmapValue:bits:atX:y: */			spanBuffer[x] = fillValue;		}		ds += dsX;		dt += dtX;		++x;	}}, fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue) {	let aaLevel;	let baseShift;	let bits;	let bmHeight;	let bmWidth;	let cMask;	let cShift;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let fillValue;	let firstPixel;	let idx;	let lastPixel;	let tileFlag;	let x;	let xp;	let yp;	let maxValue;	let newDelta;	let maxValue1;	let newDelta1;	let a;	let b;	let bmDepth;	let bmRaster;	let cMask1;	let g;	let r;	let rShift;	let value;	let maxValue2;	let newDelta2;	let maxValue3;	let newDelta3;	let a1;	let b1;	let bmDepth1;	let bmRaster1;	let cMask2;	let g1;	let r1;	let rShift1;	let value1;	let maxValue4;	let newDelta4;	let maxValue5;	let newDelta5;	let a2;	let b2;	let bmDepth2;	let bmRaster2;	let cMask3;	let g2;	let r2;	let rShift2;	let value2;	let firstPixel1;	bits = B2DPlugin.loadBitsFrom(bmFill);	if (!bits) {		return null;	}	bmWidth = objBuffer[bmFill + 10];	bmHeight = objBuffer[bmFill + 11];	tileFlag = objBuffer[bmFill + 16] === 1;	deltaX = leftX - objBuffer[bmFill + 4];	deltaY = yValue - objBuffer[bmFill + 5];	dsX = objBuffer[bmFill + 6];	dtX = objBuffer[bmFill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[bmFill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[bmFill + 9]);	aaLevel = workBuffer[48];	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	baseShift = workBuffer[49];	cMask = workBuffer[51];	cShift = workBuffer[50];	x = leftX;	while (x < firstPixel) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue = bmWidth << 16 >>> 0;			newDelta = ds;			while (newDelta < 0) {				newDelta += maxValue;			}			while (newDelta >= maxValue) {				newDelta -= maxValue;			}			ds = newDelta;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue1 = bmHeight << 16 >>> 0;			newDelta1 = dt;			while (newDelta1 < 0) {				newDelta1 += maxValue1;			}			while (newDelta1 >= maxValue1) {				newDelta1 -= maxValue1;			}			dt = newDelta1;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth = objBuffer[bmFill + 12];			bmRaster = objBuffer[bmFill + 14];			if (bmDepth === 32) {				value = (bits[(bmRaster * yp) + xp]|0);				if ((value !== 0) && ((UBANDM(value, 2130706432)) === 0)) {					value = UBORM(value, 2130706432);				}			} else {				rShift = B2DPlugin.rShiftTable.apply(this, arguments)[bmDepth];				value = bits[(bmRaster * yp) + (SHR(xp, rShift))];				cMask1 = (SHL(1, bmDepth)) - 1;				rShift = (32 - bmDepth) - ((UBAND(xp, ((SHL(1, rShift)) - 1))) * bmDepth);				value = UBAND((SHR(value, rShift)), cMask1);				if (bmDepth === 16) {					if (value !== 0) {						b = (UBANDS(value, 31)) << 3 >>> 0;						b += b >>> 5;						g = (UBANDS((value >>> 5), 31)) << 3 >>> 0;						g += g >>> 5;						r = (UBANDS((value >>> 10), 31)) << 3 >>> 0;						r += r >>> 5;						a = 255;						value = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {					value = (objBuffer[bmFill + 15] === 0) ? 0 : (PTR_ADD(objBuffer, bmFill + 18))[value];				}			}			fillValue = B2DPlugin.uncheckedTransformColor(value);			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + fillValue);		}		ds += dsX;		dt += dtX;		++x;	}	cMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);	cShift = workBuffer[49];	while (x < lastPixel) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue2 = bmWidth << 16 >>> 0;			newDelta2 = ds;			while (newDelta2 < 0) {				newDelta2 += maxValue2;			}			while (newDelta2 >= maxValue2) {				newDelta2 -= maxValue2;			}			ds = newDelta2;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue3 = bmHeight << 16 >>> 0;			newDelta3 = dt;			while (newDelta3 < 0) {				newDelta3 += maxValue3;			}			while (newDelta3 >= maxValue3) {				newDelta3 -= maxValue3;			}			dt = newDelta3;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth1 = objBuffer[bmFill + 12];			bmRaster1 = objBuffer[bmFill + 14];			if (bmDepth1 === 32) {				value1 = (bits[(bmRaster1 * yp) + xp]|0);				if ((value1 !== 0) && ((UBANDM(value1, 2130706432)) === 0)) {					value1 = UBORM(value1, 2130706432);				}			} else {				rShift1 = B2DPlugin.rShiftTable.apply(this, arguments)[bmDepth1];				value1 = bits[(bmRaster1 * yp) + (SHR(xp, rShift1))];				cMask2 = (SHL(1, bmDepth1)) - 1;				rShift1 = (32 - bmDepth1) - ((UBAND(xp, ((SHL(1, rShift1)) - 1))) * bmDepth1);				value1 = UBAND((SHR(value1, rShift1)), cMask2);				if (bmDepth1 === 16) {					if (value1 !== 0) {						b1 = (UBANDS(value1, 31)) << 3 >>> 0;						b1 += b1 >>> 5;						g1 = (UBANDS((value1 >>> 5), 31)) << 3 >>> 0;						g1 += g1 >>> 5;						r1 = (UBANDS((value1 >>> 10), 31)) << 3 >>> 0;						r1 += r1 >>> 5;						a1 = 255;						value1 = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);					}				} else {					value1 = (objBuffer[bmFill + 15] === 0) ? 0 : (PTR_ADD(objBuffer, bmFill + 18))[value1];				}			}			fillValue = B2DPlugin.uncheckedTransformColor(value1);			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + fillValue);		}		ds += SHL(dsX, cShift);		dt += SHL(dtX, cShift);		x += aaLevel;	}	cMask = workBuffer[51];	cShift = workBuffer[50];	while (x < rightX) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue4 = bmWidth << 16 >>> 0;			newDelta4 = ds;			while (newDelta4 < 0) {				newDelta4 += maxValue4;			}			while (newDelta4 >= maxValue4) {				newDelta4 -= maxValue4;			}			ds = newDelta4;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue5 = bmHeight << 16 >>> 0;			newDelta5 = dt;			while (newDelta5 < 0) {				newDelta5 += maxValue5;			}			while (newDelta5 >= maxValue5) {				newDelta5 -= maxValue5;			}			dt = newDelta5;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth2 = objBuffer[bmFill + 12];			bmRaster2 = objBuffer[bmFill + 14];			if (bmDepth2 === 32) {				value2 = (bits[(bmRaster2 * yp) + xp]|0);				if ((value2 !== 0) && ((UBANDM(value2, 2130706432)) === 0)) {					value2 = UBORM(value2, 2130706432);				}			} else {				rShift2 = B2DPlugin.rShiftTable.apply(this, arguments)[bmDepth2];				value2 = bits[(bmRaster2 * yp) + (SHR(xp, rShift2))];				cMask3 = (SHL(1, bmDepth2)) - 1;				rShift2 = (32 - bmDepth2) - ((UBAND(xp, ((SHL(1, rShift2)) - 1))) * bmDepth2);				value2 = UBAND((SHR(value2, rShift2)), cMask3);				if (bmDepth2 === 16) {					if (value2 !== 0) {						b2 = (UBANDS(value2, 31)) << 3 >>> 0;						b2 += b2 >>> 5;						g2 = (UBANDS((value2 >>> 5), 31)) << 3 >>> 0;						g2 += g2 >>> 5;						r2 = (UBANDS((value2 >>> 10), 31)) << 3 >>> 0;						r2 += r2 >>> 5;						a2 = 255;						value2 = ((b2 + (g2 << 8 >>> 0)) + (r2 << 16 >>> 0)) + (a2 << 24 >>> 0);					}				} else {					value2 = (objBuffer[bmFill + 15] === 0) ? 0 : (PTR_ADD(objBuffer, bmFill + 18))[value2];				}			}			fillValue = B2DPlugin.uncheckedTransformColor(value2);			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + fillValue);		}		ds += dsX;		dt += dtX;		++x;	}}, /*	This is the inner loop for solid color fills with anti-aliasing.	This loop has been unrolled for speed and quality into three parts:		a) copy all pixels that fall into the first full pixel.		b) copy aaLevel pixels between the first and the last full pixel		c) copy all pixels that fall in the last full pixel */fillColorSpanAAx0x1(pixelValue32, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let firstPixel;	let idx;	let lastPixel;	let pv32;	let x;	let firstPixel1;	/* Not now -- maybe later */	/* Compute the pixel boundaries. */	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	/* Part a: Deal with the first n sub-pixels */	x = leftX;	if (x < firstPixel) {		pv32 = SHR((UBAND(pixelValue32, workBuffer[51])), workBuffer[50]);		while (x < firstPixel) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + pv32);			++x;		}	}	if (x < lastPixel) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		pv32 = SHR((UBAND(pixelValue32, colorMask)), workBuffer[49]);		while (x < lastPixel) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + pv32);			x += aaLevel;		}	}	if (x < rightX) {		pv32 = SHR((UBAND(pixelValue32, workBuffer[51])), workBuffer[50]);		while (x < rightX) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + pv32);			++x;		}	}}, /*	Draw a linear gradient fill. */fillLinearGradientfromtoat(fill, leftX, rightX, yValue) {	let ds;	let dsX;	let ramp;	let rampIndex;	let rampSize;	let x;	let x0;	let x1;	let pixelValue32;	let x01;	let x11;	let pixelValue321;	let x02;	let x12;	ramp = PTR_ADD(objBuffer, fill + 12);	rampSize = objBuffer[fill + 10];	dsX = objBuffer[fill + 6];	ds = ((leftX - objBuffer[fill + 4]) * dsX) + ((yValue - objBuffer[fill + 5]) * objBuffer[fill + 7]);	x = (x0 = leftX);	/* Note: The inner loop has been divided into three parts for speed */	/* Part one: Fill everything outside the left boundary */	x1 = rightX;	while (((((rampIndex = ds >> 16)) < 0) || (rampIndex >= rampSize)) && (x < x1)) {		++x;		ds += dsX;	}	if (x > x0) {		if (rampIndex < 0) {			rampIndex = 0;		}		if (rampIndex >= rampSize) {			rampIndex = rampSize - 1;		}		/* begin fillColorSpan:from:to: */		pixelValue32 = ramp[rampIndex];		if (workBuffer[48] === 1) {			x01 = x0;			x11 = x;			while ((x01 + 4) < x11) {				spanBuffer[x01] = pixelValue32;				spanBuffer[x01 + 1] = pixelValue32;				spanBuffer[x01 + 2] = pixelValue32;				spanBuffer[x01 + 3] = pixelValue32;				x01 += 4;			}			while (x01 < x11) {				spanBuffer[x01] = pixelValue32;				++x01;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue32, x0, x);		}		/* end fillColorSpan:from:to: */	}	if (workBuffer[48] === 1) {		/* Fast version w/o anti-aliasing */		while (((((rampIndex = ds >> 16)) < rampSize) && (rampIndex >= 0)) && (x < x1)) {			spanBuffer[x] = ramp[rampIndex];			++x;			ds += dsX;		}	} else {		x = B2DPlugin.fillLinearGradientAArampdsdsXfromto(fill, ramp, ds, dsX, x, rightX);	}	if (x < x1) {		if (rampIndex < 0) {			rampIndex = 0;		}		if (rampIndex >= rampSize) {			rampIndex = rampSize - 1;		}		/* begin fillColorSpan:from:to: */		pixelValue321 = ramp[rampIndex];		if (workBuffer[48] === 1) {			x02 = x;			x12 = x1;			while ((x02 + 4) < x12) {				spanBuffer[x02] = pixelValue321;				spanBuffer[x02 + 1] = pixelValue321;				spanBuffer[x02 + 2] = pixelValue321;				spanBuffer[x02 + 3] = pixelValue321;				x02 += 4;			}			while (x02 < x12) {				spanBuffer[x02] = pixelValue321;				++x02;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue321, x, x1);		}		/* end fillColorSpan:from:to: */	}}, /*	This is the AA version of linear gradient filling. */fillLinearGradientAArampdsdsXfromto(fill, ramp, deltaS, dsX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let firstPixel;	let idx;	let lastPixel;	let rampIndex;	let rampSize;	let rampValue;	let x;	let firstPixel1;	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	rampSize = objBuffer[fill + 10];	ds = deltaS;	x = leftX;	rampIndex = ds >> 16;	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n sub-pixels */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	colorMask = workBuffer[51];	colorShift = workBuffer[50];	while ((x < firstPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < firstPixel) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + rampValue);			++x;			ds += dsX;		}		rampIndex = ds >> 16;	}	colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);	colorShift = workBuffer[49];	while ((x < lastPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < lastPixel) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + rampValue);			x += aaLevel;			ds += SHL(dsX, colorShift);		}		rampIndex = ds >> 16;	}	colorMask = workBuffer[51];	colorShift = workBuffer[50];	while ((x < rightX) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < rightX) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] = (spanBuffer[idx] + rampValue);			++x;			ds += dsX;		}		rampIndex = ds >> 16;	}	return x;}, /*	Part 2a) Compute the decreasing part of the ramp */fillRadialDecreasingrampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let ds;	let dt;	let length2;	let nextLength;	let rampIndex;	let rampValue;	let x;	let x1;	let deltaX;	let deltaY;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	rampIndex = B2DPlugin.accurateLengthOfwith(ds >> 16, dt >> 16);	rampValue = ramp[rampIndex];	length2 = (rampIndex - 1) * (rampIndex - 1);	x = leftX;	x1 = rightX;	if (x1 > objBuffer[fill + 4]) {		x1 = objBuffer[fill + 4];	}	while (x < x1) {		/* Try to copy the current value more than just once */		while ((x < x1) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2)) {			spanBuffer[x] = rampValue;			++x;			ds += dsX;			dt += dtX;		}		/* begin squaredLengthOf:with: */		deltaX = ds >> 16;		deltaY = dt >> 16;		nextLength = (deltaX * deltaX) + (deltaY * deltaY);		/* end squaredLengthOf:with: */		while (nextLength < length2) {			--rampIndex;			rampValue = ramp[rampIndex];			length2 = (rampIndex - 1) * (rampIndex - 1);		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Part 2a) Compute the decreasing part of the ramp */fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let dt;	let firstPixel;	let index;	let lastPixel;	let length2;	let nextLength;	let rampIndex;	let rampValue;	let x;	let x1;	let deltaX;	let deltaY;	let deltaX1;	let deltaY1;	let deltaX2;	let deltaY2;	let firstPixel1;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	rampIndex = B2DPlugin.accurateLengthOfwith(ds >> 16, dt >> 16);	length2 = (rampIndex - 1) * (rampIndex - 1);	x = leftX;	x1 = objBuffer[fill + 4];	if (x1 > rightX) {		x1 = rightX;	}	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > x1) ? x1 : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n sub-pixels */	lastPixel = UBAND((x1 - 1), (~((workBuffer[48] - 1)) >>> 0));	if (x < firstPixel) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < firstPixel) {			/* Try to copy the current value more than just once */			while ((x < firstPixel) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX = ds >> 16;			deltaY = dt >> 16;			nextLength = (deltaX * deltaX) + (deltaY * deltaY);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	if (x < lastPixel) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		colorShift = workBuffer[49];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < lastPixel) {			/* Try to copy the current value more than just once */			while ((x < lastPixel) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				x += aaLevel;				ds += SHL(dsX, colorShift);				dt += SHL(dtX, colorShift);			}			/* begin squaredLengthOf:with: */			deltaX1 = ds >> 16;			deltaY1 = dt >> 16;			nextLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	if (x < x1) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < x1) {			/* Try to copy the current value more than just once */			while ((x < x1) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX2 = ds >> 16;			deltaY2 = dt >> 16;			nextLength = (deltaX2 * deltaX2) + (deltaY2 * deltaY2);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Draw a radial gradient fill. */fillRadialGradientfromtoat(fill, leftX, rightX, yValue) {	let deltaST;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let length2;	let ramp;	let rampSize;	let x;	let x1;	let pixelValue32;	let x0;	let x11;	let pixelValue321;	let x01;	let x12;	ramp = PTR_ADD(objBuffer, fill + 12);	rampSize = objBuffer[fill + 10];	deltaX = leftX - objBuffer[fill + 4];	deltaY = yValue - objBuffer[fill + 5];	dsX = objBuffer[fill + 6];	dtX = objBuffer[fill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[fill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[fill + 9]);	x = leftX;	/* Note: The inner loop has been divided into three parts for speed */	/* Part one: Fill everything outside the left boundary */	x1 = rightX;	/* This is the upper bound */	length2 = (rampSize - 1) * (rampSize - 1);	while ((B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2) && (x < x1)) {		++x;		ds += dsX;		dt += dtX;	}	if (x > leftX) {		/* begin fillColorSpan:from:to: */		pixelValue32 = ramp[rampSize - 1];		if (workBuffer[48] === 1) {			x0 = leftX;			x11 = x;			while ((x0 + 4) < x11) {				spanBuffer[x0] = pixelValue32;				spanBuffer[x0 + 1] = pixelValue32;				spanBuffer[x0 + 2] = pixelValue32;				spanBuffer[x0 + 3] = pixelValue32;				x0 += 4;			}			while (x0 < x11) {				spanBuffer[x0] = pixelValue32;				++x0;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue32, leftX, x);		}		/* end fillColorSpan:from:to: */	}	deltaST = (PTR_ADD(workBuffer, 80));	deltaST[0] = ds;	deltaST[1] = dt;	if (x < objBuffer[fill + 4]) {		/* Draw the decreasing part */		x = (workBuffer[48] === 1) ? B2DPlugin.fillRadialDecreasingrampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1) : B2DPlugin.fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);	}	if (x < x1) {		/* Draw the increasing part */		x = (workBuffer[48] === 1) ? B2DPlugin.fillRadialIncreasingrampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1) : B2DPlugin.fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);	}	if (x < rightX) {		/* begin fillColorSpan:from:to: */		pixelValue321 = ramp[rampSize - 1];		if (workBuffer[48] === 1) {			x01 = x;			x12 = rightX;			while ((x01 + 4) < x12) {				spanBuffer[x01] = pixelValue321;				spanBuffer[x01 + 1] = pixelValue321;				spanBuffer[x01 + 2] = pixelValue321;				spanBuffer[x01 + 3] = pixelValue321;				x01 += 4;			}			while (x01 < x12) {				spanBuffer[x01] = pixelValue321;				++x01;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue321, x, rightX);		}		/* end fillColorSpan:from:to: */	}}, /*	Part 2b) Compute the increasing part of the ramp */fillRadialIncreasingrampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let ds;	let dt;	let lastLength;	let length2;	let nextLength;	let rampIndex;	let rampSize;	let rampValue;	let x;	let x1;	let deltaX;	let deltaY;	let deltaX1;	let deltaY1;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	rampIndex = B2DPlugin.accurateLengthOfwith(ds >> 16, dt >> 16);	rampValue = ramp[rampIndex];	rampSize = objBuffer[fill + 10];	/* This is the upper bound */	length2 = (rampSize - 1) * (rampSize - 1);	nextLength = (rampIndex + 1) * (rampIndex + 1);	/* begin squaredLengthOf:with: */	deltaX1 = ds >> 16;	deltaY1 = dt >> 16;	lastLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);	/* end squaredLengthOf:with: */	x = leftX;	x1 = rightX;	while ((x < x1) && (lastLength < length2)) {		/* Try to copy the current value more than once */		while ((x < x1) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) <= nextLength)) {			spanBuffer[x] = rampValue;			++x;			ds += dsX;			dt += dtX;		}		/* begin squaredLengthOf:with: */		deltaX = ds >> 16;		deltaY = dt >> 16;		lastLength = (deltaX * deltaX) + (deltaY * deltaY);		/* end squaredLengthOf:with: */		while (lastLength > nextLength) {			++rampIndex;			rampValue = ramp[rampIndex];			nextLength = (rampIndex + 1) * (rampIndex + 1);		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Part 2b) Compute the increasing part of the ramp */fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let dt;	let firstPixel;	let index;	let lastLength;	let lastPixel;	let length2;	let nextLength;	let rampIndex;	let rampSize;	let rampValue;	let x;	let deltaX;	let deltaY;	let deltaX1;	let deltaY1;	let deltaX2;	let deltaY2;	let deltaX3;	let deltaY3;	let firstPixel1;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	rampIndex = B2DPlugin.accurateLengthOfwith(ds >> 16, dt >> 16);	rampSize = objBuffer[fill + 10];	/* This is the upper bound */	length2 = (rampSize - 1) * (rampSize - 1);	nextLength = (rampIndex + 1) * (rampIndex + 1);	/* begin squaredLengthOf:with: */	deltaX3 = ds >> 16;	deltaY3 = dt >> 16;	lastLength = (deltaX3 * deltaX3) + (deltaY3 * deltaY3);	/* end squaredLengthOf:with: */	x = leftX;	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n subPixels */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	if ((x < firstPixel) && (lastLength < length2)) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < firstPixel) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while ((x < firstPixel) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) <= nextLength)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX = ds >> 16;			deltaY = dt >> 16;			lastLength = (deltaX * deltaX) + (deltaY * deltaY);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	if ((x < lastPixel) && (lastLength < length2)) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		colorShift = workBuffer[49];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < lastPixel) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while ((x < lastPixel) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) <= nextLength)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				x += aaLevel;				ds += SHL(dsX, colorShift);				dt += SHL(dtX, colorShift);			}			/* begin squaredLengthOf:with: */			deltaX1 = ds >> 16;			deltaY1 = dt >> 16;			lastLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	if ((x < rightX) && (lastLength < length2)) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < rightX) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while ((x < rightX) && (B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) <= nextLength)) {				index = SHR(x, baseShift);				spanBuffer[index] = (spanBuffer[index] + rampValue);				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX2 = ds >> 16;			deltaY2 = dt >> 16;			lastLength = (deltaX2 * deltaX2) + (deltaY2 * deltaY2);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Return true if fillEntry1 should be drawn before fillEntry2 */fillSortsbefore(fillEntry1, fillEntry2) {	let diff;	/* First check the depth value */	diff = workBuffer[workBuffer[10] + (fillEntry1 + 1)] - workBuffer[workBuffer[10] + (fillEntry2 + 1)];	/* See the class comment for aetScanningProblems */	return (diff === 0) ? ((workBuffer[workBuffer[10] + fillEntry1]>>>0) < (workBuffer[workBuffer[10] + fillEntry2]>>>0)) : (diff > 0);}, /*	Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code. */fillSpanfromto(fill, leftX, rightX) {	let type;	let x0;	let x1;	let x01;	let x11;	if (fill === 0) {		return false;	}	x0 = (leftX < workBuffer[35]) ? workBuffer[35] : leftX;	/* Clip left and right values */	x1 = (rightX > (SHL(workBuffer[33], workBuffer[49]))) ? (SHL(workBuffer[33], workBuffer[49])) : rightX;	if (x0 < workBuffer[36]) {		x0 = workBuffer[36];	}	if (x1 > workBuffer[37]) {		x1 = workBuffer[37];	}	if (x0 < workBuffer[32]) {		workBuffer[32] = x0;	}	if (x1 > workBuffer[34]) {		workBuffer[34] = x1;	}	if (x1 > workBuffer[35]) {		workBuffer[35] = x1;	}	if (x0 >= x1) {		return false;	}	if ((UBANDM(fill, 2130706432)) !== 0) {		/* begin fillColorSpan:from:to: */		if (workBuffer[48] === 1) {			x01 = x0;			x11 = x1;			while ((x01 + 4) < x11) {				spanBuffer[x01] = fill;				spanBuffer[x01 + 1] = fill;				spanBuffer[x01 + 2] = fill;				spanBuffer[x01 + 3] = fill;				x01 += 4;			}			while (x01 < x11) {				spanBuffer[x01] = fill;				++x01;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(fill, x0, x1);		}		/* end fillColorSpan:from:to: */	} else {		/* Store the values for the dispatch */		workBuffer[66] = fill;		workBuffer[67] = x0;		workBuffer[68] = x1;		type = (UBANDS((UBANDS(objBuffer[fill + 0], 65535)), 65280)) >>> 8;		if (type <= 1) {			return true;		}		switch (type) {		case 0:		case 1:			B2DPlugin.errorWrongIndex.apply(this, arguments);			break;		case 2:			B2DPlugin.fillLinearGradientfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);			break;		case 3:			B2DPlugin.fillRadialGradientfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);			break;		case 4:		case 5:			B2DPlugin.fillBitmapSpanfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);			break;		}	}	return false;}, /*	Check the global edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, initialize the the edge and add it to the AET */findNextExternalEntryFromGET() {	let edge;	let type;	let yValue;	/* As long as we have entries in the GET */	yValue = workBuffer[88];	while (workBuffer[11] < workBuffer[12]) {		edge = getBuffer[workBuffer[11]];		if (objBuffer[edge + 5] > yValue) {			return false;		} else {			type = UBANDS(objBuffer[edge + 0], 65535);			if ((UBANDS(type, 254)) === 2) {				return true;			} else {				if (B2DPlugin.needAvailableSpace(1)) {					switch (type) {					case 0:					case 1:					case 2:					case 3:						B2DPlugin.errorWrongIndex.apply(this, arguments);						break;					case 4:						B2DPlugin.stepToFirstLineInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 5:						B2DPlugin.stepToFirstWideLineInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 6:						B2DPlugin.stepToFirstBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 7:						B2DPlugin.stepToFirstWideBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					}					B2DPlugin.insertEdgeIntoAET(edge);					workBuffer[11]++;				} else {					return false;				}			}		}	}	return false;}, /*	Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false. *//*	self currentYGet >= 680 ifTrue:[self printAET.self halt.]. */findNextExternalFillFromAET() {	let leftEdge;	let leftX;	let rightEdge;	let rightX;	leftX = (rightX = workBuffer[37]);	while (workBuffer[13] < workBuffer[14]) {		/* TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill. */		leftEdge = (rightEdge = aetBuffer[workBuffer[13]]);		leftX = (rightX = objBuffer[leftEdge + 4]);		if (leftX >= workBuffer[37]) {			return false;		}		/* begin quickRemoveInvalidFillsAt: */		if ((workBuffer[1] - workBuffer[10]) === 0) {		} else {			while ((((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)]) <= leftX) {				B2DPlugin.hideFilldepth(((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)], ((workBuffer[1] - workBuffer[10]) === 0) ? -1 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)]);				if ((workBuffer[1] - workBuffer[10]) === 0) {					break;				}			}		}		/* end quickRemoveInvalidFillsAt: */		if ((UBANDS((UBANDS(objBuffer[leftEdge + 0], 65535)), 1)) !== 0) {			B2DPlugin.toggleWideFillOf(leftEdge);		}		if ((UBANDS(objBuffer[leftEdge + 0], 65536)) === 0) {			B2DPlugin.toggleFillsOf(leftEdge);			if (engineStopped) {				return false;			}		}		workBuffer[13]++;		if (workBuffer[13] < workBuffer[14]) {			rightEdge = aetBuffer[workBuffer[13]];			rightX = objBuffer[rightEdge + 4];			if (rightX >= workBuffer[36]) {				/* This is the visible portion */				B2DPlugin.fillAllFromto(leftX, rightX);			}		}	}	if (rightX < workBuffer[37]) {		B2DPlugin.fillAllFromto(rightX, workBuffer[37]);	}	return false;}, /*	Check the active edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, step the the edge to the next y value. */findNextExternalUpdateFromAET() {	let count;	let edge;	let type;	while (workBuffer[13] < workBuffer[14]) {		edge = aetBuffer[workBuffer[13]];		count = objBuffer[edge + 7] - 1;		if (count === 0) {			/* Edge at end -- remove it */			B2DPlugin.removeFirstAETEntry.apply(this, arguments);		} else {			/* Store remaining lines back */			objBuffer[edge + 7] = count;			type = UBANDS(objBuffer[edge + 0], 65535);			if ((UBANDS(type, 254)) === 2) {				return true;			}			switch (type) {			case 0:			case 1:			case 2:			case 3:				B2DPlugin.errorWrongIndex.apply(this, arguments);				break;			case 4:				B2DPlugin.stepToNextLineInat(aetBuffer[workBuffer[13]], workBuffer[88]);				break;			case 5:				B2DPlugin.stepToNextWideLineInat(aetBuffer[workBuffer[13]], workBuffer[88]);				break;			case 6:				B2DPlugin.stepToNextBezierInat(aetBuffer[workBuffer[13]], workBuffer[88]);				break;			case 7:				B2DPlugin.stepToNextWideBezier.apply(this, arguments);				break;			}			B2DPlugin.resortFirstAETEntry.apply(this, arguments);			workBuffer[13]++;		}	}	return false;}, /*	Return true if the edge at index i should sort before the edge at index j. */getSortsbefore(edge1, edge2) {	let diff;	if (edge1 === edge2) {		return true;	}	diff = objBuffer[edge1 + 5] - objBuffer[edge2 + 5];	if (diff !== 0) {		return diff < 0;	}	diff = objBuffer[edge1 + 4] - objBuffer[edge2 + 4];	return diff < 0;}, /*	Make the fill style with the given index invisible */hideFilldepth(fillIndex, depth) {	let index;	let newDepth;	let newRightX;	let newTop;	let newTopIndex;	let index1;	/* begin findStackFill:depth: */	index1 = 0;	while ((index1 < (workBuffer[1] - workBuffer[10])) && ((workBuffer[workBuffer[10] + index1] !== fillIndex) || (workBuffer[workBuffer[10] + (index1 + 1)] !== depth))) {		index1 += 3;	}	index = (index1 >= (workBuffer[1] - workBuffer[10])) ? -1 : index1;	/* end findStackFill:depth: */	if (index === -1) {		return false;	}	if (index === 0) {		/* begin freeStackFillEntry */		/* begin wbStackPop: */		workBuffer[10] = (workBuffer[10] + 3);		/* end wbStackPop: */		/* end freeStackFillEntry */		return true;	}	workBuffer[workBuffer[10] + index] = workBuffer[workBuffer[10] + 0];	workBuffer[workBuffer[10] + (index + 1)] = workBuffer[workBuffer[10] + 1];	workBuffer[workBuffer[10] + (index + 2)] = workBuffer[workBuffer[10] + 2];	/* begin freeStackFillEntry */	/* begin wbStackPop: */	workBuffer[10] = (workBuffer[10] + 3);	/* end wbStackPop: */	/* end freeStackFillEntry */	if ((workBuffer[1] - workBuffer[10]) <= 3) {		return true;	}	newTopIndex = 0;	index = 3;	while (index < (workBuffer[1] - workBuffer[10])) {		if (B2DPlugin.fillSortsbefore(index, newTopIndex)) {			newTopIndex = index;		}		index += 3;	}	if ((newTopIndex + 3) === (workBuffer[1] - workBuffer[10])) {		return true;	}	newTop = workBuffer[workBuffer[10] + newTopIndex];	workBuffer[workBuffer[10] + newTopIndex] = workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)];	workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)] = newTop;	newDepth = workBuffer[workBuffer[10] + (newTopIndex + 1)];	workBuffer[workBuffer[10] + (newTopIndex + 1)] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)] = newDepth;	newRightX = workBuffer[workBuffer[10] + (newTopIndex + 2)];	workBuffer[workBuffer[10] + (newTopIndex + 2)] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)] = newRightX;	return true;}, /*	Find insertion point for the given edge in the AET */indexForInsertingIntoAET(edge) {	let index;	let initialX;	initialX = objBuffer[edge + 4];	index = 0;	while ((index < workBuffer[14]) && (objBuffer[aetBuffer[index] + 4] < initialX)) {		++index;	}	while ((index < workBuffer[14]) && ((objBuffer[aetBuffer[index] + 4] === initialX) && (B2DPlugin.getSortsbefore(aetBuffer[index], edge)))) {		++index;	}	return index;}, initColorTransform() {	let transform;	transform = B2DPlugin.colorTransform.apply(this, arguments);	transform[0] = 1.0;	transform[1] = 0.0;	transform[2] = 1.0;	transform[3] = 0.0;	transform[4] = 1.0;	transform[5] = 0.0;	transform[6] = 1.0;	transform[7] = 0.0;	workBuffer[17] = 0;}, initEdgeTransform() {	let transform;	transform = B2DPlugin.edgeTransform.apply(this, arguments);	transform[0] = 1.0;	transform[1] = 0.0;	transform[2] = 0.0;	transform[3] = 0.0;	transform[4] = 1.0;	transform[5] = 0.0;	workBuffer[16] = 0;}, initialiseModule() {	loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);	copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);	return (!!loadBBFn) && (!!copyBitsFn);}, /*	Initialization stuff that needs to be done before any processing can take place. *//*	Make sure aaLevel is initialized */initializeGETProcessing() {	B2DPlugin.setAALevel(workBuffer[48]);	if (workBuffer[42] < 0) {		workBuffer[42] = 0;	}	if (workBuffer[43] > workBuffer[33]) {		workBuffer[43] = workBuffer[33];	}	workBuffer[36] = (SHL(workBuffer[42], workBuffer[49]));	workBuffer[38] = (SHL(workBuffer[44], workBuffer[49]));	workBuffer[37] = (SHL(workBuffer[43], workBuffer[49]));	workBuffer[39] = (SHL(workBuffer[45], workBuffer[49]));	workBuffer[12] = 0;	workBuffer[14] = 0;	getBuffer = PTR_ADD(objBuffer, objUsed);	/* Create the global edge table */	aetBuffer = PTR_ADD(objBuffer, objUsed);	B2DPlugin.createGlobalEdgeTable.apply(this, arguments);	if (engineStopped) {		return null;	}	if (workBuffer[12] === 0) {		/* Nothing to do */		workBuffer[88] = workBuffer[39];		return 0;	}	/* begin sortGlobalEdgeTable */	B2DPlugin.quickSortGlobalEdgeTablefromto(getBuffer, 0, workBuffer[12] - 1);	/* end sortGlobalEdgeTable */	workBuffer[88] = objBuffer[getBuffer[0] + 5];	if (workBuffer[88] < workBuffer[38]) {		workBuffer[88] = workBuffer[38];	}	workBuffer[32] = 0;	workBuffer[34] = ((SHL(workBuffer[33], workBuffer[49])) - 1);	B2DPlugin.clearSpanBuffer.apply(this, arguments);}, /*	Insert the edge with the given index from the global edge table into the active edge table.	The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX	are both set. */insertEdgeIntoAET(edge) {	let index;	/* Check for the number of lines remaining */	if (objBuffer[edge + 7] <= 0) {		return null;	}	/* And insert edge */	index = B2DPlugin.indexForInsertingIntoAET(edge);	B2DPlugin.insertToAETbeforeIndex(edge, index);}, /*	Insert the given edge into the AET. */insertToAETbeforeIndex(edge, index) {	let i;	/* Make sure we have space in the AET */	if (!B2DPlugin.needAvailableSpace(1)) {		return null;	}	i = workBuffer[14] - 1;	while (!(i < index)) {		aetBuffer[i + 1] = aetBuffer[i];		--i;	}	aetBuffer[index] = edge;	workBuffer[14]++;}, isEdge(edge) {	let type;	type = UBANDS(objBuffer[edge + 0], 65535);	return (type > 255) ? false : ((UBANDS((UBANDS(objBuffer[edge + 0], 65535)), 255)) !== 0);}, isFillOkay(fill) {	return (fill === 0) || (((UBANDM(fill, 2130706432)) !== 0) || (((fill >= 0) && (fill < objUsed)) && (((UBANDM(fill, 2130706432)) !== 0) || ((UBANDS((UBANDS(objBuffer[fill + 0], 65535)), 65280)) !== 0))));}, /*	Load and subdivide the bezier curve from point1/point2/point3.	If wideFlag is set then make sure the curve is monoton in X. */loadAndSubdivideBezierFromviatoisWide(point1, point2, point3, wideFlag) {	let bz1;	let bz2;	let index;	let index1;	let index2;	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	if (B2DPlugin.needAvailableSpace(6)) {		workBuffer[10] = (workBuffer[10] - 6);	} else {	}	/* end wbStackPush: */	bz1 = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 0)] = point1[0];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 1)] = point1[1];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 2)] = point2[0];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 3)] = point2[1];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 4)] = point3[0];	workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - bz1) + 5)] = point3[1];	index2 = (bz2 = B2DPlugin.subdivideToBeMonotoninX(bz1, wideFlag));	for (index = bz1; index <= bz2; index += 6) {		index1 = B2DPlugin.subdivideBezierFrom(index);		if (index1 > index2) {			index2 = index1;		}		if (engineStopped) {			return 0;		}	}	return Math.trunc(index2 / 6);}, loadArrayShapenSegmentsfilllineWidthlineFill(points, nSegments, fillIndex, lineWidth, lineFill) {	let i;	let pointOop;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	for (i = 0; i <= (nSegments - 1); i++) {		pointOop = points.pointers[(i * 3)];		B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), pointOop);		pointOop = points.pointers[((i * 3) + 1)];		B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), pointOop);		pointOop = points.pointers[((i * 3) + 2)];		B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 84)), pointOop);		;		/* begin transformPoints: */			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));		;		/* end transformPoints: */		x0 = (PTR_ADD(workBuffer, 80))[0];		y0 = (PTR_ADD(workBuffer, 80))[1];		x1 = (PTR_ADD(workBuffer, 82))[0];		y1 = (PTR_ADD(workBuffer, 82))[1];		x2 = (PTR_ADD(workBuffer, 84))[0];		/* Check if we can use a line */		y2 = (PTR_ADD(workBuffer, 84))[1];		if (((x0 === y0) && (x1 === y1)) || ((x1 === x2) && (y1 === y2))) {			B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(lineWidth, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 84)), lineFill, fillIndex, 0);		} else {			/* Need bezier */			segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide((PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), (lineWidth !== 0) && (lineFill !== 0));			if (engineStopped) {				return null;			}			B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);		}		if (engineStopped) {			return null;		}	}}, /*	Load a transformation from the given array. */loadArrayTransformFromintolength(transformOop, destPtr, n) {	let i;	let value;	for (i = 0; i <= (n - 1); i++) {		value = transformOop.pointers[i];		if (!((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float)))) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		if ((typeof value === "number")) {			destPtr[i] = value;		} else {			destPtr[i] = ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal());		}	}}, /*	Initialize the bezier segment stored on the stack */loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFillIndex, rightFillIndex, yOffset) {	if (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)] >= workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)]) {		/* Top to bottom */		objBuffer[bezier + 4] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)];		objBuffer[bezier + 5] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)] - yOffset);		objBuffer[bezier + 12] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)];		objBuffer[bezier + 13] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)] - yOffset);		objBuffer[bezier + 14] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];		objBuffer[bezier + 15] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)] - yOffset);	} else {		objBuffer[bezier + 4] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];		objBuffer[bezier + 5] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)] - yOffset);		objBuffer[bezier + 12] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)];		objBuffer[bezier + 13] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)] - yOffset);		objBuffer[bezier + 14] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)];		objBuffer[bezier + 15] = (workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)] - yOffset);	}	objBuffer[bezier + 6] = workBuffer[113];	objBuffer[bezier + 8] = leftFillIndex;	objBuffer[bezier + 9] = rightFillIndex;}, loadBitBltFrom(bbObj) {	return (!loadBBFn) ? (B2DPlugin.initialiseModule.apply(this, arguments) ? loadBBFn(bbObj) : false) : loadBBFn(bbObj);}, /*	Load the bitmap fill. */loadBitmapFillcolormaptilefromalongnormalxIndex(formOop, cmOop, tileFlag, point1, point2, point3, xIndex) {	let bmBits;	let bmBitsSize;	let bmDepth;	let bmFill;	let bmHeight;	let bmRaster;	let bmWidth;	let cmBits;	let cmSize;	let ppw;	if (cmOop === nil) {		cmSize = 0;		cmBits = null;	} else {		if (cmOop._class() === SmalltalkGlobals._Bitmap) {			cmSize = SIZEOF(cmOop);			cmBits = cmOop.wordsAsInt32Array();		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if ((typeof formOop === "number")) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		if ((formOop.storageType === "pointers")) {			if (SIZEOF(formOop) < 5) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				bmBits = formOop.pointers[0];				if (bmBits._class() === SmalltalkGlobals._Bitmap) {					bmBitsSize = SIZEOF(bmBits);					bmWidth = formOop.pointers[1];					bmHeight = formOop.pointers[2];					bmDepth = formOop.pointers[3];									if ((bmWidth >= 0) && (bmHeight >= 0)) {					if ((((((bmDepth === 32) || (bmDepth === 8)) || (bmDepth === 16)) || (bmDepth === 1)) || (bmDepth === 2)) || (bmDepth === 4)) {						if ((cmSize === 0) || (cmSize === (SHL(1, bmDepth)))) {							ppw = Math.trunc(32 / bmDepth);							bmRaster = Math.trunc((bmWidth + (ppw - 1)) / ppw);							if (bmBitsSize === (bmRaster * bmHeight)) {								bmFill = B2DPlugin.allocateBitmapFillcolormap(cmSize, cmBits);								if (engineStopped) {									return null;								} else {									objBuffer[bmFill + 10] = bmWidth;									objBuffer[bmFill + 11] = bmHeight;									objBuffer[bmFill + 12] = bmDepth;									objBuffer[bmFill + 14] = bmRaster;									objBuffer[bmFill + 13] = bmBitsSize;									objBuffer[bmFill + 16] = tileFlag;									objBuffer[bmFill + 2] = xIndex;									B2DPlugin.loadFillOrientationfromalongnormalwidthheight(bmFill, point1, point2, point3, bmWidth, bmHeight);									return bmFill;								}							} else {								throw Object.create(PrimitiveFailed).setPayload(1);							}						} else {							throw Object.create(PrimitiveFailed).setPayload(1);						}					} else {						throw Object.create(PrimitiveFailed).setPayload(1);					}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}}, /*	Note: Assumes that the contents of formArray has been checked before */loadBitsFrom(bmFill) {	let bitsLen;	let bitsOop;	let formOop;	let xIndex;	xIndex = objBuffer[bmFill + 2];	if (xIndex > SIZEOF(formArray)) {		return null;	} else {		formOop = formArray.pointers[xIndex];		bitsOop = formOop.pointers[0];		bitsLen = SIZEOF(bitsOop);		return (bitsLen === objBuffer[bmFill + 13]) ? bitsOop.wordsAsInt32Array() : null;	}}, /*	Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise */loadColorTransformFrom(transformOop) {	let okay;	let transform;	transform = B2DPlugin.colorTransform.apply(this, arguments);	workBuffer[17] = 0;	okay = B2DPlugin.loadTransformFromintolength(transformOop, transform, 8);	if (okay) {		workBuffer[17] = 1;		transform[1] = (transform[1] * 256.0);		transform[3] = (transform[3] * 256.0);		transform[5] = (transform[5] * 256.0);		transform[7] = (transform[7] * 256.0);		return okay;	} else {		return false;	}}, /*	Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!	 */loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList, pointsShort) {	let i;	let leftLength;	let leftRun;	let leftValue;	let lineFillLength;	let lineFillRun;	let lineFillValue;	let rightLength;	let rightRun;	let rightValue;	let widthLength;	let widthRun;	let widthValue;	let index;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	if (nSegments === 0) {		return 0;	}	leftRun = (rightRun = (widthRun = (lineFillRun = -1)));	leftLength = (rightLength = (widthLength = (lineFillLength = 1)));	leftValue = (rightValue = (widthValue = (lineFillValue = 0)));	for (i = 1; i <= nSegments; i++) {		/* Decrement current run length and load new stuff */		if (((--leftLength)) <= 0) {			++leftRun;			leftLength = (leftFills[leftRun]|0) >>> 16;			leftValue = UBANDS((leftFills[leftRun]|0), 65535);			if (leftValue !== 0) {				leftValue = fillIndexList[leftValue - 1];				leftValue = B2DPlugin.transformColor(leftValue);				if (engineStopped) {					return null;				}			}		}		if (((--rightLength)) <= 0) {			++rightRun;			rightLength = (rightFills[rightRun]|0) >>> 16;			rightValue = UBANDS((rightFills[rightRun]|0), 65535);			if (rightValue !== 0) {				rightValue = fillIndexList[rightValue - 1];				rightValue = B2DPlugin.transformColor(rightValue);			}		}		if (((--widthLength)) <= 0) {			++widthRun;			widthLength = (lineWidths[widthRun]|0) >>> 16;			widthValue = UBANDS((lineWidths[widthRun]|0), 65535);			if (widthValue !== 0) {				widthValue = B2DPlugin.transformWidth(widthValue);			}		}		if (((--lineFillLength)) <= 0) {			++lineFillRun;			lineFillLength = (lineFills[lineFillRun]|0) >>> 16;			lineFillValue = UBANDS((lineFills[lineFillRun]|0), 65535);			if (lineFillValue !== 0) {				lineFillValue = fillIndexList[lineFillValue - 1];			}		}		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if ((leftValue === rightValue) && ((widthValue === 0) || (lineFillValue === 0))) {		} else {			index = (i - 1) * 6;			if (pointsShort) {				x0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 0];				y0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 1];				x1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 2];				y1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 3];				x2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 4];				y2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 5];			} else {				x0 = (points[(index + 0)]|0);				y0 = (points[(index + 1)]|0);				x1 = (points[(index + 2)]|0);				y1 = (points[(index + 3)]|0);				x2 = (points[(index + 4)]|0);				y2 = (points[(index + 5)]|0);			}			if (((x0 === x1) && (y0 === y1)) || ((x1 === x2) && (y1 === y2))) {				if (!((x0 === x2) && (y0 === y2))) {					(PTR_ADD(workBuffer, 80))[0] = x0;					(PTR_ADD(workBuffer, 80))[1] = y0;					(PTR_ADD(workBuffer, 82))[0] = x2;					(PTR_ADD(workBuffer, 82))[1] = y2;					/* begin transformPoints: */									B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));									B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));					;					;					/* end transformPoints: */					B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(widthValue, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), lineFillValue, leftValue, rightValue);				}			} else {				(PTR_ADD(workBuffer, 80))[0] = x0;				(PTR_ADD(workBuffer, 80))[1] = y0;				(PTR_ADD(workBuffer, 82))[0] = x1;				(PTR_ADD(workBuffer, 82))[1] = y1;				(PTR_ADD(workBuffer, 84))[0] = x2;				(PTR_ADD(workBuffer, 84))[1] = y2;				/* begin transformPoints: */							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));				;				/* end transformPoints: */				segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide((PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), (widthValue !== 0) && (lineFillValue !== 0));				if (!engineStopped) {					B2DPlugin.loadWideBezierlineFillleftFillrightFilln(widthValue, lineFillValue, leftValue, rightValue, segs);				}			}		}		/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (engineStopped) {			return null;		}	}}, loadEdgeStateFrom(edgeOop) {	let edge;	edge = workBuffer[65];	if (SIZEOF(edgeOop) < 6) {		return null;	}	objBuffer[edge + 4] = edgeOop.pointers[1];	objBuffer[edge + 5] = edgeOop.pointers[2];	objBuffer[edge + 6] = edgeOop.pointers[3];	objBuffer[edge + 7] = edgeOop.pointers[4];	return edge;}, /*	Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise */loadEdgeTransformFrom(transformOop) {	let okay;	let transform;	workBuffer[16] = 0;	transform = B2DPlugin.edgeTransform.apply(this, arguments);	okay = B2DPlugin.loadTransformFromintolength(transformOop, transform, 6);	;	if (!okay) {		return false;	}	workBuffer[16] = 1;	transform[2] = (transform[2] + workBuffer[46]);	transform[5] = (transform[5] + workBuffer[47]);	return true;}, /*	Transform the points */loadFillOrientationfromalongnormalwidthheight(fill, point1, point2, point3, fillWidth, fillHeight) {	let dirX;	let dirY;	let dsLength2;	let dsX;	let dsY;	let dtLength2;	let dtX;	let dtY;	let nrmX;	let nrmY;	point2[0] = (point2[0] + point1[0]);	point2[1] = (point2[1] + point1[1]);	point3[0] = (point3[0] + point1[0]);	point3[1] = (point3[1] + point1[1]);	B2DPlugin.transformPoint(point1);	B2DPlugin.transformPoint(point2);	B2DPlugin.transformPoint(point3);	dirX = point2[0] - point1[0];	dirY = point2[1] - point1[1];	nrmX = point3[0] - point1[0];	/* Compute the scale from direction/normal into ramp size */	nrmY = point3[1] - point1[1];	dsLength2 = (dirX * dirX) + (dirY * dirY);	if (dsLength2 > 0) {		dsX = ((((dirX * fillWidth) * 65536.0) / dsLength2) | 0);		dsY = ((((dirY * fillWidth) * 65536.0) / dsLength2) | 0);	} else {		dsX = 0;		dsY = 0;	}	dtLength2 = (nrmX * nrmX) + (nrmY * nrmY);	if (dtLength2 > 0) {		dtX = ((((nrmX * fillHeight) * 65536.0) / dtLength2) | 0);		dtY = ((((nrmY * fillHeight) * 65536.0) / dtLength2) | 0);	} else {		dtX = 0;		dtY = 0;	}	objBuffer[fill + 4] = point1[0];	objBuffer[fill + 5] = point1[1];	objBuffer[fill + 6] = dsX;	objBuffer[fill + 7] = dsY;	objBuffer[fill + 8] = dtX;	objBuffer[fill + 9] = dtY;}, /*	Check all the forms from arrayOop. */loadFormsFrom(arrayOop) {	let bmBits;	let bmBitsSize;	let bmDepth;	let bmHeight;	let bmRaster;	let bmWidth;	let formOop;	let i;	let ppw;	if ((arrayOop.storageType === "pointers" && arrayOop.instSize === 0)) {		formArray = arrayOop;		for (i = 0; i <= (SIZEOF(formArray) - 1); i++) {			formOop = formArray.pointers[i];			if ((typeof formOop === "number")) {				return false;			} else {				if ((formOop.storageType === "pointers")) {					if (SIZEOF(formOop) < 5) {						return false;					} else {						bmBits = formOop.pointers[0];						if (bmBits._class() === SmalltalkGlobals._Bitmap) {							bmBitsSize = SIZEOF(bmBits);							bmWidth = formOop.pointers[1];							bmHeight = formOop.pointers[2];							bmDepth = formOop.pointers[3];													if ((bmWidth >= 0) && (bmHeight >= 0)) {							ppw = Math.trunc(32 / bmDepth);							bmRaster = Math.trunc((bmWidth + (ppw - 1)) / ppw);							if (bmBitsSize !== (bmRaster * bmHeight)) {								return false;							}						} else {							return false;						}						} else {							return false;						}					}				} else {					return false;				}			}		}		return true;	} else {		return false;	}}, /*	Load the gradient fill as defined by the color ramp. */loadGradientFillfromalongnormalisRadial(rampOop, point1, point2, point3, isRadial) {	let fill;	let rampWidth;	if (rampOop._class() !== SmalltalkGlobals._Bitmap) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	rampWidth = SIZEOF(rampOop);	fill = B2DPlugin.allocateGradientFillrampWidthisRadial(rampOop.wordsAsInt32Array(), rampWidth, isRadial);	if (engineStopped) {		return null;	}	B2DPlugin.loadFillOrientationfromalongnormalwidthheight(fill, point1, point2, point3, rampWidth, rampWidth);	return fill;}, /*	Load the line defined by point1 and point2. */loadLinefromtooffsetleftFillrightFill(line, point1, point2, yOffset, leftFill, rightFill) {	let p1;	let p2;	let yDir;	if (point1[1] <= point2[1]) {		p1 = point1;		p2 = point2;		yDir = 1;	} else {		p1 = point2;		p2 = point1;		yDir = -1;	}	objBuffer[line + 4] = p1[0];	objBuffer[line + 5] = (p1[1] - yOffset);	objBuffer[line + 6] = workBuffer[113];	objBuffer[line + 8] = leftFill;	objBuffer[line + 9] = rightFill;	objBuffer[line + 14] = p2[0];	objBuffer[line + 15] = (p2[1] - yOffset);	objBuffer[line + 11] = yDir;}, /*	Load a rectangular oval currently defined by point1/point2 */loadOvallineFillleftFillrightFill(lineWidth, lineFill, leftFill, rightFill) {	let cx;	let cy;	let h;	let i;	let nSegments;	let w;	w = ((PTR_ADD(workBuffer, 82))[0] - (PTR_ADD(workBuffer, 80))[0]) >> 1;	h = ((PTR_ADD(workBuffer, 82))[1] - (PTR_ADD(workBuffer, 80))[1]) >> 1;	cx = ((PTR_ADD(workBuffer, 82))[0] + (PTR_ADD(workBuffer, 80))[0]) >> 1;	cy = ((PTR_ADD(workBuffer, 82))[1] + (PTR_ADD(workBuffer, 80))[1]) >> 1;	for (i = 0; i <= 15; i++) {		B2DPlugin.loadOvalSegmentwhcxcy(i, w, h, cx, cy);		/* begin transformPoints: */			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));		;		/* end transformPoints: */		nSegments = B2DPlugin.loadAndSubdivideBezierFromviatoisWide((PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), (lineWidth !== 0) && (lineFill !== 0));		if (engineStopped) {			return null;		}		B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments);		if (engineStopped) {			return null;		}	}}, loadOvalSegmentwhcxcy(seg, w, h, cx, cy) {	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	/* Load start point of segment */	x0 = (((B2DPlugin.circleCosTable.apply(this, arguments)[(seg * 2) + 0] * w) + cx) | 0);	y0 = (((B2DPlugin.circleSinTable.apply(this, arguments)[(seg * 2) + 0] * h) + cy) | 0);	(PTR_ADD(workBuffer, 80))[0] = x0;	(PTR_ADD(workBuffer, 80))[1] = y0;	x2 = (((B2DPlugin.circleCosTable.apply(this, arguments)[(seg * 2) + 2] * w) + cx) | 0);	y2 = (((B2DPlugin.circleSinTable.apply(this, arguments)[(seg * 2) + 2] * h) + cy) | 0);	(PTR_ADD(workBuffer, 84))[0] = x2;	(PTR_ADD(workBuffer, 84))[1] = y2;	x1 = (((B2DPlugin.circleCosTable.apply(this, arguments)[(seg * 2) + 1] * w) + cx) | 0);	/* NOTE: The intermediate point is the point ON the curve	and not yet the control point (which is OFF the curve) */	y1 = (((B2DPlugin.circleSinTable.apply(this, arguments)[(seg * 2) + 1] * h) + cy) | 0);	x1 = (x1 * 2) - ((x0 + x2) >> 1);	y1 = (y1 * 2) - ((y0 + y2) >> 1);	(PTR_ADD(workBuffer, 82))[0] = x1;	(PTR_ADD(workBuffer, 82))[1] = y1;}, /*	Load the contents of pointOop into pointArray */loadPointfrom(pointArray, pointOop) {	let value;	if (pointOop._class() !== SmalltalkGlobals._Point) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	value = pointOop.pointers[0];	if (!((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof value === "number")) {		pointArray[0] = value;	} else {		pointArray[0] = (((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal()) | 0);	}	value = pointOop.pointers[1];	if (!((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof value === "number")) {		pointArray[1] = value;	} else {		pointArray[1] = (((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal()) | 0);	}}, loadPolygonnPointsfilllineWidthlineFillpointsShort(points, nPoints, fillIndex, lineWidth, lineFill, isShort) {	let i;	let x0;	let x1;	let y0;	let y1;	if (isShort) {		x0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[0];		y0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[1];	} else {		x0 = (points[0]|0);		y0 = (points[1]|0);	}	for (i = 1; i <= (nPoints - 1); i++) {		if (isShort) {			x1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[i * 2];			y1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[(i * 2) + 1];		} else {			x1 = (points[(i * 2)]|0);			y1 = (points[((i * 2) + 1)]|0);		}		(PTR_ADD(workBuffer, 80))[0] = x0;		(PTR_ADD(workBuffer, 80))[1] = y0;		(PTR_ADD(workBuffer, 82))[0] = x1;		(PTR_ADD(workBuffer, 82))[1] = y1;		/* begin transformPoints: */			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));			B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));		;		;		/* end transformPoints: */		B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(lineWidth, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), lineFill, fillIndex, 0);		if (engineStopped) {			return null;		} else {			x0 = x1;			y0 = y1;		}	}}, /*	Load the entire state from the interpreter for the rendering primitives.	 Answer 0 on success or a non-zero failure code on failure. */loadRenderingState(edgeOop, fillOop) {	let failCode;	let state;	if (arguments.length !== 2) {		return 5;	}	if (((failCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		return failCode;	}	((typeof fillOop === "number") ? PrimitiveFailed.signal() : fillOop);	((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);	;	if (((failCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		return failCode;	}	if (!B2DPlugin.loadBitBltFrom(engine.pointers[2])) {		return 122;	}	if (!B2DPlugin.loadFormsFrom(engine.pointers[3])) {		return 123;	}	if (SIZEOF(edgeOop) < 6) {		return 112;	}	if (SIZEOF(fillOop) < 6) {		return 113;	}	state = workBuffer[2];	return ((state === 2) || ((state === 4) || (state === 7))) ? 116 : 0;}, loadShapenSegmentsfilllineWidthlineFillpointsShort(points, nSegments, fillIndex, lineWidth, lineFill, pointsShort) {	let i;	let index;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	for (i = 1; i <= nSegments; i++) {		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if ((fillIndex === 0) && ((lineWidth === 0) || (lineFill === 0))) {		} else {			index = (i - 1) * 6;			if (pointsShort) {				x0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 0];				y0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 1];				x1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 2];				y1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 3];				x2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 4];				y2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 5];			} else {				x0 = (points[(index + 0)]|0);				y0 = (points[(index + 1)]|0);				x1 = (points[(index + 2)]|0);				y1 = (points[(index + 3)]|0);				x2 = (points[(index + 4)]|0);				y2 = (points[(index + 5)]|0);			}			if (((x0 === x1) && (y0 === y1)) || ((x1 === x2) && (y1 === y2))) {				if (!((x0 === x2) && (y0 === y2))) {					(PTR_ADD(workBuffer, 80))[0] = x0;					(PTR_ADD(workBuffer, 80))[1] = y0;					(PTR_ADD(workBuffer, 82))[0] = x2;					(PTR_ADD(workBuffer, 82))[1] = y2;					/* begin transformPoints: */									B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));									B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));					;					;					/* end transformPoints: */					B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(lineWidth, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), lineFill, fillIndex, 0);				}			} else {				(PTR_ADD(workBuffer, 80))[0] = x0;				(PTR_ADD(workBuffer, 80))[1] = y0;				(PTR_ADD(workBuffer, 82))[0] = x1;				(PTR_ADD(workBuffer, 82))[1] = y1;				(PTR_ADD(workBuffer, 84))[0] = x2;				(PTR_ADD(workBuffer, 84))[1] = y2;				/* begin transformPoints: */							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));							B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));				;				/* end transformPoints: */				segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide((PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), (lineWidth !== 0) && (lineFill !== 0));				if (!engineStopped) {					B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);				}			}		}		/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (engineStopped) {			return null;		}	}}, /*	Load the span buffer from the given oop.	 Answer 0 on success or a non-zero failure code on failure. */loadSpanBufferFrom(spanOop) {	if (spanOop._class() !== SmalltalkGlobals._Bitmap) {		return 114;	}	/* Leave last entry unused to avoid complications */	spanBuffer = spanOop.words;	workBuffer[33] = (SIZEOF(spanOop) - 1);	return 0;}, /*	Load a transformation from transformOop into the float array	defined by destPtr. The transformation is assumed to be either	an array or a FloatArray of length n. */loadTransformFromintolength(transformOop, destPtr, n) {	if (transformOop === nil) {		return false;	}	if ((typeof transformOop === "number")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(transformOop) !== n) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((transformOop.storageType === "words")) {		B2DPlugin.loadWordTransformFromintolength(transformOop, destPtr, n);	} else {		B2DPlugin.loadArrayTransformFromintolength(transformOop, destPtr, n);	}	return true;}, /*	Load the (possibly wide) bezier from the segments currently on the bezier stack. */loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments) {	let bezier;	let index;	let offset;	let wide;	if ((lineWidth === 0) || (lineFill === 0)) {		wide = false;		offset = 0;	} else {		wide = true;		offset = lineWidth >> 1;	}	index = nSegments * 6;	while (index > 0) {		bezier = wide ? B2DPlugin.allocateWideBezier.apply(this, arguments) : B2DPlugin.allocateBezier.apply(this, arguments);		if (engineStopped) {			return 0;		}		B2DPlugin.loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFill, rightFill, offset);		if (wide) {			objBuffer[bezier + 16] = lineFill;			objBuffer[bezier + 17] = lineWidth;			objBuffer[bezier + 20] = lineWidth;		}		index -= 6;	}	/* begin wbStackClear */	workBuffer[10] = workBuffer[1];	/* end wbStackClear */}, /*	Load a (possibly wide) line defined by the points p1 and p2 */loadWideLinefromtolineFillleftFillrightFill(lineWidth, p1, p2, lineFill, leftFill, rightFill) {	let line;	let offset;	let line1;	let line2;	if ((lineWidth === 0) || (lineFill === 0)) {		/* begin allocateLine */		if (B2DPlugin.allocateObjEntry(16)) {			line1 = objUsed;			objUsed = line1 + 16;			objBuffer[line1 + 0] = 4;			objBuffer[line1 + 2] = 0;			objBuffer[line1 + 1] = 16;			line = line1;		} else {			line = 0;		}		/* end allocateLine */		offset = 0;	} else {		/* begin allocateWideLine */		if (B2DPlugin.allocateObjEntry(21)) {			line2 = objUsed;			objUsed = line2 + 21;			objBuffer[line2 + 0] = 5;			objBuffer[line2 + 2] = 0;			objBuffer[line2 + 1] = 21;			line = line2;		} else {			line = 0;		}		/* end allocateWideLine */		offset = lineWidth >> 1;	}	if (engineStopped) {		return 0;	} else {		B2DPlugin.loadLinefromtooffsetleftFillrightFill(line, p1, p2, offset, leftFill, rightFill);		if ((UBANDS((UBANDS(objBuffer[line + 0], 65535)), 1)) !== 0) {			objBuffer[line + 16] = lineFill;			objBuffer[line + 17] = lineWidth;			objBuffer[line + 20] = lineWidth;		}	}}, /*	Load a float array transformation from the given oop */loadWordTransformFromintolength(transformOop, destPtr, n) {	let i;	let srcPtr;	srcPtr = transformOop.wordsAsFloat32Array();	for (i = 0; i <= (n - 1); i++) {		destPtr[i] = srcPtr[i];	}}, /*	Load the working buffer from the given oop */loadWorkBufferFrom(wbOop) {	if ((typeof wbOop === "number")) {		return 105;	}	if (!(wbOop.storageType === "words")) {		return 106;	}	if (SIZEOF(wbOop) < 256) {		return 107;	}	/* begin workBufferPut: */	workBuffer = wbOop.wordsAsInt32Array();	/* end workBufferPut: */	if (workBuffer[0] !== 1097753705) {		return 108;	}	if (workBuffer[1] !== SIZEOF(wbOop)) {		return 109;	}	if (workBuffer[8] !== 128) {		return 110;	}	objBuffer = PTR_ADD(workBuffer, workBuffer[8]);	getBuffer = PTR_ADD(objBuffer, workBuffer[9]);	/* Make sure we don't exceed the work buffer */	aetBuffer = PTR_ADD(getBuffer, workBuffer[12]);	return ((((128 + workBuffer[9]) + workBuffer[12]) + workBuffer[14]) > workBuffer[1]) ? 111 : 0;}, /*	The module with the given name was just unloaded.	Make sure we have no dangling references. */moduleUnloaded(aModuleName) {	if (strcmp(aModuleName, bbPluginName) === 0) {		/* BitBlt just shut down. How nasty. */		loadBBFn = 0;		copyBitsFn = 0;	}}, /*	The entry at index is not in the right position of the AET. 	Move it to the left until the position is okay. */moveAETEntryFromedgex(index, edge, xValue) {	let newIndex;	newIndex = index;	while ((newIndex > 0) && (objBuffer[aetBuffer[newIndex - 1] + 4] > xValue)) {		aetBuffer[newIndex] = aetBuffer[newIndex - 1];		--newIndex;	}	aetBuffer[newIndex] = edge;}, /*	Check if we have n slots available */needAvailableSpace(nSlots) {	if (((((128 + objUsed) + workBuffer[12]) + workBuffer[14]) + nSlots) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return false;	} else {		return true;	}}, /*	We have just blitted a scan line to the screen.	Do whatever seems to be a good idea here. *//*	Note: In the future we may check the time needed for this scan line and interrupt processing to give the Smalltalk code a chance to run at a certain time. *//*	Check if there is any more work to do. */postDisplayAction() {	if ((workBuffer[11] >= workBuffer[12]) && (workBuffer[14] === 0)) {		/* No more entries to process */		workBuffer[2] = 8;	}	if (workBuffer[88] >= workBuffer[39]) {		/* Out of clipping range */		workBuffer[2] = 8;	}}, primitiveAbortProcessing() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	workBuffer[2] = 8;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveAddActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 2))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);	;	edge = B2DPlugin.loadEdgeStateFrom(edgeOop);	if (!edge) {		throw Object.create(PrimitiveFailed).setPayload(112);	}	if (!B2DPlugin.needAvailableSpace(1)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	if (objBuffer[edge + 7] > 0) {		B2DPlugin.insertEdgeIntoAET(edge);	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[2] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[97]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[96] = (workBuffer[96] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBezier(startOop, endOop, viaOop, _arg4, _arg5) {	let failureCode;	let leftFill;	let nSegments;	let rightFill;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	rightFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	leftFill = (_arg4 >>> 0) === _arg4.valueOf() ? _arg4 : PrimitiveFailed.signal();	((typeof viaOop === "number") ? PrimitiveFailed.signal() : viaOop);	((typeof endOop === "number") ? PrimitiveFailed.signal() : endOop);	((typeof startOop === "number") ? PrimitiveFailed.signal() : startOop);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(leftFill) && (B2DPlugin.isFillOkay(rightFill)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	if ((leftFill === rightFill) && false) {		return null;	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), startOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), viaOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 84)), endOop);	;	/* begin transformPoints: */	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));	;	/* end transformPoints: */	nSegments = B2DPlugin.loadAndSubdivideBezierFromviatoisWide((PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), false);	/* begin needAvailableSpace: */	if (((((128 + objUsed) + workBuffer[12]) + workBuffer[14]) + (nSegments * 16)) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */	} else {	}	/* end needAvailableSpace: */	if (!engineStopped) {		leftFill = B2DPlugin.transformColor(leftFill);		rightFill = B2DPlugin.transformColor(rightFill);	}	if (!engineStopped) {		B2DPlugin.loadWideBezierlineFillleftFillrightFilln(0, 0, leftFill, rightFill, nSegments);	}	if (engineStopped) {		/* Make sure the stack is okay */		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBezierShape(points, nSegments, _arg3, lineWidth, _arg5) {	let failureCode;	let fillIndex;	let length;	let lineFill;	let pointsIsArray;	let segSize;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	lineFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	((typeof lineWidth === "number") ? lineWidth : PrimitiveFailed.signal());	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	((typeof nSegments === "number") ? nSegments : PrimitiveFailed.signal());	((typeof points === "number") ? PrimitiveFailed.signal() : points);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	length = SIZEOF(points);	if ((points.storageType === "words")) {		/* Either PointArray or ShortPointArray */		pointsIsArray = false;		if (!((length === (nSegments * 3)) || (length === (nSegments * 6)))) {			throw Object.create(PrimitiveFailed).setPayload(3);		}	} else {		/* Must be Array of points */		if (!(points.storageType === "pointers" && points.instSize === 0)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		if (length !== (nSegments * 3)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		pointsIsArray = true;	}	segSize = ((lineWidth === 0) || (lineFill === 0)) ? 16 : 21;	if (!B2DPlugin.needAvailableSpace(segSize * nSegments)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	if (!(B2DPlugin.isFillOkay(lineFill) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	lineFill = B2DPlugin.transformColor(lineFill);	fillIndex = B2DPlugin.transformColor(fillIndex);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (((lineFill === 0) || (lineWidth === 0)) && (fillIndex === 0)) {		return null;	}	if (lineWidth !== 0) {		lineWidth = B2DPlugin.transformWidth(lineWidth);		if (lineWidth < 1) {			lineWidth = 1;		}	}	if (pointsIsArray) {		B2DPlugin.loadArrayShapenSegmentsfilllineWidthlineFill(points, nSegments, fillIndex, lineWidth, lineFill);	} else {		B2DPlugin.loadShapenSegmentsfilllineWidthlineFillpointsShort(points.wordsAsInt32Array(), nSegments, fillIndex, lineWidth, lineFill, (nSegments * 3) === length);	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBitmapFill(formOop, cmOop, _arg3, originOop, dirOop, nrmOop, xIndex) {	let failureCode;	let fill;	let tileFlag;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 7) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	((typeof xIndex === "number") ? xIndex : PrimitiveFailed.signal());	if (xIndex <= 0) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	((typeof nrmOop === "number") ? PrimitiveFailed.signal() : nrmOop);	((typeof dirOop === "number") ? PrimitiveFailed.signal() : dirOop);	((typeof originOop === "number") ? PrimitiveFailed.signal() : originOop);	tileFlag = (typeof _arg3 === "boolean" ? _arg3 : PrimitiveFailed.signal());	((typeof cmOop === "number") ? PrimitiveFailed.signal() : cmOop);	((typeof formOop === "number") ? PrimitiveFailed.signal() : formOop);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), originOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), dirOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 84)), nrmOop);	;	fill = B2DPlugin.loadBitmapFillcolormaptilefromalongnormalxIndex(formOop, cmOop, tileFlag ? 1 : 0, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), xIndex - 1);	if (engineStopped) {		/* Make sure the stack is okay */		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(((fill >>> 0) !== fill.valueOf() ? PrimitiveFailed.signal() : (fill >= 0 ? fill : 4294967296 + fill)));}, primitiveAddCompressedShape(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList) {	let failureCode;	let pointsShort;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 7) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	((typeof fillIndexList === "number") ? PrimitiveFailed.signal() : fillIndexList);	((typeof lineFills === "number") ? PrimitiveFailed.signal() : lineFills);	((typeof lineWidths === "number") ? PrimitiveFailed.signal() : lineWidths);	((typeof rightFills === "number") ? PrimitiveFailed.signal() : rightFills);	((typeof leftFills === "number") ? PrimitiveFailed.signal() : leftFills);	((typeof nSegments === "number") ? nSegments : PrimitiveFailed.signal());	((typeof points === "number") ? PrimitiveFailed.signal() : points);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!B2DPlugin.checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList)) {		throw Object.create(PrimitiveFailed).setPayload(120);	}	if (!B2DPlugin.needAvailableSpace(16 * nSegments)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* Then actually load the compressed shape */	pointsShort = SIZEOF(points) === (nSegments * 3);	B2DPlugin.loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points.wordsAsInt32Array(), nSegments, leftFills.wordsAsInt32Array(), rightFills.wordsAsInt32Array(), lineWidths.wordsAsInt32Array(), lineFills.wordsAsInt32Array(), fillIndexList.wordsAsInt32Array(), pointsShort);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddGradientFill(rampOop, originOop, dirOop, nrmOop, _arg5) {	let failureCode;	let fill;	let isRadial;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	isRadial = (typeof _arg5 === "boolean" ? _arg5 : PrimitiveFailed.signal());	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), originOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), dirOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 84)), nrmOop);	;	fill = B2DPlugin.loadGradientFillfromalongnormalisRadial(rampOop, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), isRadial);	if (engineStopped) {		/* Make sure the stack is okay */		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(((fill >>> 0) !== fill.valueOf() ? PrimitiveFailed.signal() : (fill >= 0 ? fill : 4294967296 + fill)));}, primitiveAddLine(startOop, endOop, _arg3, _arg4) {	let failureCode;	let leftFill;	let rightFill;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	rightFill = (_arg4 >>> 0) === _arg4.valueOf() ? _arg4 : PrimitiveFailed.signal();	leftFill = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	((typeof endOop === "number") ? PrimitiveFailed.signal() : endOop);	((typeof startOop === "number") ? PrimitiveFailed.signal() : startOop);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(leftFill) && (B2DPlugin.isFillOkay(rightFill)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), startOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), endOop);	;	/* begin transformPoints: */	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));	;	;	/* end transformPoints: */	leftFill = B2DPlugin.transformColor(leftFill);	rightFill = B2DPlugin.transformColor(rightFill);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(0, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), 0, leftFill, rightFill);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddOval(startOop, endOop, _arg3, borderWidth, _arg5) {	let borderIndex;	let failureCode;	let fillIndex;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	borderIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	((typeof borderWidth === "number") ? borderWidth : PrimitiveFailed.signal());	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	((typeof endOop === "number") ? PrimitiveFailed.signal() : endOop);	((typeof startOop === "number") ? PrimitiveFailed.signal() : startOop);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(borderIndex) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	fillIndex = B2DPlugin.transformColor(fillIndex);	borderIndex = B2DPlugin.transformColor(borderIndex);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if ((fillIndex === 0) && ((borderIndex === 0) || (borderWidth <= 0))) {		return null;	}	if (!B2DPlugin.needAvailableSpace(256)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* Load the rectangle points */	borderWidth = ((borderWidth > 0) && (borderIndex !== 0)) ? B2DPlugin.transformWidth(borderWidth) : 0;	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), startOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), endOop);	;	B2DPlugin.loadOvallineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);	if (engineStopped) {		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddPolygon(points, nPoints, _arg3, lineWidth, _arg5) {	let failureCode;	let fillIndex;	let length;	let lineFill;	let pointsIsArray;	let segSize;	let i;	let x0;	let x1;	let y0;	let y1;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	lineFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	((typeof lineWidth === "number") ? lineWidth : PrimitiveFailed.signal());	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	((typeof nPoints === "number") ? nPoints : PrimitiveFailed.signal());	((typeof points === "number") ? PrimitiveFailed.signal() : points);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	length = SIZEOF(points);	if ((points.storageType === "words")) {		/* Either PointArray or ShortPointArray */		pointsIsArray = false;		if (!((length === nPoints) || ((nPoints * 2) === length))) {			throw Object.create(PrimitiveFailed).setPayload(3);		}	} else {		/* Must be Array of points */		if (!(points.storageType === "pointers" && points.instSize === 0)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		if (length !== nPoints) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		pointsIsArray = true;	}	segSize = ((lineWidth === 0) || (lineFill === 0)) ? 16 : 21;	if (!B2DPlugin.needAvailableSpace(segSize * nPoints)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(B2DPlugin.isFillOkay(lineFill) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	lineFill = B2DPlugin.transformColor(lineFill);	fillIndex = B2DPlugin.transformColor(fillIndex);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (((lineFill === 0) || (lineWidth === 0)) && (fillIndex === 0)) {		return null;	}	if (lineWidth !== 0) {		lineWidth = B2DPlugin.transformWidth(lineWidth);	}	if (pointsIsArray) {		/* begin loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */		B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), points.pointers[0]);			x0 = (PTR_ADD(workBuffer, 80))[0];	y0 = (PTR_ADD(workBuffer, 80))[1];	for (i = 1; i <= (nPoints - 1); i++) {		B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), points.pointers[i]);			x1 = (PTR_ADD(workBuffer, 80))[0];	y1 = (PTR_ADD(workBuffer, 80))[1];	(PTR_ADD(workBuffer, 80))[0] = x0;	(PTR_ADD(workBuffer, 80))[1] = y0;	(PTR_ADD(workBuffer, 82))[0] = x1;	(PTR_ADD(workBuffer, 82))[1] = y1;	/* begin transformPoints: */	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));	;	;	/* end transformPoints: */	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(lineWidth, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), lineFill, fillIndex, 0);	if (engineStopped) {		break;	} else {		x0 = x1;		y0 = y1;	}	}		/* end loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */	} else {		B2DPlugin.loadPolygonnPointsfilllineWidthlineFillpointsShort(points.wordsAsInt32Array(), nPoints, fillIndex, lineWidth, lineFill, nPoints === length);	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	;	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddRect(startOop, endOop, _arg3, borderWidth, _arg5) {	let borderIndex;	let failureCode;	let fillIndex;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	borderIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	((typeof borderWidth === "number") ? borderWidth : PrimitiveFailed.signal());	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	((typeof endOop === "number") ? PrimitiveFailed.signal() : endOop);	((typeof startOop === "number") ? PrimitiveFailed.signal() : startOop);	;	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(borderIndex) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	borderIndex = B2DPlugin.transformColor(borderIndex);	fillIndex = B2DPlugin.transformColor(fillIndex);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if ((fillIndex === 0) && ((borderIndex === 0) || (borderWidth === 0))) {		return null;	}	if (!B2DPlugin.needAvailableSpace(64)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* Load the rectangle */	borderWidth = ((borderWidth > 0) && (borderIndex !== 0)) ? B2DPlugin.transformWidth(borderWidth) : 0;	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), startOop);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 84)), endOop);	;	(PTR_ADD(workBuffer, 82))[0] = (PTR_ADD(workBuffer, 84))[0];	(PTR_ADD(workBuffer, 82))[1] = (PTR_ADD(workBuffer, 80))[1];	(PTR_ADD(workBuffer, 86))[0] = (PTR_ADD(workBuffer, 80))[0];	(PTR_ADD(workBuffer, 86))[1] = (PTR_ADD(workBuffer, 84))[1];	/* begin transformPoints: */	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 86)));	/* end transformPoints: */	/* begin loadRectangle:lineFill:leftFill:rightFill: */	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(borderWidth, (PTR_ADD(workBuffer, 80)), (PTR_ADD(workBuffer, 82)), borderIndex, 0, fillIndex);	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(borderWidth, (PTR_ADD(workBuffer, 82)), (PTR_ADD(workBuffer, 84)), borderIndex, 0, fillIndex);	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(borderWidth, (PTR_ADD(workBuffer, 84)), (PTR_ADD(workBuffer, 86)), borderIndex, 0, fillIndex);	B2DPlugin.loadWideLinefromtolineFillleftFillrightFill(borderWidth, (PTR_ADD(workBuffer, 86)), (PTR_ADD(workBuffer, 80)), borderIndex, 0, fillIndex);	/* end loadRectangle:lineFill:leftFill:rightFill: */	;	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveChangedActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 7))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);	;	edge = B2DPlugin.loadEdgeStateFrom(edgeOop);	if (!edge) {		throw Object.create(PrimitiveFailed).setPayload(112);	}	if (objBuffer[edge + 7] === 0) {		B2DPlugin.removeFirstAETEntry.apply(this, arguments);	} else {		B2DPlugin.resortFirstAETEntry.apply(this, arguments);		workBuffer[13]++;	}	workBuffer[2] = 6;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[107]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[106] = (workBuffer[106] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveCopyBuffer(buf1, buf2) {	let diff;	let dst;	let failCode;	let i;	let src;	let iLimiT;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(buf1))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	if (buf1._class() !== buf2._class()) {		throw Object.create(PrimitiveFailed).setPayload(114);	}	diff = SIZEOF(buf2) - SIZEOF(buf1);	if (diff < 0) {		throw Object.create(PrimitiveFailed).setPayload(115);	}	src = workBuffer;	dst = buf2.wordsAsInt32Array();	for (i = 0, iLimiT = (workBuffer[10] - 1); i <= iLimiT; i++) {		dst[i] = src[i];	}	dst[10] = (workBuffer[10] + diff);	dst[1] = (workBuffer[1] + diff);	src = PTR_ADD(src, workBuffer[10]);	dst = PTR_ADD(dst, workBuffer[10] + diff);	for (i = 0, iLimiT = ((workBuffer[1] - workBuffer[10]) - 1); i <= iLimiT; i++) {		dst[i] = src[i];	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(buf2))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: Must load bitBlt and spanBuffer */primitiveDisplaySpanBuffer() {	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 5))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!B2DPlugin.loadBitBltFrom(engine.pointers[2])) {		throw Object.create(PrimitiveFailed).setPayload(122);	}	if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {		B2DPlugin.displaySpanBufferAt(workBuffer[88]);		B2DPlugin.postDisplayAction.apply(this, arguments);	}	if (workBuffer[2] !== 8) {		workBuffer[13] = 0;		workBuffer[88]++;		workBuffer[2] = 6;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[103]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[102] = (workBuffer[102] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Turn on/off profiling. Return the old value of the flag. */primitiveDoProfileStats(newValue) {	let oldValue;	oldValue = doProfileStats;	((typeof newValue === "number") ? PrimitiveFailed.signal() : newValue);	newValue = (typeof newValue === "boolean" ? newValue : PrimitiveFailed.signal());	doProfileStats = newValue;throw Object.create(PrimitiveReturn).setPayload((typeof oldValue === "boolean" ? oldValue : PrimitiveFailed.signal()));	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveFinishedProcessing() {	let failureCode;	let finished;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	finished = workBuffer[2] === 8;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload((typeof finished === "boolean" ? finished : PrimitiveFailed.signal()));	if (doProfileStats) {		workBuffer[93]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[92] = (workBuffer[92] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveGetAALevel() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[48]));}, primitiveGetBezierStats(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof statOop === "number") ? PrimitiveFailed.signal() : statOop);	if (!((statOop.storageType === "words") && (SIZEOF(statOop) >= 4))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] = (stats[0] + workBuffer[108]);	stats[1] = (stats[1] + workBuffer[109]);	stats[2] = (stats[2] + workBuffer[110]);	stats[3] = (stats[3] + workBuffer[111]);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveGetClipRect(rectOop) {	let failureCode;	let pointOop;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof rectOop === "number") ? PrimitiveFailed.signal() : rectOop);	if (!((rectOop.storageType === "pointers") && (SIZEOF(rectOop) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	SmalltalkVM.pushRemappableOop(rectOop);	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[42], workBuffer[44]);	SmalltalkVM.topRemappableOop().pointers[0] = pointOop;	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[43], workBuffer[45]);	rectOop = SmalltalkVM.popRemappableOop();	rectOop.pointers[1] = pointOop;	throw Object.create(PrimitiveReturn).setPayload(rectOop);}, primitiveGetCounts(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof statOop === "number") ? PrimitiveFailed.signal() : statOop);	if (!((statOop.storageType === "words") && (SIZEOF(statOop) >= 9))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] = (stats[0] + workBuffer[91]);	stats[1] = (stats[1] + workBuffer[93]);	stats[2] = (stats[2] + workBuffer[95]);	stats[3] = (stats[3] + workBuffer[97]);	stats[4] = (stats[4] + workBuffer[99]);	stats[5] = (stats[5] + workBuffer[101]);	stats[6] = (stats[6] + workBuffer[103]);	stats[7] = (stats[7] + workBuffer[105]);	stats[8] = (stats[8] + workBuffer[107]);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveGetDepth() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[113]));}, /*	Return the reason why the last operation failed. */primitiveGetFailureReason() {	let failCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	/* Note -- don't call loadEngineFrom here because this will override the stopReason with Zero */	engine = this;	if ((typeof engine === "number")) {		throw Object.create(PrimitiveFailed).setPayload(101);	}	if (!(engine.storageType === "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(102);	}	if (SIZEOF(engine) < 12) {		throw Object.create(PrimitiveFailed).setPayload(103);	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(engine.pointers[0]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[64]));}, primitiveGetOffset() {	let failureCode;	let pointOop;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[46], workBuffer[47]);	throw Object.create(PrimitiveReturn).setPayload(pointOop);}, primitiveGetTimes(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof statOop === "number") ? PrimitiveFailed.signal() : statOop);	if (!((statOop.storageType === "words") && (SIZEOF(statOop) >= 9))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] = (stats[0] + workBuffer[90]);	stats[1] = (stats[1] + workBuffer[92]);	stats[2] = (stats[2] + workBuffer[94]);	stats[3] = (stats[3] + workBuffer[96]);	stats[4] = (stats[4] + workBuffer[98]);	stats[5] = (stats[5] + workBuffer[100]);	stats[6] = (stats[6] + workBuffer[102]);	stats[7] = (stats[7] + workBuffer[104]);	stats[8] = (stats[8] + workBuffer[106]);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveInitializeBuffer(wbOop) {	let size;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof wbOop === "number") ? PrimitiveFailed.signal() : wbOop);	;	if (!(wbOop.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (((size = SIZEOF(wbOop))) < 256) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin workBufferPut: */	workBuffer = wbOop.wordsAsInt32Array();	/* end workBufferPut: */	objBuffer = PTR_ADD(workBuffer, 128);	workBuffer[0] = 1097753705;	workBuffer[1] = size;	workBuffer[10] = size;	workBuffer[2] = 0;	workBuffer[8] = 128;	workBuffer[9] = 4;	objBuffer[0] = 256;	objBuffer[1] = 4;	objBuffer[2] = 0;	workBuffer[11] = 0;	workBuffer[12] = 0;	workBuffer[13] = 0;	workBuffer[14] = 0;	workBuffer[64] = 0;	workBuffer[63] = 0;	workBuffer[42] = 0;	workBuffer[43] = 0;	workBuffer[44] = 0;	workBuffer[45] = 0;	workBuffer[113] = 0;	B2DPlugin.resetGraphicsEngineStats.apply(this, arguments);	B2DPlugin.initEdgeTransform.apply(this, arguments);	B2DPlugin.initColorTransform.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(wbOop);}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveInitializeProcessing() {	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.initializeGETProcessing.apply(this, arguments);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[2] = 1;	/* begin storeEngineStateInto: */workBuffer[9] = objUsed;/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[91]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[90] = (workBuffer[90] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveMergeFillFrom(bitsOop, fillOop) {	let failureCode;	let value;	let value1;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 4))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof fillOop === "number") ? PrimitiveFailed.signal() : fillOop);	((typeof bitsOop === "number") ? PrimitiveFailed.signal() : bitsOop);	if (!(bitsOop._class() === SmalltalkGlobals._Bitmap)) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	if (SIZEOF(fillOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(113);	}	value = fillOop.pointers[0];	if (objBuffer[workBuffer[66] + 2] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	value = fillOop.pointers[1];	if (workBuffer[67] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	value = fillOop.pointers[2];	if (workBuffer[68] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	if (SIZEOF(bitsOop) < (workBuffer[68] - workBuffer[67])) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	;	B2DPlugin.fillBitmapSpanfromto(bitsOop.wordsAsInt32Array(), workBuffer[67], workBuffer[68]);	workBuffer[2] = 3;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[101]++;		/* begin incrementStat:by: */		value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[100] = (workBuffer[100] + value1);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveNeedsFlush() {	let failureCode;	let needFlush;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	needFlush = workBuffer[63] !== 0;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload((typeof needFlush === "boolean" ? needFlush : PrimitiveFailed.signal()));}, primitiveNeedsFlushPut(_arg1) {	let failureCode;	let needFlush;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	needFlush = (typeof _arg1 === "boolean" ? _arg1 : PrimitiveFailed.signal());	;	if (needFlush === true) {		workBuffer[63] = 1;	} else {		workBuffer[63] = 0;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveNextActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let hasEdge;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredStateor(this, 6, 8))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);	;	hasEdge = false;	if (workBuffer[2] !== 8) {		hasEdge = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (hasEdge) {			edge = aetBuffer[workBuffer[13]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);			workBuffer[2] = 7;		} else {			workBuffer[2] = 1;		}	}	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasEdge === "boolean" ? hasEdge : PrimitiveFailed.signal()));	if (doProfileStats) {		workBuffer[105]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[104] = (workBuffer[104] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveNextFillEntry(fillOop) {	let failureCode;	let hasFill;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 3))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!B2DPlugin.loadFormsFrom(engine.pointers[3])) {		throw Object.create(PrimitiveFailed).setPayload(123);	}	if (workBuffer[69] !== 0) {		if ((UBAND(workBuffer[88], workBuffer[52])) === 0) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;	}	((typeof fillOop === "number") ? PrimitiveFailed.signal() : fillOop);	hasFill = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (hasFill) {		B2DPlugin.storeFillStateInto(fillOop);	}	;	if (hasFill) {		workBuffer[2] = 4;	} else {		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;		workBuffer[2] = 5;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasFill === "boolean" ? hasFill : PrimitiveFailed.signal()));	if (doProfileStats) {		workBuffer[99]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[98] = (workBuffer[98] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveNextGlobalEdgeEntry(edgeOop) {	let edge;	let failureCode;	let hasEdge;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 1))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);	hasEdge = B2DPlugin.findNextExternalEntryFromGET.apply(this, arguments);	if (hasEdge) {		edge = getBuffer[workBuffer[11]];		B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);		workBuffer[11]++;	}	;	if (hasEdge) {		workBuffer[2] = 2;	} else {		/* Start scanning the AET */		workBuffer[2] = 3;		workBuffer[69] = 1;		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasEdge === "boolean" ? hasEdge : PrimitiveFailed.signal()));	if (doProfileStats) {		workBuffer[95]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[94] = (workBuffer[94] + value);		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveRegisterExternalEdge(index, initialX, initialY, initialZ, _arg5, _arg6) {	let edge;	let failureCode;	let leftFillIndex;	let rightFillIndex;	let value;	let value1;	if (arguments.length !== 6) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	rightFillIndex = (_arg6 >>> 0) === _arg6.valueOf() ? _arg6 : PrimitiveFailed.signal();	leftFillIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	((typeof initialZ === "number") ? initialZ : PrimitiveFailed.signal());	((typeof initialY === "number") ? initialY : PrimitiveFailed.signal());	((typeof initialX === "number") ? initialX : PrimitiveFailed.signal());	((typeof index === "number") ? index : PrimitiveFailed.signal());	;	if (!B2DPlugin.allocateObjEntry(10)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	if (!(B2DPlugin.isFillOkay(leftFillIndex) && (B2DPlugin.isFillOkay(rightFillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	edge = objUsed;	/* Install type and length */	objUsed = edge + 10;	objBuffer[edge + 0] = 2;	objBuffer[edge + 1] = 10;	objBuffer[edge + 2] = index;	objBuffer[edge + 4] = initialX;	objBuffer[edge + 5] = initialY;	objBuffer[edge + 6] = initialZ;	/* begin edgeLeftFillOf:put: */	value = B2DPlugin.transformColor(leftFillIndex);	objBuffer[edge + 8] = value;	/* end edgeLeftFillOf:put: */	/* begin edgeRightFillOf:put: */	value1 = B2DPlugin.transformColor(rightFillIndex);	objBuffer[edge + 9] = value1;	/* end edgeRightFillOf:put: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin storeEngineStateInto: */workBuffer[9] = objUsed;/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveRegisterExternalFill(index) {	let failureCode;	let fill;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof index === "number") ? index : PrimitiveFailed.signal());	;	fill = 0;	while (fill === 0) {		if (!B2DPlugin.allocateObjEntry(10)) {			throw Object.create(PrimitiveFailed).setPayload(111);		}		fill = objUsed;		/* Install type and length */		objUsed = fill + 4;		objBuffer[fill + 0] = 256;		objBuffer[fill + 1] = 4;		objBuffer[fill + 2] = index;	}	/* begin storeEngineStateInto: */workBuffer[9] = objUsed;/* end storeEngineStateInto: */throw Object.create(PrimitiveReturn).setPayload(((typeof fill === "number") ? fill : PrimitiveFailed.signal()));	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Start/Proceed rendering the entire image */primitiveRenderImage() {	let failCode;	if (((failCode = B2DPlugin.loadRenderingState.apply(this, arguments))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	B2DPlugin.proceedRenderingScanline.apply(this, arguments);	if (engineStopped) {		return B2DPlugin.storeRenderingState.apply(this, arguments);	}	B2DPlugin.proceedRenderingImage.apply(this, arguments);	B2DPlugin.storeRenderingState.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Start rendering the entire image */primitiveRenderScanline() {	let failCode;	if (((failCode = B2DPlugin.loadRenderingState.apply(this, arguments))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	B2DPlugin.proceedRenderingScanline.apply(this, arguments);	B2DPlugin.storeRenderingState.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetAALevel(level) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof level === "number") ? level : PrimitiveFailed.signal());	;	B2DPlugin.setAALevel(level);	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Set the BitBlt plugin to use. */primitiveSetBitBltPlugin(pluginName) {	let i;	let length;	let needReload;	let ptr;	if (!(pluginName.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(pluginName);	if (length >= 256) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	ptr = BYTESOF(pluginName);	needReload = false;	for (i = 0; i <= (length - 1); i++) {		/* Compare and store the plugin to be used */		if (bbPluginName[i] !== ptr[i]) {			bbPluginName[i] = ptr[i];			needReload = true;		}	}	if (bbPluginName[length] !== 0) {		bbPluginName[length] = 0;		needReload = true;	}	if (needReload) {		if (!B2DPlugin.initialiseModule.apply(this, arguments)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetClipRect(rectOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof rectOop === "number") ? PrimitiveFailed.signal() : rectOop);	if (!((rectOop.storageType === "pointers") && (SIZEOF(rectOop) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), rectOop.pointers[0]);	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 82)), rectOop.pointers[1]);	;	workBuffer[42] = (PTR_ADD(workBuffer, 80))[0];	workBuffer[44] = (PTR_ADD(workBuffer, 80))[1];	workBuffer[43] = (PTR_ADD(workBuffer, 82))[0];	workBuffer[45] = (PTR_ADD(workBuffer, 82))[1];	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetColorTransform(transformOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof transformOop === "number") ? PrimitiveFailed.signal() : transformOop);	;	B2DPlugin.loadColorTransformFrom(transformOop);	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetDepth(depth) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof depth === "number") ? depth : PrimitiveFailed.signal());	;	workBuffer[113] = depth;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetEdgeTransform(transformOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	((typeof transformOop === "number") ? PrimitiveFailed.signal() : transformOop);	;	B2DPlugin.loadEdgeTransformFrom(transformOop);	;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetOffset(pointOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (pointOop._class() !== SmalltalkGlobals._Point) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	B2DPlugin.loadPointfrom((PTR_ADD(workBuffer, 80)), pointOop);	;	workBuffer[46] = (PTR_ADD(workBuffer, 80))[0];	workBuffer[47] = (PTR_ADD(workBuffer, 80))[1];	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	This is the main rendering entry */proceedRenderingImage() {	let external;	let value;	let value1;	let value2;	let value3;	while (!(workBuffer[2] === 8)) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalEntryFromGET.apply(this, arguments);		if (doProfileStats) {			workBuffer[95]++;			/* begin incrementStat:by: */			value = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[94] = (workBuffer[94] + value);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 1;		}		if (external) {			workBuffer[2] = 2;			/* begin stopBecauseOf: */			workBuffer[64] = 4;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[69] = 1;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((workBuffer[69] !== 0) && ((UBAND(workBuffer[88], workBuffer[52])) === 0)) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;		external = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[99]++;			/* begin incrementStat:by: */			value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[98] = (workBuffer[98] + value1);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 3;		}		if (external) {			workBuffer[2] = 4;			/* begin stopBecauseOf: */			workBuffer[64] = 5;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {			B2DPlugin.displaySpanBufferAt(workBuffer[88]);			B2DPlugin.postDisplayAction.apply(this, arguments);		}		if (doProfileStats) {			workBuffer[103]++;			/* begin incrementStat:by: */			value2 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[102] = (workBuffer[102] + value2);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 5;		}		if (workBuffer[2] === 8) {			return 0;		}		workBuffer[13] = 0;		workBuffer[88]++;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[105]++;			/* begin incrementStat:by: */			value3 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[104] = (workBuffer[104] + value3);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 6;		}		if (external) {			workBuffer[2] = 7;			/* begin stopBecauseOf: */			workBuffer[64] = 6;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}	}}, /*	Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween. *//*	This is the main rendering entry */proceedRenderingScanline() {	let external;	let state;	let value;	let value1;	let value2;	let value3;	state = workBuffer[2];	if (state === 0) {		B2DPlugin.initializeGETProcessing.apply(this, arguments);		if (engineStopped) {			return 0;		}		state = 1;	}	if (state === 1) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalEntryFromGET.apply(this, arguments);		if (doProfileStats) {			workBuffer[95]++;			/* begin incrementStat:by: */			value = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[94] = (workBuffer[94] + value);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 1;		}		if (external) {			workBuffer[2] = 2;			/* begin stopBecauseOf: */			workBuffer[64] = 4;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[69] = 1;		state = 3;	}	if (state === 3) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((workBuffer[69] !== 0) && ((UBAND(workBuffer[88], workBuffer[52])) === 0)) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;		external = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[99]++;			/* begin incrementStat:by: */			value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[98] = (workBuffer[98] + value1);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 3;		}		if (external) {			workBuffer[2] = 4;			/* begin stopBecauseOf: */			workBuffer[64] = 5;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		state = 5;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;	}	if (state === 5) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {			B2DPlugin.displaySpanBufferAt(workBuffer[88]);			B2DPlugin.postDisplayAction.apply(this, arguments);		}		if (doProfileStats) {			workBuffer[103]++;			/* begin incrementStat:by: */			value2 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[102] = (workBuffer[102] + value2);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 5;		}		if (workBuffer[2] === 8) {			return 0;		}		state = 6;		workBuffer[13] = 0;		workBuffer[88]++;	}	if (state === 6) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[105]++;			/* begin incrementStat:by: */			value3 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[104] = (workBuffer[104] + value3);			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 6;		}		if (external) {			workBuffer[2] = 7;			/* begin stopBecauseOf: */			workBuffer[64] = 6;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[2] = 1;	}}, /*	Load the minimal required state from the engineOop, e.g., just the work buffer.	 Answer 0 on success or non-zero a failure code on failure */quickLoadEngineFrom(engineOop) {	let failCode;	;	if ((typeof engineOop === "number")) {		return 101;	}	if (!(engineOop.storageType === "pointers")) {		return 102;	}	if (SIZEOF(engineOop) < 12) {		return 103;	}	engine = engineOop;	if (((failCode = B2DPlugin.loadWorkBufferFrom(engineOop.pointers[0]))) !== 0) {		return failCode;	}	workBuffer[64] = 0;	objUsed = workBuffer[9];	engineStopped = false;	return 0;}, quickLoadEngineFromrequiredState(oop, requiredState) {	let failureCode;	if (((failureCode = B2DPlugin.quickLoadEngineFrom(oop))) !== 0) {		return failureCode;	}	if (workBuffer[2] === requiredState) {		return 0;	}	workBuffer[64] = 2;	return 116;}, quickLoadEngineFromrequiredStateor(oop, requiredState, alternativeState) {	let failureCode;	if (((failureCode = B2DPlugin.quickLoadEngineFrom(oop))) !== 0) {		return failureCode;	}	if (workBuffer[2] === requiredState) {		return 0;	}	if (workBuffer[2] === alternativeState) {		return 0;	}	workBuffer[64] = 2;	return 116;}, /*	Sort elements i through j of self to be nondescending according to	sortBlock. *//*	Note: The original loop has been heavily re-written for C translation */quickSortGlobalEdgeTablefromto(array, i, j) {	let again;	let before;	let di;	let dij;	let dj;	let ij;	let k;	let l;	let n;	let tmp;	let tt;	/* The prefix d means the data at that index. */	if (((n = (j + 1) - i)) <= 1) {		return 0;	}	di = array[i];	dj = array[j];	/* i.e., should di precede dj? */	before = B2DPlugin.getSortsbefore(di, dj);	if (!before) {		tmp = array[i];		array[i] = array[j];		array[j] = tmp;		tt = di;		di = dj;		dj = tt;	}	if (n <= 2) {		return 0;	}	/* ij is the midpoint of i and j. */	ij = (i + j) >> 1;	/* Sort di,dij,dj.  Make dij be their median. */	dij = array[ij];	/* i.e. should di precede dij? */	before = B2DPlugin.getSortsbefore(di, dij);	if (before) {		/* i.e., should dij precede dj? */		before = B2DPlugin.getSortsbefore(dij, dj);		if (!before) {			/* i.e., should dij precede dj? */			tmp = array[j];			array[j] = array[ij];			array[ij] = tmp;			dij = dj;		}	} else {		/* i.e. di should come after dij */		tmp = array[i];		array[i] = array[ij];		array[ij] = tmp;		dij = di;	}	if (n <= 3) {		return 0;	}	k = i;	l = j;	again = true;	while (again) {		before = true;		while (before) {			if (k <= ((--l))) {				tmp = array[l];				before = B2DPlugin.getSortsbefore(dij, tmp);			} else {				before = false;			}		}		before = true;		while (before) {			if (((++k)) <= l) {				tmp = array[k];				before = B2DPlugin.getSortsbefore(tmp, dij);			} else {				before = false;			}		}		again = k <= l;		if (again) {			tmp = array[k];			array[k] = array[l];			array[l] = tmp;		}	}	B2DPlugin.quickSortGlobalEdgeTablefromto(array, i, l);	B2DPlugin.quickSortGlobalEdgeTablefromto(array, k, j);}, rShiftTable() {	let theTable =		[0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1];	return theTable;}, removeFirstAETEntry() {	let index;	index = workBuffer[13];	workBuffer[14] = (workBuffer[14] - 1);	while (index < workBuffer[14]) {		aetBuffer[index] = aetBuffer[index + 1];		++index;	}}, resetGraphicsEngineStats() {	workBuffer[90] = 0;	workBuffer[92] = 0;	workBuffer[94] = 0;	workBuffer[96] = 0;	workBuffer[98] = 0;	workBuffer[100] = 0;	workBuffer[102] = 0;	workBuffer[104] = 0;	workBuffer[106] = 0;	workBuffer[91] = 0;	workBuffer[93] = 0;	workBuffer[95] = 0;	workBuffer[97] = 0;	workBuffer[99] = 0;	workBuffer[101] = 0;	workBuffer[103] = 0;	workBuffer[105] = 0;	workBuffer[107] = 0;	workBuffer[108] = 0;	workBuffer[109] = 0;	workBuffer[110] = 0;	workBuffer[111] = 0;}, resortFirstAETEntry() {	let edge;	let leftEdge;	let xValue;	if (workBuffer[13] === 0) {		return null;	}	edge = aetBuffer[workBuffer[13]];	xValue = objBuffer[edge + 4];	leftEdge = aetBuffer[workBuffer[13] - 1];	if (objBuffer[leftEdge + 4] <= xValue) {		return null;	}	B2DPlugin.moveAETEntryFromedgex(workBuffer[13], edge, xValue);}, /*	Set the anti-aliasing level. Three levels are supported:		1 - No antialiasing		2 - 2x2 unweighted anti-aliasing		4 - 4x4 unweighted anti-aliasing.	 */setAALevel(level) {	let aaLevel;	if (level >= 4) {		aaLevel = 4;	}	if ((level >= 2) && (level < 4)) {		aaLevel = 2;	}	if (level < 2) {		aaLevel = 1;	}	workBuffer[48] = aaLevel;		switch (aaLevel) {	case 1:				workBuffer[49] = 0;		workBuffer[51] = 4294967295;		workBuffer[52] = 0;		break;	case 2:				workBuffer[49] = 1;		workBuffer[51] = 4244438268;		workBuffer[52] = 1;		break;	case 4:				workBuffer[49] = 2;		workBuffer[51] = 4042322160;		workBuffer[52] = 3;		break;	default:				null;	}	workBuffer[50] = (workBuffer[49] * 2);	workBuffer[53] = workBuffer[49];}, showFilldepthrightX(fillIndex, depth, rightX) {	if (!B2DPlugin.wbStackPush(3)) {		return null;	}	workBuffer[workBuffer[10] + 0] = fillIndex;	workBuffer[workBuffer[10] + 1] = depth;	workBuffer[workBuffer[10] + 2] = rightX;	if ((workBuffer[1] - workBuffer[10]) === 3) {		return null;	}	if (B2DPlugin.fillSortsbefore(0, (workBuffer[1] - workBuffer[10]) - 3)) {		/* New top fill */		workBuffer[workBuffer[10] + 0] = workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)];		workBuffer[workBuffer[10] + (1)] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)];		workBuffer[workBuffer[10] + (2)] = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)];		workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)] = fillIndex;		workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)] = depth;		workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)] = rightX;	}}, smallSqrtTable() {	let theTable = 	[0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6];	return theTable;}, squaredLengthOfwith(deltaX, deltaY) {	return (deltaX * deltaX) + (deltaY * deltaY);}, /*	Initialize the bezier at yValue.	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure. */stepToFirstBezierInat(bezier, yValue) {	let deltaY;	let endX;	let endY;	let fwDDx;	let fwDDy;	let fwDx;	let fwDy;	let fwX1;	let fwX2;	let fwY1;	let fwY2;	let maxSteps;	let scaledStepSize;	let squaredStepSize;	let startX;	let startY;	let updateData;	let viaX;	let viaY;	let word1;	let word2;	let xValue;	let updateData1;	let fwDx1;	let fwDy1;	let lastX;	let lastY;	let minY;	/* Do a quick check if there is anything at all to do */	if ((UBANDS((UBANDS(objBuffer[bezier + 0], 65535)), 1)) !== 0 && (yValue >= objBuffer[bezier + 15])) {		return objBuffer[bezier + 7] = 0;	}	startX = objBuffer[bezier + 4];	startY = objBuffer[bezier + 5];	viaX = objBuffer[bezier + 12];	viaY = objBuffer[bezier + 13];	endX = objBuffer[bezier + 14];	endY = objBuffer[bezier + 15];	/* Initialize integer forward differencing */	deltaY = endY - startY;	fwX1 = (viaX - startX) * 2;	fwX2 = (startX + endX) - (viaX * 2);	fwY1 = (viaY - startY) * 2;	fwY2 = (startY + endY) - (viaY * 2);	maxSteps = deltaY * 2;	if (maxSteps < 2) {		maxSteps = 2;	}	scaledStepSize = Math.trunc(16777216 / maxSteps);	/* begin absoluteSquared8Dot24: */	word1 = UBANDS(scaledStepSize, 65535);	word2 = UBANDS((scaledStepSize >>> 16), 255);	squaredStepSize = ((((word1 * word1) >>> 16) + ((word1 * word2) * 2)) + ((word2 * word2) << 16 >>> 0)) >>> 8;	/* end absoluteSquared8Dot24: */	fwDx = fwX1 * scaledStepSize;	fwDDx = (fwX2 * squaredStepSize) * 2;	fwDx += fwDDx >> 1;	fwDy = fwY1 * scaledStepSize;	fwDDy = (fwY2 * squaredStepSize) * 2;	/* Store the values */	fwDy += fwDDy >> 1;	objBuffer[bezier + 7] = deltaY;	updateData = PTR_ADD(objBuffer, bezier + 10);	updateData[0] = (startX * 256);	updateData[1] = (startY * 256);	updateData[2] = fwDx;	updateData[3] = fwDy;	updateData[4] = fwDDx;	updateData[5] = fwDDy;	if (((startY = objBuffer[bezier + 5])) !== yValue) {		/* begin stepToNextBezierIn:at: */		/* begin stepToNextBezierForward:at: */		updateData1 = PTR_ADD(objBuffer, bezier + 10);		lastX = updateData1[0];		lastY = updateData1[1];		fwDx1 = updateData1[2];		fwDy1 = updateData1[3];		minY = yValue * 256;		while ((minY > lastY) && (fwDy1 >= 0)) {			lastX += (fwDx1 + 32768) >> 16;			lastY += (fwDy1 + 32768) >> 16;			fwDx1 += updateData1[4];			fwDy1 += updateData1[5];		}		updateData1[0] = lastX;		updateData1[1] = lastY;		updateData1[2] = fwDx1;		updateData1[3] = fwDy1;		xValue = lastX >> 8;		/* end stepToNextBezierForward:at: */		objBuffer[bezier + 4] = xValue;		/* end stepToNextBezierIn:at: */		objBuffer[bezier + 7] = (deltaY - (yValue - startY));	}}, /*	Initialize the line at yValue */stepToFirstLineInat(line, yValue) {	let deltaX;	let deltaY;	let error;	let errorAdjUp;	let i;	let startY;	let widthX;	let xDir;	let xInc;	let err;	let x;	/* Do a quick check if there is anything at all to do */	if ((UBANDS((UBANDS(objBuffer[line + 0], 65535)), 1)) !== 0 && (yValue >= objBuffer[line + 15])) {		return objBuffer[line + 7] = 0;	}	deltaX = objBuffer[line + 14] - objBuffer[line + 4];	/* Check if edge goes left to right */	deltaY = objBuffer[line + 15] - objBuffer[line + 5];	if (deltaX >= 0) {		xDir = 1;		widthX = deltaX;		error = 0;	} else {		xDir = -1;		widthX = 0 - deltaX;		error = 1 - deltaY;	}	if (deltaY === 0) {		/* No error for horizontal edges */		error = 0;		/* Encodes width and direction */		xInc = deltaX;		errorAdjUp = 0;	} else {		/* Check if edge is y-major */		if (deltaY > widthX) {			/* Note: The '>' instead of '>=' could be important here... */			xInc = 0;			errorAdjUp = widthX;		} else {			xInc = (Math.trunc(widthX / deltaY)) * xDir;			errorAdjUp = MOD(widthX, deltaY);		}	}	objBuffer[line + 7] = deltaY;	objBuffer[line + 10] = xDir;	objBuffer[line + 12] = xInc;	objBuffer[line + 13] = error;	objBuffer[line + 14] = errorAdjUp;	objBuffer[line + 15] = deltaY;	if (((startY = objBuffer[line + 5])) !== yValue) {		for (i = startY; i <= (yValue - 1); i++) {			/* begin stepToNextLineIn:at: */			x = objBuffer[line + 4] + objBuffer[line + 12];			err = objBuffer[line + 13] + objBuffer[line + 14];			if (err > 0) {				x += objBuffer[line + 10];				err -= objBuffer[line + 15];			}			objBuffer[line + 13] = err;			objBuffer[line + 4] = x;			/* end stepToNextLineIn:at: */		}		objBuffer[line + 7] = (deltaY - (yValue - startY));	}}, /*	Initialize the bezier at yValue */stepToFirstWideBezierInat(bezier, yValue) {	let endX;	let i;	let lineOffset;	let lineWidth;	let nLines;	let startY;	let xDir;	let yEntry;	let yExit;	/* Get some values */	lineWidth = objBuffer[bezier + 20];	/* Compute the incremental values of the bezier */	lineOffset = lineWidth >> 1;	endX = objBuffer[bezier + 14];	startY = objBuffer[bezier + 5];	B2DPlugin.stepToFirstBezierInat(bezier, startY);	/* Copy the incremental update data */	nLines = objBuffer[bezier + 7];	for (i = 0; i <= 5; i++) {		(PTR_ADD(objBuffer, bezier + 22))[i] = (PTR_ADD(objBuffer, bezier + 10))[i];	}	xDir = (PTR_ADD(objBuffer, bezier + 10))[2];	if (xDir === 0) {		(PTR_ADD(objBuffer, bezier + 10))[4];	}	/* Adjust the curve to start/end at the right position */	xDir = (xDir >= 0) ? 1 : -1;	if (xDir < 0) {		B2DPlugin.adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX);	} else {		B2DPlugin.adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX);	}	if (nLines === 0) {		(PTR_ADD(objBuffer, bezier + 10))[0] = (objBuffer[bezier + 21] * 256);	}	objBuffer[bezier + 7] = (nLines + lineWidth);	/* turned on at lineOffset */	yEntry = 0;	/* turned off at zero */	yExit = (0 - nLines) - lineOffset;	objBuffer[bezier + 18] = yEntry;	objBuffer[bezier + 19] = yExit;	if ((yEntry >= lineOffset) && (yExit < 0)) {		objBuffer[bezier + 0] = (UBAND((UBANDS(objBuffer[bezier + 0], 65535)), 4294901759));	} else {		objBuffer[bezier + 0] = (UBORS((UBANDS(objBuffer[bezier + 0], 65535)), 65536));	}	B2DPlugin.computeFinalWideBezierValueswidth(bezier, lineWidth);	if (startY !== yValue) {		/* Note: Must single step here so that entry/exit works */		for (i = startY; i <= (yValue - 1); i++) {			B2DPlugin.stepToNextWideBezierInat(bezier, i);		}		objBuffer[bezier + 7] = (objBuffer[bezier + 7] - (yValue - startY));	}}, /*	Initialize the wide line at yValue. */stepToFirstWideLineInat(line, yValue) {	let i;	let lineOffset;	let lineWidth;	let nLines;	let startX;	let startY;	let xDir;	let yEntry;	let yExit;	let lastX;	let lineOffset1;	let lineWidth1;	let nextX;	let yEntry1;	let yExit1;	let err;	let x;	/* Get some values */	lineWidth = objBuffer[line + 20];	/* Compute the incremental values of the line */	lineOffset = lineWidth >> 1;	startX = objBuffer[line + 4];	startY = objBuffer[line + 5];	B2DPlugin.stepToFirstLineInat(line, startY);	nLines = objBuffer[line + 7];	/* Adjust the line to start at the correct X position */	xDir = objBuffer[line + 10];	objBuffer[line + 4] = (startX - lineOffset);	objBuffer[line + 7] = (nLines + lineWidth);	if (xDir > 0) {		objBuffer[line + 17] = (objBuffer[line + 12] + lineWidth);	} else {		objBuffer[line + 17] = (lineWidth - objBuffer[line + 12]);		objBuffer[line + 4] = (objBuffer[line + 4] + objBuffer[line + 12]);	}	/* turned on at lineOffset */	yEntry = 0;	/* turned off at zero */	yExit = (0 - nLines) - lineOffset;	objBuffer[line + 18] = yEntry;	objBuffer[line + 19] = yExit;	if ((yEntry >= lineOffset) && (yExit < 0)) {		objBuffer[line + 0] = (UBAND((UBANDS(objBuffer[line + 0], 65535)), 4294901759));	} else {		objBuffer[line + 0] = (UBORS((UBANDS(objBuffer[line + 0], 65535)), 65536));	}	if (startY !== yValue) {		for (i = startY; i <= (yValue - 1); i++) {			/* begin stepToNextWideLineIn:at: */			yEntry1 = objBuffer[line + 18] + 1;			yExit1 = objBuffer[line + 19] + 1;			objBuffer[line + 18] = yEntry1;			objBuffer[line + 19] = yExit1;			lineWidth1 = objBuffer[line + 20];			lineOffset1 = lineWidth1 >> 1;			if (yEntry1 >= lineOffset1) {				objBuffer[line + 0] = (UBAND((UBANDS(objBuffer[line + 0], 65535)), 4294901759));			}			if (yExit1 >= 0) {				objBuffer[line + 0] = (UBORS((UBANDS(objBuffer[line + 0], 65535)), 65536));			}			lastX = objBuffer[line + 4];			/* begin stepToNextLineIn:at: */			x = objBuffer[line + 4] + objBuffer[line + 12];			err = objBuffer[line + 13] + objBuffer[line + 14];			if (err > 0) {				x += objBuffer[line + 10];				err -= objBuffer[line + 15];			}			objBuffer[line + 13] = err;			objBuffer[line + 4] = x;			/* end stepToNextLineIn:at: */			nextX = objBuffer[line + 4];			if ((yEntry1 <= lineWidth1) || ((yExit1 + lineOffset1) >= 0)) {				B2DPlugin.adjustWideLineafterSteppingFromto(line, lastX, nextX);			}			/* end stepToNextWideLineIn:at: */		}		objBuffer[line + 7] = (objBuffer[line + 7] - (yValue - startY));	}}, /*	Incrementally step to the next scan line in the given bezier */stepToNextBezierInat(bezier, yValue) {	let xValue;	let updateData;	let fwDx;	let fwDy;	let lastX;	let lastY;	let minY;	/* begin stepToNextBezierForward:at: */	updateData = PTR_ADD(objBuffer, bezier + 10);	lastX = updateData[0];	lastY = updateData[1];	fwDx = updateData[2];	fwDy = updateData[3];	minY = yValue * 256;	while ((minY > lastY) && (fwDy >= 0)) {		lastX += (fwDx + 32768) >> 16;		lastY += (fwDy + 32768) >> 16;		fwDx += updateData[4];		fwDy += updateData[5];	}	updateData[0] = lastX;	updateData[1] = lastY;	updateData[2] = fwDx;	updateData[3] = fwDy;	xValue = lastX >> 8;	/* end stepToNextBezierForward:at: */	objBuffer[bezier + 4] = xValue;}, /*	Incrementally step to the next scan line in the given line */stepToNextLineInat(line, yValue) {	let err;	let x;	x = objBuffer[line + 4] + objBuffer[line + 12];	err = objBuffer[line + 13] + objBuffer[line + 14];	if (err > 0) {		x += objBuffer[line + 10];		err -= objBuffer[line + 15];	}	objBuffer[line + 13] = err;	objBuffer[line + 4] = x;}, /*	Initialize the current entry in the GET by stepping to the current scan line */stepToNextWideBezier() {	B2DPlugin.stepToNextWideBezierInat(aetBuffer[workBuffer[13]], workBuffer[88]);}, /*	Incrementally step to the next scan line in the given wide bezier */stepToNextWideBezierInat(bezier, yValue) {	let lineOffset;	let lineWidth;	let yEntry;	let yExit;	let updateData;	let fwDx;	let fwDy;	let lastX;	let lastY;	let minY;	let updateData1;	let fwDx1;	let fwDy1;	let lastX1;	let lastY1;	let minY1;	/* Don't inline this */	lineWidth = objBuffer[bezier + 20];	lineOffset = lineWidth >> 1;	yEntry = objBuffer[bezier + 18] + 1;	yExit = objBuffer[bezier + 19] + 1;	objBuffer[bezier + 18] = yEntry;	objBuffer[bezier + 19] = yExit;	if (yEntry >= lineOffset) {		objBuffer[bezier + 0] = (UBAND((UBANDS(objBuffer[bezier + 0], 65535)), 4294901759));	}	if (yExit >= 0) {		objBuffer[bezier + 0] = (UBORS((UBANDS(objBuffer[bezier + 0], 65535)), 65536));	}	if ((yExit + lineOffset) < 0) {		/* begin stepToNextBezierForward:at: */		updateData = PTR_ADD(objBuffer, bezier + 10);		lastX = updateData[0];		lastY = updateData[1];		fwDx = updateData[2];		fwDy = updateData[3];		minY = yValue * 256;		while ((minY > lastY) && (fwDy >= 0)) {			lastX += (fwDx + 32768) >> 16;			lastY += (fwDy + 32768) >> 16;			fwDx += updateData[4];			fwDy += updateData[5];		}		updateData[0] = lastX;		updateData[1] = lastY;		updateData[2] = fwDx;		updateData[3] = fwDy;		lastX >> 8;		/* end stepToNextBezierForward:at: */	} else {		/* Adjust the last x value to the final x recorded previously */		(PTR_ADD(objBuffer, bezier + 10))[0] = (objBuffer[bezier + 21] * 256);	}	/* begin stepToNextBezierForward:at: */	updateData1 = PTR_ADD(objBuffer, bezier + 22);	lastX1 = updateData1[0];	lastY1 = updateData1[1];	fwDx1 = updateData1[2];	fwDy1 = updateData1[3];	minY1 = yValue * 256;	while ((minY1 > lastY1) && (fwDy1 >= 0)) {		lastX1 += (fwDx1 + 32768) >> 16;		lastY1 += (fwDy1 + 32768) >> 16;		fwDx1 += updateData1[4];		fwDy1 += updateData1[5];	}	updateData1[0] = lastX1;	updateData1[1] = lastY1;	updateData1[2] = fwDx1;	updateData1[3] = fwDy1;	lastX1 >> 8;	/* end stepToNextBezierForward:at: */	B2DPlugin.computeFinalWideBezierValueswidth(bezier, lineWidth);}, /*	Incrementally step to the next scan line in the given wide line */stepToNextWideLineInat(line, yValue) {	let lastX;	let lineOffset;	let lineWidth;	let nextX;	let yEntry;	let yExit;	let err;	let x;	/* Adjust entry/exit values */	yEntry = objBuffer[line + 18] + 1;	yExit = objBuffer[line + 19] + 1;	objBuffer[line + 18] = yEntry;	objBuffer[line + 19] = yExit;	lineWidth = objBuffer[line + 20];	lineOffset = lineWidth >> 1;	if (yEntry >= lineOffset) {		objBuffer[line + 0] = (UBAND((UBANDS(objBuffer[line + 0], 65535)), 4294901759));	}	if (yExit >= 0) {		objBuffer[line + 0] = (UBORS((UBANDS(objBuffer[line + 0], 65535)), 65536));	}	lastX = objBuffer[line + 4];	/* begin stepToNextLineIn:at: */	x = objBuffer[line + 4] + objBuffer[line + 12];	err = objBuffer[line + 13] + objBuffer[line + 14];	if (err > 0) {		x += objBuffer[line + 10];		err -= objBuffer[line + 15];	}	objBuffer[line + 13] = err;	objBuffer[line + 4] = x;	/* end stepToNextLineIn:at: */	/* Check for special start/end adjustments */	nextX = objBuffer[line + 4];	if ((yEntry <= lineWidth) || ((yExit + lineOffset) >= 0)) {		/* Yes, need an update */		B2DPlugin.adjustWideLineafterSteppingFromto(line, lastX, nextX);	}}, storeEdgeStateFrominto(edge, edgeOop) {	if (SIZEOF(edgeOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	edgeOop.pointers[0] = objBuffer[edge + 2];	edgeOop.pointers[1] = objBuffer[edge + 4];	edgeOop.pointers[2] = workBuffer[88];	edgeOop.pointers[3] = objBuffer[edge + 6];	edgeOop.pointers[4] = objBuffer[edge + 7];	workBuffer[65] = edge;}, storeFillStateInto(fillOop) {	let fillIndex;	let leftX;	let rightX;	fillIndex = workBuffer[66];	leftX = workBuffer[67];	rightX = workBuffer[68];	if (SIZEOF(fillOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	fillOop.pointers[0] = objBuffer[fillIndex + 2];	fillOop.pointers[1] = leftX;	fillOop.pointers[2] = rightX;	fillOop.pointers[3] = workBuffer[88];}, storeRenderingState(edgeOop, fillOop) {	let edge;	let reason;	;	if (engineStopped) {		/* Check the stop reason and store the required information */		/* begin storeStopStateIntoEdge:fill: */		((typeof edgeOop === "number") ? PrimitiveFailed.signal() : edgeOop);		((typeof fillOop === "number") ? PrimitiveFailed.signal() : fillOop);		reason = workBuffer[64];		if (reason === 4) {			edge = getBuffer[workBuffer[11]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);			workBuffer[11]++;		}		if (reason === 5) {			B2DPlugin.storeFillStateInto(fillOop);		}		if (reason === 6) {			edge = aetBuffer[workBuffer[13]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);		}		/* end storeStopStateIntoEdge:fill: */	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[64]));}, /*	Subdivide the given bezier curve if necessary */subdivideBezier(index) {	let deltaX;	let deltaY;	let endX;	let endY;	let startX;	let startY;	startY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)];	/* If the receiver is horizontal, don't do anything */	endY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)];	if (endY === startY) {		return index;	}	deltaY = endY - startY;	if (deltaY < 0) {		deltaY = 0 - deltaY;	}	if (deltaY > 255) {		workBuffer[109]++;		return B2DPlugin.computeBezierSplitAtHalf(index);	}	startX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)];	endX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];	deltaX = endX - startX;	if (deltaX < 0) {		deltaX = 0 - deltaX;	}	if ((deltaY * 32) < deltaX) {		workBuffer[110]++;		return B2DPlugin.computeBezierSplitAtHalf(index);	}	return index;}, /*	Recursively subdivide the curve on the bezier stack. */subdivideBezierFrom(index) {	let index1;	let index2;	let otherIndex;	otherIndex = B2DPlugin.subdivideBezier(index);	if (otherIndex !== index) {		index1 = B2DPlugin.subdivideBezierFrom(index);		if (engineStopped) {			return 0;		}		index2 = B2DPlugin.subdivideBezierFrom(otherIndex);		return engineStopped ? 0 : ((index1 >= index2) ? index1 : index2);	}	return index;}, /*	Check if the given bezier curve is monoton in Y, and, if desired in X. 	If not, subdivide it */subdivideToBeMonotoninX(base, doTestX) {	let base2;	let index1;	let index2;	base2 = (index1 = (index2 = B2DPlugin.subdivideToBeMonotonInY(base)));	if (doTestX) {		index1 = B2DPlugin.subdivideToBeMonotonInX(base);	}	if (index1 > index2) {		index2 = index1;	}	if ((base !== base2) && (doTestX)) {		index1 = B2DPlugin.subdivideToBeMonotonInX(base2);	}	if (index1 > index2) {		index2 = index1;	}	return index2;}, /*	Check if the given bezier curve is monoton in X. If not, subdivide it */subdivideToBeMonotonInX(index) {	let denom;	let dx1;	let dx2;	let endX;	let num;	let startX;	let viaX;	startX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 0)];	viaX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 2)];	endX = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 4)];	dx1 = viaX - startX;	dx2 = endX - viaX;	if ((dx1 * dx2) >= 0) {		return index;	}	workBuffer[108]++;	denom = dx2 - dx1;	num = dx1;	if (num < 0) {		num = 0 - num;	}	if (denom < 0) {		denom = 0 - denom;	}	return B2DPlugin.computeBeziersplitAt(index, num / denom);}, /*	Check if the given bezier curve is monoton in Y. If not, subdivide it */subdivideToBeMonotonInY(index) {	let denom;	let dy1;	let dy2;	let endY;	let num;	let startY;	let viaY;	startY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 1)];	viaY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 3)];	endY = workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - index) + 5)];	dy1 = viaY - startY;	dy2 = endY - viaY;	if ((dy1 * dy2) >= 0) {		return index;	}	workBuffer[108]++;	denom = dy2 - dy1;	num = dy1;	if (num < 0) {		num = 0 - num;	}	if (denom < 0) {		denom = 0 - denom;	}	return B2DPlugin.computeBeziersplitAt(index, num / denom);}, /*	Make the fill style with the given index either visible or invisible */toggleFilldepthrightX(fillIndex, depth, rightX) {	let hidden;	if ((workBuffer[1] - workBuffer[10]) === 0) {		if (B2DPlugin.wbStackPush(3)) {			workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)] = fillIndex;			workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)] = depth;			workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)] = rightX;		}	} else {		hidden = B2DPlugin.hideFilldepth(fillIndex, depth);		if (!hidden) {			B2DPlugin.showFilldepthrightX(fillIndex, depth, rightX);		}	}}, toggleFillsOf(edge) {	let depth;	let fillIndex;	if (!B2DPlugin.needAvailableSpace(6)) {		return null;	}	depth = objBuffer[edge + 6] << 1 >>> 0;	fillIndex = objBuffer[edge + 8];	if (fillIndex !== 0) {		B2DPlugin.toggleFilldepthrightX(fillIndex, depth, 999999999);	}	fillIndex = objBuffer[edge + 9];	if (fillIndex !== 0) {		B2DPlugin.toggleFilldepthrightX(fillIndex, depth, 999999999);	}	/* begin quickRemoveInvalidFillsAt: */	if ((workBuffer[1] - workBuffer[10]) === 0) {	} else {		while ((((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)]) <= objBuffer[edge + 4]) {			B2DPlugin.hideFilldepth(((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)], ((workBuffer[1] - workBuffer[10]) === 0) ? -1 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)]);			if ((workBuffer[1] - workBuffer[10]) === 0) {				break;			}		}	}	/* end quickRemoveInvalidFillsAt: */}, toggleWideFillOf(edge) {	let depth;	let fill;	let index;	let lineWidth;	let rightX;	let type;	let index1;	type = (UBANDS(objBuffer[edge + 0], 65535)) >>> 1;	dispatchedValue = edge;	switch (type) {	case 0:	case 1:		B2DPlugin.errorWrongIndex.apply(this, arguments);		break;	case 2:		dispatchReturnValue = objBuffer[dispatchedValue + 17];		break;	case 3:		dispatchReturnValue = objBuffer[dispatchedValue + 17];		break;	}	lineWidth = dispatchReturnValue;	switch (type) {	case 0:	case 1:		B2DPlugin.errorWrongIndex.apply(this, arguments);		break;	case 2:		dispatchReturnValue = objBuffer[dispatchedValue + 16];		break;	case 3:		dispatchReturnValue = objBuffer[dispatchedValue + 16];		break;	}	fill = dispatchReturnValue;	if (fill === 0) {		return null;	}	if (!B2DPlugin.needAvailableSpace(3)) {		return null;	}	/* So lines sort before interior fills */	depth = (objBuffer[edge + 6] << 1 >>> 0) + 1;	rightX = objBuffer[edge + 4] + lineWidth;	/* begin findStackFill:depth: */	index1 = 0;	while ((index1 < (workBuffer[1] - workBuffer[10])) && ((workBuffer[workBuffer[10] + index1] !== fill) || (workBuffer[workBuffer[10] + (index1 + 1)] !== depth))) {		index1 += 3;	}	index = (index1 >= (workBuffer[1] - workBuffer[10])) ? -1 : index1;	/* end findStackFill:depth: */	if (index === -1) {		B2DPlugin.showFilldepthrightX(fill, depth, rightX);	} else {		if (workBuffer[workBuffer[10] + (index + 2)] < rightX) {			workBuffer[workBuffer[10] + (index + 2)] = rightX;		}	}	/* begin quickRemoveInvalidFillsAt: */	if ((workBuffer[1] - workBuffer[10]) === 0) {	} else {		while ((((workBuffer[1] - workBuffer[10]) === 0) ? 999999999 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 2)]) <= objBuffer[edge + 4]) {			B2DPlugin.hideFilldepth(((workBuffer[1] - workBuffer[10]) === 0) ? 0 : workBuffer[workBuffer[10] + ((workBuffer[1] - workBuffer[10]) - 3)], ((workBuffer[1] - workBuffer[10]) === 0) ? -1 : workBuffer[workBuffer[10] + (((workBuffer[1] - workBuffer[10]) - 3) + 1)]);			if ((workBuffer[1] - workBuffer[10]) === 0) {				break;			}		}	}	/* end quickRemoveInvalidFillsAt: */}, transformColor(fillIndex) {	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {		b = UBANDS(fillIndex, 255);		g = UBANDS((fillIndex >>> 8), 255);		r = UBANDS((fillIndex >>> 16), 255);		a = UBANDS((fillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = B2DPlugin.colorTransform.apply(this, arguments);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			return 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			return ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	} else {		return fillIndex;	}}, /*	Transform the given point. If haveMatrix is true then use the current transformation. */transformPoint(point) {	let xValue;	let yValue;	let dstPoint;	let transform;	let x;	let y;	if (workBuffer[16] !== 0) {		/* Note: AA adjustment is done in #transformPoint: for higher accuracy */		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue = (point[0]|0);		yValue = (point[1]|0);		dstPoint = point;		transform = B2DPlugin.edgeTransform.apply(this, arguments);		x = (((((transform[0] * xValue) + (transform[1] * yValue)) + transform[2]) * workBuffer[48]) | 0);		y = (((((transform[3] * xValue) + (transform[4] * yValue)) + transform[5]) * workBuffer[48]) | 0);		dstPoint[0] = x;		dstPoint[1] = y;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		/* Multiply each component by aaLevel and add a half pixel */		point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);		point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);	}}, /*	Transform the given width */transformWidth(w) {	let deltaX;	let deltaY;	let dstWidth;	let dstWidth2;	if (w === 0) {		return 0;	}	(PTR_ADD(workBuffer, 80))[0] = 0;	(PTR_ADD(workBuffer, 80))[1] = 0;	(PTR_ADD(workBuffer, 82))[0] = (w * 256);	(PTR_ADD(workBuffer, 82))[1] = 0;	(PTR_ADD(workBuffer, 84))[0] = 0;	(PTR_ADD(workBuffer, 84))[1] = (w * 256);	/* begin transformPoints: */	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 80)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 82)));	B2DPlugin.transformPoint((PTR_ADD(workBuffer, 84)));	;	/* end transformPoints: */	deltaX = ((PTR_ADD(workBuffer, 82))[0] - (PTR_ADD(workBuffer, 80))[0]);	deltaY = ((PTR_ADD(workBuffer, 82))[1] - (PTR_ADD(workBuffer, 80))[1]);	dstWidth = ((Math.sqrt((deltaX * deltaX) + (deltaY * deltaY)) | 0) + 128) >> 8;	deltaX = ((PTR_ADD(workBuffer, 84))[0] - (PTR_ADD(workBuffer, 80))[0]);	deltaY = ((PTR_ADD(workBuffer, 84))[1] - (PTR_ADD(workBuffer, 80))[1]);	dstWidth2 = ((Math.sqrt((deltaX * deltaX) + (deltaY * deltaY)) | 0) + 128) >> 8;	if (dstWidth2 < dstWidth) {		dstWidth = dstWidth2;	}	return (dstWidth === 0) ? 1 : dstWidth;}, uncheckedTransformColor(fillIndex) {	let a;	let b;	let g;	let r;	let transform;	if (workBuffer[17] !== 0) {		b = UBANDS(fillIndex, 255);		g = UBANDS((fillIndex >>> 8), 255);		r = UBANDS((fillIndex >>> 16), 255);		a = UBANDS((fillIndex >>> 24), 255);		transform = B2DPlugin.colorTransform.apply(this, arguments);		r = (((r * transform[0]) + transform[1]) | 0);		g = (((g * transform[2]) + transform[3]) | 0);		b = (((b * transform[4]) + transform[5]) | 0);		a = (((a * transform[6]) + transform[7]) | 0);		r = Math.max(r, 0);		r = Math.min(r, 255);		g = Math.max(g, 0);		g = Math.min(g, 255);		b = Math.max(b, 0);		b = Math.min(b, 255);		a = Math.max(a, 0);		a = Math.min(a, 255);		/* ALWAYS return zero for transparent fills */		return (a < 16) ? 0 : (((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0));	} else {		return fillIndex;	}}, wbStackPush(nItems) {	if (B2DPlugin.needAvailableSpace(nItems)) {		workBuffer[10] = (workBuffer[10] - nItems);		return true;	} else {		return false;	}}, }