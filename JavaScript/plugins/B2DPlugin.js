/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:10 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	BalloonEnginePlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let aetBuffer;let bbPluginName = "BitBltPlugin";let copyBitsFn;let dispatchReturnValue = 0;let dispatchedValue = 0;let doProfileStats = 0;let engine = 0;let engineStopped = 0;let formArray = 0;let geProfileTime = 0;let getBuffer;let loadBBFn;let objBuffer;let objUsed = 0;let spanBuffer;let workBuffer;globalThis.B2DPlugin = {addEdgeToGET(edge) {	if (!B2DPlugin.allocateGETEntry(1)) {		return 0;	}	getBuffer[workBuffer[12]] = edge;	workBuffer[12]++;}, /*	Adjust the wide bezier curve (dx < 0) to start/end at the right point */adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX) {	let lastX;	let lastY;	objBuffer[bezier + 10] -= lineOffset * 256;	lastX = objBuffer[bezier + 22];	objBuffer[bezier + 22] = (lastX + ((lineWidth - lineOffset) * 256));	lastY = objBuffer[bezier + 23];	objBuffer[bezier + 23] = (lastY + (lineWidth * 256));	objBuffer[bezier + 21] = (endX - lineOffset);}, /*	Adjust the wide bezier curve (dx >= 0) to start/end at the right point */adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX) {	let lastX;	let lastY;	objBuffer[bezier + 10] += lineOffset * 256;	lastX = objBuffer[bezier + 22];	objBuffer[bezier + 22] = (lastX - ((lineWidth - lineOffset) * 256));	/* Set lineWidth pixels down */	lastY = objBuffer[bezier + 23];	objBuffer[bezier + 23] = (lastY + (lineWidth * 256));	objBuffer[bezier + 21] = ((endX - lineOffset) + lineWidth);}, /*	Adjust the wide line after it has been stepped from lastX to nextX.	Special adjustments of line width and start position are made here	to simulate a rectangular brush */adjustWideLineafterSteppingFromto(line, lastX, nextX) {	let baseWidth;	let deltaX;	let lineOffset;	let lineWidth;	let xDir;	let yEntry;	let yExit;	/* Don't inline this */	/* Fetch the values the adjustment decisions are based on */	yEntry = objBuffer[line + 18];	yExit = objBuffer[line + 19];	baseWidth = objBuffer[line + 20];	lineOffset = baseWidth >> 1;	lineWidth = objBuffer[line + 17];	xDir = objBuffer[line + 10];	/* Adjust the start of the line to fill an entire rectangle */	deltaX = nextX - lastX;	if (yEntry < baseWidth) {		if (xDir < 0) {			/* effectively adding */			lineWidth -= deltaX;		} else {			lineWidth += deltaX;			objBuffer[line + 4] = lastX;		}	}	if ((yExit + lineOffset) === 0) {		if (xDir > 0) {			lineWidth -= objBuffer[line + 12];		} else {			/* effectively subtracting */			lineWidth += objBuffer[line + 12];			objBuffer[line + 4] = lastX;		}	}	if ((yExit + lineOffset) > 0) {		if (xDir < 0) {			/* effectively subtracting */			lineWidth += deltaX;			objBuffer[line + 4] = lastX;		} else {			lineWidth -= deltaX;		}	}	objBuffer[line + 17] = lineWidth;}, /*	Allocate n slots in the global edge table */allocateGETEntry(nSlots) {	let dstIndex;	let i;	let srcIndex;	/* First allocate nSlots in the AET */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + nSlots + 128) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return false;	}	/* end needAvailableSpace: */	if (workBuffer[14] !== 0) {		/* Then move the AET upwards */		srcIndex = workBuffer[14];		dstIndex = workBuffer[14] + nSlots;		const iLimiT = workBuffer[14];		for (i = 1; i <= iLimiT; i++) {			aetBuffer[(--dstIndex)] = aetBuffer[(--srcIndex)];		}	}	aetBuffer = PTR_ADD(aetBuffer, nSlots);	return true;}, /*	Allocate n slots in the object buffer */allocateObjEntry(nSlots) {	let dstIndex;	let i;	let srcIndex;	/* First allocate nSlots in the GET */	if (!B2DPlugin.allocateGETEntry(nSlots)) {		return false;	}	if (workBuffer[12] !== 0) {		/* Then move the GET upwards */		srcIndex = workBuffer[12];		dstIndex = workBuffer[12] + nSlots;		const iLimiT = workBuffer[12];		for (i = 1; i <= iLimiT; i++) {			getBuffer[(--dstIndex)] = getBuffer[(--srcIndex)];		}	}	getBuffer = PTR_ADD(getBuffer, nSlots);	return true;}, /*	Check the fill indexes in the run-length encoded fillList */checkCompressedFillIndexListmaxsegments(fillList, maxIndex, nSegs) {	let fillPtr;	let i;	let length;	let nFills;	let runLength;	let runValue;	length = SIZEOF(fillList);	fillPtr = fillList.wordsAsInt32Array();	nFills = 0;	for (i = 0; i < length; i++) {		runLength = (fillPtr[i]|0) >>> 16;		runValue = UBANDS((fillPtr[i]|0), 65535);		if (!((runValue >= 0) && (runValue <= maxIndex))) {			return false;		}		nFills += runLength;	}	return nFills === nSegs;}, /*	Check if the indexList (containing fill handles) is okay. */checkCompressedFills(indexList) {	let fillIndex;	let fillPtr;	let i;	let length;	/* First check if the oops have the right format */	if ((indexList.storageType !== "words")) {		return false;	}	length = SIZEOF(indexList);	fillPtr = indexList.wordsAsInt32Array();	for (i = 0; i < length; i++) {		/* Make sure the fill is okay */		fillIndex = fillPtr[i];		if (!B2DPlugin.isFillOkay(fillIndex)) {			return false;		}	}	return true;}, /*	Check the run-length encoded lineWidthList matches nSegments */checkCompressedLineWidthssegments(lineWidthList, nSegments) {	let i;	let length;	let nItems;	let ptr;	let runLength;	length = SIZEOF(lineWidthList);	ptr = lineWidthList.wordsAsInt32Array();	nItems = 0;	for (i = 0; i < length; i++) {		runLength = (ptr[i]|0) >>> 16;		nItems += runLength;	}	return nItems === nSegments;}, /*	Check if the given point array can be handled by the engine. */checkCompressedPointssegments(points, nSegments) {	let pSize;	if ((points.storageType !== "words")) {		return false;	}	/* The points must be either in PointArray format or ShortPointArray format.	Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either		pSize = nSegments * 3,		for ShortPointArrays or,		pSize = nSegments * 6,		for PointArrays */	pSize = SIZEOF(points);	return ((pSize === (nSegments * 3)) || (pSize === (nSegments * 6)));}, /*	Check if the given shape can be handled by the engine. 	Since there are a number of requirements this is an extra method. */checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList) {	let maxFillIndex;	if (!B2DPlugin.checkCompressedPointssegments(points, nSegments)) {		return false;	}	if (!B2DPlugin.checkCompressedFills(fillIndexList)) {		return false;	}	maxFillIndex = SIZEOF(fillIndexList);	return B2DPlugin.checkCompressedFillIndexListmaxsegments(leftFills, maxFillIndex, nSegments) && (B2DPlugin.checkCompressedFillIndexListmaxsegments(rightFills, maxFillIndex, nSegments) && (B2DPlugin.checkCompressedFillIndexListmaxsegments(lineFills, maxFillIndex, nSegments) && (B2DPlugin.checkCompressedLineWidthssegments(lineWidths, nSegments))));}, circleCosTable() {	let theTable =		[1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,		1.0 ];	return theTable;}, circleSinTable() {	let theTable =		[0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		 0.0 ];	return theTable;}, /*	Clear the current span buffer.	The span buffer is only cleared in the area that has been used by the previous scan line. */clearSpanBuffer() {	let x0;	let x1;	x0 = SHR(workBuffer[32], workBuffer[49]);	x1 = (SHR(workBuffer[34], workBuffer[49])) + 1;	if (x0 < 0) {		x0 = 0;	}	if (x1 > workBuffer[33]) {		x1 = workBuffer[33];	}	while (x0 < x1) {		spanBuffer[x0] = 0;		++x0;	}	workBuffer[32] = workBuffer[33];	workBuffer[34] = 0;}, /*	Split the bezier curve at the given parametric value.	Note: Since this method is only invoked to make non-monoton		beziers monoton we must check for the resulting y values		to be *really* between the start and end value. */computeBeziersplitAt(index, param) {	let endX;	let endY;	let leftViaX;	let leftViaY;	let newIndex;	let rightViaX;	let rightViaY;	let sharedX;	let sharedY;	let startX;	let startY;	let viaX;	let viaY;	leftViaX = startX = workBuffer[workBuffer[1] - index];	leftViaY = startY = workBuffer[workBuffer[1] + 1 - index];	viaX = rightViaX = workBuffer[workBuffer[1] + 2 - index];	viaY = rightViaY = workBuffer[workBuffer[1] + 3 - index];	endX = workBuffer[workBuffer[1] + 4 - index];	/* Compute intermediate points */	endY = workBuffer[workBuffer[1] + 5 - index];	sharedX = leftViaX = leftViaX + (((viaX - startX) * param) | 0);	sharedY = leftViaY = leftViaY + (((viaY - startY) * param) | 0);	rightViaX += (((endX - viaX) * param) | 0);	/* Compute new shared point */	rightViaY += (((endY - viaY) * param) | 0);	sharedX += (((rightViaX - leftViaX) * param) | 0);	/* Check the new via points */	sharedY += (((rightViaY - leftViaY) * param) | 0);	leftViaY = (startY > sharedY) ? ((leftViaY > startY) ? startY : ((leftViaY < sharedY) ? sharedY : leftViaY)) : ((leftViaY < startY) ? startY : ((leftViaY > sharedY) ? sharedY : leftViaY));	rightViaY = (sharedY > endY) ? ((rightViaY > sharedY) ? sharedY : ((rightViaY < endY) ? endY : rightViaY)) : ((rightViaY < sharedY) ? sharedY : ((rightViaY > endY) ? endY : rightViaY));	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 134) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */	} else {		workBuffer[10] -= 6;	}	/* end needAvailableSpace: */	/* end wbStackPush: */	newIndex = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	workBuffer[workBuffer[1] + 2 - index] = leftViaX;	workBuffer[workBuffer[1] + 3 - index] = leftViaY;	workBuffer[workBuffer[1] + 4 - index] = sharedX;	workBuffer[workBuffer[1] + 5 - index] = sharedY;	workBuffer[workBuffer[1] - newIndex] = sharedX;	workBuffer[workBuffer[1] + 1 - newIndex] = sharedY;	workBuffer[workBuffer[1] + 2 - newIndex] = rightViaX;	workBuffer[workBuffer[1] + 3 - newIndex] = rightViaY;	workBuffer[workBuffer[1] + 4 - newIndex] = endX;	workBuffer[workBuffer[1] + 5 - newIndex] = endY;	return newIndex;}, /*	Split the bezier curve at 0.5. */computeBezierSplitAtHalf(index) {	let endX;	let endY;	let leftViaX;	let leftViaY;	let newIndex;	let rightViaX;	let rightViaY;	let sharedX;	let sharedY;	let startX;	let startY;	let viaX;	let viaY;	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 134) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */	} else {		workBuffer[10] -= 6;	}	/* end needAvailableSpace: */	/* end wbStackPush: */	newIndex = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	leftViaX = startX = workBuffer[workBuffer[1] - index];	leftViaY = startY = workBuffer[workBuffer[1] + 1 - index];	viaX = rightViaX = workBuffer[workBuffer[1] + 2 - index];	viaY = rightViaY = workBuffer[workBuffer[1] + 3 - index];	endX = workBuffer[workBuffer[1] + 4 - index];	/* Compute intermediate points */	endY = workBuffer[workBuffer[1] + 5 - index];	leftViaX += (viaX - startX) >> 1;	leftViaY += (viaY - startY) >> 1;	sharedX = rightViaX = rightViaX + ((endX - viaX) >> 1);	/* Compute new shared point */	sharedY = rightViaY = rightViaY + ((endY - viaY) >> 1);	sharedX += (leftViaX - rightViaX) >> 1;	/* Store the first part back */	sharedY += (leftViaY - rightViaY) >> 1;	workBuffer[workBuffer[1] + 2 - index] = leftViaX;	workBuffer[workBuffer[1] + 3 - index] = leftViaY;	workBuffer[workBuffer[1] + 4 - index] = sharedX;	workBuffer[workBuffer[1] + 5 - index] = sharedY;	workBuffer[workBuffer[1] - newIndex] = sharedX;	workBuffer[workBuffer[1] + 1 - newIndex] = sharedY;	workBuffer[workBuffer[1] + 2 - newIndex] = rightViaX;	workBuffer[workBuffer[1] + 3 - newIndex] = rightViaY;	workBuffer[workBuffer[1] + 4 - newIndex] = endX;	workBuffer[workBuffer[1] + 5 - newIndex] = endY;	return newIndex;}, /*	Create the global edge table */createGlobalEdgeTable() {	let end;	let object;	let type;	let lineWidth;	let lineWidth1;	object = 0;	end = objUsed;	while (object < end) {		/* Note: addEdgeToGET: may fail on insufficient space but that's not a problem here */		/* begin isEdge: */		type = UBANDS(objBuffer[object], 65535);		if (type <= 255) {			if ((UBANDS((UBANDS(objBuffer[object], 65535)), 255)) !== 0) {				if (objBuffer[object + 5] < workBuffer[39]) {					/* begin checkedAddEdgeToGET: */					if ((UBANDS((UBANDS(objBuffer[object], 65535)), 254)) === 4) {						/* begin checkedAddLineToGET: */						lineWidth1 = ((UBANDS((UBANDS(objBuffer[object], 65535)), 1)) !== 0) ? objBuffer[object + 20] : 0;						if ((objBuffer[object + 15] + lineWidth1) >= workBuffer[38]) {							if (!(((objBuffer[object + 4] - lineWidth1) >= workBuffer[37]) && ((objBuffer[object + 14] - lineWidth1) >= workBuffer[37]))) {								B2DPlugin.addEdgeToGET(object);							}						}						/* end checkedAddLineToGET: */					} else {						if ((UBANDS((UBANDS(objBuffer[object], 65535)), 254)) === 6) {							/* begin checkedAddBezierToGET: */							lineWidth = ((UBANDS((UBANDS(objBuffer[object], 65535)), 1)) !== 0) ? objBuffer[object + 20] : 0;							if ((objBuffer[object + 15] + lineWidth) >= workBuffer[38]) {								if (!(((objBuffer[object + 4] - lineWidth) >= workBuffer[37]) && ((objBuffer[object + 14] - lineWidth) >= workBuffer[37]))) {									B2DPlugin.addEdgeToGET(object);								}							}							/* end checkedAddBezierToGET: */						} else {							B2DPlugin.addEdgeToGET(object);						}					}					/* end checkedAddEdgeToGET: */				}			}		}		/* end isEdge: */		object += objBuffer[object + 1];	}}, /*	Display the span buffer at the current scan line. */displaySpanBufferAt(y) {	let targetX0;	let targetX1;	let targetY;	/* self aaLevelGet > 1 ifTrue:[self adjustAALevel]. */	targetX0 = SHR(workBuffer[32], workBuffer[49]);	if (targetX0 < workBuffer[42]) {		targetX0 = workBuffer[42];	}	targetX1 = SHR(((workBuffer[34] + workBuffer[48]) - 1), workBuffer[49]);	if (targetX1 > workBuffer[43]) {		targetX1 = workBuffer[43];	}	targetY = SHR(y, workBuffer[49]);	if ((targetY < workBuffer[44]) || ((targetY >= workBuffer[45]) || ((targetX1 < workBuffer[42]) || (targetX0 >= workBuffer[43])))) {		return 0;	}	if (!copyBitsFn) {		/* begin initialiseModule */		loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);		copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);		if ((!!loadBBFn) && (!!copyBitsFn)) {			copyBitsFn(targetX0, targetX1, targetY);		}		/* end initialiseModule */	} else {		copyBitsFn(targetX0, targetX1, targetY);	}}, /*	Fill the span buffer between leftEdge and rightEdge using the given bits.	Note: We always start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those with depth 32) directly. */fillBitmapSpanfromto(bits, leftX, rightX) {	let baseShift;	let bitX;	let colorMask;	let colorShift;	let fillValue;	let x;	let x0;	let x1;	x0 = leftX;	x1 = rightX;	/* Hack for pre-increment */	bitX = -1;	if (workBuffer[48] === 1) {		/* Speedy version for no anti-aliasing */		while (x0 < x1) {			fillValue = (bits[(++bitX)]|0);			spanBuffer[x0] = fillValue;			++x0;		}	} else {		/* Generic version with anti-aliasing */		colorMask = workBuffer[51];		colorShift = workBuffer[50];		baseShift = workBuffer[49];		while (x0 < x1) {			x = SHR(x0, baseShift);			fillValue = (bits[(++bitX)]|0);			fillValue = SHR((UBAND(fillValue, colorMask)), colorShift);			spanBuffer[x] += fillValue;			++x0;		}	}	if (x1 > workBuffer[34]) {		workBuffer[34] = x1;	}	if (x1 > workBuffer[35]) {		workBuffer[35] = x1;	}}, fillBitmapSpanfromtoat(bmFill, leftX, rightX, yValue) {	let bits;	let bmHeight;	let bmWidth;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let fillValue;	let tileFlag;	let x;	let x1;	let xp;	let yp;	let maxValue;	let newDelta;	let maxValue1;	let newDelta1;	let a;	let b;	let bmDepth;	let bmRaster;	let cMask;	let g;	let r;	let rShift;	let value;	let a1;	let b1;	let g1;	let r1;	let transform;	let a2;	let b2;	let g2;	let r2;	let transform1;	let bitsLen;	let bitsOop;	let formOop;	let xIndex;	if (workBuffer[48] !== 1) {		return B2DPlugin.fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue);	}	/* begin loadBitsFrom: */	xIndex = objBuffer[bmFill + 2];	if (xIndex > SIZEOF(formArray)) {		bits = null;	} else {		formOop = formArray.pointers[xIndex];		bitsOop = formOop.pointers[0];		bitsLen = SIZEOF(bitsOop);		bits = (bitsLen === objBuffer[bmFill + 13]) ? bitsOop.wordsAsInt32Array() : null;	}	/* end loadBitsFrom: */	if (!bits) {		return null;	}	bmWidth = objBuffer[bmFill + 10];	bmHeight = objBuffer[bmFill + 11];	tileFlag = objBuffer[bmFill + 16] === 1;	deltaX = leftX - objBuffer[bmFill + 4];	deltaY = yValue - objBuffer[bmFill + 5];	dsX = objBuffer[bmFill + 6];	dtX = objBuffer[bmFill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[bmFill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[bmFill + 9]);	x = leftX;	x1 = rightX;	while (x < x1) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue = bmWidth << 16 >>> 0;			newDelta = ds;			while (newDelta < 0) {				newDelta += maxValue;			}			while (newDelta >= maxValue) {				newDelta -= maxValue;			}			ds = newDelta;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue1 = bmHeight << 16 >>> 0;			newDelta1 = dt;			while (newDelta1 < 0) {				newDelta1 += maxValue1;			}			while (newDelta1 >= maxValue1) {				newDelta1 -= maxValue1;			}			dt = newDelta1;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth = objBuffer[bmFill + 12];			bmRaster = objBuffer[bmFill + 14];			if (bmDepth === 32) {				value = (bits[(bmRaster * yp) + xp]|0);				if ((value !== 0) && ((UBANDM(value, 2130706432)) === 0)) {					value = UBORM(value, 2130706432);				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b1 = UBANDS(value, 255);					g1 = UBANDS((value >>> 8), 255);					r1 = UBANDS((value >>> 16), 255);					a1 = UBANDS((value >>> 24), 255);					transform = FPTR_ADD(workBuffer, 24);					r1 = (((r1 * transform[0]) + transform[1]) | 0);					g1 = (((g1 * transform[2]) + transform[3]) | 0);					b1 = (((b1 * transform[4]) + transform[5]) | 0);					a1 = (((a1 * transform[6]) + transform[7]) | 0);					r1 = Math.max(r1, 0);					r1 = Math.min(r1, 255);					g1 = Math.max(g1, 0);					g1 = Math.min(g1, 255);					b1 = Math.max(b1, 0);					b1 = Math.min(b1, 255);					a1 = Math.max(a1, 0);					a1 = Math.min(a1, 255);					fillValue = (a1 < 16) ? 0 : (((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0));				} else {					fillValue = value;				}				/* end uncheckedTransformColor: */			} else {				rShift = B2DPlugin.rShiftTable()[bmDepth];				value = bits[(bmRaster * yp) + (SHR(xp, rShift))];				cMask = (SHL(1, bmDepth)) - 1;				rShift = 32 - bmDepth - ((UBAND(xp, ((SHL(1, rShift)) - 1))) * bmDepth);				value = UBAND((SHR(value, rShift)), cMask);				if (bmDepth === 16) {					if (value !== 0) {						b = (UBANDS(value, 31)) << 3 >>> 0;						b += b >>> 5;						g = (UBANDS((value >>> 5), 31)) << 3 >>> 0;						g += g >>> 5;						r = (UBANDS((value >>> 10), 31)) << 3 >>> 0;						r += r >>> 5;						a = 255;						value = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {					value = (objBuffer[bmFill + 15] === 0) ? 0 : objBuffer[value + bmFill + 18];				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b2 = UBANDS(value, 255);					g2 = UBANDS((value >>> 8), 255);					r2 = UBANDS((value >>> 16), 255);					a2 = UBANDS((value >>> 24), 255);					transform1 = FPTR_ADD(workBuffer, 24);					r2 = (((r2 * transform1[0]) + transform1[1]) | 0);					g2 = (((g2 * transform1[2]) + transform1[3]) | 0);					b2 = (((b2 * transform1[4]) + transform1[5]) | 0);					a2 = (((a2 * transform1[6]) + transform1[7]) | 0);					r2 = Math.max(r2, 0);					r2 = Math.min(r2, 255);					g2 = Math.max(g2, 0);					g2 = Math.min(g2, 255);					b2 = Math.max(b2, 0);					b2 = Math.min(b2, 255);					a2 = Math.max(a2, 0);					a2 = Math.min(a2, 255);					fillValue = (a2 < 16) ? 0 : (((b2 + (g2 << 8 >>> 0)) + (r2 << 16 >>> 0)) + (a2 << 24 >>> 0));				} else {					fillValue = value;				}				/* end uncheckedTransformColor: */			}			/* end bitmapValue:bits:atX:y: */			spanBuffer[x] = fillValue;		}		ds += dsX;		dt += dtX;		++x;	}}, fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue) {	let aaLevel;	let baseShift;	let bits;	let bmHeight;	let bmWidth;	let cMask;	let cShift;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let fillValue;	let firstPixel;	let idx;	let lastPixel;	let tileFlag;	let x;	let xp;	let yp;	let maxValue;	let newDelta;	let maxValue1;	let newDelta1;	let maxValue2;	let newDelta2;	let maxValue3;	let newDelta3;	let maxValue4;	let newDelta4;	let maxValue5;	let newDelta5;	let firstPixel1;	let a;	let b;	let bmDepth;	let bmRaster;	let cMask1;	let g;	let r;	let rShift;	let value;	let a1;	let b1;	let g1;	let r1;	let transform;	let a2;	let b2;	let g2;	let r2;	let transform1;	let a3;	let b3;	let bmDepth1;	let bmRaster1;	let cMask2;	let g3;	let r3;	let rShift1;	let value1;	let a11;	let b11;	let g11;	let r11;	let transform2;	let a21;	let b21;	let g21;	let r21;	let transform11;	let a4;	let b4;	let bmDepth2;	let bmRaster2;	let cMask3;	let g4;	let r4;	let rShift2;	let value2;	let a12;	let b12;	let g12;	let r12;	let transform3;	let a22;	let b22;	let g22;	let r22;	let transform12;	let bitsLen;	let bitsOop;	let formOop;	let xIndex;	/* begin loadBitsFrom: */	xIndex = objBuffer[bmFill + 2];	if (xIndex > SIZEOF(formArray)) {		bits = null;	} else {		formOop = formArray.pointers[xIndex];		bitsOop = formOop.pointers[0];		bitsLen = SIZEOF(bitsOop);		bits = (bitsLen === objBuffer[bmFill + 13]) ? bitsOop.wordsAsInt32Array() : null;	}	/* end loadBitsFrom: */	if (!bits) {		return null;	}	bmWidth = objBuffer[bmFill + 10];	bmHeight = objBuffer[bmFill + 11];	tileFlag = objBuffer[bmFill + 16] === 1;	deltaX = leftX - objBuffer[bmFill + 4];	deltaY = yValue - objBuffer[bmFill + 5];	dsX = objBuffer[bmFill + 6];	dtX = objBuffer[bmFill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[bmFill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[bmFill + 9]);	aaLevel = workBuffer[48];	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	baseShift = workBuffer[49];	cMask = workBuffer[51];	cShift = workBuffer[50];	x = leftX;	while (x < firstPixel) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue = bmWidth << 16 >>> 0;			newDelta = ds;			while (newDelta < 0) {				newDelta += maxValue;			}			while (newDelta >= maxValue) {				newDelta -= maxValue;			}			ds = newDelta;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue1 = bmHeight << 16 >>> 0;			newDelta1 = dt;			while (newDelta1 < 0) {				newDelta1 += maxValue1;			}			while (newDelta1 >= maxValue1) {				newDelta1 -= maxValue1;			}			dt = newDelta1;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth = objBuffer[bmFill + 12];			bmRaster = objBuffer[bmFill + 14];			if (bmDepth === 32) {				value = (bits[(bmRaster * yp) + xp]|0);				if ((value !== 0) && ((UBANDM(value, 2130706432)) === 0)) {					value = UBORM(value, 2130706432);				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b1 = UBANDS(value, 255);					g1 = UBANDS((value >>> 8), 255);					r1 = UBANDS((value >>> 16), 255);					a1 = UBANDS((value >>> 24), 255);					transform = FPTR_ADD(workBuffer, 24);					r1 = (((r1 * transform[0]) + transform[1]) | 0);					g1 = (((g1 * transform[2]) + transform[3]) | 0);					b1 = (((b1 * transform[4]) + transform[5]) | 0);					a1 = (((a1 * transform[6]) + transform[7]) | 0);					r1 = Math.max(r1, 0);					r1 = Math.min(r1, 255);					g1 = Math.max(g1, 0);					g1 = Math.min(g1, 255);					b1 = Math.max(b1, 0);					b1 = Math.min(b1, 255);					a1 = Math.max(a1, 0);					a1 = Math.min(a1, 255);					fillValue = (a1 < 16) ? 0 : (((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0));				} else {					fillValue = value;				}				/* end uncheckedTransformColor: */			} else {				rShift = B2DPlugin.rShiftTable()[bmDepth];				value = bits[(bmRaster * yp) + (SHR(xp, rShift))];				cMask1 = (SHL(1, bmDepth)) - 1;				rShift = 32 - bmDepth - ((UBAND(xp, ((SHL(1, rShift)) - 1))) * bmDepth);				value = UBAND((SHR(value, rShift)), cMask1);				if (bmDepth === 16) {					if (value !== 0) {						b = (UBANDS(value, 31)) << 3 >>> 0;						b += b >>> 5;						g = (UBANDS((value >>> 5), 31)) << 3 >>> 0;						g += g >>> 5;						r = (UBANDS((value >>> 10), 31)) << 3 >>> 0;						r += r >>> 5;						a = 255;						value = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {					value = (objBuffer[bmFill + 15] === 0) ? 0 : objBuffer[value + bmFill + 18];				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b2 = UBANDS(value, 255);					g2 = UBANDS((value >>> 8), 255);					r2 = UBANDS((value >>> 16), 255);					a2 = UBANDS((value >>> 24), 255);					transform1 = FPTR_ADD(workBuffer, 24);					r2 = (((r2 * transform1[0]) + transform1[1]) | 0);					g2 = (((g2 * transform1[2]) + transform1[3]) | 0);					b2 = (((b2 * transform1[4]) + transform1[5]) | 0);					a2 = (((a2 * transform1[6]) + transform1[7]) | 0);					r2 = Math.max(r2, 0);					r2 = Math.min(r2, 255);					g2 = Math.max(g2, 0);					g2 = Math.min(g2, 255);					b2 = Math.max(b2, 0);					b2 = Math.min(b2, 255);					a2 = Math.max(a2, 0);					a2 = Math.min(a2, 255);					fillValue = (a2 < 16) ? 0 : (((b2 + (g2 << 8 >>> 0)) + (r2 << 16 >>> 0)) + (a2 << 24 >>> 0));				} else {					fillValue = value;				}				/* end uncheckedTransformColor: */			}			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] += fillValue;		}		ds += dsX;		dt += dtX;		++x;	}	cMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);	cShift = workBuffer[49];	while (x < lastPixel) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue2 = bmWidth << 16 >>> 0;			newDelta2 = ds;			while (newDelta2 < 0) {				newDelta2 += maxValue2;			}			while (newDelta2 >= maxValue2) {				newDelta2 -= maxValue2;			}			ds = newDelta2;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue3 = bmHeight << 16 >>> 0;			newDelta3 = dt;			while (newDelta3 < 0) {				newDelta3 += maxValue3;			}			while (newDelta3 >= maxValue3) {				newDelta3 -= maxValue3;			}			dt = newDelta3;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth1 = objBuffer[bmFill + 12];			bmRaster1 = objBuffer[bmFill + 14];			if (bmDepth1 === 32) {				value1 = (bits[(bmRaster1 * yp) + xp]|0);				if ((value1 !== 0) && ((UBANDM(value1, 2130706432)) === 0)) {					value1 = UBORM(value1, 2130706432);				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b11 = UBANDS(value1, 255);					g11 = UBANDS((value1 >>> 8), 255);					r11 = UBANDS((value1 >>> 16), 255);					a11 = UBANDS((value1 >>> 24), 255);					transform2 = FPTR_ADD(workBuffer, 24);					r11 = (((r11 * transform2[0]) + transform2[1]) | 0);					g11 = (((g11 * transform2[2]) + transform2[3]) | 0);					b11 = (((b11 * transform2[4]) + transform2[5]) | 0);					a11 = (((a11 * transform2[6]) + transform2[7]) | 0);					r11 = Math.max(r11, 0);					r11 = Math.min(r11, 255);					g11 = Math.max(g11, 0);					g11 = Math.min(g11, 255);					b11 = Math.max(b11, 0);					b11 = Math.min(b11, 255);					a11 = Math.max(a11, 0);					a11 = Math.min(a11, 255);					fillValue = (a11 < 16) ? 0 : (((b11 + (g11 << 8 >>> 0)) + (r11 << 16 >>> 0)) + (a11 << 24 >>> 0));				} else {					fillValue = value1;				}				/* end uncheckedTransformColor: */			} else {				rShift1 = B2DPlugin.rShiftTable()[bmDepth1];				value1 = bits[(bmRaster1 * yp) + (SHR(xp, rShift1))];				cMask2 = (SHL(1, bmDepth1)) - 1;				rShift1 = 32 - bmDepth1 - ((UBAND(xp, ((SHL(1, rShift1)) - 1))) * bmDepth1);				value1 = UBAND((SHR(value1, rShift1)), cMask2);				if (bmDepth1 === 16) {					if (value1 !== 0) {						b3 = (UBANDS(value1, 31)) << 3 >>> 0;						b3 += b3 >>> 5;						g3 = (UBANDS((value1 >>> 5), 31)) << 3 >>> 0;						g3 += g3 >>> 5;						r3 = (UBANDS((value1 >>> 10), 31)) << 3 >>> 0;						r3 += r3 >>> 5;						a3 = 255;						value1 = ((b3 + (g3 << 8 >>> 0)) + (r3 << 16 >>> 0)) + (a3 << 24 >>> 0);					}				} else {					value1 = (objBuffer[bmFill + 15] === 0) ? 0 : objBuffer[value1 + bmFill + 18];				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b21 = UBANDS(value1, 255);					g21 = UBANDS((value1 >>> 8), 255);					r21 = UBANDS((value1 >>> 16), 255);					a21 = UBANDS((value1 >>> 24), 255);					transform11 = FPTR_ADD(workBuffer, 24);					r21 = (((r21 * transform11[0]) + transform11[1]) | 0);					g21 = (((g21 * transform11[2]) + transform11[3]) | 0);					b21 = (((b21 * transform11[4]) + transform11[5]) | 0);					a21 = (((a21 * transform11[6]) + transform11[7]) | 0);					r21 = Math.max(r21, 0);					r21 = Math.min(r21, 255);					g21 = Math.max(g21, 0);					g21 = Math.min(g21, 255);					b21 = Math.max(b21, 0);					b21 = Math.min(b21, 255);					a21 = Math.max(a21, 0);					a21 = Math.min(a21, 255);					fillValue = (a21 < 16) ? 0 : (((b21 + (g21 << 8 >>> 0)) + (r21 << 16 >>> 0)) + (a21 << 24 >>> 0));				} else {					fillValue = value1;				}				/* end uncheckedTransformColor: */			}			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] += fillValue;		}		ds += SHL(dsX, cShift);		dt += SHL(dtX, cShift);		x += aaLevel;	}	cMask = workBuffer[51];	cShift = workBuffer[50];	while (x < rightX) {		if (tileFlag) {			/* begin repeatValue:max: */			maxValue4 = bmWidth << 16 >>> 0;			newDelta4 = ds;			while (newDelta4 < 0) {				newDelta4 += maxValue4;			}			while (newDelta4 >= maxValue4) {				newDelta4 -= maxValue4;			}			ds = newDelta4;			/* end repeatValue:max: */			/* begin repeatValue:max: */			maxValue5 = bmHeight << 16 >>> 0;			newDelta5 = dt;			while (newDelta5 < 0) {				newDelta5 += maxValue5;			}			while (newDelta5 >= maxValue5) {				newDelta5 -= maxValue5;			}			dt = newDelta5;			/* end repeatValue:max: */		}		xp = ds >> 16;		yp = dt >> 16;		if (!tileFlag) {			xp = (xp < 0) ? 0 : ((xp >= bmWidth) ? (bmWidth - 1) : xp);			yp = (yp < 0) ? 0 : ((yp >= bmHeight) ? (bmHeight - 1) : yp);		}		if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {			/* begin bitmapValue:bits:atX:y: */			bmDepth2 = objBuffer[bmFill + 12];			bmRaster2 = objBuffer[bmFill + 14];			if (bmDepth2 === 32) {				value2 = (bits[(bmRaster2 * yp) + xp]|0);				if ((value2 !== 0) && ((UBANDM(value2, 2130706432)) === 0)) {					value2 = UBORM(value2, 2130706432);				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b12 = UBANDS(value2, 255);					g12 = UBANDS((value2 >>> 8), 255);					r12 = UBANDS((value2 >>> 16), 255);					a12 = UBANDS((value2 >>> 24), 255);					transform3 = FPTR_ADD(workBuffer, 24);					r12 = (((r12 * transform3[0]) + transform3[1]) | 0);					g12 = (((g12 * transform3[2]) + transform3[3]) | 0);					b12 = (((b12 * transform3[4]) + transform3[5]) | 0);					a12 = (((a12 * transform3[6]) + transform3[7]) | 0);					r12 = Math.max(r12, 0);					r12 = Math.min(r12, 255);					g12 = Math.max(g12, 0);					g12 = Math.min(g12, 255);					b12 = Math.max(b12, 0);					b12 = Math.min(b12, 255);					a12 = Math.max(a12, 0);					a12 = Math.min(a12, 255);					fillValue = (a12 < 16) ? 0 : (((b12 + (g12 << 8 >>> 0)) + (r12 << 16 >>> 0)) + (a12 << 24 >>> 0));				} else {					fillValue = value2;				}				/* end uncheckedTransformColor: */			} else {				rShift2 = B2DPlugin.rShiftTable()[bmDepth2];				value2 = bits[(bmRaster2 * yp) + (SHR(xp, rShift2))];				cMask3 = (SHL(1, bmDepth2)) - 1;				rShift2 = 32 - bmDepth2 - ((UBAND(xp, ((SHL(1, rShift2)) - 1))) * bmDepth2);				value2 = UBAND((SHR(value2, rShift2)), cMask3);				if (bmDepth2 === 16) {					if (value2 !== 0) {						b4 = (UBANDS(value2, 31)) << 3 >>> 0;						b4 += b4 >>> 5;						g4 = (UBANDS((value2 >>> 5), 31)) << 3 >>> 0;						g4 += g4 >>> 5;						r4 = (UBANDS((value2 >>> 10), 31)) << 3 >>> 0;						r4 += r4 >>> 5;						a4 = 255;						value2 = ((b4 + (g4 << 8 >>> 0)) + (r4 << 16 >>> 0)) + (a4 << 24 >>> 0);					}				} else {					value2 = (objBuffer[bmFill + 15] === 0) ? 0 : objBuffer[value2 + bmFill + 18];				}				/* begin uncheckedTransformColor: */				if (workBuffer[17] !== 0) {					b22 = UBANDS(value2, 255);					g22 = UBANDS((value2 >>> 8), 255);					r22 = UBANDS((value2 >>> 16), 255);					a22 = UBANDS((value2 >>> 24), 255);					transform12 = FPTR_ADD(workBuffer, 24);					r22 = (((r22 * transform12[0]) + transform12[1]) | 0);					g22 = (((g22 * transform12[2]) + transform12[3]) | 0);					b22 = (((b22 * transform12[4]) + transform12[5]) | 0);					a22 = (((a22 * transform12[6]) + transform12[7]) | 0);					r22 = Math.max(r22, 0);					r22 = Math.min(r22, 255);					g22 = Math.max(g22, 0);					g22 = Math.min(g22, 255);					b22 = Math.max(b22, 0);					b22 = Math.min(b22, 255);					a22 = Math.max(a22, 0);					a22 = Math.min(a22, 255);					fillValue = (a22 < 16) ? 0 : (((b22 + (g22 << 8 >>> 0)) + (r22 << 16 >>> 0)) + (a22 << 24 >>> 0));				} else {					fillValue = value2;				}				/* end uncheckedTransformColor: */			}			/* end bitmapValue:bits:atX:y: */			fillValue = SHR((UBAND(fillValue, cMask)), cShift);			idx = SHR(x, baseShift);			spanBuffer[idx] += fillValue;		}		ds += dsX;		dt += dtX;		++x;	}}, /*	This is the inner loop for solid color fills with anti-aliasing.	This loop has been unrolled for speed and quality into three parts:		a) copy all pixels that fall into the first full pixel.		b) copy aaLevel pixels between the first and the last full pixel		c) copy all pixels that fall in the last full pixel */fillColorSpanAAx0x1(pixelValue32, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let firstPixel;	let idx;	let lastPixel;	let pv32;	let x;	let firstPixel1;	/* Not now -- maybe later */	/* Compute the pixel boundaries. */	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	/* Part a: Deal with the first n sub-pixels */	x = leftX;	if (x < firstPixel) {		pv32 = SHR((UBAND(pixelValue32, workBuffer[51])), workBuffer[50]);		while (x < firstPixel) {			idx = SHR(x, baseShift);			spanBuffer[idx] += pv32;			++x;		}	}	if (x < lastPixel) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		pv32 = SHR((UBAND(pixelValue32, colorMask)), workBuffer[49]);		while (x < lastPixel) {			idx = SHR(x, baseShift);			spanBuffer[idx] += pv32;			x += aaLevel;		}	}	if (x < rightX) {		pv32 = SHR((UBAND(pixelValue32, workBuffer[51])), workBuffer[50]);		while (x < rightX) {			idx = SHR(x, baseShift);			spanBuffer[idx] += pv32;			++x;		}	}}, /*	Draw a linear gradient fill. */fillLinearGradientfromtoat(fill, leftX, rightX, yValue) {	let ds;	let dsX;	let ramp;	let rampIndex;	let rampSize;	let x;	let x0;	let x1;	let pixelValue32;	let x01;	let x11;	let pixelValue321;	let x02;	let x12;	ramp = PTR_ADD(objBuffer, fill + 12);	rampSize = objBuffer[fill + 10];	dsX = objBuffer[fill + 6];	ds = ((leftX - objBuffer[fill + 4]) * dsX) + ((yValue - objBuffer[fill + 5]) * objBuffer[fill + 7]);	x0 = x = leftX;	/* Note: The inner loop has been divided into three parts for speed */	/* Part one: Fill everything outside the left boundary */	x1 = rightX;	while (((((rampIndex = ds >> 16)) < 0) || (rampIndex >= rampSize)) && (x < x1)) {		++x;		ds += dsX;	}	if (x > x0) {		if (rampIndex < 0) {			rampIndex = 0;		}		if (rampIndex >= rampSize) {			rampIndex = rampSize - 1;		}		/* begin fillColorSpan:from:to: */		pixelValue32 = ramp[rampIndex];		if (workBuffer[48] === 1) {			x01 = x0;			x11 = x;			while ((x01 + 4) < x11) {				spanBuffer[x01] = pixelValue32;				spanBuffer[x01 + 1] = pixelValue32;				spanBuffer[x01 + 2] = pixelValue32;				spanBuffer[x01 + 3] = pixelValue32;				x01 += 4;			}			while (x01 < x11) {				spanBuffer[x01] = pixelValue32;				++x01;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue32, x0, x);		}		/* end fillColorSpan:from:to: */	}	if (workBuffer[48] === 1) {		/* Fast version w/o anti-aliasing */		while (((((rampIndex = ds >> 16)) < rampSize) && (rampIndex >= 0)) && (x < x1)) {			spanBuffer[x] = ramp[rampIndex];			++x;			ds += dsX;		}	} else {		x = B2DPlugin.fillLinearGradientAArampdsdsXfromto(fill, ramp, ds, dsX, x, rightX);	}	if (x < x1) {		if (rampIndex < 0) {			rampIndex = 0;		}		if (rampIndex >= rampSize) {			rampIndex = rampSize - 1;		}		/* begin fillColorSpan:from:to: */		pixelValue321 = ramp[rampIndex];		if (workBuffer[48] === 1) {			x02 = x;			x12 = x1;			while ((x02 + 4) < x12) {				spanBuffer[x02] = pixelValue321;				spanBuffer[x02 + 1] = pixelValue321;				spanBuffer[x02 + 2] = pixelValue321;				spanBuffer[x02 + 3] = pixelValue321;				x02 += 4;			}			while (x02 < x12) {				spanBuffer[x02] = pixelValue321;				++x02;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue321, x, x1);		}		/* end fillColorSpan:from:to: */	}}, /*	This is the AA version of linear gradient filling. */fillLinearGradientAArampdsdsXfromto(fill, ramp, deltaS, dsX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let firstPixel;	let idx;	let lastPixel;	let rampIndex;	let rampSize;	let rampValue;	let x;	let firstPixel1;	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	rampSize = objBuffer[fill + 10];	ds = deltaS;	x = leftX;	rampIndex = ds >> 16;	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n sub-pixels */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	colorMask = workBuffer[51];	colorShift = workBuffer[50];	while ((x < firstPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < firstPixel) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] += rampValue;			++x;			ds += dsX;		}		rampIndex = ds >> 16;	}	colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);	colorShift = workBuffer[49];	while ((x < lastPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < lastPixel) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] += rampValue;			x += aaLevel;			ds += SHL(dsX, colorShift);		}		rampIndex = ds >> 16;	}	colorMask = workBuffer[51];	colorShift = workBuffer[50];	while ((x < rightX) && ((rampIndex < rampSize) && (rampIndex >= 0))) {		rampValue = ramp[rampIndex];		/* Copy as many pixels as possible */		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < rightX) && ((ds >> 16) === rampIndex)) {			idx = SHR(x, baseShift);			spanBuffer[idx] += rampValue;			++x;			ds += dsX;		}		rampIndex = ds >> 16;	}	return x;}, /*	Part 2a) Compute the decreasing part of the ramp */fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let dt;	let firstPixel;	let index;	let lastPixel;	let length2;	let nextLength;	let rampIndex;	let rampValue;	let x;	let x1;	let deltaX;	let deltaY;	let deltaX1;	let deltaY1;	let deltaX2;	let deltaY2;	let deltaX3;	let deltaY3;	let deltaX4;	let deltaY4;	let deltaX5;	let deltaY5;	let deltaX6;	let deltaY6;	let length21;	let firstPixel1;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	/* begin accurateLengthOf:with: */	deltaX6 = ds >> 16;	deltaY6 = dt >> 16;	if (deltaX6 === 0) {		rampIndex = (deltaY6 < 0) ? (0 - deltaY6) : deltaY6;	} else {		if (deltaY6 === 0) {			rampIndex = (deltaX6 < 0) ? (0 - deltaX6) : deltaX6;		} else {			length21 = (deltaX6 * deltaX6) + (deltaY6 * deltaY6);			rampIndex = (length21 < 32) ? B2DPlugin.smallSqrtTable()[length21] : ((Math.sqrt(length21) + 0.5) | 0);		}	}	/* end accurateLengthOf:with: */	length2 = (rampIndex - 1) * (rampIndex - 1);	x = leftX;	x1 = objBuffer[fill + 4];	if (x1 > rightX) {		x1 = rightX;	}	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > x1) ? x1 : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n sub-pixels */	lastPixel = UBAND((x1 - 1), (~((workBuffer[48] - 1)) >>> 0));	if (x < firstPixel) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < firstPixel) {			/* Try to copy the current value more than just once */			while (true) {				let ret1;				if (x < firstPixel) {					/* begin squaredLengthOf:with: */					deltaX = ds >> 16;					deltaY = dt >> 16;					ret1 = ((deltaX * deltaX) + (deltaY * deltaY)) >= length2;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX1 = ds >> 16;			deltaY1 = dt >> 16;			nextLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	if (x < lastPixel) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		colorShift = workBuffer[49];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < lastPixel) {			/* Try to copy the current value more than just once */			while (true) {				let ret1;				if (x < lastPixel) {					/* begin squaredLengthOf:with: */					deltaX2 = ds >> 16;					deltaY2 = dt >> 16;					ret1 = ((deltaX2 * deltaX2) + (deltaY2 * deltaY2)) >= length2;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				x += aaLevel;				ds += SHL(dsX, colorShift);				dt += SHL(dtX, colorShift);			}			/* begin squaredLengthOf:with: */			deltaX3 = ds >> 16;			deltaY3 = dt >> 16;			nextLength = (deltaX3 * deltaX3) + (deltaY3 * deltaY3);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	if (x < x1) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while (x < x1) {			/* Try to copy the current value more than just once */			while (true) {				let ret1;				if (x < x1) {					/* begin squaredLengthOf:with: */					deltaX4 = ds >> 16;					deltaY4 = dt >> 16;					ret1 = ((deltaX4 * deltaX4) + (deltaY4 * deltaY4)) >= length2;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX5 = ds >> 16;			deltaY5 = dt >> 16;			nextLength = (deltaX5 * deltaX5) + (deltaY5 * deltaY5);			/* end squaredLengthOf:with: */			while (nextLength < length2) {				--rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				length2 = (rampIndex - 1) * (rampIndex - 1);			}		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Draw a radial gradient fill. */fillRadialGradientfromtoat(fill, leftX, rightX, yValue) {	let deltaST;	let deltaX;	let deltaY;	let ds;	let dsX;	let dt;	let dtX;	let length2;	let ramp;	let rampSize;	let x;	let x1;	let pixelValue32;	let x0;	let x11;	let ds1;	let dt1;	let length22;	let nextLength;	let rampIndex;	let rampValue;	let x2;	let x12;	let deltaX3;	let deltaY3;	let deltaX1;	let deltaY1;	let deltaX2;	let deltaY2;	let length21;	let pixelValue321;	let x01;	let x13;	let ds2;	let dt2;	let lastLength;	let length23;	let nextLength1;	let rampIndex1;	let rampSize1;	let rampValue1;	let x3;	let x14;	let deltaX4;	let deltaY4;	let deltaX11;	let deltaY11;	let deltaX21;	let deltaY21;	let length211;	let deltaX31;	let deltaY31;	ramp = PTR_ADD(objBuffer, fill + 12);	rampSize = objBuffer[fill + 10];	deltaX = leftX - objBuffer[fill + 4];	deltaY = yValue - objBuffer[fill + 5];	dsX = objBuffer[fill + 6];	dtX = objBuffer[fill + 8];	ds = (deltaX * dsX) + (deltaY * objBuffer[fill + 7]);	dt = (deltaX * dtX) + (deltaY * objBuffer[fill + 9]);	x = leftX;	/* Note: The inner loop has been divided into three parts for speed */	/* Part one: Fill everything outside the left boundary */	x1 = rightX;	/* This is the upper bound */	length2 = (rampSize - 1) * (rampSize - 1);	while ((B2DPlugin.squaredLengthOfwith(ds >> 16, dt >> 16) >= length2) && (x < x1)) {		++x;		ds += dsX;		dt += dtX;	}	if (x > leftX) {		/* begin fillColorSpan:from:to: */		pixelValue32 = ramp[rampSize - 1];		if (workBuffer[48] === 1) {			x0 = leftX;			x11 = x;			while ((x0 + 4) < x11) {				spanBuffer[x0] = pixelValue32;				spanBuffer[x0 + 1] = pixelValue32;				spanBuffer[x0 + 2] = pixelValue32;				spanBuffer[x0 + 3] = pixelValue32;				x0 += 4;			}			while (x0 < x11) {				spanBuffer[x0] = pixelValue32;				++x0;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue32, leftX, x);		}		/* end fillColorSpan:from:to: */	}	deltaST = PTR_ADD(workBuffer, 80);	deltaST[0] = ds;	deltaST[1] = dt;	if (x < objBuffer[fill + 4]) {		/* Draw the decreasing part */		if (workBuffer[48] === 1) {			/* begin fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: */			ds1 = (deltaST[0]|0);			dt1 = (deltaST[1]|0);			/* begin accurateLengthOf:with: */			deltaX2 = ds1 >> 16;			deltaY2 = dt1 >> 16;			if (deltaX2 === 0) {				rampIndex = (deltaY2 < 0) ? (0 - deltaY2) : deltaY2;			} else {				if (deltaY2 === 0) {					rampIndex = (deltaX2 < 0) ? (0 - deltaX2) : deltaX2;				} else {					length21 = (deltaX2 * deltaX2) + (deltaY2 * deltaY2);					rampIndex = (length21 < 32) ? B2DPlugin.smallSqrtTable()[length21] : ((Math.sqrt(length21) + 0.5) | 0);				}			}			/* end accurateLengthOf:with: */			rampValue = ramp[rampIndex];			length22 = (rampIndex - 1) * (rampIndex - 1);			x2 = x;			x12 = x1;			if (x12 > objBuffer[fill + 4]) {				x12 = objBuffer[fill + 4];			}			while (x2 < x12) {				while (true) {					let ret1;					if (x2 < x12) {						/* begin squaredLengthOf:with: */						deltaX3 = ds1 >> 16;						deltaY3 = dt1 >> 16;						ret1 = ((deltaX3 * deltaX3) + (deltaY3 * deltaY3)) >= length22;						/* end squaredLengthOf:with: */					} else {						ret1 = false;					};					if (!(ret1)) break;					spanBuffer[x2] = rampValue;					++x2;					ds1 += dsX;					dt1 += dtX;				}				/* begin squaredLengthOf:with: */				deltaX1 = ds1 >> 16;				deltaY1 = dt1 >> 16;				nextLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);				/* end squaredLengthOf:with: */				while (nextLength < length22) {					--rampIndex;					rampValue = ramp[rampIndex];					length22 = (rampIndex - 1) * (rampIndex - 1);				}			}			deltaST[0] = ds1;			deltaST[1] = dt1;			x = x2;			/* end fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: */		} else {			x = B2DPlugin.fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);		}	}	if (x < x1) {		/* Draw the increasing part */		if (workBuffer[48] === 1) {			/* begin fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: */			ds2 = (deltaST[0]|0);			dt2 = (deltaST[1]|0);			/* begin accurateLengthOf:with: */			deltaX21 = ds2 >> 16;			deltaY21 = dt2 >> 16;			if (deltaX21 === 0) {				rampIndex1 = (deltaY21 < 0) ? (0 - deltaY21) : deltaY21;			} else {				if (deltaY21 === 0) {					rampIndex1 = (deltaX21 < 0) ? (0 - deltaX21) : deltaX21;				} else {					length211 = (deltaX21 * deltaX21) + (deltaY21 * deltaY21);					rampIndex1 = (length211 < 32) ? B2DPlugin.smallSqrtTable()[length211] : ((Math.sqrt(length211) + 0.5) | 0);				}			}			/* end accurateLengthOf:with: */			rampValue1 = ramp[rampIndex1];			rampSize1 = objBuffer[fill + 10];			length23 = (rampSize1 - 1) * (rampSize1 - 1);			nextLength1 = (rampIndex1 + 1) * (rampIndex1 + 1);			/* begin squaredLengthOf:with: */			deltaX31 = ds2 >> 16;			deltaY31 = dt2 >> 16;			lastLength = (deltaX31 * deltaX31) + (deltaY31 * deltaY31);			/* end squaredLengthOf:with: */			x3 = x;			x14 = x1;			while ((x3 < x14) && (lastLength < length23)) {				while (true) {					let ret1;					if (x3 < x14) {						/* begin squaredLengthOf:with: */						deltaX4 = ds2 >> 16;						deltaY4 = dt2 >> 16;						ret1 = ((deltaX4 * deltaX4) + (deltaY4 * deltaY4)) <= nextLength1;						/* end squaredLengthOf:with: */					} else {						ret1 = false;					};					if (!(ret1)) break;					spanBuffer[x3] = rampValue1;					++x3;					ds2 += dsX;					dt2 += dtX;				}				/* begin squaredLengthOf:with: */				deltaX11 = ds2 >> 16;				deltaY11 = dt2 >> 16;				lastLength = (deltaX11 * deltaX11) + (deltaY11 * deltaY11);				/* end squaredLengthOf:with: */				while (lastLength > nextLength1) {					++rampIndex1;					rampValue1 = ramp[rampIndex1];					nextLength1 = (rampIndex1 + 1) * (rampIndex1 + 1);				}			}			deltaST[0] = ds2;			deltaST[1] = dt2;			x = x3;			/* end fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: */		} else {			x = B2DPlugin.fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);		}	}	if (x < rightX) {		/* begin fillColorSpan:from:to: */		pixelValue321 = ramp[rampSize - 1];		if (workBuffer[48] === 1) {			x01 = x;			x13 = rightX;			while ((x01 + 4) < x13) {				spanBuffer[x01] = pixelValue321;				spanBuffer[x01 + 1] = pixelValue321;				spanBuffer[x01 + 2] = pixelValue321;				spanBuffer[x01 + 3] = pixelValue321;				x01 += 4;			}			while (x01 < x13) {				spanBuffer[x01] = pixelValue321;				++x01;			}		} else {			B2DPlugin.fillColorSpanAAx0x1(pixelValue321, x, rightX);		}		/* end fillColorSpan:from:to: */	}}, /*	Part 2b) Compute the increasing part of the ramp */fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, leftX, rightX) {	let aaLevel;	let baseShift;	let colorMask;	let colorShift;	let ds;	let dt;	let firstPixel;	let index;	let lastLength;	let lastPixel;	let length2;	let nextLength;	let rampIndex;	let rampSize;	let rampValue;	let x;	let deltaX;	let deltaY;	let deltaX1;	let deltaY1;	let deltaX2;	let deltaY2;	let deltaX3;	let deltaY3;	let deltaX4;	let deltaY4;	let deltaX5;	let deltaY5;	let deltaX6;	let deltaY6;	let length21;	let deltaX7;	let deltaY7;	let firstPixel1;	ds = (deltaST[0]|0);	dt = (deltaST[1]|0);	aaLevel = workBuffer[48];	baseShift = workBuffer[49];	/* begin accurateLengthOf:with: */	deltaX6 = ds >> 16;	deltaY6 = dt >> 16;	if (deltaX6 === 0) {		rampIndex = (deltaY6 < 0) ? (0 - deltaY6) : deltaY6;	} else {		if (deltaY6 === 0) {			rampIndex = (deltaX6 < 0) ? (0 - deltaX6) : deltaX6;		} else {			length21 = (deltaX6 * deltaX6) + (deltaY6 * deltaY6);			rampIndex = (length21 < 32) ? B2DPlugin.smallSqrtTable()[length21] : ((Math.sqrt(length21) + 0.5) | 0);		}	}	/* end accurateLengthOf:with: */	rampSize = objBuffer[fill + 10];	/* This is the upper bound */	length2 = (rampSize - 1) * (rampSize - 1);	nextLength = (rampIndex + 1) * (rampIndex + 1);	/* begin squaredLengthOf:with: */	deltaX7 = ds >> 16;	deltaY7 = dt >> 16;	lastLength = (deltaX7 * deltaX7) + (deltaY7 * deltaY7);	/* end squaredLengthOf:with: */	x = leftX;	/* begin aaFirstPixelFrom:to: */	firstPixel1 = UBAND(((leftX + workBuffer[48]) - 1), (~((workBuffer[48] - 1)) >>> 0));	firstPixel = (firstPixel1 > rightX) ? rightX : firstPixel1;	/* end aaFirstPixelFrom:to: */	/* Deal with the first n subPixels */	lastPixel = UBAND((rightX - 1), (~((workBuffer[48] - 1)) >>> 0));	if ((x < firstPixel) && (lastLength < length2)) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < firstPixel) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while (true) {				let ret1;				if (x < firstPixel) {					/* begin squaredLengthOf:with: */					deltaX = ds >> 16;					deltaY = dt >> 16;					ret1 = ((deltaX * deltaX) + (deltaY * deltaY)) <= nextLength;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX1 = ds >> 16;			deltaY1 = dt >> 16;			lastLength = (deltaX1 * deltaX1) + (deltaY1 * deltaY1);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	if ((x < lastPixel) && (lastLength < length2)) {		colorMask = UBORM((SHR(workBuffer[51], workBuffer[49])), 1894838512);		colorShift = workBuffer[49];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < lastPixel) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while (true) {				let ret1;				if (x < lastPixel) {					/* begin squaredLengthOf:with: */					deltaX2 = ds >> 16;					deltaY2 = dt >> 16;					ret1 = ((deltaX2 * deltaX2) + (deltaY2 * deltaY2)) <= nextLength;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				x += aaLevel;				ds += SHL(dsX, colorShift);				dt += SHL(dtX, colorShift);			}			/* begin squaredLengthOf:with: */			deltaX3 = ds >> 16;			deltaY3 = dt >> 16;			lastLength = (deltaX3 * deltaX3) + (deltaY3 * deltaY3);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	if ((x < rightX) && (lastLength < length2)) {		colorMask = workBuffer[51];		colorShift = workBuffer[50];		rampValue = ramp[rampIndex];		rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);		while ((x < rightX) && (lastLength < length2)) {			/* Try to copy the current value more than once */			while (true) {				let ret1;				if (x < rightX) {					/* begin squaredLengthOf:with: */					deltaX4 = ds >> 16;					deltaY4 = dt >> 16;					ret1 = ((deltaX4 * deltaX4) + (deltaY4 * deltaY4)) <= nextLength;					/* end squaredLengthOf:with: */				} else {					ret1 = false;				};				if (!(ret1)) break;				index = SHR(x, baseShift);				spanBuffer[index] += rampValue;				++x;				ds += dsX;				dt += dtX;			}			/* begin squaredLengthOf:with: */			deltaX5 = ds >> 16;			deltaY5 = dt >> 16;			lastLength = (deltaX5 * deltaX5) + (deltaY5 * deltaY5);			/* end squaredLengthOf:with: */			while (lastLength > nextLength) {				++rampIndex;				rampValue = ramp[rampIndex];				rampValue = SHR((UBAND(rampValue, colorMask)), colorShift);				nextLength = (rampIndex + 1) * (rampIndex + 1);			}		}	}	deltaST[0] = ds;	deltaST[1] = dt;	return x;}, /*	Return true if fillEntry1 should be drawn before fillEntry2 */fillSortsbefore(fillEntry1, fillEntry2) {	let diff;	/* First check the depth value */	diff = workBuffer[fillEntry1 + workBuffer[10] + 1] - workBuffer[fillEntry2 + workBuffer[10] + 1];	if (diff === 0) {		return (workBuffer[workBuffer[10] + fillEntry1]>>>0) < (workBuffer[workBuffer[10] + fillEntry2]>>>0);	} else {		return diff > 0;	}}, /*	Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code. */fillSpanfromto(fill, leftX, rightX) {	let type;	let x0;	let x1;	let x01;	let x11;	if (fill !== 0) {		x0 = (leftX < workBuffer[35]) ? workBuffer[35] : leftX;		x1 = (rightX > (SHL(workBuffer[33], workBuffer[49]))) ? (SHL(workBuffer[33], workBuffer[49])) : rightX;		if (x0 < workBuffer[36]) {			x0 = workBuffer[36];		}		if (x1 > workBuffer[37]) {			x1 = workBuffer[37];		}		if (x0 < workBuffer[32]) {			workBuffer[32] = x0;		}		if (x1 > workBuffer[34]) {			workBuffer[34] = x1;		}		if (x1 > workBuffer[35]) {			workBuffer[35] = x1;		}		if (x0 < x1) {			if ((UBANDM(fill, 2130706432)) !== 0) {				/* begin fillColorSpan:from:to: */				if (workBuffer[48] === 1) {					x01 = x0;					x11 = x1;					while ((x01 + 4) < x11) {						spanBuffer[x01] = fill;						spanBuffer[x01 + 1] = fill;						spanBuffer[x01 + 2] = fill;						spanBuffer[x01 + 3] = fill;						x01 += 4;					}					while (x01 < x11) {						spanBuffer[x01] = fill;						++x01;					}				} else {					B2DPlugin.fillColorSpanAAx0x1(fill, x0, x1);				}				/* end fillColorSpan:from:to: */			} else {				/* Store the values for the dispatch */				workBuffer[66] = fill;				workBuffer[67] = x0;				workBuffer[68] = x1;				type = (UBANDS((UBANDS(objBuffer[fill], 65535)), 65280)) >>> 8;				if (type <= 1) {					return true;				}				switch (type) {				case 0:				case 1:					/* begin errorWrongIndex */					/* end errorWrongIndex */					break;				case 2:					B2DPlugin.fillLinearGradientfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);					break;				case 3:					B2DPlugin.fillRadialGradientfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);					break;				case 4:				case 5:					B2DPlugin.fillBitmapSpanfromtoat(workBuffer[66], workBuffer[67], workBuffer[68], workBuffer[88]);					break;				}			}		}	}	return false;}, /*	Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false. *//*	self currentYGet >= 680 ifTrue:[self printAET.self halt.]. */findNextExternalFillFromAET() {	let leftEdge;	let leftX;	let rightEdge;	let rightX;	let fill;	let startX;	let stopX;	let returnValueFromLoop_fillAllFromto_3827;	let brokenFromLoop_fillAllFromto_3827;	let rightX1;	let fill1;	let startX1;	let stopX1;	let returnValueFromLoop_fillAllFromto_3210;	let brokenFromLoop_fillAllFromto_3210;	leftX = rightX = workBuffer[37];	while (workBuffer[13] < workBuffer[14]) {		/* TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill. */		rightEdge = leftEdge = aetBuffer[workBuffer[13]];		leftX = rightX = objBuffer[leftEdge + 4];		if (leftX >= workBuffer[37]) {			return false;		}		/* begin quickRemoveInvalidFillsAt: */		if (workBuffer[1] !== workBuffer[10]) {			while (((workBuffer[1] === workBuffer[10]	? 999999999	: workBuffer[workBuffer[1] - 1])) <= leftX) {				B2DPlugin.hideFilldepth((workBuffer[1] === workBuffer[10]					? 0					: workBuffer[workBuffer[1] - 3]), (workBuffer[1] === workBuffer[10]					? -1					: workBuffer[workBuffer[1] - 2]));				if (workBuffer[1] === workBuffer[10]) {					break;				}			}		}		/* end quickRemoveInvalidFillsAt: */		if ((UBANDS((UBANDS(objBuffer[leftEdge], 65535)), 1)) !== 0) {			B2DPlugin.toggleWideFillOf(leftEdge);		}		if ((UBANDS(objBuffer[leftEdge], 65536)) === 0) {			B2DPlugin.toggleFillsOf(leftEdge);			if (engineStopped) {				return false;			}		}		workBuffer[13]++;		if (workBuffer[13] < workBuffer[14]) {			rightEdge = aetBuffer[workBuffer[13]];			rightX = objBuffer[rightEdge + 4];			if (rightX >= workBuffer[36]) {				/* This is the visible portion */				/* begin fillAllFrom:to: */				fill = (workBuffer[1] === workBuffer[10]) ? 0 : workBuffer[workBuffer[1] - 3];				startX = leftX;				stopX = (workBuffer[1] === workBuffer[10]) ? 999999999 : workBuffer[workBuffer[1] - 1];				brokenFromLoop_fillAllFromto_3827 = false;				while (stopX < rightX) {					fill = ((workBuffer[1] === workBuffer[10]	? 0	: workBuffer[workBuffer[1] - 3]));					if (fill !== 0) {						if (B2DPlugin.fillSpanfromto(fill, startX, stopX)) {							returnValueFromLoop_fillAllFromto_3827 = true;							brokenFromLoop_fillAllFromto_3827 = true;							break;						}					}					/* begin quickRemoveInvalidFillsAt: */					if (workBuffer[1] !== workBuffer[10]) {						while (((workBuffer[1] === workBuffer[10]	? 999999999	: workBuffer[workBuffer[1] - 1])) <= stopX) {							B2DPlugin.hideFilldepth((workBuffer[1] === workBuffer[10]								? 0								: workBuffer[workBuffer[1] - 3]), (workBuffer[1] === workBuffer[10]								? -1								: workBuffer[workBuffer[1] - 2]));							if (workBuffer[1] === workBuffer[10]) {								break;							}						}					}					/* end quickRemoveInvalidFillsAt: */					startX = stopX;					stopX = (workBuffer[1] === workBuffer[10]) ? 999999999 : workBuffer[workBuffer[1] - 1];				}				if (!brokenFromLoop_fillAllFromto_3827) {					fill = ((workBuffer[1] === workBuffer[10]	? 0	: workBuffer[workBuffer[1] - 3]));					if (fill !== 0) {						B2DPlugin.fillSpanfromto(fill, startX, rightX);					}				}				/* end fillAllFrom:to: */			}		}	}	if (rightX < workBuffer[37]) {		/* begin fillAllFrom:to: */		rightX1 = workBuffer[37];		fill1 = (workBuffer[1] === workBuffer[10]) ? 0 : workBuffer[workBuffer[1] - 3];		startX1 = rightX;		stopX1 = (workBuffer[1] === workBuffer[10]) ? 999999999 : workBuffer[workBuffer[1] - 1];		brokenFromLoop_fillAllFromto_3210 = false;		while (stopX1 < rightX1) {			fill1 = ((workBuffer[1] === workBuffer[10]	? 0	: workBuffer[workBuffer[1] - 3]));			if (fill1 !== 0) {				if (B2DPlugin.fillSpanfromto(fill1, startX1, stopX1)) {					returnValueFromLoop_fillAllFromto_3210 = true;					brokenFromLoop_fillAllFromto_3210 = true;					break;				}			}			/* begin quickRemoveInvalidFillsAt: */			if (workBuffer[1] !== workBuffer[10]) {				while (((workBuffer[1] === workBuffer[10]	? 999999999	: workBuffer[workBuffer[1] - 1])) <= stopX1) {					B2DPlugin.hideFilldepth((workBuffer[1] === workBuffer[10]						? 0						: workBuffer[workBuffer[1] - 3]), (workBuffer[1] === workBuffer[10]						? -1						: workBuffer[workBuffer[1] - 2]));					if (workBuffer[1] === workBuffer[10]) {						break;					}				}			}			/* end quickRemoveInvalidFillsAt: */			startX1 = stopX1;			stopX1 = (workBuffer[1] === workBuffer[10]) ? 999999999 : workBuffer[workBuffer[1] - 1];		}		if (!brokenFromLoop_fillAllFromto_3210) {			fill1 = ((workBuffer[1] === workBuffer[10]	? 0	: workBuffer[workBuffer[1] - 3]));			if (fill1 !== 0) {				B2DPlugin.fillSpanfromto(fill1, startX1, rightX1);			}		}		/* end fillAllFrom:to: */	}	return false;}, /*	Check the active edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, step the the edge to the next y value. */findNextExternalUpdateFromAET() {	let count;	let edge;	let type;	let line;	let err;	let x;	let bezier;	let xValue;	let updateData;	let fwDx;	let fwDy;	let lastX;	let lastY;	let minY;	let line1;	let lastX1;	let lineOffset;	let lineWidth;	let nextX;	let yEntry;	let yExit;	let err1;	let x1;	while (workBuffer[13] < workBuffer[14]) {		edge = aetBuffer[workBuffer[13]];		count = objBuffer[edge + 7] - 1;		if (count === 0) {			/* Edge at end -- remove it */			B2DPlugin.removeFirstAETEntry.apply(this, arguments);		} else {			/* Store remaining lines back */			objBuffer[edge + 7] = count;			type = UBANDS(objBuffer[edge], 65535);			if ((UBANDS(type, 254)) === 2) {				return true;			}			switch (type) {			case 0:			case 1:			case 2:			case 3:				/* begin errorWrongIndex */				/* end errorWrongIndex */				break;			case 4:				/* begin stepToNextLineIn:at: */				line = aetBuffer[workBuffer[13]];				x = objBuffer[line + 4] + objBuffer[line + 12];				err = objBuffer[line + 13] + objBuffer[line + 14];				if (err > 0) {					x += objBuffer[line + 10];					err -= objBuffer[line + 15];				}				objBuffer[line + 13] = err;				objBuffer[line + 4] = x;				/* end stepToNextLineIn:at: */				break;			case 5:				/* begin stepToNextWideLineIn:at: */				line1 = aetBuffer[workBuffer[13]];				yEntry = objBuffer[line1 + 18] + 1;				yExit = objBuffer[line1 + 19] + 1;				objBuffer[line1 + 18] = yEntry;				objBuffer[line1 + 19] = yExit;				lineWidth = objBuffer[line1 + 20];				lineOffset = lineWidth >> 1;				if (yEntry >= lineOffset) {					objBuffer[line1] = (UBANDM((UBANDS(objBuffer[line1], 65535)), 2147418111));				}				if (yExit >= 0) {					objBuffer[line1] = (UBORS((UBANDS(objBuffer[line1], 65535)), 65536));				}				lastX1 = objBuffer[line1 + 4];				/* begin stepToNextLineIn:at: */				x1 = objBuffer[line1 + 4] + objBuffer[line1 + 12];				err1 = objBuffer[line1 + 13] + objBuffer[line1 + 14];				if (err1 > 0) {					x1 += objBuffer[line1 + 10];					err1 -= objBuffer[line1 + 15];				}				objBuffer[line1 + 13] = err1;				objBuffer[line1 + 4] = x1;				/* end stepToNextLineIn:at: */				nextX = objBuffer[line1 + 4];				if ((yEntry <= lineWidth) || ((yExit + lineOffset) >= 0)) {					B2DPlugin.adjustWideLineafterSteppingFromto(line1, lastX1, nextX);				}				/* end stepToNextWideLineIn:at: */				break;			case 6:				/* begin stepToNextBezierIn:at: */				bezier = aetBuffer[workBuffer[13]];				/* begin stepToNextBezierForward:at: */				updateData = PTR_ADD(objBuffer, bezier + 10);				lastX = updateData[0];				lastY = updateData[1];				fwDx = updateData[2];				fwDy = updateData[3];				minY = workBuffer[88] * 256;				while ((minY > lastY) && (fwDy >= 0)) {					lastX += (fwDx + 32768) >> 16;					lastY += (fwDy + 32768) >> 16;					fwDx += updateData[4];					fwDy += updateData[5];				}				updateData[0] = lastX;				updateData[1] = lastY;				updateData[2] = fwDx;				updateData[3] = fwDy;				xValue = lastX >> 8;				/* end stepToNextBezierForward:at: */				objBuffer[bezier + 4] = xValue;				/* end stepToNextBezierIn:at: */				break;			case 7:				/* begin stepToNextWideBezier */				B2DPlugin.stepToNextWideBezierInat(aetBuffer[workBuffer[13]], workBuffer[88]);				/* end stepToNextWideBezier */				break;			}			B2DPlugin.resortFirstAETEntry.apply(this, arguments);			workBuffer[13]++;		}	}	return false;}, /*	Return true if the edge at index i should sort before the edge at index j. */getSortsbefore(edge1, edge2) {	let diff;	if (edge1 === edge2) {		return true;	}	diff = objBuffer[edge1 + 5] - objBuffer[edge2 + 5];	if (diff !== 0) {		return diff < 0;	}	diff = objBuffer[edge1 + 4] - objBuffer[edge2 + 4];	return diff < 0;}, /*	Make the fill style with the given index invisible */hideFilldepth(fillIndex, depth) {	let index;	let newDepth;	let newRightX;	let newTop;	let newTopIndex;	let index1;	/* begin findStackFill:depth: */	index1 = 0;	while ((index1 < (workBuffer[1] - workBuffer[10])) && ((workBuffer[workBuffer[10] + index1] !== fillIndex) || (workBuffer[index1 + workBuffer[10] + 1] !== depth))) {		index1 += 3;	}	index = (index1 >= (workBuffer[1] - workBuffer[10])) ? -1 : index1;	/* end findStackFill:depth: */	if (index === -1) {		return false;	}	if (index === 0) {		/* begin freeStackFillEntry */		/* begin wbStackPop: */		workBuffer[10] += 3;		/* end wbStackPop: */		/* end freeStackFillEntry */		return true;	}	workBuffer[workBuffer[10] + index] = workBuffer[workBuffer[10]];	workBuffer[index + workBuffer[10] + 1] = workBuffer[workBuffer[10] + 1];	workBuffer[index + workBuffer[10] + 2] = workBuffer[workBuffer[10] + 2];	/* begin freeStackFillEntry */	/* begin wbStackPop: */	workBuffer[10] += 3;	/* end wbStackPop: */	/* end freeStackFillEntry */	if ((workBuffer[1] - workBuffer[10]) <= 3) {		return true;	}	newTopIndex = 0;	index = 3;	while (index < (workBuffer[1] - workBuffer[10])) {		if (B2DPlugin.fillSortsbefore(index, newTopIndex)) {			newTopIndex = index;		}		index += 3;	}	if ((newTopIndex + 3) === (workBuffer[1] - workBuffer[10])) {		return true;	}	newTop = workBuffer[workBuffer[10] + newTopIndex];	workBuffer[workBuffer[10] + newTopIndex] = workBuffer[workBuffer[1] - 3];	workBuffer[workBuffer[1] - 3] = newTop;	newDepth = workBuffer[newTopIndex + workBuffer[10] + 1];	workBuffer[newTopIndex + workBuffer[10] + 1] = workBuffer[workBuffer[1] - 2];	workBuffer[workBuffer[1] - 2] = newDepth;	newRightX = workBuffer[newTopIndex + workBuffer[10] + 2];	workBuffer[newTopIndex + workBuffer[10] + 2] = workBuffer[workBuffer[1] - 1];	workBuffer[workBuffer[1] - 1] = newRightX;	return true;}, /*	Find insertion point for the given edge in the AET */indexForInsertingIntoAET(edge) {	let index;	let initialX;	initialX = objBuffer[edge + 4];	index = 0;	while ((index < workBuffer[14]) && (objBuffer[aetBuffer[index] + 4] < initialX)) {		++index;	}	while ((index < workBuffer[14]) && ((objBuffer[aetBuffer[index] + 4] === initialX) && (B2DPlugin.getSortsbefore(aetBuffer[index], edge)))) {		++index;	}	return index;}, initColorTransform() {	let transform;	transform = FPTR_ADD(workBuffer, 24);	transform[0] = 1.0;	transform[1] = 0.0;	transform[2] = 1.0;	transform[3] = 0.0;	transform[4] = 1.0;	transform[5] = 0.0;	transform[6] = 1.0;	transform[7] = 0.0;	workBuffer[17] = 0;}, initEdgeTransform() {	let transform;	transform = FPTR_ADD(workBuffer, 18);	transform[0] = 1.0;	transform[1] = 0.0;	transform[2] = 0.0;	transform[3] = 0.0;	transform[4] = 1.0;	transform[5] = 0.0;	workBuffer[16] = 0;}, initialiseModule() {	loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);	copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);	return (!!loadBBFn) && (!!copyBitsFn);}, /*	Initialization stuff that needs to be done before any processing can take place. *//*	Make sure aaLevel is initialized */initializeGETProcessing() {	B2DPlugin.setAALevel(workBuffer[48]);	if (workBuffer[42] < 0) {		workBuffer[42] = 0;	}	if (workBuffer[43] > workBuffer[33]) {		workBuffer[43] = workBuffer[33];	}	workBuffer[36] = (SHL(workBuffer[42], workBuffer[49]));	workBuffer[38] = (SHL(workBuffer[44], workBuffer[49]));	workBuffer[37] = (SHL(workBuffer[43], workBuffer[49]));	workBuffer[39] = (SHL(workBuffer[45], workBuffer[49]));	workBuffer[12] = 0;	workBuffer[14] = 0;	getBuffer = PTR_ADD(objBuffer, objUsed);	/* Create the global edge table */	aetBuffer = PTR_ADD(objBuffer, objUsed);	B2DPlugin.createGlobalEdgeTable.apply(this, arguments);	if (engineStopped) {		return null;	}	if (workBuffer[12] === 0) {		/* Nothing to do */		workBuffer[88] = workBuffer[39];		return 0;	}	/* begin sortGlobalEdgeTable */	B2DPlugin.quickSortGlobalEdgeTablefromto(getBuffer, 0, workBuffer[12] - 1);	/* end sortGlobalEdgeTable */	workBuffer[88] = objBuffer[getBuffer[0] + 5];	if (workBuffer[88] < workBuffer[38]) {		workBuffer[88] = workBuffer[38];	}	workBuffer[32] = 0;	workBuffer[34] = ((SHL(workBuffer[33], workBuffer[49])) - 1);	B2DPlugin.clearSpanBuffer.apply(this, arguments);}, /*	Insert the edge with the given index from the global edge table into the active edge table.	The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX	are both set. */insertEdgeIntoAET(edge) {	let index;	/* Check for the number of lines remaining */	if (objBuffer[edge + 7] <= 0) {		return null;	}	/* And insert edge */	index = B2DPlugin.indexForInsertingIntoAET(edge);	B2DPlugin.insertToAETbeforeIndex(edge, index);}, /*	Insert the given edge into the AET. */insertToAETbeforeIndex(edge, index) {	let i;	/* Make sure we have space in the AET */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 129) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return null;	}	/* end needAvailableSpace: */	i = workBuffer[14] - 1;	while (!(i < index)) {		aetBuffer[i + 1] = aetBuffer[i];		--i;	}	aetBuffer[index] = edge;	workBuffer[14]++;}, isFillOkay(fill) {	return (fill === 0) || (((UBANDM(fill, 2130706432)) !== 0) || (((fill >= 0) && (fill < objUsed)) && (((UBANDM(fill, 2130706432)) !== 0) || ((UBANDS((UBANDS(objBuffer[fill], 65535)), 65280)) !== 0))));}, /*	Load and subdivide the bezier curve from point1/point2/point3.	If wideFlag is set then make sure the curve is monoton in X. */loadAndSubdivideBezierFromviatoisWide(point1, point2, point3, wideFlag) {	let bz1;	let bz2;	let index;	let index1;	let index2;	/* begin allocateBezierStackEntry */	/* begin wbStackPush: */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 134) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */	} else {		workBuffer[10] -= 6;	}	/* end needAvailableSpace: */	/* end wbStackPush: */	bz1 = workBuffer[1] - workBuffer[10];	/* end allocateBezierStackEntry */	if (engineStopped) {		return 0;	}	workBuffer[workBuffer[1] - bz1] = point1[0];	workBuffer[workBuffer[1] + 1 - bz1] = point1[1];	workBuffer[workBuffer[1] + 2 - bz1] = point2[0];	workBuffer[workBuffer[1] + 3 - bz1] = point2[1];	workBuffer[workBuffer[1] + 4 - bz1] = point3[0];	workBuffer[workBuffer[1] + 5 - bz1] = point3[1];	bz2 = index2 = B2DPlugin.subdivideToBeMonotoninX(bz1, wideFlag);	for (index = bz1; index <= bz2; index += 6) {		index1 = B2DPlugin.subdivideBezierFrom(index);		if (index1 > index2) {			index2 = index1;		}		if (engineStopped) {			return 0;		}	}	return Math.trunc(index2 / 6);}, loadArrayShapenSegmentsfilllineWidthlineFill(points, nSegments, fillIndex, lineWidth, lineFill) {	let i;	let pointOop;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform1;	let x11;	let y11;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x21;	let y21;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	for (i = 0; i < nSegments; i++) {		pointOop = points.pointers[(i * 3)];		B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), pointOop);		pointOop = points.pointers[((i * 3) + 1)];		B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), pointOop);		pointOop = points.pointers[((i * 3) + 2)];		B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 84), pointOop);		/* begin transformPoints: */			/* begin transformPoint: */	point = PTR_ADD(workBuffer, 80);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue = (point[0]|0);		yValue = (point[1]|0);		dstPoint1 = point;		transform = FPTR_ADD(workBuffer, 18);		x = (((((transform[0] * xValue) + (transform[1] * yValue)) + transform[2]) * workBuffer[48]) | 0);		y = (((((transform[3] * xValue) + (transform[4] * yValue)) + transform[5]) * workBuffer[48]) | 0);		dstPoint1[0] = x;		dstPoint1[1] = y;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);		point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */			/* begin transformPoint: */	point1 = PTR_ADD(workBuffer, 82);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue1 = (point1[0]|0);		yValue1 = (point1[1]|0);		dstPoint11 = point1;		transform1 = FPTR_ADD(workBuffer, 18);		x11 = (((((transform1[0] * xValue1) + (transform1[1] * yValue1)) + transform1[2]) * workBuffer[48]) | 0);		y11 = (((((transform1[3] * xValue1) + (transform1[4] * yValue1)) + transform1[5]) * workBuffer[48]) | 0);		dstPoint11[0] = x11;		dstPoint11[1] = y11;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);		point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */			/* begin transformPoint: */	point2 = PTR_ADD(workBuffer, 84);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue2 = (point2[0]|0);		yValue2 = (point2[1]|0);		dstPoint12 = point2;		transform2 = FPTR_ADD(workBuffer, 18);		x21 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);		y21 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);		dstPoint12[0] = x21;		dstPoint12[1] = y21;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);		point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */		/* end transformPoints: */		x0 = PTR_ADD(workBuffer, 80)[0];		y0 = PTR_ADD(workBuffer, 80)[1];		x1 = PTR_ADD(workBuffer, 82)[0];		y1 = PTR_ADD(workBuffer, 82)[1];		x2 = PTR_ADD(workBuffer, 84)[0];		/* Check if we can use a line */		y2 = PTR_ADD(workBuffer, 84)[1];		if (((x0 === y0) && (x1 === y1)) || ((x1 === x2) && (y1 === y2))) {			/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */			p1 = PTR_ADD(workBuffer, 80);			p2 = PTR_ADD(workBuffer, 84);			if ((lineWidth === 0) || (lineFill === 0)) {				/* begin allocateLine */				if (B2DPlugin.allocateObjEntry(16)) {					line1 = objUsed;					objUsed = line1 + 16;					objBuffer[line1] = 4;					objBuffer[line1 + 2] = 0;					objBuffer[line1 + 1] = 16;					line = line1;				} else {					line = 0;				}				/* end allocateLine */				offset = 0;			} else {				/* begin allocateWideLine */				if (B2DPlugin.allocateObjEntry(21)) {					line2 = objUsed;					objUsed = line2 + 21;					objBuffer[line2] = 5;					objBuffer[line2 + 2] = 0;					objBuffer[line2 + 1] = 21;					line = line2;				} else {					line = 0;				}				/* end allocateWideLine */				offset = lineWidth >> 1;			}			if (!engineStopped) {				/* begin loadLine:from:to:offset:leftFill:rightFill: */				if (p1[1] <= p2[1]) {					p11 = p1;					p21 = p2;					yDir = 1;				} else {					p11 = p2;					p21 = p1;					yDir = -1;				}				objBuffer[line + 4] = p11[0];				objBuffer[line + 5] = (p11[1] - offset);				objBuffer[line + 6] = workBuffer[113];				objBuffer[line + 8] = fillIndex;				objBuffer[line + 9] = 0;				objBuffer[line + 14] = p21[0];				objBuffer[line + 15] = (p21[1] - offset);				objBuffer[line + 11] = yDir;				/* end loadLine:from:to:offset:leftFill:rightFill: */				if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {					objBuffer[line + 16] = lineFill;					objBuffer[line + 17] = lineWidth;					objBuffer[line + 20] = lineWidth;				}			}			/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */		} else {			/* Need bezier */			segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide(PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), (lineWidth !== 0) && (lineFill !== 0));			if (engineStopped) {				return null;			}			B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);		}		if (engineStopped) {			return null;		}	}}, /*	Load a transformation from the given array. */loadArrayTransformFromintolength(transformOop, destPtr, n) {	let i;	let value;	for (i = 0; i < n; i++) {		value = transformOop.pointers[i];		if (!((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float)))) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		if ((typeof value === "number")) {			destPtr[i] = value;		} else {			destPtr[i] = ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal());		}	}}, /*	Initialize the bezier segment stored on the stack */loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFillIndex, rightFillIndex, yOffset) {	if (workBuffer[workBuffer[1] + 5 - index] >= workBuffer[workBuffer[1] + 1 - index]) {		/* Top to bottom */		objBuffer[bezier + 4] = workBuffer[workBuffer[1] - index];		objBuffer[bezier + 5] = (workBuffer[workBuffer[1] + 1 - index] - yOffset);		objBuffer[bezier + 12] = workBuffer[workBuffer[1] + 2 - index];		objBuffer[bezier + 13] = (workBuffer[workBuffer[1] + 3 - index] - yOffset);		objBuffer[bezier + 14] = workBuffer[workBuffer[1] + 4 - index];		objBuffer[bezier + 15] = (workBuffer[workBuffer[1] + 5 - index] - yOffset);	} else {		objBuffer[bezier + 4] = workBuffer[workBuffer[1] + 4 - index];		objBuffer[bezier + 5] = (workBuffer[workBuffer[1] + 5 - index] - yOffset);		objBuffer[bezier + 12] = workBuffer[workBuffer[1] + 2 - index];		objBuffer[bezier + 13] = (workBuffer[workBuffer[1] + 3 - index] - yOffset);		objBuffer[bezier + 14] = workBuffer[workBuffer[1] - index];		objBuffer[bezier + 15] = (workBuffer[workBuffer[1] + 1 - index] - yOffset);	}	objBuffer[bezier + 6] = workBuffer[113];	objBuffer[bezier + 8] = leftFillIndex;	objBuffer[bezier + 9] = rightFillIndex;}, /*	Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!	 */loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList, pointsShort) {	let i;	let leftLength;	let leftRun;	let leftValue;	let lineFillLength;	let lineFillRun;	let lineFillValue;	let rightLength;	let rightRun;	let rightValue;	let widthLength;	let widthRun;	let widthValue;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let index;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform5;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform12;	let x11;	let y11;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x21;	let y21;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	let point4;	let xValue4;	let yValue4;	let dstPoint14;	let transform4;	let x4;	let y4;	let point11;	let xValue11;	let yValue11;	let dstPoint111;	let transform11;	let x12;	let y12;	let point21;	let xValue21;	let yValue21;	let dstPoint121;	let transform21;	let x22;	let y22;	let point31;	let xValue31;	let yValue31;	let dstPoint131;	let transform31;	let x31;	let y31;	if (nSegments === 0) {		return 0;	}	widthRun = rightRun = lineFillRun = leftRun = -1;	lineFillLength = leftLength = widthLength = rightLength = 1;	rightValue = widthValue = lineFillValue = leftValue = 0;	for (i = 1; i <= nSegments; i++) {		/* Decrement current run length and load new stuff */		if (((--leftLength)) <= 0) {			++leftRun;			leftLength = (leftFills[leftRun]|0) >>> 16;			leftValue = UBANDS((leftFills[leftRun]|0), 65535);			if (leftValue !== 0) {				leftValue = fillIndexList[leftValue - 1];				/* begin transformColor: */				if ((leftValue === 0) || ((UBANDM(leftValue, 2130706432)) !== 0)) {					b = UBANDS(leftValue, 255);					g = UBANDS((leftValue >>> 8), 255);					r = UBANDS((leftValue >>> 16), 255);					a = UBANDS((leftValue >>> 24), 255);					if (workBuffer[17] !== 0) {						transform = FPTR_ADD(workBuffer, 24);						alphaScale = ((a * transform[6]) + transform[7]) / a;						r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);						g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);						b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);						a = a * alphaScale|0;						r = Math.max(r, 0);						r = Math.min(r, 255);						g = Math.max(g, 0);						g = Math.min(g, 255);						b = Math.max(b, 0);						b = Math.min(b, 255);						a = Math.max(a, 0);						a = Math.min(a, 255);					}					if (a < 1) {						leftValue = 0;					} else {						if ((a < 255) && (workBuffer[63] !== 0)) {							/* begin stopBecauseOf: */							workBuffer[64] = 3;							engineStopped = true;							/* end stopBecauseOf: */						}						leftValue = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {				}				/* end transformColor: */				if (engineStopped) {					return null;				}			}		}		if (((--rightLength)) <= 0) {			++rightRun;			rightLength = (rightFills[rightRun]|0) >>> 16;			rightValue = UBANDS((rightFills[rightRun]|0), 65535);			if (rightValue !== 0) {				rightValue = fillIndexList[rightValue - 1];				/* begin transformColor: */				if ((rightValue === 0) || ((UBANDM(rightValue, 2130706432)) !== 0)) {					b1 = UBANDS(rightValue, 255);					g1 = UBANDS((rightValue >>> 8), 255);					r1 = UBANDS((rightValue >>> 16), 255);					a1 = UBANDS((rightValue >>> 24), 255);					if (workBuffer[17] !== 0) {						transform1 = FPTR_ADD(workBuffer, 24);						alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;						r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);						g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);						b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);						a1 = a1 * alphaScale1|0;						r1 = Math.max(r1, 0);						r1 = Math.min(r1, 255);						g1 = Math.max(g1, 0);						g1 = Math.min(g1, 255);						b1 = Math.max(b1, 0);						b1 = Math.min(b1, 255);						a1 = Math.max(a1, 0);						a1 = Math.min(a1, 255);					}					if (a1 < 1) {						rightValue = 0;					} else {						if ((a1 < 255) && (workBuffer[63] !== 0)) {							/* begin stopBecauseOf: */							workBuffer[64] = 3;							engineStopped = true;							/* end stopBecauseOf: */						}						rightValue = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);					}				} else {				}				/* end transformColor: */			}		}		if (((--widthLength)) <= 0) {			++widthRun;			widthLength = (lineWidths[widthRun]|0) >>> 16;			widthValue = UBANDS((lineWidths[widthRun]|0), 65535);			if (widthValue !== 0) {				widthValue = B2DPlugin.transformWidth(widthValue);			}		}		if (((--lineFillLength)) <= 0) {			++lineFillRun;			lineFillLength = (lineFills[lineFillRun]|0) >>> 16;			lineFillValue = UBANDS((lineFills[lineFillRun]|0), 65535);			if (lineFillValue !== 0) {				lineFillValue = fillIndexList[lineFillValue - 1];			}		}		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (!((leftValue === rightValue) && ((widthValue === 0) || (lineFillValue === 0)))) {			index = (i - 1) * 6;			if (pointsShort) {				x0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index];				y0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 1];				x1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 2];				y1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 3];				x2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 4];				y2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 5];			} else {				x0 = (points[(index)]|0);				y0 = (points[(index + 1)]|0);				x1 = (points[(index + 2)]|0);				y1 = (points[(index + 3)]|0);				x2 = (points[(index + 4)]|0);				y2 = (points[(index + 5)]|0);			}			if (((x0 === x1) && (y0 === y1)) || ((x1 === x2) && (y1 === y2))) {				if (!((x0 === x2) && (y0 === y2))) {					PTR_ADD(workBuffer, 80)[0] = x0;					PTR_ADD(workBuffer, 80)[1] = y0;					PTR_ADD(workBuffer, 82)[0] = x2;					PTR_ADD(workBuffer, 82)[1] = y2;					/* begin transformPoints: */									/* begin transformPoint: */				point = PTR_ADD(workBuffer, 80);				if (workBuffer[16] !== 0) {					/* begin transformPoint:into: */					/* begin transformPointX:y:into: */					xValue = (point[0]|0);					yValue = (point[1]|0);					dstPoint1 = point;					transform5 = FPTR_ADD(workBuffer, 18);					x = (((((transform5[0] * xValue) + (transform5[1] * yValue)) + transform5[2]) * workBuffer[48]) | 0);					y = (((((transform5[3] * xValue) + (transform5[4] * yValue)) + transform5[5]) * workBuffer[48]) | 0);					dstPoint1[0] = x;					dstPoint1[1] = y;					/* end transformPointX:y:into: */					/* end transformPoint:into: */				} else {					point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);					point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);				}				/* end transformPoint: */									/* begin transformPoint: */				point1 = PTR_ADD(workBuffer, 82);				if (workBuffer[16] !== 0) {					/* begin transformPoint:into: */					/* begin transformPointX:y:into: */					xValue1 = (point1[0]|0);					yValue1 = (point1[1]|0);					dstPoint11 = point1;					transform12 = FPTR_ADD(workBuffer, 18);					x11 = (((((transform12[0] * xValue1) + (transform12[1] * yValue1)) + transform12[2]) * workBuffer[48]) | 0);					y11 = (((((transform12[3] * xValue1) + (transform12[4] * yValue1)) + transform12[5]) * workBuffer[48]) | 0);					dstPoint11[0] = x11;					dstPoint11[1] = y11;					/* end transformPointX:y:into: */					/* end transformPoint:into: */				} else {					point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);					point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);				}				/* end transformPoint: */					/* end transformPoints: */					/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */					p1 = PTR_ADD(workBuffer, 80);					p2 = PTR_ADD(workBuffer, 82);					if ((widthValue === 0) || (lineFillValue === 0)) {						/* begin allocateLine */						if (B2DPlugin.allocateObjEntry(16)) {							line1 = objUsed;							objUsed = line1 + 16;							objBuffer[line1] = 4;							objBuffer[line1 + 2] = 0;							objBuffer[line1 + 1] = 16;							line = line1;						} else {							line = 0;						}						/* end allocateLine */						offset = 0;					} else {						/* begin allocateWideLine */						if (B2DPlugin.allocateObjEntry(21)) {							line2 = objUsed;							objUsed = line2 + 21;							objBuffer[line2] = 5;							objBuffer[line2 + 2] = 0;							objBuffer[line2 + 1] = 21;							line = line2;						} else {							line = 0;						}						/* end allocateWideLine */						offset = widthValue >> 1;					}					if (!engineStopped) {						/* begin loadLine:from:to:offset:leftFill:rightFill: */						if (p1[1] <= p2[1]) {							p11 = p1;							p21 = p2;							yDir = 1;						} else {							p11 = p2;							p21 = p1;							yDir = -1;						}						objBuffer[line + 4] = p11[0];						objBuffer[line + 5] = (p11[1] - offset);						objBuffer[line + 6] = workBuffer[113];						objBuffer[line + 8] = leftValue;						objBuffer[line + 9] = rightValue;						objBuffer[line + 14] = p21[0];						objBuffer[line + 15] = (p21[1] - offset);						objBuffer[line + 11] = yDir;						/* end loadLine:from:to:offset:leftFill:rightFill: */						if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {							objBuffer[line + 16] = lineFillValue;							objBuffer[line + 17] = widthValue;							objBuffer[line + 20] = widthValue;						}					}					/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */				}			} else {				PTR_ADD(workBuffer, 80)[0] = x0;				PTR_ADD(workBuffer, 80)[1] = y0;				PTR_ADD(workBuffer, 82)[0] = x1;				PTR_ADD(workBuffer, 82)[1] = y1;				PTR_ADD(workBuffer, 84)[0] = x2;				PTR_ADD(workBuffer, 84)[1] = y2;				/* begin transformPoints: */							/* begin transformPoint: */			point4 = PTR_ADD(workBuffer, 80);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue4 = (point4[0]|0);				yValue4 = (point4[1]|0);				dstPoint14 = point4;				transform4 = FPTR_ADD(workBuffer, 18);				x4 = (((((transform4[0] * xValue4) + (transform4[1] * yValue4)) + transform4[2]) * workBuffer[48]) | 0);				y4 = (((((transform4[3] * xValue4) + (transform4[4] * yValue4)) + transform4[5]) * workBuffer[48]) | 0);				dstPoint14[0] = x4;				dstPoint14[1] = y4;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point4[0] = ((point4[0] + workBuffer[46]) * workBuffer[48]);				point4[1] = ((point4[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */							/* begin transformPoint: */			point11 = PTR_ADD(workBuffer, 82);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue11 = (point11[0]|0);				yValue11 = (point11[1]|0);				dstPoint111 = point11;				transform11 = FPTR_ADD(workBuffer, 18);				x12 = (((((transform11[0] * xValue11) + (transform11[1] * yValue11)) + transform11[2]) * workBuffer[48]) | 0);				y12 = (((((transform11[3] * xValue11) + (transform11[4] * yValue11)) + transform11[5]) * workBuffer[48]) | 0);				dstPoint111[0] = x12;				dstPoint111[1] = y12;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point11[0] = ((point11[0] + workBuffer[46]) * workBuffer[48]);				point11[1] = ((point11[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */							/* begin transformPoint: */			point21 = PTR_ADD(workBuffer, 84);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue21 = (point21[0]|0);				yValue21 = (point21[1]|0);				dstPoint121 = point21;				transform21 = FPTR_ADD(workBuffer, 18);				x22 = (((((transform21[0] * xValue21) + (transform21[1] * yValue21)) + transform21[2]) * workBuffer[48]) | 0);				y22 = (((((transform21[3] * xValue21) + (transform21[4] * yValue21)) + transform21[5]) * workBuffer[48]) | 0);				dstPoint121[0] = x22;				dstPoint121[1] = y22;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point21[0] = ((point21[0] + workBuffer[46]) * workBuffer[48]);				point21[1] = ((point21[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */				/* end transformPoints: */				segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide(PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), (widthValue !== 0) && (lineFillValue !== 0));				if (!engineStopped) {					B2DPlugin.loadWideBezierlineFillleftFillrightFilln(widthValue, lineFillValue, leftValue, rightValue, segs);				}			}		}		/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (engineStopped) {			return null;		}	}}, loadEdgeStateFrom(edgeOop) {	let edge;	edge = workBuffer[65];	if (SIZEOF(edgeOop) < 6) {		return null;	}	objBuffer[edge + 4] = edgeOop.pointers[1];	objBuffer[edge + 5] = edgeOop.pointers[2];	objBuffer[edge + 6] = edgeOop.pointers[3];	objBuffer[edge + 7] = edgeOop.pointers[4];	return edge;}, /*	Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise */loadEdgeTransformFrom(transformOop) {	let okay;	let transform;	workBuffer[16] = 0;	transform = FPTR_ADD(workBuffer, 18);	okay = B2DPlugin.loadTransformFromintolength(transformOop, transform, 6);	if (!okay) {		return false;	}	workBuffer[16] = 1;	transform[2] = (transform[2] + workBuffer[46]);	transform[5] = (transform[5] + workBuffer[47]);	return true;}, /*	Load the gradient fill as defined by the color ramp. */loadGradientFillfromalongnormalisRadial(rampOop, point1, point2, point3, isRadial) {	let fill;	let rampWidth;	let ramp;	let fill1;	let fillSize;	let i;	let i1;	let rampPtr;	let arg21;	let fillIndex;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let dirX;	let dirY;	let dsLength2;	let dsX;	let dsY;	let dtLength2;	let dtX;	let dtY;	let nrmX;	let nrmY;	let xValue;	let yValue;	let dstPoint1;	let transform3;	let x;	let y;	let xValue1;	let yValue1;	let dstPoint11;	let transform1;	let x1;	let y1;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	if (rampOop._class() !== SmalltalkGlobals._Bitmap) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	rampWidth = SIZEOF(rampOop);	/* begin allocateGradientFill:rampWidth:isRadial: */	ramp = rampOop.wordsAsInt32Array();	fillSize = rampWidth + 12;	if (B2DPlugin.allocateObjEntry(fillSize)) {		fill1 = objUsed;		objUsed = fill1 + fillSize;		if (isRadial) {			objBuffer[fill1] = 768;		} else {			objBuffer[fill1] = 512;		}		objBuffer[fill1 + 2] = 0;		objBuffer[fill1 + 1] = fillSize;		rampPtr = PTR_ADD(objBuffer, fill1 + 12);		if (workBuffer[17] !== 0) {			for (i = 0; i < rampWidth; i++) {				/* begin transformColor: */				fillIndex = ramp[i];				if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {					b = UBANDS(fillIndex, 255);					g = UBANDS((fillIndex >>> 8), 255);					r = UBANDS((fillIndex >>> 16), 255);					a = UBANDS((fillIndex >>> 24), 255);					if (workBuffer[17] !== 0) {						transform = FPTR_ADD(workBuffer, 24);						alphaScale = ((a * transform[6]) + transform[7]) / a;						r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);						g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);						b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);						a = a * alphaScale|0;						r = Math.max(r, 0);						r = Math.min(r, 255);						g = Math.max(g, 0);						g = Math.min(g, 255);						b = Math.max(b, 0);						b = Math.min(b, 255);						a = Math.max(a, 0);						a = Math.min(a, 255);					}					if (a < 1) {						arg21 = 0;					} else {						if ((a < 255) && (workBuffer[63] !== 0)) {							/* begin stopBecauseOf: */							workBuffer[64] = 3;							engineStopped = true;							/* end stopBecauseOf: */						}						arg21 = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);					}				} else {					arg21 = fillIndex;				}				/* end transformColor: */				rampPtr[i] = arg21;			}		} else {			for (i1 = 0; i1 < rampWidth; i1++) {				rampPtr[i1] = ramp[i1];			}		}		objBuffer[fill1 + 10] = rampWidth;		fill = fill1;	} else {		fill = 0;	}	/* end allocateGradientFill:rampWidth:isRadial: */	if (engineStopped) {		return null;	}	/* begin loadFillOrientation:from:along:normal:width:height: */	point2[0] += point1[0];	point2[1] += point1[1];	point3[0] += point1[0];	point3[1] += point1[1];	/* begin transformPoint: */	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue = (point1[0]|0);		yValue = (point1[1]|0);		dstPoint1 = point1;		transform3 = FPTR_ADD(workBuffer, 18);		x = (((((transform3[0] * xValue) + (transform3[1] * yValue)) + transform3[2]) * workBuffer[48]) | 0);		y = (((((transform3[3] * xValue) + (transform3[4] * yValue)) + transform3[5]) * workBuffer[48]) | 0);		dstPoint1[0] = x;		dstPoint1[1] = y;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);		point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */	/* begin transformPoint: */	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue1 = (point2[0]|0);		yValue1 = (point2[1]|0);		dstPoint11 = point2;		transform1 = FPTR_ADD(workBuffer, 18);		x1 = (((((transform1[0] * xValue1) + (transform1[1] * yValue1)) + transform1[2]) * workBuffer[48]) | 0);		y1 = (((((transform1[3] * xValue1) + (transform1[4] * yValue1)) + transform1[5]) * workBuffer[48]) | 0);		dstPoint11[0] = x1;		dstPoint11[1] = y1;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);		point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */	/* begin transformPoint: */	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue2 = (point3[0]|0);		yValue2 = (point3[1]|0);		dstPoint12 = point3;		transform2 = FPTR_ADD(workBuffer, 18);		x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);		y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);		dstPoint12[0] = x2;		dstPoint12[1] = y2;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point3[0] = ((point3[0] + workBuffer[46]) * workBuffer[48]);		point3[1] = ((point3[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */	dirX = point2[0] - point1[0];	dirY = point2[1] - point1[1];	nrmX = point3[0] - point1[0];	nrmY = point3[1] - point1[1];	dsLength2 = (dirX * dirX) + (dirY * dirY);	if (dsLength2 > 0) {		dsX = ((((dirX * rampWidth) * 65536.0) / dsLength2) | 0);		dsY = ((((dirY * rampWidth) * 65536.0) / dsLength2) | 0);	} else {		dsX = 0;		dsY = 0;	}	dtLength2 = (nrmX * nrmX) + (nrmY * nrmY);	if (dtLength2 > 0) {		dtX = ((((nrmX * rampWidth) * 65536.0) / dtLength2) | 0);		dtY = ((((nrmY * rampWidth) * 65536.0) / dtLength2) | 0);	} else {		dtX = 0;		dtY = 0;	}	objBuffer[fill + 4] = point1[0];	objBuffer[fill + 5] = point1[1];	objBuffer[fill + 6] = dsX;	objBuffer[fill + 7] = dsY;	objBuffer[fill + 8] = dtX;	objBuffer[fill + 9] = dtY;	/* end loadFillOrientation:from:along:normal:width:height: */	return fill;}, /*	Load a rectangular oval currently defined by point1/point2 */loadOvallineFillleftFillrightFill(lineWidth, lineFill, leftFill, rightFill) {	let cx;	let cy;	let h;	let i;	let nSegments;	let w;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform1;	let x1;	let y1;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	w = (PTR_ADD(workBuffer, 82)[0] - PTR_ADD(workBuffer, 80)[0]) >> 1;	h = (PTR_ADD(workBuffer, 82)[1] - PTR_ADD(workBuffer, 80)[1]) >> 1;	cx = (PTR_ADD(workBuffer, 82)[0] + PTR_ADD(workBuffer, 80)[0]) >> 1;	cy = (PTR_ADD(workBuffer, 82)[1] + PTR_ADD(workBuffer, 80)[1]) >> 1;	for (i = 0; i <= 15; i++) {		B2DPlugin.loadOvalSegmentwhcxcy(i, w, h, cx, cy);		/* begin transformPoints: */			/* begin transformPoint: */	point = PTR_ADD(workBuffer, 80);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue = (point[0]|0);		yValue = (point[1]|0);		dstPoint1 = point;		transform = FPTR_ADD(workBuffer, 18);		x = (((((transform[0] * xValue) + (transform[1] * yValue)) + transform[2]) * workBuffer[48]) | 0);		y = (((((transform[3] * xValue) + (transform[4] * yValue)) + transform[5]) * workBuffer[48]) | 0);		dstPoint1[0] = x;		dstPoint1[1] = y;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);		point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */			/* begin transformPoint: */	point1 = PTR_ADD(workBuffer, 82);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue1 = (point1[0]|0);		yValue1 = (point1[1]|0);		dstPoint11 = point1;		transform1 = FPTR_ADD(workBuffer, 18);		x1 = (((((transform1[0] * xValue1) + (transform1[1] * yValue1)) + transform1[2]) * workBuffer[48]) | 0);		y1 = (((((transform1[3] * xValue1) + (transform1[4] * yValue1)) + transform1[5]) * workBuffer[48]) | 0);		dstPoint11[0] = x1;		dstPoint11[1] = y1;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);		point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */			/* begin transformPoint: */	point2 = PTR_ADD(workBuffer, 84);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue2 = (point2[0]|0);		yValue2 = (point2[1]|0);		dstPoint12 = point2;		transform2 = FPTR_ADD(workBuffer, 18);		x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);		y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);		dstPoint12[0] = x2;		dstPoint12[1] = y2;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);		point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */		/* end transformPoints: */		nSegments = B2DPlugin.loadAndSubdivideBezierFromviatoisWide(PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), (lineWidth !== 0) && (lineFill !== 0));		if (engineStopped) {			return null;		}		B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments);		if (engineStopped) {			return null;		}	}}, loadOvalSegmentwhcxcy(seg, w, h, cx, cy) {	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	/* Load start point of segment */	x0 = (((B2DPlugin.circleCosTable()[(seg * 2)] * w) + cx) | 0);	y0 = (((B2DPlugin.circleSinTable()[(seg * 2)] * h) + cy) | 0);	PTR_ADD(workBuffer, 80)[0] = x0;	PTR_ADD(workBuffer, 80)[1] = y0;	x2 = (((B2DPlugin.circleCosTable()[(seg * 2) + 2] * w) + cx) | 0);	y2 = (((B2DPlugin.circleSinTable()[(seg * 2) + 2] * h) + cy) | 0);	PTR_ADD(workBuffer, 84)[0] = x2;	PTR_ADD(workBuffer, 84)[1] = y2;	x1 = (((B2DPlugin.circleCosTable()[(seg * 2) + 1] * w) + cx) | 0);	/* NOTE: The intermediate point is the point ON the curve	and not yet the control point (which is OFF the curve) */	y1 = (((B2DPlugin.circleSinTable()[(seg * 2) + 1] * h) + cy) | 0);	x1 = (x1 * 2) - ((x0 + x2) >> 1);	y1 = (y1 * 2) - ((y0 + y2) >> 1);	PTR_ADD(workBuffer, 82)[0] = x1;	PTR_ADD(workBuffer, 82)[1] = y1;}, /*	Load the contents of pointOop into pointArray */loadPointfrom(pointArray, pointOop) {	let value;	if (pointOop._class() !== SmalltalkGlobals._Point) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	value = pointOop.pointers[0];	if (!((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof value === "number")) {		pointArray[0] = value;	} else {		pointArray[0] = (((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal()) | 0);	}	value = pointOop.pointers[1];	if ((typeof value === "number") || ((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float))) {		if ((typeof value === "number")) {			pointArray[1] = value;		} else {			pointArray[1] = (((typeof value === "number" && (value | 0) !== value && !Number.isSafeInteger(value) || value._class() === SmalltalkGlobals._Float) ? value.valueOf() : PrimitiveFailed.signal()) | 0);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}}, /*	Load the entire state from the interpreter for the rendering primitives.	 Answer 0 on success or a non-zero failure code on failure. */loadRenderingState(edgeOop, fillOop) {	let failCode;	let state;	let arrayOop;	let bmBits;	let bmBitsSize;	let bmDepth;	let bmHeight;	let bmRaster;	let bmWidth;	let formOop;	let i;	let ppw;	let returnValueFromLoop_loadFormsFrom_1373;	let brokenFromLoop_loadFormsFrom_1373;	if (arguments.length !== 2) {		return 5;	}	if (((failCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		return failCode;	}	if (typeof fillOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		return failCode;	}	/* begin loadBitBltFrom: */	if (!loadBBFn) {		/* begin initialiseModule */		loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);		copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);		if ((!!loadBBFn) && (!!copyBitsFn)) {			if (!loadBBFn(engine.pointers[2])) {				return 122;			}		} else {			return 122;		}		/* end initialiseModule */	} else {		if (!loadBBFn(engine.pointers[2])) {			return 122;		}	}	/* end loadBitBltFrom: */	/* begin loadFormsFrom: */	arrayOop = engine.pointers[3];	if ((arrayOop.storageType === "pointers" && arrayOop.instSize === 0)) {		formArray = arrayOop;		brokenFromLoop_loadFormsFrom_1373 = false;		const iLimiT = SIZEOF(formArray);		for (i = 0; i < iLimiT; i++) {			formOop = formArray.pointers[i];			if ((typeof formOop === "number")) {				returnValueFromLoop_loadFormsFrom_1373 = false;				brokenFromLoop_loadFormsFrom_1373 = true;				break;			} else {				if ((formOop.storageType === "pointers")) {					if (SIZEOF(formOop) < 5) {						returnValueFromLoop_loadFormsFrom_1373 = false;						brokenFromLoop_loadFormsFrom_1373 = true;						break;					} else {						bmBits = formOop.pointers[0];						if (bmBits._class() === SmalltalkGlobals._Bitmap) {							bmBitsSize = SIZEOF(bmBits);							bmWidth = formOop.pointers[1];							bmHeight = formOop.pointers[2];							bmDepth = formOop.pointers[3];							if ((bmWidth >= 0) && (bmHeight >= 0)) {								ppw = Math.trunc(32 / bmDepth);								bmRaster = Math.trunc((ppw + bmWidth - 1) / ppw);								if (bmBitsSize !== (bmRaster * bmHeight)) {									returnValueFromLoop_loadFormsFrom_1373 = false;									brokenFromLoop_loadFormsFrom_1373 = true;									break;								}							} else {								returnValueFromLoop_loadFormsFrom_1373 = false;								brokenFromLoop_loadFormsFrom_1373 = true;								break;							}						} else {							returnValueFromLoop_loadFormsFrom_1373 = false;							brokenFromLoop_loadFormsFrom_1373 = true;							break;						}					}				} else {					returnValueFromLoop_loadFormsFrom_1373 = false;					brokenFromLoop_loadFormsFrom_1373 = true;					break;				}			}		}		if (brokenFromLoop_loadFormsFrom_1373) {			if (!returnValueFromLoop_loadFormsFrom_1373) {				return 123;			}		}	} else {		return 123;	}	/* end loadFormsFrom: */	if (SIZEOF(edgeOop) < 6) {		return 112;	}	if (SIZEOF(fillOop) < 6) {		return 113;	}	state = workBuffer[2];	return ((state === 2) || ((state === 4) || (state === 7))) ? 116 : 0;}, loadShapenSegmentsfilllineWidthlineFillpointsShort(points, nSegments, fillIndex, lineWidth, lineFill, pointsShort) {	let i;	let index;	let segs;	let x0;	let x1;	let x2;	let y0;	let y1;	let y2;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform1;	let x11;	let y11;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x21;	let y21;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	let point4;	let xValue4;	let yValue4;	let dstPoint14;	let transform4;	let x4;	let y4;	let point11;	let xValue11;	let yValue11;	let dstPoint111;	let transform11;	let x12;	let y12;	let point21;	let xValue21;	let yValue21;	let dstPoint121;	let transform21;	let x22;	let y22;	let point31;	let xValue31;	let yValue31;	let dstPoint131;	let transform31;	let x31;	let y31;	for (i = 1; i <= nSegments; i++) {		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (!((fillIndex === 0) && ((lineWidth === 0) || (lineFill === 0)))) {			index = (i - 1) * 6;			if (pointsShort) {				x0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index];				y0 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 1];				x1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 2];				y1 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 3];				x2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 4];				y2 = (points.int16Array || (points.int16Array = new Int16Array(points.buffer, points.byteOffset)))[index + 5];			} else {				x0 = (points[(index)]|0);				y0 = (points[(index + 1)]|0);				x1 = (points[(index + 2)]|0);				y1 = (points[(index + 3)]|0);				x2 = (points[(index + 4)]|0);				y2 = (points[(index + 5)]|0);			}			if (((x0 === x1) && (y0 === y1)) || ((x1 === x2) && (y1 === y2))) {				if (!((x0 === x2) && (y0 === y2))) {					PTR_ADD(workBuffer, 80)[0] = x0;					PTR_ADD(workBuffer, 80)[1] = y0;					PTR_ADD(workBuffer, 82)[0] = x2;					PTR_ADD(workBuffer, 82)[1] = y2;					/* begin transformPoints: */									/* begin transformPoint: */				point = PTR_ADD(workBuffer, 80);				if (workBuffer[16] !== 0) {					/* begin transformPoint:into: */					/* begin transformPointX:y:into: */					xValue = (point[0]|0);					yValue = (point[1]|0);					dstPoint1 = point;					transform = FPTR_ADD(workBuffer, 18);					x = (((((transform[0] * xValue) + (transform[1] * yValue)) + transform[2]) * workBuffer[48]) | 0);					y = (((((transform[3] * xValue) + (transform[4] * yValue)) + transform[5]) * workBuffer[48]) | 0);					dstPoint1[0] = x;					dstPoint1[1] = y;					/* end transformPointX:y:into: */					/* end transformPoint:into: */				} else {					point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);					point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);				}				/* end transformPoint: */									/* begin transformPoint: */				point1 = PTR_ADD(workBuffer, 82);				if (workBuffer[16] !== 0) {					/* begin transformPoint:into: */					/* begin transformPointX:y:into: */					xValue1 = (point1[0]|0);					yValue1 = (point1[1]|0);					dstPoint11 = point1;					transform1 = FPTR_ADD(workBuffer, 18);					x11 = (((((transform1[0] * xValue1) + (transform1[1] * yValue1)) + transform1[2]) * workBuffer[48]) | 0);					y11 = (((((transform1[3] * xValue1) + (transform1[4] * yValue1)) + transform1[5]) * workBuffer[48]) | 0);					dstPoint11[0] = x11;					dstPoint11[1] = y11;					/* end transformPointX:y:into: */					/* end transformPoint:into: */				} else {					point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);					point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);				}				/* end transformPoint: */					/* end transformPoints: */					/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */					p1 = PTR_ADD(workBuffer, 80);					p2 = PTR_ADD(workBuffer, 82);					if ((lineWidth === 0) || (lineFill === 0)) {						/* begin allocateLine */						if (B2DPlugin.allocateObjEntry(16)) {							line1 = objUsed;							objUsed = line1 + 16;							objBuffer[line1] = 4;							objBuffer[line1 + 2] = 0;							objBuffer[line1 + 1] = 16;							line = line1;						} else {							line = 0;						}						/* end allocateLine */						offset = 0;					} else {						/* begin allocateWideLine */						if (B2DPlugin.allocateObjEntry(21)) {							line2 = objUsed;							objUsed = line2 + 21;							objBuffer[line2] = 5;							objBuffer[line2 + 2] = 0;							objBuffer[line2 + 1] = 21;							line = line2;						} else {							line = 0;						}						/* end allocateWideLine */						offset = lineWidth >> 1;					}					if (!engineStopped) {						/* begin loadLine:from:to:offset:leftFill:rightFill: */						if (p1[1] <= p2[1]) {							p11 = p1;							p21 = p2;							yDir = 1;						} else {							p11 = p2;							p21 = p1;							yDir = -1;						}						objBuffer[line + 4] = p11[0];						objBuffer[line + 5] = (p11[1] - offset);						objBuffer[line + 6] = workBuffer[113];						objBuffer[line + 8] = fillIndex;						objBuffer[line + 9] = 0;						objBuffer[line + 14] = p21[0];						objBuffer[line + 15] = (p21[1] - offset);						objBuffer[line + 11] = yDir;						/* end loadLine:from:to:offset:leftFill:rightFill: */						if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {							objBuffer[line + 16] = lineFill;							objBuffer[line + 17] = lineWidth;							objBuffer[line + 20] = lineWidth;						}					}					/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */				}			} else {				PTR_ADD(workBuffer, 80)[0] = x0;				PTR_ADD(workBuffer, 80)[1] = y0;				PTR_ADD(workBuffer, 82)[0] = x1;				PTR_ADD(workBuffer, 82)[1] = y1;				PTR_ADD(workBuffer, 84)[0] = x2;				PTR_ADD(workBuffer, 84)[1] = y2;				/* begin transformPoints: */							/* begin transformPoint: */			point4 = PTR_ADD(workBuffer, 80);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue4 = (point4[0]|0);				yValue4 = (point4[1]|0);				dstPoint14 = point4;				transform4 = FPTR_ADD(workBuffer, 18);				x4 = (((((transform4[0] * xValue4) + (transform4[1] * yValue4)) + transform4[2]) * workBuffer[48]) | 0);				y4 = (((((transform4[3] * xValue4) + (transform4[4] * yValue4)) + transform4[5]) * workBuffer[48]) | 0);				dstPoint14[0] = x4;				dstPoint14[1] = y4;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point4[0] = ((point4[0] + workBuffer[46]) * workBuffer[48]);				point4[1] = ((point4[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */							/* begin transformPoint: */			point11 = PTR_ADD(workBuffer, 82);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue11 = (point11[0]|0);				yValue11 = (point11[1]|0);				dstPoint111 = point11;				transform11 = FPTR_ADD(workBuffer, 18);				x12 = (((((transform11[0] * xValue11) + (transform11[1] * yValue11)) + transform11[2]) * workBuffer[48]) | 0);				y12 = (((((transform11[3] * xValue11) + (transform11[4] * yValue11)) + transform11[5]) * workBuffer[48]) | 0);				dstPoint111[0] = x12;				dstPoint111[1] = y12;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point11[0] = ((point11[0] + workBuffer[46]) * workBuffer[48]);				point11[1] = ((point11[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */							/* begin transformPoint: */			point21 = PTR_ADD(workBuffer, 84);			if (workBuffer[16] !== 0) {				/* begin transformPoint:into: */				/* begin transformPointX:y:into: */				xValue21 = (point21[0]|0);				yValue21 = (point21[1]|0);				dstPoint121 = point21;				transform21 = FPTR_ADD(workBuffer, 18);				x22 = (((((transform21[0] * xValue21) + (transform21[1] * yValue21)) + transform21[2]) * workBuffer[48]) | 0);				y22 = (((((transform21[3] * xValue21) + (transform21[4] * yValue21)) + transform21[5]) * workBuffer[48]) | 0);				dstPoint121[0] = x22;				dstPoint121[1] = y22;				/* end transformPointX:y:into: */				/* end transformPoint:into: */			} else {				point21[0] = ((point21[0] + workBuffer[46]) * workBuffer[48]);				point21[1] = ((point21[1] + workBuffer[47]) * workBuffer[48]);			}			/* end transformPoint: */				/* end transformPoints: */				segs = B2DPlugin.loadAndSubdivideBezierFromviatoisWide(PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), (lineWidth !== 0) && (lineFill !== 0));				if (!engineStopped) {					B2DPlugin.loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);				}			}		}		/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */		if (engineStopped) {			return null;		}	}}, /*	Load the span buffer from the given oop.	 Answer 0 on success or a non-zero failure code on failure. */loadSpanBufferFrom(spanOop) {	if (spanOop._class() !== SmalltalkGlobals._Bitmap) {		return 114;	}	/* Leave last entry unused to avoid complications */	spanBuffer = spanOop.words;	workBuffer[33] = (SIZEOF(spanOop) - 1);	return 0;}, /*	Load a transformation from transformOop into the float array	defined by destPtr. The transformation is assumed to be either	an array or a FloatArray of length n. */loadTransformFromintolength(transformOop, destPtr, n) {	if (transformOop === nil) {		return false;	} else {		if ((typeof transformOop === "number")) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			if (SIZEOF(transformOop) === n) {				if ((transformOop.storageType === "words")) {					B2DPlugin.loadWordTransformFromintolength(transformOop, destPtr, n);				} else {					B2DPlugin.loadArrayTransformFromintolength(transformOop, destPtr, n);				}				return true;			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}}, /*	Load the (possibly wide) bezier from the segments currently on the bezier stack. */loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments) {	let bezier;	let index;	let offset;	let wide;	let bezier1;	let bezier2;	if ((lineWidth === 0) || (lineFill === 0)) {		wide = false;		offset = 0;	} else {		wide = true;		offset = lineWidth >> 1;	}	index = nSegments * 6;	while (index > 0) {		if (wide) {			/* begin allocateWideBezier */			if (B2DPlugin.allocateObjEntry(28)) {				bezier1 = objUsed;				objUsed = bezier1 + 28;				objBuffer[bezier1] = 7;				objBuffer[bezier1 + 2] = 0;				objBuffer[bezier1 + 1] = 28;				bezier = bezier1;			} else {				bezier = 0;			}			/* end allocateWideBezier */		} else {			/* begin allocateBezier */			if (B2DPlugin.allocateObjEntry(16)) {				bezier2 = objUsed;				objUsed = bezier2 + 16;				objBuffer[bezier2] = 6;				objBuffer[bezier2 + 2] = 0;				objBuffer[bezier2 + 1] = 16;				bezier = bezier2;			} else {				bezier = 0;			}			/* end allocateBezier */		}		if (engineStopped) {			return 0;		}		B2DPlugin.loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFill, rightFill, offset);		if (wide) {			objBuffer[bezier + 16] = lineFill;			objBuffer[bezier + 17] = lineWidth;			objBuffer[bezier + 20] = lineWidth;		}		index -= 6;	}	/* begin wbStackClear */	workBuffer[10] = workBuffer[1];	/* end wbStackClear */}, /*	Load a float array transformation from the given oop */loadWordTransformFromintolength(transformOop, destPtr, n) {	let i;	let srcPtr;	srcPtr = transformOop.wordsAsFloat32Array();	for (i = 0; i < n; i++) {		destPtr[i] = srcPtr[i];	}}, /*	Load the working buffer from the given oop */loadWorkBufferFrom(wbOop) {	if ((typeof wbOop === "number")) {		return 105;	}	if ((wbOop.storageType !== "words")) {		return 106;	}	if (SIZEOF(wbOop) < 256) {		return 107;	}	/* begin workBufferPut: */	workBuffer = wbOop.wordsAsInt32Array();	/* end workBufferPut: */	if (workBuffer[0] !== 1097753705) {		return 108;	}	if (workBuffer[1] !== SIZEOF(wbOop)) {		return 109;	}	if (workBuffer[8] !== 128) {		return 110;	}	objBuffer = PTR_ADD(workBuffer, workBuffer[8]);	getBuffer = PTR_ADD(objBuffer, workBuffer[9]);	/* Make sure we don't exceed the work buffer */	aetBuffer = PTR_ADD(getBuffer, workBuffer[12]);	return ((workBuffer[9] + workBuffer[12] + workBuffer[14] + 128) > workBuffer[1]) ? 111 : 0;}, /*	The module with the given name was just unloaded.	Make sure we have no dangling references. */moduleUnloaded(aModuleName) {	if (strcmp(aModuleName, bbPluginName) === 0) {		/* BitBlt just shut down. How nasty. */		loadBBFn = 0;		copyBitsFn = 0;	}}, /*	The entry at index is not in the right position of the AET. 	Move it to the left until the position is okay. */moveAETEntryFromedgex(index, edge, xValue) {	let newIndex;	newIndex = index;	while ((newIndex > 0) && (objBuffer[aetBuffer[newIndex - 1] + 4] > xValue)) {		aetBuffer[newIndex] = aetBuffer[newIndex - 1];		--newIndex;	}	aetBuffer[newIndex] = edge;}, /*	We have just blitted a scan line to the screen.	Do whatever seems to be a good idea here. *//*	Note: In the future we may check the time needed for this scan line and interrupt processing to give the Smalltalk code a chance to run at a certain time. *//*	Check if there is any more work to do. */postDisplayAction() {	if ((workBuffer[11] >= workBuffer[12]) && (workBuffer[14] === 0)) {		/* No more entries to process */		workBuffer[2] = 8;	}	if (workBuffer[88] >= workBuffer[39]) {		/* Out of clipping range */		workBuffer[2] = 8;	}}, primitiveAbortProcessing() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	workBuffer[2] = 8;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveAddActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 2))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	edge = B2DPlugin.loadEdgeStateFrom(edgeOop);	if (!edge) {		throw Object.create(PrimitiveFailed).setPayload(112);	}	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 129) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* end needAvailableSpace: */	if (objBuffer[edge + 7] > 0) {		B2DPlugin.insertEdgeIntoAET(edge);	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[2] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[97]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[96] += value;		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBezier(startOop, endOop, viaOop, _arg4, _arg5) {	let failureCode;	let leftFill;	let nSegments;	let rightFill;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform4;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform11;	let x1;	let y1;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	rightFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	leftFill = (_arg4 >>> 0) === _arg4.valueOf() ? _arg4 : PrimitiveFailed.signal();	if (typeof viaOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof endOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof startOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(leftFill) && (B2DPlugin.isFillOkay(rightFill)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), startOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), viaOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 84), endOop);	/* begin transformPoints: */	/* begin transformPoint: */point = PTR_ADD(workBuffer, 80);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue = (point[0]|0);	yValue = (point[1]|0);	dstPoint1 = point;	transform4 = FPTR_ADD(workBuffer, 18);	x = (((((transform4[0] * xValue) + (transform4[1] * yValue)) + transform4[2]) * workBuffer[48]) | 0);	y = (((((transform4[3] * xValue) + (transform4[4] * yValue)) + transform4[5]) * workBuffer[48]) | 0);	dstPoint1[0] = x;	dstPoint1[1] = y;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);	point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point1 = PTR_ADD(workBuffer, 82);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue1 = (point1[0]|0);	yValue1 = (point1[1]|0);	dstPoint11 = point1;	transform11 = FPTR_ADD(workBuffer, 18);	x1 = (((((transform11[0] * xValue1) + (transform11[1] * yValue1)) + transform11[2]) * workBuffer[48]) | 0);	y1 = (((((transform11[3] * xValue1) + (transform11[4] * yValue1)) + transform11[5]) * workBuffer[48]) | 0);	dstPoint11[0] = x1;	dstPoint11[1] = y1;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);	point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point2 = PTR_ADD(workBuffer, 84);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue2 = (point2[0]|0);	yValue2 = (point2[1]|0);	dstPoint12 = point2;	transform2 = FPTR_ADD(workBuffer, 18);	x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);	y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);	dstPoint12[0] = x2;	dstPoint12[1] = y2;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);	point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* end transformPoints: */	nSegments = B2DPlugin.loadAndSubdivideBezierFromviatoisWide(PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), false);	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + (nSegments * 16) + 128) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */	}	/* end needAvailableSpace: */	if (!engineStopped) {		/* begin transformColor: */		if ((leftFill === 0) || ((UBANDM(leftFill, 2130706432)) !== 0)) {			b = UBANDS(leftFill, 255);			g = UBANDS((leftFill >>> 8), 255);			r = UBANDS((leftFill >>> 16), 255);			a = UBANDS((leftFill >>> 24), 255);			if (workBuffer[17] !== 0) {				transform = FPTR_ADD(workBuffer, 24);				alphaScale = ((a * transform[6]) + transform[7]) / a;				r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);				g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);				b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);				a = a * alphaScale|0;				r = Math.max(r, 0);				r = Math.min(r, 255);				g = Math.max(g, 0);				g = Math.min(g, 255);				b = Math.max(b, 0);				b = Math.min(b, 255);				a = Math.max(a, 0);				a = Math.min(a, 255);			}			if (a < 1) {				leftFill = 0;			} else {				if ((a < 255) && (workBuffer[63] !== 0)) {					/* begin stopBecauseOf: */					workBuffer[64] = 3;					engineStopped = true;					/* end stopBecauseOf: */				}				leftFill = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);			}		}		/* end transformColor: */		/* begin transformColor: */		if ((rightFill === 0) || ((UBANDM(rightFill, 2130706432)) !== 0)) {			b1 = UBANDS(rightFill, 255);			g1 = UBANDS((rightFill >>> 8), 255);			r1 = UBANDS((rightFill >>> 16), 255);			a1 = UBANDS((rightFill >>> 24), 255);			if (workBuffer[17] !== 0) {				transform1 = FPTR_ADD(workBuffer, 24);				alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;				r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);				g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);				b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);				a1 = a1 * alphaScale1|0;				r1 = Math.max(r1, 0);				r1 = Math.min(r1, 255);				g1 = Math.max(g1, 0);				g1 = Math.min(g1, 255);				b1 = Math.max(b1, 0);				b1 = Math.min(b1, 255);				a1 = Math.max(a1, 0);				a1 = Math.min(a1, 255);			}			if (a1 < 1) {				rightFill = 0;			} else {				if ((a1 < 255) && (workBuffer[63] !== 0)) {					/* begin stopBecauseOf: */					workBuffer[64] = 3;					engineStopped = true;					/* end stopBecauseOf: */				}				rightFill = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);			}		}		/* end transformColor: */	}	if (!engineStopped) {		B2DPlugin.loadWideBezierlineFillleftFillrightFilln(0, 0, leftFill, rightFill, nSegments);	}	if (engineStopped) {		/* Make sure the stack is okay */		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBezierShape(points, nSegments, _arg3, lineWidth, _arg5) {	let failureCode;	let fillIndex;	let length;	let lineFill;	let pointsIsArray;	let segSize;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	lineFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	if (!(typeof lineWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	if (!(typeof nSegments === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof points === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	length = SIZEOF(points);	if ((points.storageType === "words")) {		/* Either PointArray or ShortPointArray */		pointsIsArray = false;		if (!((length === (nSegments * 3)) || (length === (nSegments * 6)))) {			throw Object.create(PrimitiveFailed).setPayload(3);		}	} else {		/* Must be Array of points */		if ((points.storageType !== "pointers" || points.instSize !== 0)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		if (length !== (nSegments * 3)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		pointsIsArray = true;	}	segSize = ((lineWidth === 0) || (lineFill === 0)) ? 16 : 21;	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + (segSize * nSegments) + 128) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* end needAvailableSpace: */	if (!(B2DPlugin.isFillOkay(lineFill) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	/* begin transformColor: */	if ((lineFill === 0) || ((UBANDM(lineFill, 2130706432)) !== 0)) {		b = UBANDS(lineFill, 255);		g = UBANDS((lineFill >>> 8), 255);		r = UBANDS((lineFill >>> 16), 255);		a = UBANDS((lineFill >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			lineFill = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			lineFill = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	}	/* end transformColor: */	/* begin transformColor: */	if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {		b1 = UBANDS(fillIndex, 255);		g1 = UBANDS((fillIndex >>> 8), 255);		r1 = UBANDS((fillIndex >>> 16), 255);		a1 = UBANDS((fillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			fillIndex = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			fillIndex = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	}	/* end transformColor: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (((lineFill === 0) || (lineWidth === 0)) && (fillIndex === 0)) {		return null;	}	if (lineWidth !== 0) {		lineWidth = B2DPlugin.transformWidth(lineWidth);		if (lineWidth < 1) {			lineWidth = 1;		}	}	if (pointsIsArray) {		B2DPlugin.loadArrayShapenSegmentsfilllineWidthlineFill(points, nSegments, fillIndex, lineWidth, lineFill);	} else {		B2DPlugin.loadShapenSegmentsfilllineWidthlineFillpointsShort(points.wordsAsInt32Array(), nSegments, fillIndex, lineWidth, lineFill, (nSegments * 3) === length);	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddBitmapFill(formOop, cmOop, _arg3, originOop, dirOop, nrmOop, xIndex) {	let failureCode;	let fill;	let tileFlag;	let tileFlag1;	let point1;	let point2;	let point3;	let xIndex1;	let bmBits;	let bmBitsSize;	let bmDepth;	let bmFill;	let bmHeight;	let bmRaster;	let bmWidth;	let cmBits;	let cmSize;	let ppw;	let cm;	let fill2;	let fillSize;	let i;	let i1;	let arg21;	let fillIndex;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let cm1;	let fill1;	let fillSize1;	let i2;	let i11;	let arg211;	let fillIndex1;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let dirX;	let dirY;	let dsLength2;	let dsX;	let dsY;	let dtLength2;	let dtX;	let dtY;	let nrmX;	let nrmY;	let xValue;	let yValue;	let dstPoint1;	let transform3;	let x;	let y;	let xValue1;	let yValue1;	let dstPoint11;	let transform11;	let x1;	let y1;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let dirX1;	let dirY1;	let dsLength21;	let dsX1;	let dsY1;	let dtLength21;	let dtX1;	let dtY1;	let nrmX1;	let nrmY1;	let xValue3;	let yValue3;	let dstPoint13;	let transform4;	let x3;	let y3;	let xValue11;	let yValue11;	let dstPoint111;	let transform12;	let x11;	let y11;	let xValue21;	let yValue21;	let dstPoint121;	let transform21;	let x21;	let y21;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 7) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (!(typeof xIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (xIndex <= 0) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	if (typeof nrmOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof dirOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof originOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	tileFlag = (typeof _arg3 === "boolean" ? _arg3 : PrimitiveFailed.signal());	if (typeof cmOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof formOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), originOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), dirOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 84), nrmOop);	/* begin loadBitmapFill:colormap:tile:from:along:normal:xIndex: */	tileFlag1 = tileFlag ? 1 : 0;	point1 = PTR_ADD(workBuffer, 80);	point2 = PTR_ADD(workBuffer, 82);	point3 = PTR_ADD(workBuffer, 84);	xIndex1 = xIndex - 1;	if (cmOop === nil) {		cmSize = 0;		cmBits = null;		if ((typeof formOop === "number")) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			if ((formOop.storageType === "pointers")) {				if (SIZEOF(formOop) < 5) {					throw Object.create(PrimitiveFailed).setPayload(1);				} else {					bmBits = formOop.pointers[0];					if (bmBits._class() === SmalltalkGlobals._Bitmap) {						bmBitsSize = SIZEOF(bmBits);						bmWidth = formOop.pointers[1];						bmHeight = formOop.pointers[2];						bmDepth = formOop.pointers[3];						if ((bmWidth >= 0) && (bmHeight >= 0)) {							if ((((((bmDepth === 32) || (bmDepth === 8)) || (bmDepth === 16)) || (bmDepth === 1)) || (bmDepth === 2)) || (bmDepth === 4)) {								if ((cmSize === 0) || (cmSize === (SHL(1, bmDepth)))) {									ppw = Math.trunc(32 / bmDepth);									bmRaster = Math.trunc((ppw + bmWidth - 1) / ppw);									if (bmBitsSize === (bmRaster * bmHeight)) {										/* begin allocateBitmapFill:colormap: */										fillSize = cmSize + 18;										if (B2DPlugin.allocateObjEntry(fillSize)) {											fill2 = objUsed;											objUsed = fill2 + fillSize;											objBuffer[fill2] = 1024;											objBuffer[fill2 + 2] = 0;											objBuffer[fill2 + 1] = fillSize;											cm = PTR_ADD(objBuffer, fill2 + 18);											if (workBuffer[17] !== 0) {												for (i = 0; i < cmSize; i++) {													/* begin transformColor: */													fillIndex = cmBits[i];													if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {														b = UBANDS(fillIndex, 255);														g = UBANDS((fillIndex >>> 8), 255);														r = UBANDS((fillIndex >>> 16), 255);														a = UBANDS((fillIndex >>> 24), 255);														if (workBuffer[17] !== 0) {															transform = FPTR_ADD(workBuffer, 24);															alphaScale = ((a * transform[6]) + transform[7]) / a;															r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);															g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);															b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);															a = a * alphaScale|0;															r = Math.max(r, 0);															r = Math.min(r, 255);															g = Math.max(g, 0);															g = Math.min(g, 255);															b = Math.max(b, 0);															b = Math.min(b, 255);															a = Math.max(a, 0);															a = Math.min(a, 255);														}														if (a < 1) {															arg21 = 0;														} else {															if ((a < 255) && (workBuffer[63] !== 0)) {																/* begin stopBecauseOf: */																workBuffer[64] = 3;																engineStopped = true;																/* end stopBecauseOf: */															}															arg21 = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);														}													} else {														arg21 = fillIndex;													}													/* end transformColor: */													cm[i] = arg21;												}											} else {												for (i1 = 0; i1 < cmSize; i1++) {													cm[i1] = cmBits[i1];												}											}											objBuffer[fill2 + 15] = cmSize;											bmFill = fill2;										} else {											bmFill = 0;										}										/* end allocateBitmapFill:colormap: */										if (engineStopped) {											fill = null;										} else {											objBuffer[bmFill + 10] = bmWidth;											objBuffer[bmFill + 11] = bmHeight;											objBuffer[bmFill + 12] = bmDepth;											objBuffer[bmFill + 14] = bmRaster;											objBuffer[bmFill + 13] = bmBitsSize;											objBuffer[bmFill + 16] = tileFlag1;											objBuffer[bmFill + 2] = xIndex1;											/* begin loadFillOrientation:from:along:normal:width:height: */											point2[0] += point1[0];											point2[1] += point1[1];											point3[0] += point1[0];											point3[1] += point1[1];											/* begin transformPoint: */											if (workBuffer[16] !== 0) {												/* begin transformPoint:into: */												/* begin transformPointX:y:into: */												xValue = (point1[0]|0);												yValue = (point1[1]|0);												dstPoint1 = point1;												transform3 = FPTR_ADD(workBuffer, 18);												x = (((((transform3[0] * xValue) + (transform3[1] * yValue)) + transform3[2]) * workBuffer[48]) | 0);												y = (((((transform3[3] * xValue) + (transform3[4] * yValue)) + transform3[5]) * workBuffer[48]) | 0);												dstPoint1[0] = x;												dstPoint1[1] = y;												/* end transformPointX:y:into: */												/* end transformPoint:into: */											} else {												point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);												point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);											}											/* end transformPoint: */											/* begin transformPoint: */											if (workBuffer[16] !== 0) {												/* begin transformPoint:into: */												/* begin transformPointX:y:into: */												xValue1 = (point2[0]|0);												yValue1 = (point2[1]|0);												dstPoint11 = point2;												transform11 = FPTR_ADD(workBuffer, 18);												x1 = (((((transform11[0] * xValue1) + (transform11[1] * yValue1)) + transform11[2]) * workBuffer[48]) | 0);												y1 = (((((transform11[3] * xValue1) + (transform11[4] * yValue1)) + transform11[5]) * workBuffer[48]) | 0);												dstPoint11[0] = x1;												dstPoint11[1] = y1;												/* end transformPointX:y:into: */												/* end transformPoint:into: */											} else {												point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);												point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);											}											/* end transformPoint: */											/* begin transformPoint: */											if (workBuffer[16] !== 0) {												/* begin transformPoint:into: */												/* begin transformPointX:y:into: */												xValue2 = (point3[0]|0);												yValue2 = (point3[1]|0);												dstPoint12 = point3;												transform2 = FPTR_ADD(workBuffer, 18);												x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);												y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);												dstPoint12[0] = x2;												dstPoint12[1] = y2;												/* end transformPointX:y:into: */												/* end transformPoint:into: */											} else {												point3[0] = ((point3[0] + workBuffer[46]) * workBuffer[48]);												point3[1] = ((point3[1] + workBuffer[47]) * workBuffer[48]);											}											/* end transformPoint: */											dirX = point2[0] - point1[0];											dirY = point2[1] - point1[1];											nrmX = point3[0] - point1[0];											nrmY = point3[1] - point1[1];											dsLength2 = (dirX * dirX) + (dirY * dirY);											if (dsLength2 > 0) {												dsX = ((((dirX * bmWidth) * 65536.0) / dsLength2) | 0);												dsY = ((((dirY * bmWidth) * 65536.0) / dsLength2) | 0);											} else {												dsX = 0;												dsY = 0;											}											dtLength2 = (nrmX * nrmX) + (nrmY * nrmY);											if (dtLength2 > 0) {												dtX = ((((nrmX * bmHeight) * 65536.0) / dtLength2) | 0);												dtY = ((((nrmY * bmHeight) * 65536.0) / dtLength2) | 0);											} else {												dtX = 0;												dtY = 0;											}											objBuffer[bmFill + 4] = point1[0];											objBuffer[bmFill + 5] = point1[1];											objBuffer[bmFill + 6] = dsX;											objBuffer[bmFill + 7] = dsY;											objBuffer[bmFill + 8] = dtX;											objBuffer[bmFill + 9] = dtY;											/* end loadFillOrientation:from:along:normal:width:height: */											fill = bmFill;										}									} else {										throw Object.create(PrimitiveFailed).setPayload(1);									}								} else {									throw Object.create(PrimitiveFailed).setPayload(1);								}							} else {								throw Object.create(PrimitiveFailed).setPayload(1);							}						} else {							throw Object.create(PrimitiveFailed).setPayload(1);						}					} else {						throw Object.create(PrimitiveFailed).setPayload(1);					}				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	} else {		if (cmOop._class() === SmalltalkGlobals._Bitmap) {			cmSize = SIZEOF(cmOop);			cmBits = cmOop.wordsAsInt32Array();			if ((typeof formOop === "number")) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				if ((formOop.storageType === "pointers")) {					if (SIZEOF(formOop) < 5) {						throw Object.create(PrimitiveFailed).setPayload(1);					} else {						bmBits = formOop.pointers[0];						if (bmBits._class() === SmalltalkGlobals._Bitmap) {							bmBitsSize = SIZEOF(bmBits);							bmWidth = formOop.pointers[1];							bmHeight = formOop.pointers[2];							bmDepth = formOop.pointers[3];							if ((bmWidth >= 0) && (bmHeight >= 0)) {								if ((((((bmDepth === 32) || (bmDepth === 8)) || (bmDepth === 16)) || (bmDepth === 1)) || (bmDepth === 2)) || (bmDepth === 4)) {									if ((cmSize === 0) || (cmSize === (SHL(1, bmDepth)))) {										ppw = Math.trunc(32 / bmDepth);										bmRaster = Math.trunc((ppw + bmWidth - 1) / ppw);										if (bmBitsSize === (bmRaster * bmHeight)) {											/* begin allocateBitmapFill:colormap: */											fillSize1 = cmSize + 18;											if (B2DPlugin.allocateObjEntry(fillSize1)) {												fill1 = objUsed;												objUsed = fill1 + fillSize1;												objBuffer[fill1] = 1024;												objBuffer[fill1 + 2] = 0;												objBuffer[fill1 + 1] = fillSize1;												cm1 = PTR_ADD(objBuffer, fill1 + 18);												if (workBuffer[17] !== 0) {													for (i2 = 0; i2 < cmSize; i2++) {														/* begin transformColor: */														fillIndex1 = cmBits[i2];														if ((fillIndex1 === 0) || ((UBANDM(fillIndex1, 2130706432)) !== 0)) {															b1 = UBANDS(fillIndex1, 255);															g1 = UBANDS((fillIndex1 >>> 8), 255);															r1 = UBANDS((fillIndex1 >>> 16), 255);															a1 = UBANDS((fillIndex1 >>> 24), 255);															if (workBuffer[17] !== 0) {																transform1 = FPTR_ADD(workBuffer, 24);																alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;																r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);																g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);																b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);																a1 = a1 * alphaScale1|0;																r1 = Math.max(r1, 0);																r1 = Math.min(r1, 255);																g1 = Math.max(g1, 0);																g1 = Math.min(g1, 255);																b1 = Math.max(b1, 0);																b1 = Math.min(b1, 255);																a1 = Math.max(a1, 0);																a1 = Math.min(a1, 255);															}															if (a1 < 1) {																arg211 = 0;															} else {																if ((a1 < 255) && (workBuffer[63] !== 0)) {																	/* begin stopBecauseOf: */																	workBuffer[64] = 3;																	engineStopped = true;																	/* end stopBecauseOf: */																}																arg211 = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);															}														} else {															arg211 = fillIndex1;														}														/* end transformColor: */														cm1[i2] = arg211;													}												} else {													for (i11 = 0; i11 < cmSize; i11++) {														cm1[i11] = cmBits[i11];													}												}												objBuffer[fill1 + 15] = cmSize;												bmFill = fill1;											} else {												bmFill = 0;											}											/* end allocateBitmapFill:colormap: */											if (engineStopped) {												fill = null;											} else {												objBuffer[bmFill + 10] = bmWidth;												objBuffer[bmFill + 11] = bmHeight;												objBuffer[bmFill + 12] = bmDepth;												objBuffer[bmFill + 14] = bmRaster;												objBuffer[bmFill + 13] = bmBitsSize;												objBuffer[bmFill + 16] = tileFlag1;												objBuffer[bmFill + 2] = xIndex1;												/* begin loadFillOrientation:from:along:normal:width:height: */												point2[0] += point1[0];												point2[1] += point1[1];												point3[0] += point1[0];												point3[1] += point1[1];												/* begin transformPoint: */												if (workBuffer[16] !== 0) {													/* begin transformPoint:into: */													/* begin transformPointX:y:into: */													xValue3 = (point1[0]|0);													yValue3 = (point1[1]|0);													dstPoint13 = point1;													transform4 = FPTR_ADD(workBuffer, 18);													x3 = (((((transform4[0] * xValue3) + (transform4[1] * yValue3)) + transform4[2]) * workBuffer[48]) | 0);													y3 = (((((transform4[3] * xValue3) + (transform4[4] * yValue3)) + transform4[5]) * workBuffer[48]) | 0);													dstPoint13[0] = x3;													dstPoint13[1] = y3;													/* end transformPointX:y:into: */													/* end transformPoint:into: */												} else {													point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);													point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);												}												/* end transformPoint: */												/* begin transformPoint: */												if (workBuffer[16] !== 0) {													/* begin transformPoint:into: */													/* begin transformPointX:y:into: */													xValue11 = (point2[0]|0);													yValue11 = (point2[1]|0);													dstPoint111 = point2;													transform12 = FPTR_ADD(workBuffer, 18);													x11 = (((((transform12[0] * xValue11) + (transform12[1] * yValue11)) + transform12[2]) * workBuffer[48]) | 0);													y11 = (((((transform12[3] * xValue11) + (transform12[4] * yValue11)) + transform12[5]) * workBuffer[48]) | 0);													dstPoint111[0] = x11;													dstPoint111[1] = y11;													/* end transformPointX:y:into: */													/* end transformPoint:into: */												} else {													point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);													point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);												}												/* end transformPoint: */												/* begin transformPoint: */												if (workBuffer[16] !== 0) {													/* begin transformPoint:into: */													/* begin transformPointX:y:into: */													xValue21 = (point3[0]|0);													yValue21 = (point3[1]|0);													dstPoint121 = point3;													transform21 = FPTR_ADD(workBuffer, 18);													x21 = (((((transform21[0] * xValue21) + (transform21[1] * yValue21)) + transform21[2]) * workBuffer[48]) | 0);													y21 = (((((transform21[3] * xValue21) + (transform21[4] * yValue21)) + transform21[5]) * workBuffer[48]) | 0);													dstPoint121[0] = x21;													dstPoint121[1] = y21;													/* end transformPointX:y:into: */													/* end transformPoint:into: */												} else {													point3[0] = ((point3[0] + workBuffer[46]) * workBuffer[48]);													point3[1] = ((point3[1] + workBuffer[47]) * workBuffer[48]);												}												/* end transformPoint: */												dirX1 = point2[0] - point1[0];												dirY1 = point2[1] - point1[1];												nrmX1 = point3[0] - point1[0];												nrmY1 = point3[1] - point1[1];												dsLength21 = (dirX1 * dirX1) + (dirY1 * dirY1);												if (dsLength21 > 0) {													dsX1 = ((((dirX1 * bmWidth) * 65536.0) / dsLength21) | 0);													dsY1 = ((((dirY1 * bmWidth) * 65536.0) / dsLength21) | 0);												} else {													dsX1 = 0;													dsY1 = 0;												}												dtLength21 = (nrmX1 * nrmX1) + (nrmY1 * nrmY1);												if (dtLength21 > 0) {													dtX1 = ((((nrmX1 * bmHeight) * 65536.0) / dtLength21) | 0);													dtY1 = ((((nrmY1 * bmHeight) * 65536.0) / dtLength21) | 0);												} else {													dtX1 = 0;													dtY1 = 0;												}												objBuffer[bmFill + 4] = point1[0];												objBuffer[bmFill + 5] = point1[1];												objBuffer[bmFill + 6] = dsX1;												objBuffer[bmFill + 7] = dsY1;												objBuffer[bmFill + 8] = dtX1;												objBuffer[bmFill + 9] = dtY1;												/* end loadFillOrientation:from:along:normal:width:height: */												fill = bmFill;											}										} else {											throw Object.create(PrimitiveFailed).setPayload(1);										}									} else {										throw Object.create(PrimitiveFailed).setPayload(1);									}								} else {									throw Object.create(PrimitiveFailed).setPayload(1);								}							} else {								throw Object.create(PrimitiveFailed).setPayload(1);							}						} else {							throw Object.create(PrimitiveFailed).setPayload(1);						}					}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	/* end loadBitmapFill:colormap:tile:from:along:normal:xIndex: */	if (engineStopped) {		/* Make sure the stack is okay */		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(((fill >>> 0) !== fill.valueOf() ? PrimitiveFailed.signal() : (fill >= 0 ? fill : 4294967296 + fill)));}, primitiveAddCompressedShape(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList) {	let failureCode;	let pointsShort;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 7) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (typeof fillIndexList === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof lineFills === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof lineWidths === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof rightFills === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof leftFills === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof nSegments === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof points === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!B2DPlugin.checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList)) {		throw Object.create(PrimitiveFailed).setPayload(120);	}	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + (16 * nSegments) + 128) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* end needAvailableSpace: */	/* Then actually load the compressed shape */	pointsShort = SIZEOF(points) === (nSegments * 3);	B2DPlugin.loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points.wordsAsInt32Array(), nSegments, leftFills.wordsAsInt32Array(), rightFills.wordsAsInt32Array(), lineWidths.wordsAsInt32Array(), lineFills.wordsAsInt32Array(), fillIndexList.wordsAsInt32Array(), pointsShort);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddGradientFill(rampOop, originOop, dirOop, nrmOop, _arg5) {	let failureCode;	let fill;	let isRadial;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	isRadial = (typeof _arg5 === "boolean" ? _arg5 : PrimitiveFailed.signal());	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), originOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), dirOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 84), nrmOop);	fill = B2DPlugin.loadGradientFillfromalongnormalisRadial(rampOop, PTR_ADD(workBuffer, 80), PTR_ADD(workBuffer, 82), PTR_ADD(workBuffer, 84), isRadial);	if (engineStopped) {		/* Make sure the stack is okay */		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(((fill >>> 0) !== fill.valueOf() ? PrimitiveFailed.signal() : (fill >= 0 ? fill : 4294967296 + fill)));}, primitiveAddLine(startOop, endOop, _arg3, _arg4) {	let failureCode;	let leftFill;	let rightFill;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform4;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform11;	let x1;	let y1;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	rightFill = (_arg4 >>> 0) === _arg4.valueOf() ? _arg4 : PrimitiveFailed.signal();	leftFill = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	if (typeof endOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof startOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(leftFill) && (B2DPlugin.isFillOkay(rightFill)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), startOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), endOop);	/* begin transformPoints: */	/* begin transformPoint: */point = PTR_ADD(workBuffer, 80);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue = (point[0]|0);	yValue = (point[1]|0);	dstPoint1 = point;	transform4 = FPTR_ADD(workBuffer, 18);	x = (((((transform4[0] * xValue) + (transform4[1] * yValue)) + transform4[2]) * workBuffer[48]) | 0);	y = (((((transform4[3] * xValue) + (transform4[4] * yValue)) + transform4[5]) * workBuffer[48]) | 0);	dstPoint1[0] = x;	dstPoint1[1] = y;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);	point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point1 = PTR_ADD(workBuffer, 82);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue1 = (point1[0]|0);	yValue1 = (point1[1]|0);	dstPoint11 = point1;	transform11 = FPTR_ADD(workBuffer, 18);	x1 = (((((transform11[0] * xValue1) + (transform11[1] * yValue1)) + transform11[2]) * workBuffer[48]) | 0);	y1 = (((((transform11[3] * xValue1) + (transform11[4] * yValue1)) + transform11[5]) * workBuffer[48]) | 0);	dstPoint11[0] = x1;	dstPoint11[1] = y1;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);	point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* end transformPoints: */	/* begin transformColor: */	if ((leftFill === 0) || ((UBANDM(leftFill, 2130706432)) !== 0)) {		b = UBANDS(leftFill, 255);		g = UBANDS((leftFill >>> 8), 255);		r = UBANDS((leftFill >>> 16), 255);		a = UBANDS((leftFill >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			leftFill = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			leftFill = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	}	/* end transformColor: */	/* begin transformColor: */	if ((rightFill === 0) || ((UBANDM(rightFill, 2130706432)) !== 0)) {		b1 = UBANDS(rightFill, 255);		g1 = UBANDS((rightFill >>> 8), 255);		r1 = UBANDS((rightFill >>> 16), 255);		a1 = UBANDS((rightFill >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			rightFill = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			rightFill = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	}	/* end transformColor: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */	p1 = PTR_ADD(workBuffer, 80);	p2 = PTR_ADD(workBuffer, 82);	/* begin allocateLine */if (B2DPlugin.allocateObjEntry(16)) {	line1 = objUsed;	objUsed = line1 + 16;	objBuffer[line1] = 4;	objBuffer[line1 + 2] = 0;	objBuffer[line1 + 1] = 16;	line = line1;} else {	line = 0;}/* end allocateLine */offset = 0;	if (!engineStopped) {		/* begin loadLine:from:to:offset:leftFill:rightFill: */		if (p1[1] <= p2[1]) {			p11 = p1;			p21 = p2;			yDir = 1;		} else {			p11 = p2;			p21 = p1;			yDir = -1;		}		objBuffer[line + 4] = p11[0];		objBuffer[line + 5] = (p11[1] - offset);		objBuffer[line + 6] = workBuffer[113];		objBuffer[line + 8] = leftFill;		objBuffer[line + 9] = rightFill;		objBuffer[line + 14] = p21[0];		objBuffer[line + 15] = (p21[1] - offset);		objBuffer[line + 11] = yDir;		/* end loadLine:from:to:offset:leftFill:rightFill: */		if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {			objBuffer[line + 16] = 0;			objBuffer[line + 17] = 0;			objBuffer[line + 20] = 0;		}	}	/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddOval(startOop, endOop, _arg3, borderWidth, _arg5) {	let borderIndex;	let failureCode;	let fillIndex;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	borderIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	if (!(typeof borderWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	if (typeof endOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof startOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(borderIndex) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	/* begin transformColor: */	if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {		b = UBANDS(fillIndex, 255);		g = UBANDS((fillIndex >>> 8), 255);		r = UBANDS((fillIndex >>> 16), 255);		a = UBANDS((fillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			fillIndex = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			fillIndex = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	}	/* end transformColor: */	/* begin transformColor: */	if ((borderIndex === 0) || ((UBANDM(borderIndex, 2130706432)) !== 0)) {		b1 = UBANDS(borderIndex, 255);		g1 = UBANDS((borderIndex >>> 8), 255);		r1 = UBANDS((borderIndex >>> 16), 255);		a1 = UBANDS((borderIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			borderIndex = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			borderIndex = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	}	/* end transformColor: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if ((fillIndex === 0) && ((borderIndex === 0) || (borderWidth <= 0))) {		return null;	}	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 384) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* end needAvailableSpace: */	borderWidth = ((borderWidth > 0) && (borderIndex !== 0)) ? B2DPlugin.transformWidth(borderWidth) : 0;	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), startOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), endOop);	B2DPlugin.loadOvallineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);	if (engineStopped) {		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddPolygon(points, nPoints, _arg3, lineWidth, _arg5) {	let failureCode;	let fillIndex;	let length;	let lineFill;	let pointsIsArray;	let segSize;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let i;	let x0;	let x1;	let y0;	let y1;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform4;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform11;	let x11;	let y11;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	let returnValueFromLoop_loadArrayPolygonnPointsfilllineWidthlineFill_949;	let brokenFromLoop_loadArrayPolygonnPointsfilllineWidthlineFill_949;	let points1;	let isShort;	let i1;	let x01;	let x12;	let y01;	let y12;	let p12;	let p22;	let line3;	let offset1;	let line11;	let line21;	let p111;	let p211;	let yDir1;	let point4;	let xValue4;	let yValue4;	let dstPoint14;	let transform5;	let x4;	let y4;	let point11;	let xValue11;	let yValue11;	let dstPoint111;	let transform12;	let x111;	let y111;	let point21;	let xValue21;	let yValue21;	let dstPoint121;	let transform21;	let x21;	let y21;	let point31;	let xValue31;	let yValue31;	let dstPoint131;	let transform31;	let x31;	let y31;	let returnValueFromLoop_loadPolygonnPointsfilllineWidthlineFillpointsShort_1978;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	lineFill = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	if (!(typeof lineWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	if (!(typeof nPoints === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof points === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	length = SIZEOF(points);	if ((points.storageType === "words")) {		/* Either PointArray or ShortPointArray */		pointsIsArray = false;		if (!((length === nPoints) || ((nPoints * 2) === length))) {			throw Object.create(PrimitiveFailed).setPayload(3);		}	} else {		/* Must be Array of points */		if ((points.storageType !== "pointers" || points.instSize !== 0)) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		if (length !== nPoints) {			throw Object.create(PrimitiveFailed).setPayload(3);		}		pointsIsArray = true;	}	segSize = ((lineWidth === 0) || (lineFill === 0)) ? 16 : 21;	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + (segSize * nPoints) + 128) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end needAvailableSpace: */	if (!(B2DPlugin.isFillOkay(lineFill) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	/* begin transformColor: */	if ((lineFill === 0) || ((UBANDM(lineFill, 2130706432)) !== 0)) {		b = UBANDS(lineFill, 255);		g = UBANDS((lineFill >>> 8), 255);		r = UBANDS((lineFill >>> 16), 255);		a = UBANDS((lineFill >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			lineFill = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			lineFill = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	}	/* end transformColor: */	/* begin transformColor: */	if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {		b1 = UBANDS(fillIndex, 255);		g1 = UBANDS((fillIndex >>> 8), 255);		r1 = UBANDS((fillIndex >>> 16), 255);		a1 = UBANDS((fillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			fillIndex = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			fillIndex = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	}	/* end transformColor: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (((lineFill === 0) || (lineWidth === 0)) && (fillIndex === 0)) {		return null;	}	if (lineWidth !== 0) {		lineWidth = B2DPlugin.transformWidth(lineWidth);	}	if (pointsIsArray) {		/* begin loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */		B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), points.pointers[0]);			x0 = PTR_ADD(workBuffer, 80)[0];	y0 = PTR_ADD(workBuffer, 80)[1];	brokenFromLoop_loadArrayPolygonnPointsfilllineWidthlineFill_949 = false;	for (i = 1; i < nPoints; i++) {		B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), points.pointers[i]);		x1 = PTR_ADD(workBuffer, 80)[0];		y1 = PTR_ADD(workBuffer, 80)[1];		PTR_ADD(workBuffer, 80)[0] = x0;		PTR_ADD(workBuffer, 80)[1] = y0;		PTR_ADD(workBuffer, 82)[0] = x1;		PTR_ADD(workBuffer, 82)[1] = y1;		/* begin transformPoints: */			/* begin transformPoint: */	point = PTR_ADD(workBuffer, 80);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue = (point[0]|0);		yValue = (point[1]|0);		dstPoint1 = point;		transform4 = FPTR_ADD(workBuffer, 18);		x = (((((transform4[0] * xValue) + (transform4[1] * yValue)) + transform4[2]) * workBuffer[48]) | 0);		y = (((((transform4[3] * xValue) + (transform4[4] * yValue)) + transform4[5]) * workBuffer[48]) | 0);		dstPoint1[0] = x;		dstPoint1[1] = y;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);		point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */			/* begin transformPoint: */	point1 = PTR_ADD(workBuffer, 82);	if (workBuffer[16] !== 0) {		/* begin transformPoint:into: */		/* begin transformPointX:y:into: */		xValue1 = (point1[0]|0);		yValue1 = (point1[1]|0);		dstPoint11 = point1;		transform11 = FPTR_ADD(workBuffer, 18);		x11 = (((((transform11[0] * xValue1) + (transform11[1] * yValue1)) + transform11[2]) * workBuffer[48]) | 0);		y11 = (((((transform11[3] * xValue1) + (transform11[4] * yValue1)) + transform11[5]) * workBuffer[48]) | 0);		dstPoint11[0] = x11;		dstPoint11[1] = y11;		/* end transformPointX:y:into: */		/* end transformPoint:into: */	} else {		point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);		point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);	}	/* end transformPoint: */		/* end transformPoints: */		/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */		p1 = PTR_ADD(workBuffer, 80);		p2 = PTR_ADD(workBuffer, 82);		if ((lineWidth === 0) || (lineFill === 0)) {			/* begin allocateLine */			if (B2DPlugin.allocateObjEntry(16)) {				line1 = objUsed;				objUsed = line1 + 16;				objBuffer[line1] = 4;				objBuffer[line1 + 2] = 0;				objBuffer[line1 + 1] = 16;				line = line1;			} else {				line = 0;			}			/* end allocateLine */			offset = 0;		} else {			/* begin allocateWideLine */			if (B2DPlugin.allocateObjEntry(21)) {				line2 = objUsed;				objUsed = line2 + 21;				objBuffer[line2] = 5;				objBuffer[line2 + 2] = 0;				objBuffer[line2 + 1] = 21;				line = line2;			} else {				line = 0;			}			/* end allocateWideLine */			offset = lineWidth >> 1;		}		if (!engineStopped) {			/* begin loadLine:from:to:offset:leftFill:rightFill: */			if (p1[1] <= p2[1]) {				p11 = p1;				p21 = p2;				yDir = 1;			} else {				p11 = p2;				p21 = p1;				yDir = -1;			}			objBuffer[line + 4] = p11[0];			objBuffer[line + 5] = (p11[1] - offset);			objBuffer[line + 6] = workBuffer[113];			objBuffer[line + 8] = fillIndex;			objBuffer[line + 9] = 0;			objBuffer[line + 14] = p21[0];			objBuffer[line + 15] = (p21[1] - offset);			objBuffer[line + 11] = yDir;			/* end loadLine:from:to:offset:leftFill:rightFill: */			if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {				objBuffer[line + 16] = lineFill;				objBuffer[line + 17] = lineWidth;				objBuffer[line + 20] = lineWidth;			}		}		/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */		if (engineStopped) {			returnValueFromLoop_loadArrayPolygonnPointsfilllineWidthlineFill_949 = null;			brokenFromLoop_loadArrayPolygonnPointsfilllineWidthlineFill_949 = true;			break;		} else {			x0 = x1;			y0 = y1;		}	}		/* end loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */	} else {		/* begin loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */		points1 = points.wordsAsInt32Array();		isShort = nPoints === length;		if (isShort) {			x01 = (points1.int16Array || (points1.int16Array = new Int16Array(points1.buffer, points1.byteOffset)))[0];			y01 = (points1.int16Array || (points1.int16Array = new Int16Array(points1.buffer, points1.byteOffset)))[1];		} else {			x01 = (points1[0]|0);			y01 = (points1[1]|0);		}		for (i1 = 1; i1 < nPoints; i1++) {			if (isShort) {				x12 = (points1.int16Array || (points1.int16Array = new Int16Array(points1.buffer, points1.byteOffset)))[i1 * 2];				y12 = (points1.int16Array || (points1.int16Array = new Int16Array(points1.buffer, points1.byteOffset)))[(i1 * 2) + 1];			} else {				x12 = (points1[(i1 * 2)]|0);				y12 = (points1[((i1 * 2) + 1)]|0);			}			PTR_ADD(workBuffer, 80)[0] = x01;			PTR_ADD(workBuffer, 80)[1] = y01;			PTR_ADD(workBuffer, 82)[0] = x12;			PTR_ADD(workBuffer, 82)[1] = y12;			/* begin transformPoints: */					/* begin transformPoint: */		point4 = PTR_ADD(workBuffer, 80);		if (workBuffer[16] !== 0) {			/* begin transformPoint:into: */			/* begin transformPointX:y:into: */			xValue4 = (point4[0]|0);			yValue4 = (point4[1]|0);			dstPoint14 = point4;			transform5 = FPTR_ADD(workBuffer, 18);			x4 = (((((transform5[0] * xValue4) + (transform5[1] * yValue4)) + transform5[2]) * workBuffer[48]) | 0);			y4 = (((((transform5[3] * xValue4) + (transform5[4] * yValue4)) + transform5[5]) * workBuffer[48]) | 0);			dstPoint14[0] = x4;			dstPoint14[1] = y4;			/* end transformPointX:y:into: */			/* end transformPoint:into: */		} else {			point4[0] = ((point4[0] + workBuffer[46]) * workBuffer[48]);			point4[1] = ((point4[1] + workBuffer[47]) * workBuffer[48]);		}		/* end transformPoint: */					/* begin transformPoint: */		point11 = PTR_ADD(workBuffer, 82);		if (workBuffer[16] !== 0) {			/* begin transformPoint:into: */			/* begin transformPointX:y:into: */			xValue11 = (point11[0]|0);			yValue11 = (point11[1]|0);			dstPoint111 = point11;			transform12 = FPTR_ADD(workBuffer, 18);			x111 = (((((transform12[0] * xValue11) + (transform12[1] * yValue11)) + transform12[2]) * workBuffer[48]) | 0);			y111 = (((((transform12[3] * xValue11) + (transform12[4] * yValue11)) + transform12[5]) * workBuffer[48]) | 0);			dstPoint111[0] = x111;			dstPoint111[1] = y111;			/* end transformPointX:y:into: */			/* end transformPoint:into: */		} else {			point11[0] = ((point11[0] + workBuffer[46]) * workBuffer[48]);			point11[1] = ((point11[1] + workBuffer[47]) * workBuffer[48]);		}		/* end transformPoint: */			/* end transformPoints: */			/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */			p12 = PTR_ADD(workBuffer, 80);			p22 = PTR_ADD(workBuffer, 82);			if ((lineWidth === 0) || (lineFill === 0)) {				/* begin allocateLine */				if (B2DPlugin.allocateObjEntry(16)) {					line11 = objUsed;					objUsed = line11 + 16;					objBuffer[line11] = 4;					objBuffer[line11 + 2] = 0;					objBuffer[line11 + 1] = 16;					line3 = line11;				} else {					line3 = 0;				}				/* end allocateLine */				offset1 = 0;			} else {				/* begin allocateWideLine */				if (B2DPlugin.allocateObjEntry(21)) {					line21 = objUsed;					objUsed = line21 + 21;					objBuffer[line21] = 5;					objBuffer[line21 + 2] = 0;					objBuffer[line21 + 1] = 21;					line3 = line21;				} else {					line3 = 0;				}				/* end allocateWideLine */				offset1 = lineWidth >> 1;			}			if (!engineStopped) {				/* begin loadLine:from:to:offset:leftFill:rightFill: */				if (p12[1] <= p22[1]) {					p111 = p12;					p211 = p22;					yDir1 = 1;				} else {					p111 = p22;					p211 = p12;					yDir1 = -1;				}				objBuffer[line3 + 4] = p111[0];				objBuffer[line3 + 5] = (p111[1] - offset1);				objBuffer[line3 + 6] = workBuffer[113];				objBuffer[line3 + 8] = fillIndex;				objBuffer[line3 + 9] = 0;				objBuffer[line3 + 14] = p211[0];				objBuffer[line3 + 15] = (p211[1] - offset1);				objBuffer[line3 + 11] = yDir1;				/* end loadLine:from:to:offset:leftFill:rightFill: */				if ((UBANDS((UBANDS(objBuffer[line3], 65535)), 1)) !== 0) {					objBuffer[line3 + 16] = lineFill;					objBuffer[line3 + 17] = lineWidth;					objBuffer[line3 + 20] = lineWidth;				}			}			/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */			if (engineStopped) {				returnValueFromLoop_loadPolygonnPointsfilllineWidthlineFillpointsShort_1978 = null;				break;			} else {				x01 = x12;				y01 = y12;			}		}		/* end loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */	}	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveAddRect(startOop, endOop, _arg3, borderWidth, _arg5) {	let borderIndex;	let failureCode;	let fillIndex;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	let p1;	let p2;	let line;	let offset;	let line1;	let line2;	let p11;	let p21;	let yDir;	let p12;	let p22;	let line3;	let offset1;	let line11;	let line21;	let p111;	let p211;	let yDir1;	let p13;	let p23;	let line4;	let offset2;	let line12;	let line22;	let p112;	let p212;	let yDir2;	let p14;	let p24;	let line5;	let offset3;	let line13;	let line23;	let p113;	let p213;	let yDir3;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform4;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform11;	let x1;	let y1;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	/* Fail if we have the wrong number of arguments */	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	borderIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	if (!(typeof borderWidth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	fillIndex = (_arg3 >>> 0) === _arg3.valueOf() ? _arg3 : PrimitiveFailed.signal();	if (typeof endOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof startOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(B2DPlugin.isFillOkay(borderIndex) && (B2DPlugin.isFillOkay(fillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	/* begin transformColor: */	if ((borderIndex === 0) || ((UBANDM(borderIndex, 2130706432)) !== 0)) {		b = UBANDS(borderIndex, 255);		g = UBANDS((borderIndex >>> 8), 255);		r = UBANDS((borderIndex >>> 16), 255);		a = UBANDS((borderIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			borderIndex = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			borderIndex = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	}	/* end transformColor: */	/* begin transformColor: */	if ((fillIndex === 0) || ((UBANDM(fillIndex, 2130706432)) !== 0)) {		b1 = UBANDS(fillIndex, 255);		g1 = UBANDS((fillIndex >>> 8), 255);		r1 = UBANDS((fillIndex >>> 16), 255);		a1 = UBANDS((fillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			fillIndex = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			fillIndex = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	}	/* end transformColor: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if ((fillIndex === 0) && ((borderIndex === 0) || (borderWidth === 0))) {		return null;	}	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 192) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		throw Object.create(PrimitiveFailed).setPayload(111);	}	/* end needAvailableSpace: */	borderWidth = ((borderWidth > 0) && (borderIndex !== 0)) ? B2DPlugin.transformWidth(borderWidth) : 0;	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), startOop);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 84), endOop);	PTR_ADD(workBuffer, 82)[0] = PTR_ADD(workBuffer, 84)[0];	PTR_ADD(workBuffer, 82)[1] = PTR_ADD(workBuffer, 80)[1];	PTR_ADD(workBuffer, 86)[0] = PTR_ADD(workBuffer, 80)[0];	PTR_ADD(workBuffer, 86)[1] = PTR_ADD(workBuffer, 84)[1];	/* begin transformPoints: */	/* begin transformPoint: */point = PTR_ADD(workBuffer, 80);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue = (point[0]|0);	yValue = (point[1]|0);	dstPoint1 = point;	transform4 = FPTR_ADD(workBuffer, 18);	x = (((((transform4[0] * xValue) + (transform4[1] * yValue)) + transform4[2]) * workBuffer[48]) | 0);	y = (((((transform4[3] * xValue) + (transform4[4] * yValue)) + transform4[5]) * workBuffer[48]) | 0);	dstPoint1[0] = x;	dstPoint1[1] = y;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);	point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point1 = PTR_ADD(workBuffer, 82);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue1 = (point1[0]|0);	yValue1 = (point1[1]|0);	dstPoint11 = point1;	transform11 = FPTR_ADD(workBuffer, 18);	x1 = (((((transform11[0] * xValue1) + (transform11[1] * yValue1)) + transform11[2]) * workBuffer[48]) | 0);	y1 = (((((transform11[3] * xValue1) + (transform11[4] * yValue1)) + transform11[5]) * workBuffer[48]) | 0);	dstPoint11[0] = x1;	dstPoint11[1] = y1;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);	point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point2 = PTR_ADD(workBuffer, 84);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue2 = (point2[0]|0);	yValue2 = (point2[1]|0);	dstPoint12 = point2;	transform2 = FPTR_ADD(workBuffer, 18);	x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);	y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);	dstPoint12[0] = x2;	dstPoint12[1] = y2;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);	point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point3 = PTR_ADD(workBuffer, 86);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue3 = (point3[0]|0);	yValue3 = (point3[1]|0);	dstPoint13 = point3;	transform3 = FPTR_ADD(workBuffer, 18);	x3 = (((((transform3[0] * xValue3) + (transform3[1] * yValue3)) + transform3[2]) * workBuffer[48]) | 0);	y3 = (((((transform3[3] * xValue3) + (transform3[4] * yValue3)) + transform3[5]) * workBuffer[48]) | 0);	dstPoint13[0] = x3;	dstPoint13[1] = y3;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point3[0] = ((point3[0] + workBuffer[46]) * workBuffer[48]);	point3[1] = ((point3[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* end transformPoints: */	/* begin loadRectangle:lineFill:leftFill:rightFill: */	/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */	p1 = PTR_ADD(workBuffer, 80);	p2 = PTR_ADD(workBuffer, 82);	if ((borderWidth === 0) || (borderIndex === 0)) {		/* begin allocateLine */		if (B2DPlugin.allocateObjEntry(16)) {			line1 = objUsed;			objUsed = line1 + 16;			objBuffer[line1] = 4;			objBuffer[line1 + 2] = 0;			objBuffer[line1 + 1] = 16;			line = line1;		} else {			line = 0;		}		/* end allocateLine */		offset = 0;	} else {		/* begin allocateWideLine */		if (B2DPlugin.allocateObjEntry(21)) {			line2 = objUsed;			objUsed = line2 + 21;			objBuffer[line2] = 5;			objBuffer[line2 + 2] = 0;			objBuffer[line2 + 1] = 21;			line = line2;		} else {			line = 0;		}		/* end allocateWideLine */		offset = borderWidth >> 1;	}	if (!engineStopped) {		/* begin loadLine:from:to:offset:leftFill:rightFill: */		if (p1[1] <= p2[1]) {			p11 = p1;			p21 = p2;			yDir = 1;		} else {			p11 = p2;			p21 = p1;			yDir = -1;		}		objBuffer[line + 4] = p11[0];		objBuffer[line + 5] = (p11[1] - offset);		objBuffer[line + 6] = workBuffer[113];		objBuffer[line + 8] = 0;		objBuffer[line + 9] = fillIndex;		objBuffer[line + 14] = p21[0];		objBuffer[line + 15] = (p21[1] - offset);		objBuffer[line + 11] = yDir;		/* end loadLine:from:to:offset:leftFill:rightFill: */		if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) !== 0) {			objBuffer[line + 16] = borderIndex;			objBuffer[line + 17] = borderWidth;			objBuffer[line + 20] = borderWidth;		}	}	/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */	/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */	p12 = PTR_ADD(workBuffer, 82);	p22 = PTR_ADD(workBuffer, 84);	if ((borderWidth === 0) || (borderIndex === 0)) {		/* begin allocateLine */		if (B2DPlugin.allocateObjEntry(16)) {			line11 = objUsed;			objUsed = line11 + 16;			objBuffer[line11] = 4;			objBuffer[line11 + 2] = 0;			objBuffer[line11 + 1] = 16;			line3 = line11;		} else {			line3 = 0;		}		/* end allocateLine */		offset1 = 0;	} else {		/* begin allocateWideLine */		if (B2DPlugin.allocateObjEntry(21)) {			line21 = objUsed;			objUsed = line21 + 21;			objBuffer[line21] = 5;			objBuffer[line21 + 2] = 0;			objBuffer[line21 + 1] = 21;			line3 = line21;		} else {			line3 = 0;		}		/* end allocateWideLine */		offset1 = borderWidth >> 1;	}	if (!engineStopped) {		/* begin loadLine:from:to:offset:leftFill:rightFill: */		if (p12[1] <= p22[1]) {			p111 = p12;			p211 = p22;			yDir1 = 1;		} else {			p111 = p22;			p211 = p12;			yDir1 = -1;		}		objBuffer[line3 + 4] = p111[0];		objBuffer[line3 + 5] = (p111[1] - offset1);		objBuffer[line3 + 6] = workBuffer[113];		objBuffer[line3 + 8] = 0;		objBuffer[line3 + 9] = fillIndex;		objBuffer[line3 + 14] = p211[0];		objBuffer[line3 + 15] = (p211[1] - offset1);		objBuffer[line3 + 11] = yDir1;		/* end loadLine:from:to:offset:leftFill:rightFill: */		if ((UBANDS((UBANDS(objBuffer[line3], 65535)), 1)) !== 0) {			objBuffer[line3 + 16] = borderIndex;			objBuffer[line3 + 17] = borderWidth;			objBuffer[line3 + 20] = borderWidth;		}	}	/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */	/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */	p13 = PTR_ADD(workBuffer, 84);	p23 = PTR_ADD(workBuffer, 86);	if ((borderWidth === 0) || (borderIndex === 0)) {		/* begin allocateLine */		if (B2DPlugin.allocateObjEntry(16)) {			line12 = objUsed;			objUsed = line12 + 16;			objBuffer[line12] = 4;			objBuffer[line12 + 2] = 0;			objBuffer[line12 + 1] = 16;			line4 = line12;		} else {			line4 = 0;		}		/* end allocateLine */		offset2 = 0;	} else {		/* begin allocateWideLine */		if (B2DPlugin.allocateObjEntry(21)) {			line22 = objUsed;			objUsed = line22 + 21;			objBuffer[line22] = 5;			objBuffer[line22 + 2] = 0;			objBuffer[line22 + 1] = 21;			line4 = line22;		} else {			line4 = 0;		}		/* end allocateWideLine */		offset2 = borderWidth >> 1;	}	if (!engineStopped) {		/* begin loadLine:from:to:offset:leftFill:rightFill: */		if (p13[1] <= p23[1]) {			p112 = p13;			p212 = p23;			yDir2 = 1;		} else {			p112 = p23;			p212 = p13;			yDir2 = -1;		}		objBuffer[line4 + 4] = p112[0];		objBuffer[line4 + 5] = (p112[1] - offset2);		objBuffer[line4 + 6] = workBuffer[113];		objBuffer[line4 + 8] = 0;		objBuffer[line4 + 9] = fillIndex;		objBuffer[line4 + 14] = p212[0];		objBuffer[line4 + 15] = (p212[1] - offset2);		objBuffer[line4 + 11] = yDir2;		/* end loadLine:from:to:offset:leftFill:rightFill: */		if ((UBANDS((UBANDS(objBuffer[line4], 65535)), 1)) !== 0) {			objBuffer[line4 + 16] = borderIndex;			objBuffer[line4 + 17] = borderWidth;			objBuffer[line4 + 20] = borderWidth;		}	}	/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */	/* begin loadWideLine:from:to:lineFill:leftFill:rightFill: */	p14 = PTR_ADD(workBuffer, 86);	p24 = PTR_ADD(workBuffer, 80);	if ((borderWidth === 0) || (borderIndex === 0)) {		/* begin allocateLine */		if (B2DPlugin.allocateObjEntry(16)) {			line13 = objUsed;			objUsed = line13 + 16;			objBuffer[line13] = 4;			objBuffer[line13 + 2] = 0;			objBuffer[line13 + 1] = 16;			line5 = line13;		} else {			line5 = 0;		}		/* end allocateLine */		offset3 = 0;	} else {		/* begin allocateWideLine */		if (B2DPlugin.allocateObjEntry(21)) {			line23 = objUsed;			objUsed = line23 + 21;			objBuffer[line23] = 5;			objBuffer[line23 + 2] = 0;			objBuffer[line23 + 1] = 21;			line5 = line23;		} else {			line5 = 0;		}		/* end allocateWideLine */		offset3 = borderWidth >> 1;	}	if (!engineStopped) {		/* begin loadLine:from:to:offset:leftFill:rightFill: */		if (p14[1] <= p24[1]) {			p113 = p14;			p213 = p24;			yDir3 = 1;		} else {			p113 = p24;			p213 = p14;			yDir3 = -1;		}		objBuffer[line5 + 4] = p113[0];		objBuffer[line5 + 5] = (p113[1] - offset3);		objBuffer[line5 + 6] = workBuffer[113];		objBuffer[line5 + 8] = 0;		objBuffer[line5 + 9] = fillIndex;		objBuffer[line5 + 14] = p213[0];		objBuffer[line5 + 15] = (p213[1] - offset3);		objBuffer[line5 + 11] = yDir3;		/* end loadLine:from:to:offset:leftFill:rightFill: */		if ((UBANDS((UBANDS(objBuffer[line5], 65535)), 1)) !== 0) {			objBuffer[line5 + 16] = borderIndex;			objBuffer[line5 + 17] = borderWidth;			objBuffer[line5 + 20] = borderWidth;		}	}	/* end loadWideLine:from:to:lineFill:leftFill:rightFill: */	/* end loadRectangle:lineFill:leftFill:rightFill: */	workBuffer[63] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveChangedActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 7))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	edge = B2DPlugin.loadEdgeStateFrom(edgeOop);	if (!edge) {		throw Object.create(PrimitiveFailed).setPayload(112);	}	if (objBuffer[edge + 7] === 0) {		B2DPlugin.removeFirstAETEntry.apply(this, arguments);	} else {		B2DPlugin.resortFirstAETEntry.apply(this, arguments);		workBuffer[13]++;	}	workBuffer[2] = 6;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[107]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[106] += value;		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveCopyBuffer(buf1, buf2) {	let diff;	let dst;	let failCode;	let i;	let i1;	let src;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(buf1))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	if (buf1._class() !== buf2._class()) {		throw Object.create(PrimitiveFailed).setPayload(114);	}	diff = SIZEOF(buf2) - SIZEOF(buf1);	if (diff < 0) {		throw Object.create(PrimitiveFailed).setPayload(115);	}	src = workBuffer;	dst = buf2.wordsAsInt32Array();	const iLimiT = workBuffer[10];	for (i = 0; i < iLimiT; i++) {		dst[i] = src[i];	}	dst[10] = (workBuffer[10] + diff);	dst[1] = (workBuffer[1] + diff);	src = PTR_ADD(src, workBuffer[10]);	dst = PTR_ADD(dst, workBuffer[10] + diff);	const i1LimiT = workBuffer[1] - workBuffer[10];	for (i1 = 0; i1 < i1LimiT; i1++) {		dst[i1] = src[i1];	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(buf2))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: Must load bitBlt and spanBuffer */primitiveDisplaySpanBuffer() {	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 5))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	/* begin loadBitBltFrom: */	if (!loadBBFn) {		/* begin initialiseModule */		loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);		copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);		if ((!!loadBBFn) && (!!copyBitsFn)) {			if (!loadBBFn(engine.pointers[2])) {				throw Object.create(PrimitiveFailed).setPayload(122);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(122);		}		/* end initialiseModule */	} else {		if (!loadBBFn(engine.pointers[2])) {			throw Object.create(PrimitiveFailed).setPayload(122);		}	}	/* end loadBitBltFrom: */	if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {		B2DPlugin.displaySpanBufferAt(workBuffer[88]);		B2DPlugin.postDisplayAction.apply(this, arguments);	}	if (workBuffer[2] !== 8) {		workBuffer[13] = 0;		workBuffer[88]++;		workBuffer[2] = 6;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[103]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[102] += value;		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Turn on/off profiling. Return the old value of the flag. */primitiveDoProfileStats(newValue) {	let oldValue;	oldValue = doProfileStats;	if (typeof newValue === "number") throw Object.create(PrimitiveFailed).setPayload(1);	newValue = (typeof newValue === "boolean" ? newValue : PrimitiveFailed.signal());	doProfileStats = newValue;	throw Object.create(PrimitiveReturn).setPayload((typeof oldValue === "boolean" ? oldValue : PrimitiveFailed.signal()));}, primitiveFinishedProcessing() {	let failureCode;	let finished;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	finished = workBuffer[2] === 8;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload((typeof finished === "boolean" ? finished : PrimitiveFailed.signal()));}, primitiveGetAALevel() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[48]));}, primitiveGetBezierStats(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof statOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(((statOop.storageType === "words") && (SIZEOF(statOop) >= 4)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] += workBuffer[108];	stats[1] += workBuffer[109];	stats[2] += workBuffer[110];	stats[3] += workBuffer[111];	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveGetClipRect(rectOop) {	let failureCode;	let pointOop;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof rectOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(((rectOop.storageType === "pointers") && (SIZEOF(rectOop) >= 2)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	SmalltalkVM.pushRemappableOop(rectOop);	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[42], workBuffer[44]);	SmalltalkVM.topRemappableOop().pointers[0] = pointOop;	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[43], workBuffer[45]);	rectOop = SmalltalkVM.popRemappableOop();	rectOop.pointers[1] = pointOop;	throw Object.create(PrimitiveReturn).setPayload(rectOop);}, primitiveGetCounts(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof statOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(((statOop.storageType === "words") && (SIZEOF(statOop) >= 9)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] += workBuffer[91];	stats[1] += workBuffer[93];	stats[2] += workBuffer[95];	stats[3] += workBuffer[97];	stats[4] += workBuffer[99];	stats[5] += workBuffer[101];	stats[6] += workBuffer[103];	stats[7] += workBuffer[105];	stats[8] += workBuffer[107];	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveGetDepth() {	let failureCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[113]));}, /*	Return the reason why the last operation failed. */primitiveGetFailureReason() {	let failCode;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	/* Note -- don't call loadEngineFrom here because this will override the stopReason with Zero */	engine = this;	if ((typeof engine === "number")) {		throw Object.create(PrimitiveFailed).setPayload(101);	}	if ((engine.storageType !== "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(102);	}	if (SIZEOF(engine) < 12) {		throw Object.create(PrimitiveFailed).setPayload(103);	}	if (((failCode = B2DPlugin.loadWorkBufferFrom(engine.pointers[0]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[64]));}, primitiveGetOffset() {	let failureCode;	let pointOop;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	pointOop = SmalltalkVM.makePointwithxValueyValue(workBuffer[46], workBuffer[47]);	throw Object.create(PrimitiveReturn).setPayload(pointOop);}, primitiveGetTimes(statOop) {	let failureCode;	let stats;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof statOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(((statOop.storageType === "words") && (SIZEOF(statOop) >= 9)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	stats = statOop.wordsAsInt32Array();	stats[0] += workBuffer[90];	stats[1] += workBuffer[92];	stats[2] += workBuffer[94];	stats[3] += workBuffer[96];	stats[4] += workBuffer[98];	stats[5] += workBuffer[100];	stats[6] += workBuffer[102];	stats[7] += workBuffer[104];	stats[8] += workBuffer[106];	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveInitializeBuffer(wbOop) {	let size;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof wbOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((wbOop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (((size = SIZEOF(wbOop))) < 256) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin workBufferPut: */	workBuffer = wbOop.wordsAsInt32Array();	/* end workBufferPut: */	objBuffer = PTR_ADD(workBuffer, 128);	workBuffer[0] = 1097753705;	workBuffer[1] = size;	workBuffer[10] = size;	workBuffer[2] = 0;	workBuffer[8] = 128;	workBuffer[9] = 4;	objBuffer[0] = 256;	objBuffer[1] = 4;	objBuffer[2] = 0;	workBuffer[11] = 0;	workBuffer[12] = 0;	workBuffer[13] = 0;	workBuffer[14] = 0;	workBuffer[64] = 0;	workBuffer[63] = 0;	workBuffer[42] = 0;	workBuffer[43] = 0;	workBuffer[44] = 0;	workBuffer[45] = 0;	workBuffer[113] = 0;	B2DPlugin.resetGraphicsEngineStats.apply(this, arguments);	B2DPlugin.initEdgeTransform.apply(this, arguments);	B2DPlugin.initColorTransform.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(wbOop);}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveInitializeProcessing() {	let failureCode;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	B2DPlugin.initializeGETProcessing.apply(this, arguments);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	workBuffer[2] = 1;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[91]++;		/* begin incrementStat:by: */		value = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[90] += value;		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveMergeFillFrom(bitsOop, fillOop) {	let failureCode;	let value;	let value1;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 4))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof fillOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof bitsOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!((bitsOop._class() === SmalltalkGlobals._Bitmap))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	if (SIZEOF(fillOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(113);	}	value = fillOop.pointers[0];	if (objBuffer[workBuffer[66] + 2] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	value = fillOop.pointers[1];	if (workBuffer[67] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	value = fillOop.pointers[2];	if (workBuffer[68] !== value) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	if (SIZEOF(bitsOop) < (workBuffer[68] - workBuffer[67])) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	B2DPlugin.fillBitmapSpanfromto(bitsOop.wordsAsInt32Array(), workBuffer[67], workBuffer[68]);	workBuffer[2] = 3;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	if (doProfileStats) {		workBuffer[101]++;		/* begin incrementStat:by: */		value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;		workBuffer[100] += value1;		/* end incrementStat:by: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveNeedsFlush() {	let failureCode;	let needFlush;	if (arguments.length !== 0) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	needFlush = workBuffer[63] !== 0;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload((typeof needFlush === "boolean" ? needFlush : PrimitiveFailed.signal()));}, primitiveNeedsFlushPut(_arg1) {	let failureCode;	let needFlush;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFrom(this))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	needFlush = (typeof _arg1 === "boolean" ? _arg1 : PrimitiveFailed.signal());	if (needFlush === true) {		workBuffer[63] = 1;	} else {		workBuffer[63] = 0;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveNextActiveEdgeEntry(edgeOop) {	let edge;	let failureCode;	let hasEdge;	let value;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredStateor(this, 6, 8))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	hasEdge = false;	if (workBuffer[2] !== 8) {		hasEdge = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (hasEdge) {			edge = aetBuffer[workBuffer[13]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);			workBuffer[2] = 7;		} else {			workBuffer[2] = 1;		}	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasEdge === "boolean" ? hasEdge : PrimitiveFailed.signal()));}, /*	Note: No need to load bitBlt but must load spanBuffer */primitiveNextFillEntry(fillOop) {	let failureCode;	let hasFill;	let value;	let arrayOop;	let bmBits;	let bmBitsSize;	let bmDepth;	let bmHeight;	let bmRaster;	let bmWidth;	let formOop;	let i;	let ppw;	let returnValueFromLoop_loadFormsFrom_3493;	let brokenFromLoop_loadFormsFrom_3493;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 3))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (((failureCode = B2DPlugin.loadSpanBufferFrom(engine.pointers[1]))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	/* begin loadFormsFrom: */	arrayOop = engine.pointers[3];	if ((arrayOop.storageType === "pointers" && arrayOop.instSize === 0)) {		formArray = arrayOop;		brokenFromLoop_loadFormsFrom_3493 = false;		const iLimiT = SIZEOF(formArray);		for (i = 0; i < iLimiT; i++) {			formOop = formArray.pointers[i];			if ((typeof formOop === "number")) {				returnValueFromLoop_loadFormsFrom_3493 = false;				brokenFromLoop_loadFormsFrom_3493 = true;				break;			} else {				if ((formOop.storageType === "pointers")) {					if (SIZEOF(formOop) < 5) {						returnValueFromLoop_loadFormsFrom_3493 = false;						brokenFromLoop_loadFormsFrom_3493 = true;						break;					} else {						bmBits = formOop.pointers[0];						if (bmBits._class() === SmalltalkGlobals._Bitmap) {							bmBitsSize = SIZEOF(bmBits);							bmWidth = formOop.pointers[1];							bmHeight = formOop.pointers[2];							bmDepth = formOop.pointers[3];							if ((bmWidth >= 0) && (bmHeight >= 0)) {								ppw = Math.trunc(32 / bmDepth);								bmRaster = Math.trunc((ppw + bmWidth - 1) / ppw);								if (bmBitsSize !== (bmRaster * bmHeight)) {									returnValueFromLoop_loadFormsFrom_3493 = false;									brokenFromLoop_loadFormsFrom_3493 = true;									break;								}							} else {								returnValueFromLoop_loadFormsFrom_3493 = false;								brokenFromLoop_loadFormsFrom_3493 = true;								break;							}						} else {							returnValueFromLoop_loadFormsFrom_3493 = false;							brokenFromLoop_loadFormsFrom_3493 = true;							break;						}					}				} else {					returnValueFromLoop_loadFormsFrom_3493 = false;					brokenFromLoop_loadFormsFrom_3493 = true;					break;				}			}		}		if (brokenFromLoop_loadFormsFrom_3493) {			if (!returnValueFromLoop_loadFormsFrom_3493) {				throw Object.create(PrimitiveFailed).setPayload(123);			}		}	} else {		throw Object.create(PrimitiveFailed).setPayload(123);	}	/* end loadFormsFrom: */	if (workBuffer[69] !== 0) {		if ((UBAND(workBuffer[88], workBuffer[52])) === 0) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;	}	if (typeof fillOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	hasFill = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	}	if (hasFill) {		B2DPlugin.storeFillStateInto(fillOop);	}	if (hasFill) {		workBuffer[2] = 4;	} else {		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;		workBuffer[2] = 5;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasFill === "boolean" ? hasFill : PrimitiveFailed.signal()));}, /*	Note: No need to load either bitBlt or spanBuffer */primitiveNextGlobalEdgeEntry(edgeOop) {	let edge;	let failureCode;	let hasEdge;	let value;	let edge1;	let type;	let yValue;	let brokenFromLoop_findNextExternalEntryFromGET_3267;	if (doProfileStats) {		geProfileTime = SmalltalkVM.ioMicroMSecs();	}	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 1))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin findNextExternalEntryFromGET */	yValue = workBuffer[88];	brokenFromLoop_findNextExternalEntryFromGET_3267 = false;	while (workBuffer[11] < workBuffer[12]) {		edge1 = getBuffer[workBuffer[11]];		if (objBuffer[edge1 + 5] > yValue) {			hasEdge = false;			brokenFromLoop_findNextExternalEntryFromGET_3267 = true;			break;		} else {			type = UBANDS(objBuffer[edge1], 65535);			if ((UBANDS(type, 254)) === 2) {				hasEdge = true;				brokenFromLoop_findNextExternalEntryFromGET_3267 = true;				break;			} else {				/* begin needAvailableSpace: */				if ((objUsed + workBuffer[12] + workBuffer[14] + 129) > workBuffer[10]) {					/* begin stopBecauseOf: */					workBuffer[64] = 1;					engineStopped = true;					/* end stopBecauseOf: */					hasEdge = false;					brokenFromLoop_findNextExternalEntryFromGET_3267 = true;					break;				} else {					switch (type) {					case 0:					case 1:					case 2:					case 3:						/* begin errorWrongIndex */						/* end errorWrongIndex */						break;					case 4:						B2DPlugin.stepToFirstLineInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 5:						B2DPlugin.stepToFirstWideLineInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 6:						B2DPlugin.stepToFirstBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					case 7:						B2DPlugin.stepToFirstWideBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);						break;					}					B2DPlugin.insertEdgeIntoAET(edge1);					workBuffer[11]++;				}				/* end needAvailableSpace: */			}		}	}	if (!brokenFromLoop_findNextExternalEntryFromGET_3267) {		hasEdge = false;	}	/* end findNextExternalEntryFromGET */	if (hasEdge) {		edge = getBuffer[workBuffer[11]];		B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);		workBuffer[11]++;	}	if (hasEdge) {		workBuffer[2] = 2;	} else {		/* Start scanning the AET */		workBuffer[2] = 3;		workBuffer[69] = 1;		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(!(typeof hasEdge === "boolean" ? hasEdge : PrimitiveFailed.signal()));}, primitiveRegisterExternalEdge(index, initialX, initialY, initialZ, _arg5, _arg6) {	let edge;	let failureCode;	let leftFillIndex;	let rightFillIndex;	let value;	let value1;	let a;	let alphaScale;	let b;	let g;	let r;	let transform;	let a1;	let alphaScale1;	let b1;	let g1;	let r1;	let transform1;	if (arguments.length !== 6) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	rightFillIndex = (_arg6 >>> 0) === _arg6.valueOf() ? _arg6 : PrimitiveFailed.signal();	leftFillIndex = (_arg5 >>> 0) === _arg5.valueOf() ? _arg5 : PrimitiveFailed.signal();	if (!(typeof initialZ === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof initialY === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof initialX === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!B2DPlugin.allocateObjEntry(10)) {		throw Object.create(PrimitiveFailed).setPayload(111);	}	if (!(B2DPlugin.isFillOkay(leftFillIndex) && (B2DPlugin.isFillOkay(rightFillIndex)))) {		throw Object.create(PrimitiveFailed).setPayload(117);	}	edge = objUsed;	/* Install type and length */	objUsed = edge + 10;	objBuffer[edge] = 2;	objBuffer[edge + 1] = 10;	objBuffer[edge + 2] = index;	objBuffer[edge + 4] = initialX;	objBuffer[edge + 5] = initialY;	objBuffer[edge + 6] = initialZ;	/* begin edgeLeftFillOf:put: */	/* begin transformColor: */	if ((leftFillIndex === 0) || ((UBANDM(leftFillIndex, 2130706432)) !== 0)) {		b = UBANDS(leftFillIndex, 255);		g = UBANDS((leftFillIndex >>> 8), 255);		r = UBANDS((leftFillIndex >>> 16), 255);		a = UBANDS((leftFillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform = FPTR_ADD(workBuffer, 24);			alphaScale = ((a * transform[6]) + transform[7]) / a;			r = ((((r * transform[0]) + transform[1]) * alphaScale) | 0);			g = ((((g * transform[2]) + transform[3]) * alphaScale) | 0);			b = ((((b * transform[4]) + transform[5]) * alphaScale) | 0);			a = a * alphaScale|0;			r = Math.max(r, 0);			r = Math.min(r, 255);			g = Math.max(g, 0);			g = Math.min(g, 255);			b = Math.max(b, 0);			b = Math.min(b, 255);			a = Math.max(a, 0);			a = Math.min(a, 255);		}		if (a < 1) {			value = 0;		} else {			if ((a < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			value = ((b + (g << 8 >>> 0)) + (r << 16 >>> 0)) + (a << 24 >>> 0);		}	} else {		value = leftFillIndex;	}	/* end transformColor: */	objBuffer[edge + 8] = value;	/* end edgeLeftFillOf:put: */	/* begin edgeRightFillOf:put: */	/* begin transformColor: */	if ((rightFillIndex === 0) || ((UBANDM(rightFillIndex, 2130706432)) !== 0)) {		b1 = UBANDS(rightFillIndex, 255);		g1 = UBANDS((rightFillIndex >>> 8), 255);		r1 = UBANDS((rightFillIndex >>> 16), 255);		a1 = UBANDS((rightFillIndex >>> 24), 255);		if (workBuffer[17] !== 0) {			transform1 = FPTR_ADD(workBuffer, 24);			alphaScale1 = ((a1 * transform1[6]) + transform1[7]) / a1;			r1 = ((((r1 * transform1[0]) + transform1[1]) * alphaScale1) | 0);			g1 = ((((g1 * transform1[2]) + transform1[3]) * alphaScale1) | 0);			b1 = ((((b1 * transform1[4]) + transform1[5]) * alphaScale1) | 0);			a1 = a1 * alphaScale1|0;			r1 = Math.max(r1, 0);			r1 = Math.min(r1, 255);			g1 = Math.max(g1, 0);			g1 = Math.min(g1, 255);			b1 = Math.max(b1, 0);			b1 = Math.min(b1, 255);			a1 = Math.max(a1, 0);			a1 = Math.min(a1, 255);		}		if (a1 < 1) {			value1 = 0;		} else {			if ((a1 < 255) && (workBuffer[63] !== 0)) {				/* begin stopBecauseOf: */				workBuffer[64] = 3;				engineStopped = true;				/* end stopBecauseOf: */			}			value1 = ((b1 + (g1 << 8 >>> 0)) + (r1 << 16 >>> 0)) + (a1 << 24 >>> 0);		}	} else {		value1 = rightFillIndex;	}	/* end transformColor: */	objBuffer[edge + 9] = value1;	/* end edgeRightFillOf:put: */	if (engineStopped) {		throw Object.create(PrimitiveFailed).setPayload(104);	} else {		/* begin storeEngineStateInto: */		workBuffer[9] = objUsed;		/* end storeEngineStateInto: */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveRegisterExternalFill(index) {	let failureCode;	let fill;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	fill = 0;	while (fill === 0) {		if (!B2DPlugin.allocateObjEntry(10)) {			throw Object.create(PrimitiveFailed).setPayload(111);		}		fill = objUsed;		/* Install type and length */		objUsed = fill + 4;		objBuffer[fill] = 256;		objBuffer[fill + 1] = 4;		objBuffer[fill + 2] = index;	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(((typeof fill === "number") ? fill : PrimitiveFailed.signal()));}, /*	Start/Proceed rendering the entire image */primitiveRenderImage() {	let failCode;	if (((failCode = B2DPlugin.loadRenderingState.apply(this, arguments))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	B2DPlugin.proceedRenderingScanline.apply(this, arguments);	if (engineStopped) {		return B2DPlugin.storeRenderingState.apply(this, arguments);	}	B2DPlugin.proceedRenderingImage.apply(this, arguments);	B2DPlugin.storeRenderingState.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Start rendering the entire image */primitiveRenderScanline() {	let failCode;	if (((failCode = B2DPlugin.loadRenderingState.apply(this, arguments))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failCode);	}	B2DPlugin.proceedRenderingScanline.apply(this, arguments);	B2DPlugin.storeRenderingState.apply(this, arguments);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetAALevel(level) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(typeof level === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	B2DPlugin.setAALevel(level);	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Set the BitBlt plugin to use. */primitiveSetBitBltPlugin(pluginName) {	let i;	let length;	let needReload;	let ptr;	if ((pluginName.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(pluginName);	if (length >= 256) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	ptr = BYTESOF(pluginName);	needReload = false;	for (i = 0; i < length; i++) {		/* Compare and store the plugin to be used */		if (bbPluginName[i] !== ptr[i]) {			bbPluginName[i] = ptr[i];			needReload = true;		}	}	if (bbPluginName[length] !== 0) {		bbPluginName[length] = 0;		needReload = true;	}	if (needReload) {		/* begin initialiseModule */		loadBBFn = SmalltalkVM.ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);		copyBitsFn = SmalltalkVM.ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);		if (!((!!loadBBFn) && (!!copyBitsFn))) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		/* end initialiseModule */	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetClipRect(rectOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof rectOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(((rectOop.storageType === "pointers") && (SIZEOF(rectOop) >= 2)))) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), rectOop.pointers[0]);	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 82), rectOop.pointers[1]);	workBuffer[42] = PTR_ADD(workBuffer, 80)[0];	workBuffer[44] = PTR_ADD(workBuffer, 80)[1];	workBuffer[43] = PTR_ADD(workBuffer, 82)[0];	workBuffer[45] = PTR_ADD(workBuffer, 82)[1];	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetColorTransform(transformOop) {	let failureCode;	let okay;	let transform;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof transformOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadColorTransformFrom: */	transform = FPTR_ADD(workBuffer, 24);	workBuffer[17] = 0;	okay = B2DPlugin.loadTransformFromintolength(transformOop, transform, 8);	if (okay) {		workBuffer[17] = 1;		transform[1] = (transform[1] * 256.0);		transform[3] = (transform[3] * 256.0);		transform[5] = (transform[5] * 256.0);		transform[7] = (transform[7] * 256.0);	}	/* end loadColorTransformFrom: */	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetDepth(depth) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (!(typeof depth === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	workBuffer[113] = depth;	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetEdgeTransform(transformOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (typeof transformOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	B2DPlugin.loadEdgeTransformFrom(transformOop);	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveSetOffset(pointOop) {	let failureCode;	if (arguments.length !== 1) {		throw Object.create(PrimitiveFailed).setPayload(5);	}	if (((failureCode = B2DPlugin.quickLoadEngineFromrequiredState(this, 0))) !== 0) {		throw Object.create(PrimitiveFailed).setPayload(failureCode);	}	if (pointOop._class() !== SmalltalkGlobals._Point) {		throw Object.create(PrimitiveFailed).setPayload(3);	}	B2DPlugin.loadPointfrom(PTR_ADD(workBuffer, 80), pointOop);	workBuffer[46] = PTR_ADD(workBuffer, 80)[0];	workBuffer[47] = PTR_ADD(workBuffer, 80)[1];	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	This is the main rendering entry */proceedRenderingImage() {	let external;	let value;	let value1;	let value2;	let value3;	let edge;	let type;	let yValue;	let brokenFromLoop_findNextExternalEntryFromGET_2612;	while (!(workBuffer[2] === 8)) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		/* begin findNextExternalEntryFromGET */		yValue = workBuffer[88];		brokenFromLoop_findNextExternalEntryFromGET_2612 = false;		while (workBuffer[11] < workBuffer[12]) {			edge = getBuffer[workBuffer[11]];			if (objBuffer[edge + 5] > yValue) {				external = false;				brokenFromLoop_findNextExternalEntryFromGET_2612 = true;				break;			} else {				type = UBANDS(objBuffer[edge], 65535);				if ((UBANDS(type, 254)) === 2) {					external = true;					brokenFromLoop_findNextExternalEntryFromGET_2612 = true;					break;				} else {					/* begin needAvailableSpace: */					if ((objUsed + workBuffer[12] + workBuffer[14] + 129) > workBuffer[10]) {						/* begin stopBecauseOf: */						workBuffer[64] = 1;						engineStopped = true;						/* end stopBecauseOf: */						external = false;						brokenFromLoop_findNextExternalEntryFromGET_2612 = true;						break;					} else {						switch (type) {						case 0:						case 1:						case 2:						case 3:							/* begin errorWrongIndex */							/* end errorWrongIndex */							break;						case 4:							B2DPlugin.stepToFirstLineInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 5:							B2DPlugin.stepToFirstWideLineInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 6:							B2DPlugin.stepToFirstBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 7:							B2DPlugin.stepToFirstWideBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						}						B2DPlugin.insertEdgeIntoAET(edge);						workBuffer[11]++;					}					/* end needAvailableSpace: */				}			}		}		if (!brokenFromLoop_findNextExternalEntryFromGET_2612) {			external = false;		}		/* end findNextExternalEntryFromGET */		if (doProfileStats) {			workBuffer[95]++;			/* begin incrementStat:by: */			value = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[94] += value;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 1;		}		if (external) {			workBuffer[2] = 2;			/* begin stopBecauseOf: */			workBuffer[64] = 4;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[69] = 1;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((workBuffer[69] !== 0) && ((UBAND(workBuffer[88], workBuffer[52])) === 0)) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;		external = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[99]++;			/* begin incrementStat:by: */			value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[98] += value1;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 3;		}		if (external) {			workBuffer[2] = 4;			/* begin stopBecauseOf: */			workBuffer[64] = 5;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {			B2DPlugin.displaySpanBufferAt(workBuffer[88]);			B2DPlugin.postDisplayAction.apply(this, arguments);		}		if (doProfileStats) {			workBuffer[103]++;			/* begin incrementStat:by: */			value2 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[102] += value2;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 5;		}		if (workBuffer[2] === 8) {			return 0;		}		workBuffer[13] = 0;		workBuffer[88]++;		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[105]++;			/* begin incrementStat:by: */			value3 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[104] += value3;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 6;		}		if (external) {			workBuffer[2] = 7;			/* begin stopBecauseOf: */			workBuffer[64] = 6;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}	}}, /*	Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween. *//*	This is the main rendering entry */proceedRenderingScanline() {	let external;	let state;	let value;	let value1;	let value2;	let value3;	let edge;	let type;	let yValue;	let brokenFromLoop_findNextExternalEntryFromGET_679;	state = workBuffer[2];	if (state === 0) {		B2DPlugin.initializeGETProcessing.apply(this, arguments);		if (engineStopped) {			return 0;		}		state = 1;	}	if (state === 1) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		/* begin findNextExternalEntryFromGET */		yValue = workBuffer[88];		brokenFromLoop_findNextExternalEntryFromGET_679 = false;		while (workBuffer[11] < workBuffer[12]) {			edge = getBuffer[workBuffer[11]];			if (objBuffer[edge + 5] > yValue) {				external = false;				brokenFromLoop_findNextExternalEntryFromGET_679 = true;				break;			} else {				type = UBANDS(objBuffer[edge], 65535);				if ((UBANDS(type, 254)) === 2) {					external = true;					brokenFromLoop_findNextExternalEntryFromGET_679 = true;					break;				} else {					/* begin needAvailableSpace: */					if ((objUsed + workBuffer[12] + workBuffer[14] + 129) > workBuffer[10]) {						/* begin stopBecauseOf: */						workBuffer[64] = 1;						engineStopped = true;						/* end stopBecauseOf: */						external = false;						brokenFromLoop_findNextExternalEntryFromGET_679 = true;						break;					} else {						switch (type) {						case 0:						case 1:						case 2:						case 3:							/* begin errorWrongIndex */							/* end errorWrongIndex */							break;						case 4:							B2DPlugin.stepToFirstLineInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 5:							B2DPlugin.stepToFirstWideLineInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 6:							B2DPlugin.stepToFirstBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						case 7:							B2DPlugin.stepToFirstWideBezierInat(getBuffer[workBuffer[11]], workBuffer[88]);							break;						}						B2DPlugin.insertEdgeIntoAET(edge);						workBuffer[11]++;					}					/* end needAvailableSpace: */				}			}		}		if (!brokenFromLoop_findNextExternalEntryFromGET_679) {			external = false;		}		/* end findNextExternalEntryFromGET */		if (doProfileStats) {			workBuffer[95]++;			/* begin incrementStat:by: */			value = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[94] += value;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 1;		}		if (external) {			workBuffer[2] = 2;			/* begin stopBecauseOf: */			workBuffer[64] = 4;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[13] = 0;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[69] = 1;		state = 3;	}	if (state === 3) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((workBuffer[69] !== 0) && ((UBAND(workBuffer[88], workBuffer[52])) === 0)) {			B2DPlugin.clearSpanBuffer.apply(this, arguments);		}		workBuffer[69] = 0;		external = B2DPlugin.findNextExternalFillFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[99]++;			/* begin incrementStat:by: */			value1 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[98] += value1;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 3;		}		if (external) {			workBuffer[2] = 4;			/* begin stopBecauseOf: */			workBuffer[64] = 5;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		state = 5;		/* begin wbStackClear */		workBuffer[10] = workBuffer[1];		/* end wbStackClear */		workBuffer[35] = 0;	}	if (state === 5) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		if ((UBAND(workBuffer[88], workBuffer[52])) === workBuffer[52]) {			B2DPlugin.displaySpanBufferAt(workBuffer[88]);			B2DPlugin.postDisplayAction.apply(this, arguments);		}		if (doProfileStats) {			workBuffer[103]++;			/* begin incrementStat:by: */			value2 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[102] += value2;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 5;		}		if (workBuffer[2] === 8) {			return 0;		}		state = 6;		workBuffer[13] = 0;		workBuffer[88]++;	}	if (state === 6) {		if (doProfileStats) {			geProfileTime = SmalltalkVM.ioMicroMSecs();		}		external = B2DPlugin.findNextExternalUpdateFromAET.apply(this, arguments);		if (doProfileStats) {			workBuffer[105]++;			/* begin incrementStat:by: */			value3 = SmalltalkVM.ioMicroMSecs() - geProfileTime;			workBuffer[104] += value3;			/* end incrementStat:by: */		}		if (engineStopped) {			return workBuffer[2] = 6;		}		if (external) {			workBuffer[2] = 7;			/* begin stopBecauseOf: */			workBuffer[64] = 6;			engineStopped = true;			return null;			/* end stopBecauseOf: */		}		workBuffer[2] = 1;	}}, /*	Load the minimal required state from the engineOop, e.g., just the work buffer.	 Answer 0 on success or non-zero a failure code on failure */quickLoadEngineFrom(engineOop) {	let failCode;	if ((typeof engineOop === "number")) {		return 101;	}	if ((engineOop.storageType !== "pointers")) {		return 102;	}	if (SIZEOF(engineOop) < 12) {		return 103;	}	engine = engineOop;	if (((failCode = B2DPlugin.loadWorkBufferFrom(engineOop.pointers[0]))) !== 0) {		return failCode;	}	workBuffer[64] = 0;	objUsed = workBuffer[9];	engineStopped = false;	return 0;}, quickLoadEngineFromrequiredState(oop, requiredState) {	let failureCode;	if (((failureCode = B2DPlugin.quickLoadEngineFrom(oop))) !== 0) {		return failureCode;	}	if (workBuffer[2] === requiredState) {		return 0;	}	workBuffer[64] = 2;	return 116;}, quickLoadEngineFromrequiredStateor(oop, requiredState, alternativeState) {	let failureCode;	if (((failureCode = B2DPlugin.quickLoadEngineFrom(oop))) !== 0) {		return failureCode;	}	if (workBuffer[2] === requiredState) {		return 0;	}	if (workBuffer[2] === alternativeState) {		return 0;	}	workBuffer[64] = 2;	return 116;}, /*	Sort elements i through j of self to be nondescending according to	sortBlock. *//*	Note: The original loop has been heavily re-written for C translation */quickSortGlobalEdgeTablefromto(array, i, j) {	let again;	let before;	let di;	let dij;	let dj;	let ij;	let k;	let l;	let n;	let tmp;	let tt;	/* The prefix d means the data at that index. */	if (((n = j + 1 - i)) <= 1) {		return 0;	}	di = array[i];	dj = array[j];	/* i.e., should di precede dj? */	before = B2DPlugin.getSortsbefore(di, dj);	if (!before) {		tmp = array[i];		array[i] = array[j];		array[j] = tmp;		tt = di;		di = dj;		dj = tt;	}	if (n <= 2) {		return 0;	}	/* ij is the midpoint of i and j. */	ij = (i + j) >> 1;	/* Sort di,dij,dj.  Make dij be their median. */	dij = array[ij];	/* i.e. should di precede dij? */	before = B2DPlugin.getSortsbefore(di, dij);	if (before) {		/* i.e., should dij precede dj? */		before = B2DPlugin.getSortsbefore(dij, dj);		if (!before) {			/* i.e., should dij precede dj? */			tmp = array[j];			array[j] = array[ij];			array[ij] = tmp;			dij = dj;		}	} else {		/* i.e. di should come after dij */		tmp = array[i];		array[i] = array[ij];		array[ij] = tmp;		dij = di;	}	if (n <= 3) {		return 0;	}	k = i;	l = j;	again = true;	while (again) {		before = true;		while (before) {			if (k <= ((--l))) {				tmp = array[l];				before = B2DPlugin.getSortsbefore(dij, tmp);			} else {				before = false;			}		}		before = true;		while (before) {			if (((++k)) <= l) {				tmp = array[k];				before = B2DPlugin.getSortsbefore(tmp, dij);			} else {				before = false;			}		}		again = k <= l;		if (again) {			tmp = array[k];			array[k] = array[l];			array[l] = tmp;		}	}	B2DPlugin.quickSortGlobalEdgeTablefromto(array, i, l);	B2DPlugin.quickSortGlobalEdgeTablefromto(array, k, j);}, rShiftTable() {	let theTable =		[0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1];	return theTable;}, removeFirstAETEntry() {	let index;	index = workBuffer[13];	workBuffer[14]--;	while (index < workBuffer[14]) {		aetBuffer[index] = aetBuffer[index + 1];		++index;	}}, resetGraphicsEngineStats() {	workBuffer[90] = 0;	workBuffer[92] = 0;	workBuffer[94] = 0;	workBuffer[96] = 0;	workBuffer[98] = 0;	workBuffer[100] = 0;	workBuffer[102] = 0;	workBuffer[104] = 0;	workBuffer[106] = 0;	workBuffer[91] = 0;	workBuffer[93] = 0;	workBuffer[95] = 0;	workBuffer[97] = 0;	workBuffer[99] = 0;	workBuffer[101] = 0;	workBuffer[103] = 0;	workBuffer[105] = 0;	workBuffer[107] = 0;	workBuffer[108] = 0;	workBuffer[109] = 0;	workBuffer[110] = 0;	workBuffer[111] = 0;}, resortFirstAETEntry() {	let edge;	let leftEdge;	let xValue;	if (workBuffer[13] === 0) {		return null;	}	edge = aetBuffer[workBuffer[13]];	xValue = objBuffer[edge + 4];	leftEdge = aetBuffer[workBuffer[13] - 1];	if (objBuffer[leftEdge + 4] <= xValue) {		return null;	}	B2DPlugin.moveAETEntryFromedgex(workBuffer[13], edge, xValue);}, /*	Set the anti-aliasing level. Three levels are supported:		1 - No antialiasing		2 - 2x2 unweighted anti-aliasing		4 - 4x4 unweighted anti-aliasing.	 */setAALevel(level) {	let aaLevel;	if (level >= 4) {		aaLevel = 4;	}	if ((level >= 2) && (level < 4)) {		aaLevel = 2;	}	if (level < 2) {		aaLevel = 1;	}	workBuffer[48] = aaLevel;		switch (aaLevel) {	case 1:				workBuffer[49] = 0;		workBuffer[51] = 4294967295;		workBuffer[52] = 0;		break;	case 2:				workBuffer[49] = 1;		workBuffer[51] = 4244438268;		workBuffer[52] = 1;		break;	case 4:				workBuffer[49] = 2;		workBuffer[51] = 4042322160;		workBuffer[52] = 3;		break;	default:			}	workBuffer[50] = (workBuffer[49] * 2);	workBuffer[53] = workBuffer[49];}, showFilldepthrightX(fillIndex, depth, rightX) {	/* begin wbStackPush: */	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 131) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return null;	} else {		workBuffer[10] -= 3;	}	/* end needAvailableSpace: */	/* end wbStackPush: */	workBuffer[workBuffer[10]] = fillIndex;	workBuffer[workBuffer[10] + 1] = depth;	workBuffer[workBuffer[10] + 2] = rightX;	if ((workBuffer[1] - workBuffer[10]) === 3) {		return null;	} else {		if (B2DPlugin.fillSortsbefore(0, (workBuffer[1] - workBuffer[10]) - 3)) {			/* New top fill */			workBuffer[workBuffer[10]] = workBuffer[workBuffer[1] - 3];			workBuffer[workBuffer[10] + 1] = workBuffer[workBuffer[1] - 2];			workBuffer[workBuffer[10] + 2] = workBuffer[workBuffer[1] - 1];			workBuffer[workBuffer[1] - 3] = fillIndex;			workBuffer[workBuffer[1] - 2] = depth;			workBuffer[workBuffer[1] - 1] = rightX;		}	}}, smallSqrtTable() {	let theTable = 	[0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6];	return theTable;}, squaredLengthOfwith(deltaX, deltaY) {	return (deltaX * deltaX) + (deltaY * deltaY);}, /*	Initialize the bezier at yValue.	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure. */stepToFirstBezierInat(bezier, yValue) {	let deltaY;	let endX;	let endY;	let fwDDx;	let fwDDy;	let fwDx;	let fwDy;	let fwX1;	let fwX2;	let fwY1;	let fwY2;	let maxSteps;	let scaledStepSize;	let squaredStepSize;	let startX;	let startY;	let updateData;	let viaX;	let viaY;	let word1;	let word2;	let xValue;	let updateData1;	let fwDx1;	let fwDy1;	let lastX;	let lastY;	let minY;	/* Do a quick check if there is anything at all to do */	if ((UBANDS((UBANDS(objBuffer[bezier], 65535)), 1)) === 0 && (yValue >= objBuffer[bezier + 15])) {		return objBuffer[bezier + 7] = 0;	}	startX = objBuffer[bezier + 4];	startY = objBuffer[bezier + 5];	viaX = objBuffer[bezier + 12];	viaY = objBuffer[bezier + 13];	endX = objBuffer[bezier + 14];	endY = objBuffer[bezier + 15];	/* Initialize integer forward differencing */	deltaY = endY - startY;	fwX1 = (viaX - startX) * 2;	fwX2 = (startX + endX) - (viaX * 2);	fwY1 = (viaY - startY) * 2;	fwY2 = (startY + endY) - (viaY * 2);	maxSteps = deltaY * 2;	if (maxSteps < 2) {		maxSteps = 2;	}	scaledStepSize = Math.trunc(16777216 / maxSteps);	/* begin absoluteSquared8Dot24: */	word1 = UBANDS(scaledStepSize, 65535);	word2 = UBANDS((scaledStepSize >>> 16), 255);	squaredStepSize = ((((word1 * word1) >>> 16) + ((word1 * word2) * 2)) + ((word2 * word2) << 16 >>> 0)) >>> 8;	/* end absoluteSquared8Dot24: */	fwDx = fwX1 * scaledStepSize;	fwDDx = (fwX2 * squaredStepSize) * 2;	fwDx += fwDDx >> 1;	fwDy = fwY1 * scaledStepSize;	fwDDy = (fwY2 * squaredStepSize) * 2;	/* Store the values */	fwDy += fwDDy >> 1;	objBuffer[bezier + 7] = deltaY;	updateData = PTR_ADD(objBuffer, bezier + 10);	updateData[0] = (startX * 256);	updateData[1] = (startY * 256);	updateData[2] = fwDx;	updateData[3] = fwDy;	updateData[4] = fwDDx;	updateData[5] = fwDDy;	if (((startY = objBuffer[bezier + 5])) !== yValue) {		/* begin stepToNextBezierIn:at: */		/* begin stepToNextBezierForward:at: */		updateData1 = PTR_ADD(objBuffer, bezier + 10);		lastX = updateData1[0];		lastY = updateData1[1];		fwDx1 = updateData1[2];		fwDy1 = updateData1[3];		minY = yValue * 256;		while ((minY > lastY) && (fwDy1 >= 0)) {			lastX += (fwDx1 + 32768) >> 16;			lastY += (fwDy1 + 32768) >> 16;			fwDx1 += updateData1[4];			fwDy1 += updateData1[5];		}		updateData1[0] = lastX;		updateData1[1] = lastY;		updateData1[2] = fwDx1;		updateData1[3] = fwDy1;		xValue = lastX >> 8;		/* end stepToNextBezierForward:at: */		objBuffer[bezier + 4] = xValue;		/* end stepToNextBezierIn:at: */		objBuffer[bezier + 7] = (deltaY - (yValue - startY));	}}, /*	Initialize the line at yValue */stepToFirstLineInat(line, yValue) {	let deltaX;	let deltaY;	let error;	let errorAdjUp;	let i;	let startY;	let widthX;	let xDir;	let xInc;	let err;	let x;	/* Do a quick check if there is anything at all to do */	if ((UBANDS((UBANDS(objBuffer[line], 65535)), 1)) === 0 && (yValue >= objBuffer[line + 15])) {		return objBuffer[line + 7] = 0;	}	deltaX = objBuffer[line + 14] - objBuffer[line + 4];	/* Check if edge goes left to right */	deltaY = objBuffer[line + 15] - objBuffer[line + 5];	if (deltaX >= 0) {		xDir = 1;		widthX = deltaX;		error = 0;	} else {		xDir = -1;		widthX = 0 - deltaX;		error = 1 - deltaY;	}	if (deltaY === 0) {		/* No error for horizontal edges */		error = 0;		/* Encodes width and direction */		xInc = deltaX;		errorAdjUp = 0;	} else {		/* Check if edge is y-major */		if (deltaY > widthX) {			/* Note: The '>' instead of '>=' could be important here... */			xInc = 0;			errorAdjUp = widthX;		} else {			xInc = (Math.trunc(widthX / deltaY)) * xDir;			errorAdjUp = MOD(widthX, deltaY);		}	}	objBuffer[line + 7] = deltaY;	objBuffer[line + 10] = xDir;	objBuffer[line + 12] = xInc;	objBuffer[line + 13] = error;	objBuffer[line + 14] = errorAdjUp;	objBuffer[line + 15] = deltaY;	if (((startY = objBuffer[line + 5])) !== yValue) {		for (i = startY; i < yValue; i++) {			/* begin stepToNextLineIn:at: */			x = objBuffer[line + 4] + objBuffer[line + 12];			err = objBuffer[line + 13] + objBuffer[line + 14];			if (err > 0) {				x += objBuffer[line + 10];				err -= objBuffer[line + 15];			}			objBuffer[line + 13] = err;			objBuffer[line + 4] = x;			/* end stepToNextLineIn:at: */		}		objBuffer[line + 7] = (deltaY - (yValue - startY));	}}, /*	Initialize the bezier at yValue */stepToFirstWideBezierInat(bezier, yValue) {	let endX;	let i;	let i1;	let lineOffset;	let lineWidth;	let nLines;	let startY;	let xDir;	let yEntry;	let yExit;	let leftX;	let rightX;	let temp;	/* Get some values */	lineWidth = objBuffer[bezier + 20];	/* Compute the incremental values of the bezier */	lineOffset = lineWidth >> 1;	endX = objBuffer[bezier + 14];	startY = objBuffer[bezier + 5];	B2DPlugin.stepToFirstBezierInat(bezier, startY);	/* Copy the incremental update data */	nLines = objBuffer[bezier + 7];	for (i = 0; i <= 5; i++) {		objBuffer[i + bezier + 22] = objBuffer[i + bezier + 10];	}	xDir = objBuffer[bezier + 12];	if (xDir === 0) {	}	/* Adjust the curve to start/end at the right position */	xDir = (xDir >= 0) ? 1 : -1;	if (xDir < 0) {		B2DPlugin.adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX);	} else {		B2DPlugin.adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX);	}	if (nLines === 0) {		objBuffer[bezier + 10] = (objBuffer[bezier + 21] * 256);	}	objBuffer[bezier + 7] = (nLines + lineWidth);	/* turned on at lineOffset */	yEntry = 0;	/* turned off at zero */	yExit = 0 - nLines - lineOffset;	objBuffer[bezier + 18] = yEntry;	objBuffer[bezier + 19] = yExit;	if ((yEntry >= lineOffset) && (yExit < 0)) {		objBuffer[bezier] = (UBANDM((UBANDS(objBuffer[bezier], 65535)), 2147418111));	} else {		objBuffer[bezier] = (UBORS((UBANDS(objBuffer[bezier], 65535)), 65536));	}	/* begin computeFinalWideBezierValues:width: */	leftX = objBuffer[bezier + 10] >> 8;	rightX = objBuffer[bezier + 22] >> 8;	if (leftX > rightX) {		temp = leftX;		leftX = rightX;		rightX = temp;	}	objBuffer[bezier + 4] = leftX;	if ((rightX - leftX) > lineWidth) {		objBuffer[bezier + 17] = (rightX - leftX);	} else {		objBuffer[bezier + 17] = lineWidth;	}	/* end computeFinalWideBezierValues:width: */	if (startY !== yValue) {		/* Note: Must single step here so that entry/exit works */		for (i1 = startY; i1 < yValue; i1++) {			B2DPlugin.stepToNextWideBezierInat(bezier, i1);		}		objBuffer[bezier + 7] -= yValue - startY;	}}, /*	Initialize the wide line at yValue. */stepToFirstWideLineInat(line, yValue) {	let i;	let lineOffset;	let lineWidth;	let nLines;	let startX;	let startY;	let xDir;	let yEntry;	let yExit;	let lastX;	let lineOffset1;	let lineWidth1;	let nextX;	let yEntry1;	let yExit1;	let err;	let x;	/* Get some values */	lineWidth = objBuffer[line + 20];	/* Compute the incremental values of the line */	lineOffset = lineWidth >> 1;	startX = objBuffer[line + 4];	startY = objBuffer[line + 5];	B2DPlugin.stepToFirstLineInat(line, startY);	nLines = objBuffer[line + 7];	/* Adjust the line to start at the correct X position */	xDir = objBuffer[line + 10];	objBuffer[line + 4] = (startX - lineOffset);	objBuffer[line + 7] = (nLines + lineWidth);	if (xDir > 0) {		objBuffer[line + 17] = (objBuffer[line + 12] + lineWidth);	} else {		objBuffer[line + 17] = (lineWidth - objBuffer[line + 12]);		objBuffer[line + 4] += objBuffer[line + 12];	}	/* turned on at lineOffset */	yEntry = 0;	/* turned off at zero */	yExit = 0 - nLines - lineOffset;	objBuffer[line + 18] = yEntry;	objBuffer[line + 19] = yExit;	if ((yEntry >= lineOffset) && (yExit < 0)) {		objBuffer[line] = (UBANDM((UBANDS(objBuffer[line], 65535)), 2147418111));	} else {		objBuffer[line] = (UBORS((UBANDS(objBuffer[line], 65535)), 65536));	}	if (startY !== yValue) {		for (i = startY; i < yValue; i++) {			/* begin stepToNextWideLineIn:at: */			yEntry1 = objBuffer[line + 18] + 1;			yExit1 = objBuffer[line + 19] + 1;			objBuffer[line + 18] = yEntry1;			objBuffer[line + 19] = yExit1;			lineWidth1 = objBuffer[line + 20];			lineOffset1 = lineWidth1 >> 1;			if (yEntry1 >= lineOffset1) {				objBuffer[line] = (UBANDM((UBANDS(objBuffer[line], 65535)), 2147418111));			}			if (yExit1 >= 0) {				objBuffer[line] = (UBORS((UBANDS(objBuffer[line], 65535)), 65536));			}			lastX = objBuffer[line + 4];			/* begin stepToNextLineIn:at: */			x = objBuffer[line + 4] + objBuffer[line + 12];			err = objBuffer[line + 13] + objBuffer[line + 14];			if (err > 0) {				x += objBuffer[line + 10];				err -= objBuffer[line + 15];			}			objBuffer[line + 13] = err;			objBuffer[line + 4] = x;			/* end stepToNextLineIn:at: */			nextX = objBuffer[line + 4];			if ((yEntry1 <= lineWidth1) || ((yExit1 + lineOffset1) >= 0)) {				B2DPlugin.adjustWideLineafterSteppingFromto(line, lastX, nextX);			}			/* end stepToNextWideLineIn:at: */		}		objBuffer[line + 7] -= yValue - startY;	}}, /*	Incrementally step to the next scan line in the given wide bezier */stepToNextWideBezierInat(bezier, yValue) {	let lineOffset;	let lineWidth;	let yEntry;	let yExit;	let updateData;	let fwDx;	let fwDy;	let lastX;	let lastY;	let minY;	let updateData1;	let fwDx1;	let fwDy1;	let lastX1;	let lastY1;	let minY1;	let leftX;	let rightX;	let temp;	/* Don't inline this */	lineWidth = objBuffer[bezier + 20];	lineOffset = lineWidth >> 1;	yEntry = objBuffer[bezier + 18] + 1;	yExit = objBuffer[bezier + 19] + 1;	objBuffer[bezier + 18] = yEntry;	objBuffer[bezier + 19] = yExit;	if (yEntry >= lineOffset) {		objBuffer[bezier] = (UBANDM((UBANDS(objBuffer[bezier], 65535)), 2147418111));	}	if (yExit >= 0) {		objBuffer[bezier] = (UBORS((UBANDS(objBuffer[bezier], 65535)), 65536));	}	if ((yExit + lineOffset) < 0) {		/* begin stepToNextBezierForward:at: */		updateData = PTR_ADD(objBuffer, bezier + 10);		lastX = updateData[0];		lastY = updateData[1];		fwDx = updateData[2];		fwDy = updateData[3];		minY = yValue * 256;		while ((minY > lastY) && (fwDy >= 0)) {			lastX += (fwDx + 32768) >> 16;			lastY += (fwDy + 32768) >> 16;			fwDx += updateData[4];			fwDy += updateData[5];		}		updateData[0] = lastX;		updateData[1] = lastY;		updateData[2] = fwDx;		updateData[3] = fwDy;		/* end stepToNextBezierForward:at: */	} else {		/* Adjust the last x value to the final x recorded previously */		objBuffer[bezier + 10] = (objBuffer[bezier + 21] * 256);	}	/* begin stepToNextBezierForward:at: */	updateData1 = PTR_ADD(objBuffer, bezier + 22);	lastX1 = updateData1[0];	lastY1 = updateData1[1];	fwDx1 = updateData1[2];	fwDy1 = updateData1[3];	minY1 = yValue * 256;	while ((minY1 > lastY1) && (fwDy1 >= 0)) {		lastX1 += (fwDx1 + 32768) >> 16;		lastY1 += (fwDy1 + 32768) >> 16;		fwDx1 += updateData1[4];		fwDy1 += updateData1[5];	}	updateData1[0] = lastX1;	updateData1[1] = lastY1;	updateData1[2] = fwDx1;	updateData1[3] = fwDy1;	/* end stepToNextBezierForward:at: */	/* begin computeFinalWideBezierValues:width: */	leftX = objBuffer[bezier + 10] >> 8;	rightX = objBuffer[bezier + 22] >> 8;	if (leftX > rightX) {		temp = leftX;		leftX = rightX;		rightX = temp;	}	objBuffer[bezier + 4] = leftX;	if ((rightX - leftX) > lineWidth) {		objBuffer[bezier + 17] = (rightX - leftX);	} else {		objBuffer[bezier + 17] = lineWidth;	}	/* end computeFinalWideBezierValues:width: */}, storeEdgeStateFrominto(edge, edgeOop) {	if (SIZEOF(edgeOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	edgeOop.pointers[0] = objBuffer[edge + 2];	edgeOop.pointers[1] = objBuffer[edge + 4];	edgeOop.pointers[2] = workBuffer[88];	edgeOop.pointers[3] = objBuffer[edge + 6];	edgeOop.pointers[4] = objBuffer[edge + 7];	workBuffer[65] = edge;}, storeFillStateInto(fillOop) {	let fillIndex;	let leftX;	let rightX;	fillIndex = workBuffer[66];	leftX = workBuffer[67];	rightX = workBuffer[68];	if (SIZEOF(fillOop) < 6) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	fillOop.pointers[0] = objBuffer[fillIndex + 2];	fillOop.pointers[1] = leftX;	fillOop.pointers[2] = rightX;	fillOop.pointers[3] = workBuffer[88];}, storeRenderingState(edgeOop, fillOop) {	let edge;	let reason;	if (engineStopped) {		/* Check the stop reason and store the required information */		/* begin storeStopStateIntoEdge:fill: */		if (typeof edgeOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);		if (typeof fillOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);		reason = workBuffer[64];		if (reason === 4) {			edge = getBuffer[workBuffer[11]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);			workBuffer[11]++;		}		if (reason === 5) {			B2DPlugin.storeFillStateInto(fillOop);		}		if (reason === 6) {			edge = aetBuffer[workBuffer[13]];			B2DPlugin.storeEdgeStateFrominto(edge, edgeOop);		}		/* end storeStopStateIntoEdge:fill: */	}	/* begin storeEngineStateInto: */	workBuffer[9] = objUsed;	/* end storeEngineStateInto: */	throw Object.create(PrimitiveReturn).setPayload(CHECKEDINTEGER(workBuffer[64]));}, /*	Subdivide the given bezier curve if necessary */subdivideBezier(index) {	let deltaX;	let deltaY;	let endX;	let endY;	let startX;	let startY;	startY = workBuffer[workBuffer[1] + 1 - index];	/* If the receiver is horizontal, don't do anything */	endY = workBuffer[workBuffer[1] + 5 - index];	if (endY === startY) {		return index;	}	deltaY = endY - startY;	if (deltaY < 0) {		deltaY = 0 - deltaY;	}	if (deltaY > 255) {		workBuffer[109]++;		return B2DPlugin.computeBezierSplitAtHalf(index);	}	startX = workBuffer[workBuffer[1] - index];	endX = workBuffer[workBuffer[1] + 4 - index];	deltaX = endX - startX;	if (deltaX < 0) {		deltaX = 0 - deltaX;	}	if ((deltaY * 32) < deltaX) {		workBuffer[110]++;		return B2DPlugin.computeBezierSplitAtHalf(index);	} else {		return index;	}}, /*	Recursively subdivide the curve on the bezier stack. */subdivideBezierFrom(index) {	let index1;	let index2;	let otherIndex;	otherIndex = B2DPlugin.subdivideBezier(index);	if (otherIndex === index) {		return index;	} else {		index1 = B2DPlugin.subdivideBezierFrom(index);		if (engineStopped) {			return 0;		}		index2 = B2DPlugin.subdivideBezierFrom(otherIndex);		if (engineStopped) {			return 0;		}		return (index1 >= index2) ? index1 : index2;	}}, /*	Check if the given bezier curve is monoton in Y, and, if desired in X. 	If not, subdivide it */subdivideToBeMonotoninX(base, doTestX) {	let base2;	let index1;	let index2;	base2 = index1 = index2 = B2DPlugin.subdivideToBeMonotonInY(base);	if (doTestX) {		index1 = B2DPlugin.subdivideToBeMonotonInX(base);	}	if (index1 > index2) {		index2 = index1;	}	if ((base !== base2) && (doTestX)) {		index1 = B2DPlugin.subdivideToBeMonotonInX(base2);	}	if (index1 > index2) {		index2 = index1;	}	return index2;}, /*	Check if the given bezier curve is monoton in X. If not, subdivide it */subdivideToBeMonotonInX(index) {	let denom;	let dx1;	let dx2;	let endX;	let num;	let startX;	let viaX;	startX = workBuffer[workBuffer[1] - index];	viaX = workBuffer[workBuffer[1] + 2 - index];	endX = workBuffer[workBuffer[1] + 4 - index];	dx1 = viaX - startX;	dx2 = endX - viaX;	if ((dx1 * dx2) >= 0) {		return index;	}	workBuffer[108]++;	denom = dx2 - dx1;	num = dx1;	if (num < 0) {		num = 0 - num;	}	if (denom < 0) {		denom = 0 - denom;	}	return B2DPlugin.computeBeziersplitAt(index, num / denom);}, /*	Check if the given bezier curve is monoton in Y. If not, subdivide it */subdivideToBeMonotonInY(index) {	let denom;	let dy1;	let dy2;	let endY;	let num;	let startY;	let viaY;	startY = workBuffer[workBuffer[1] + 1 - index];	viaY = workBuffer[workBuffer[1] + 3 - index];	endY = workBuffer[workBuffer[1] + 5 - index];	dy1 = viaY - startY;	dy2 = endY - viaY;	if ((dy1 * dy2) >= 0) {		return index;	}	workBuffer[108]++;	denom = dy2 - dy1;	num = dy1;	if (num < 0) {		num = 0 - num;	}	if (denom < 0) {		denom = 0 - denom;	}	return B2DPlugin.computeBeziersplitAt(index, num / denom);}, /*	Make the fill style with the given index either visible or invisible */toggleFilldepthrightX(fillIndex, depth, rightX) {	let hidden;	if (workBuffer[1] === workBuffer[10]) {		/* begin wbStackPush: */		/* begin needAvailableSpace: */		if ((objUsed + workBuffer[12] + workBuffer[14] + 131) > workBuffer[10]) {			/* begin stopBecauseOf: */			workBuffer[64] = 1;			engineStopped = true;			/* end stopBecauseOf: */		} else {			workBuffer[10] -= 3;			workBuffer[workBuffer[1] - 3] = fillIndex;			workBuffer[workBuffer[1] - 2] = depth;			workBuffer[workBuffer[1] - 1] = rightX;		}		/* end needAvailableSpace: */		/* end wbStackPush: */	} else {		hidden = B2DPlugin.hideFilldepth(fillIndex, depth);		if (!hidden) {			B2DPlugin.showFilldepthrightX(fillIndex, depth, rightX);		}	}}, toggleFillsOf(edge) {	let depth;	let fillIndex;	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 134) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return null;	}	/* end needAvailableSpace: */	depth = objBuffer[edge + 6] << 1 >>> 0;	fillIndex = objBuffer[edge + 8];	if (fillIndex !== 0) {		B2DPlugin.toggleFilldepthrightX(fillIndex, depth, 999999999);	}	fillIndex = objBuffer[edge + 9];	if (fillIndex !== 0) {		B2DPlugin.toggleFilldepthrightX(fillIndex, depth, 999999999);	}	/* begin quickRemoveInvalidFillsAt: */	if (workBuffer[1] !== workBuffer[10]) {		while (((workBuffer[1] === workBuffer[10]	? 999999999	: workBuffer[workBuffer[1] - 1])) <= objBuffer[edge + 4]) {			B2DPlugin.hideFilldepth((workBuffer[1] === workBuffer[10]				? 0				: workBuffer[workBuffer[1] - 3]), (workBuffer[1] === workBuffer[10]				? -1				: workBuffer[workBuffer[1] - 2]));			if (workBuffer[1] === workBuffer[10]) {				break;			}		}	}	/* end quickRemoveInvalidFillsAt: */}, toggleWideFillOf(edge) {	let depth;	let fill;	let index;	let lineWidth;	let rightX;	let type;	let index1;	type = (UBANDS(objBuffer[edge], 65535)) >>> 1;	dispatchedValue = edge;	switch (type) {	case 0:	case 1:		/* begin errorWrongIndex */		/* end errorWrongIndex */		break;	case 2:		dispatchReturnValue = objBuffer[dispatchedValue + 17];		break;	case 3:		dispatchReturnValue = objBuffer[dispatchedValue + 17];		break;	}	lineWidth = dispatchReturnValue;	switch (type) {	case 0:	case 1:		/* begin errorWrongIndex */		/* end errorWrongIndex */		break;	case 2:		dispatchReturnValue = objBuffer[dispatchedValue + 16];		break;	case 3:		dispatchReturnValue = objBuffer[dispatchedValue + 16];		break;	}	fill = dispatchReturnValue;	if (fill === 0) {		return null;	}	/* begin needAvailableSpace: */	if ((objUsed + workBuffer[12] + workBuffer[14] + 131) > workBuffer[10]) {		/* begin stopBecauseOf: */		workBuffer[64] = 1;		engineStopped = true;		/* end stopBecauseOf: */		return null;	}	/* end needAvailableSpace: */	/* So lines sort before interior fills */	depth = (objBuffer[edge + 6] << 1 >>> 0) + 1;	rightX = objBuffer[edge + 4] + lineWidth;	/* begin findStackFill:depth: */	index1 = 0;	while ((index1 < (workBuffer[1] - workBuffer[10])) && ((workBuffer[workBuffer[10] + index1] !== fill) || (workBuffer[index1 + workBuffer[10] + 1] !== depth))) {		index1 += 3;	}	index = (index1 >= (workBuffer[1] - workBuffer[10])) ? -1 : index1;	/* end findStackFill:depth: */	if (index === -1) {		B2DPlugin.showFilldepthrightX(fill, depth, rightX);	} else {		if (workBuffer[index + workBuffer[10] + 2] < rightX) {			workBuffer[index + workBuffer[10] + 2] = rightX;		}	}	/* begin quickRemoveInvalidFillsAt: */	if (workBuffer[1] !== workBuffer[10]) {		while (((workBuffer[1] === workBuffer[10]	? 999999999	: workBuffer[workBuffer[1] - 1])) <= objBuffer[edge + 4]) {			B2DPlugin.hideFilldepth((workBuffer[1] === workBuffer[10]				? 0				: workBuffer[workBuffer[1] - 3]), (workBuffer[1] === workBuffer[10]				? -1				: workBuffer[workBuffer[1] - 2]));			if (workBuffer[1] === workBuffer[10]) {				break;			}		}	}	/* end quickRemoveInvalidFillsAt: */}, /*	Transform the given width */transformWidth(w) {	let deltaX;	let deltaY;	let dstWidth;	let dstWidth2;	let point;	let xValue;	let yValue;	let dstPoint1;	let transform;	let x;	let y;	let point1;	let xValue1;	let yValue1;	let dstPoint11;	let transform1;	let x1;	let y1;	let point2;	let xValue2;	let yValue2;	let dstPoint12;	let transform2;	let x2;	let y2;	let point3;	let xValue3;	let yValue3;	let dstPoint13;	let transform3;	let x3;	let y3;	if (w === 0) {		return 0;	}	PTR_ADD(workBuffer, 80)[0] = 0;	PTR_ADD(workBuffer, 80)[1] = 0;	PTR_ADD(workBuffer, 82)[0] = (w * 256);	PTR_ADD(workBuffer, 82)[1] = 0;	PTR_ADD(workBuffer, 84)[0] = 0;	PTR_ADD(workBuffer, 84)[1] = (w * 256);	/* begin transformPoints: */	/* begin transformPoint: */point = PTR_ADD(workBuffer, 80);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue = (point[0]|0);	yValue = (point[1]|0);	dstPoint1 = point;	transform = FPTR_ADD(workBuffer, 18);	x = (((((transform[0] * xValue) + (transform[1] * yValue)) + transform[2]) * workBuffer[48]) | 0);	y = (((((transform[3] * xValue) + (transform[4] * yValue)) + transform[5]) * workBuffer[48]) | 0);	dstPoint1[0] = x;	dstPoint1[1] = y;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point[0] = ((point[0] + workBuffer[46]) * workBuffer[48]);	point[1] = ((point[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point1 = PTR_ADD(workBuffer, 82);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue1 = (point1[0]|0);	yValue1 = (point1[1]|0);	dstPoint11 = point1;	transform1 = FPTR_ADD(workBuffer, 18);	x1 = (((((transform1[0] * xValue1) + (transform1[1] * yValue1)) + transform1[2]) * workBuffer[48]) | 0);	y1 = (((((transform1[3] * xValue1) + (transform1[4] * yValue1)) + transform1[5]) * workBuffer[48]) | 0);	dstPoint11[0] = x1;	dstPoint11[1] = y1;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point1[0] = ((point1[0] + workBuffer[46]) * workBuffer[48]);	point1[1] = ((point1[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* begin transformPoint: */point2 = PTR_ADD(workBuffer, 84);if (workBuffer[16] !== 0) {	/* begin transformPoint:into: */	/* begin transformPointX:y:into: */	xValue2 = (point2[0]|0);	yValue2 = (point2[1]|0);	dstPoint12 = point2;	transform2 = FPTR_ADD(workBuffer, 18);	x2 = (((((transform2[0] * xValue2) + (transform2[1] * yValue2)) + transform2[2]) * workBuffer[48]) | 0);	y2 = (((((transform2[3] * xValue2) + (transform2[4] * yValue2)) + transform2[5]) * workBuffer[48]) | 0);	dstPoint12[0] = x2;	dstPoint12[1] = y2;	/* end transformPointX:y:into: */	/* end transformPoint:into: */} else {	point2[0] = ((point2[0] + workBuffer[46]) * workBuffer[48]);	point2[1] = ((point2[1] + workBuffer[47]) * workBuffer[48]);}/* end transformPoint: */	/* end transformPoints: */	deltaX = (PTR_ADD(workBuffer, 82)[0] - PTR_ADD(workBuffer, 80)[0]);	deltaY = (PTR_ADD(workBuffer, 82)[1] - PTR_ADD(workBuffer, 80)[1]);	dstWidth = ((Math.sqrt((deltaX * deltaX) + (deltaY * deltaY)) | 0) + 128) >> 8;	deltaX = (PTR_ADD(workBuffer, 84)[0] - PTR_ADD(workBuffer, 80)[0]);	deltaY = (PTR_ADD(workBuffer, 84)[1] - PTR_ADD(workBuffer, 80)[1]);	dstWidth2 = ((Math.sqrt((deltaX * deltaX) + (deltaY * deltaY)) | 0) + 128) >> 8;	if (dstWidth2 < dstWidth) {		dstWidth = dstWidth2;	}	return (dstWidth === 0) ? 1 : dstWidth;}, }