/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:25 pm */
/* Automatically generated by
	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4
   from
	MiscPrimitivePlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787
 */
var VM_PROXY_MAJOR = 1
var VM_PROXY_MINOR = 11


/*** Functions ***/
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }
function BYTESOF(obj) {
	if (obj.bytes) return obj.bytes;
	if (typeof obj === "bigint") {
		let asString = (obj >= 0 ? obj : -obj).toString(16);
		const length = (asString.length + 1) >>> 1;
		asString = asString.padStart(length << 1, "0");
		const bytes = new Uint8Array(length);
		for (let i = length - 1, j = 0; i >= 0; i--)
			bytes[i] = parseInt(asString.slice(j, j += 2), 16);
		return bytes;
	}}
function CHECKEDINTEGER(val) {
	return typeof val === "number" ? val : PrimitiveFailed.signal()
}
function CHECKEDBOOLEAN(val) {
	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()
}
function UBOR(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a | b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :
		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);
	}	//unsigned bit or
function UBORM(a, maskedB) {
	a = a >>> 0;
	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;
	}	//unsigned bit or
function UBORS(a, smallB) {
	if ((a | 0) === a)
		return a | smallB;
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;
	}	//unsigned bit or

function UBAND(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a & b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :
		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);
	}	//unsigned bit and
function UBANDM(a, maskedB) {
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;
	}	//unsigned bit and
function UBANDS(a, smallB) {
	if ((a | 0) === a)
		return a & smallB;
	a = a >>> 0;
	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;
	}	//unsigned bit and

function UBXOR(a, b) {
	if ((a | 0) === a && (b | 0) === b)
		return a ^ b;
	a = a >>> 0; b = b >>> 0;
	return a >= 2147483648 ?
		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :
		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);
	}	//unsigned bit xor
function UBXORM(a, maskedB) {
	a = a >>> 0;
	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;
	}	//unsigned bit xor
function UBXORS(a, smallB) {
	if ((a | 0) === a)
		return a ^ smallB;
	a = a >>> 0;
	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;
	}	//unsigned bit xor

function MOD(a, b) {
	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulus
function SHL(a, b) {
	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }
function SHR(a, b) {
	return b > 31 ? 0 : a >>> b }
function SHIFT(a, b) {
	b = b | 0;
	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }
function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }
function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }
function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }
function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }
function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }
function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }
function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }

/*** Variables ***/



globalThis.MiscPrimitivePlugin = {

/*	Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array. */

primitiveCompareString(string1Oop, string2Oop, orderOop) {
	let c1;
	let c2;
	let i;
	let len1;
	let len2;
	let string1;
	let string2;
	let order;


	/* primitiveExternalCall */

	string1 = string1Oop.storageType !== "bytes" ? (string1Oop.storageType !== "words" ? PrimitiveFailed.signal() : string1Oop.wordsAsUint8Array()) : BYTESOF(string1Oop);
	string2 = string2Oop.storageType !== "bytes" ? (string2Oop.storageType !== "words" ? PrimitiveFailed.signal() : string2Oop.wordsAsUint8Array()) : BYTESOF(string2Oop);
	order = orderOop.storageType !== "bytes" ? (orderOop.storageType !== "words" ? PrimitiveFailed.signal() : orderOop.wordsAsUint8Array()) : BYTESOF(orderOop);
	len1 = string1.length;
	len2 = string2.length;
	const iLimiT = Math.min(len1, len2);
	for (i = 1; i <= iLimiT; i++) {
		c1 = order[string1[i - 1]];
		c2 = order[string2[i - 1]];
		if (c1 !== c2) {
			throw Object.create(PrimitiveReturn).setPayload(((c1 < c2) ? 1 : 3));
		}
	}
	throw Object.create(PrimitiveReturn).setPayload(((len1 === len2) ? 2 : ((len1 < len2) ? 1 : 3)));
}
, 

/*	Store a run-coded compression of the receiver into the byteArray ba,
	and return the last index stored into. ba is assumed to be large enough.
	The encoding is as follows...
		S {N D}*.
		S is the size of the original bitmap, followed by run-coded pairs.
		N is a run-length * 4 + data code.
		D, the data, depends on the data code...
			0	skip N words, D is absent
			1	N words with all 4 bytes = D (1 byte)
			2	N words all = D (4 bytes)
			3	N words follow in D (4N bytes)
		S and N are encoded as follows...
			0-223	0-223
			224-254	(0-30)*256 + next byte (0-7935)
			255		next 4 bytes */

primitiveCompressToByteArray(bmOop, baOop) {
	let eqBytes;
	let i;
	let j;
	let k;
	let lowByte;
	let m;
	let size;
	let word;
	let j1;
	let j2;
	let anInt;
	let i1;
	let j3;
	let anInt1;
	let i11;
	let j4;
	let i12;
	let j5;
	let anInt2;
	let i13;
	let j6;
	let i14;
	let j7;
	let bm;
	let ba;


	/* primitiveExternalCall */

	bm = bmOop.storageType === "words" ? bmOop.wordsAsInt32Array() : PrimitiveFailed.signal();
	ba = baOop.storageType !== "bytes" ? (baOop.storageType !== "words" ? PrimitiveFailed.signal() : baOop.wordsAsUint8Array()) : BYTESOF(baOop);
	size = bm.length;
	/* begin encodeInt:in:at: */
	if (size <= 223) {
		ba[0] = size;
		i = 2;
	} else {
		if (size <= 7935) {
			ba[0] = ((size >> 8) + 224);
			ba[1] = (MOD(size, 256));
			i = 3;
		} else {
			ba[0] = 255;
			/* begin encodeBytesOf:in:at: */
			i14 = 2;
			for (j7 = 0; j7 <= 3; j7++) {
				ba[(i14 + j7) - 1] = (UBANDS((SHR(size, ((3 - j7) * 8))), 255));
			}
			i = i14 + 4;
			/* end encodeBytesOf:in:at: */
		}
	}
	/* end encodeInt:in:at: */
	k = 1;
	while (k <= size) {
		word = bm[k - 1];
		lowByte = UBANDS(word, 255);
		eqBytes = ((UBANDS((word >>> 8), 255)) === lowByte) && (((UBANDS((word >>> 16), 255)) === lowByte) && ((UBANDS((word >>> 24), 255)) === lowByte));
		j = k;
		while ((j < size) && (word === bm[j])) {
			++j;
		}
		if (j > k) {

			/* We have two or more = words, ending at j */

			if (eqBytes) {

				/* Actually words of = bytes */

				/* begin encodeInt:in:at: */
				anInt = (((j - k) + 1) * 4) + 1;
				if (anInt <= 223) {
					ba[i - 1] = anInt;
					++i;
				} else {
					if (anInt <= 7935) {
						ba[i - 1] = ((anInt >> 8) + 224);
						ba[i] = (MOD(anInt, 256));
						i += 2;
					} else {
						ba[i - 1] = 255;
						/* begin encodeBytesOf:in:at: */
						i1 = i + 1;
						for (j3 = 0; j3 <= 3; j3++) {
							ba[(i1 + j3) - 1] = (UBANDS((SHR(anInt, ((3 - j3) * 8))), 255));
						}
						i = i1 + 4;
						/* end encodeBytesOf:in:at: */
					}
				}
				/* end encodeInt:in:at: */
				ba[i - 1] = lowByte;
				++i;
			} else {
				/* begin encodeInt:in:at: */
				anInt1 = (((j - k) + 1) * 4) + 2;
				if (anInt1 <= 223) {
					ba[i - 1] = anInt1;
					++i;
				} else {
					if (anInt1 <= 7935) {
						ba[i - 1] = ((anInt1 >> 8) + 224);
						ba[i] = (MOD(anInt1, 256));
						i += 2;
					} else {
						ba[i - 1] = 255;
						/* begin encodeBytesOf:in:at: */
						i11 = i + 1;
						for (j4 = 0; j4 <= 3; j4++) {
							ba[(i11 + j4) - 1] = (UBANDS((SHR(anInt1, ((3 - j4) * 8))), 255));
						}
						i = i11 + 4;
						/* end encodeBytesOf:in:at: */
					}
				}
				/* end encodeInt:in:at: */
				/* begin encodeBytesOf:in:at: */
				for (j1 = 0; j1 <= 3; j1++) {
					ba[(i + j1) - 1] = (UBANDS((SHR(word, ((3 - j1) * 8))), 255));
				}
				i += 4;
				/* end encodeBytesOf:in:at: */
			}
			k = j + 1;
		} else {

			/* Check for word of 4 = bytes */

			if (eqBytes) {

				/* Note 1 word of 4 = bytes */

				/* begin encodeInt:in:at: */
							ba[i - 1] = 5;
			++i;

				/* end encodeInt:in:at: */
				ba[i - 1] = lowByte;
				++i;
				++k;
			} else {

				/* Finally, check for junk */

				while ((j < size) && (bm[j - 1] !== bm[j])) {
					++j;
				}
				if (j === size) {
					++j;
				}
				/* begin encodeInt:in:at: */
				anInt2 = ((j - k) * 4) + 3;
				if (anInt2 <= 223) {
					ba[i - 1] = anInt2;
					++i;
				} else {
					if (anInt2 <= 7935) {
						ba[i - 1] = ((anInt2 >> 8) + 224);
						ba[i] = (MOD(anInt2, 256));
						i += 2;
					} else {
						ba[i - 1] = 255;
						/* begin encodeBytesOf:in:at: */
						i13 = i + 1;
						for (j6 = 0; j6 <= 3; j6++) {
							ba[(i13 + j6) - 1] = (UBANDS((SHR(anInt2, ((3 - j6) * 8))), 255));
						}
						i = i13 + 4;
						/* end encodeBytesOf:in:at: */
					}
				}
				/* end encodeInt:in:at: */
				for (m = k; m < j; m++) {
					/* begin encodeBytesOf:in:at: */
					for (j2 = 0; j2 <= 3; j2++) {
						ba[(i + j2) - 1] = (UBANDS((SHR(bm[m - 1], ((3 - j2) * 8))), 255));
					}
					i += 4;
					/* end encodeBytesOf:in:at: */
				}
				k = j;
			}
		}
	}
	throw Object.create(PrimitiveReturn).setPayload((i - 1));
}
, 

/*	Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples. */

primitiveConvert8BitSigned(aByteArrayOop, aSoundBufferOop) {
	let i;
	let n;
	let s;
	let aByteArray;
	let aSoundBuffer;


	/* primitiveExternalCall */

	aByteArray = aByteArrayOop.storageType !== "bytes" ? (aByteArrayOop.storageType !== "words" ? PrimitiveFailed.signal() : aByteArrayOop.wordsAsUint8Array()) : BYTESOF(aByteArrayOop);
	aSoundBuffer = aSoundBufferOop.storageType !== "shorts" ? (aSoundBufferOop.storageType !== "words" ? PrimitiveFailed.signal() : aSoundBufferOop.wordsAsUint16Array()) : aSoundBufferOop.shorts;
	n = aByteArray.length;
	for (i = 1; i <= n; i++) {
		s = aByteArray[i - 1];
		if (s > 127) {
			aSoundBuffer[i - 1] = ((s - 256) << 8 >>> 0);
		} else {
			aSoundBuffer[i - 1] = (s << 8 >>> 0);
		}
	}
}
, 

/*	Decompress the body of a byteArray encoded by compressToByteArray (qv)...
	The format is simply a sequence of run-coded pairs, {N D}*.
		N is a run-length * 4 + data code.
		D, the data, depends on the data code...
			0	skip N words, D is absent
				(could be used to skip from one raster line to the next)
			1	N words with all 4 bytes = D (1 byte)
			2	N words all = D (4 bytes)
			3	N words follow in D (4N bytes)
		S and N are encoded as follows (see decodeIntFrom:)...
			0-223	0-223
			224-254	(0-30)*256 + next byte (0-7935)
			255		next 4 bytes */
/*	NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm. */

primitiveDecompressFromByteArray(bmOop, baOop, index) {
	let anInt;
	let code;
	let data;
	let end;
	let i;
	let j;
	let j1;
	let j11;
	let j12;
	let j2;
	let k;
	let m;
	let n;
	let pastEnd;
	let bm;
	let ba;


	/* primitiveExternalCall */

	bm = bmOop.storageType === "words" ? bmOop.wordsAsInt32Array() : PrimitiveFailed.signal();
	ba = baOop.storageType !== "bytes" ? (baOop.storageType !== "words" ? PrimitiveFailed.signal() : baOop.wordsAsUint8Array()) : BYTESOF(baOop);
	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);

	/* byteArray read index */

	i = index;
	end = ba.length;

	/* bitmap write index */

	k = 1;
	pastEnd = bm.length + 1;
	while (i <= end) {

		/* Decode next run start N */

		anInt = ba[i - 1];
		++i;
		if (anInt > 223) {
			if (anInt <= 254) {
				anInt = ((anInt - 224) * 256) + ba[i - 1];
				++i;
			} else {
				anInt = 0;
				for (j = 1; j <= 4; j++) {
					anInt = (anInt << 8 >>> 0) + ba[i - 1];
					++i;
				}
			}
		}
		n = anInt >>> 2;
		if ((k + n) > pastEnd) {
			throw Object.create(PrimitiveFailed).setPayload(1);
		} else {
			code = UBANDS(anInt, 3);
			
			switch (code) {
			case 0:
								break;
			case 1:
				
				/* n consecutive words of 4 bytes = the following byte */

				data = ba[i - 1];
				++i;
				data = UBOR(data, (data << 8 >>> 0));
				data = UBOR(data, (data << 16 >>> 0));
				for (j1 = 1; j1 <= n; j1++) {
					bm[k - 1] = data;
					++k;
				}
				break;
			case 2:
				
				/* n consecutive words = 4 following bytes */

				data = 0;
				for (j11 = 1; j11 <= 4; j11++) {
					data = UBOR((data << 8 >>> 0), ba[i - 1]);
					++i;
				}
				for (j12 = 1; j12 <= n; j12++) {
					bm[k - 1] = data;
					++k;
				}
				break;
			case 3:
				
				/* n consecutive words from the data... */

				for (m = 1; m <= n; m++) {
					data = 0;
					for (j2 = 1; j2 <= 4; j2++) {
						data = UBOR((data << 8 >>> 0), ba[i - 1]);
						++i;
					}
					bm[k - 1] = data;
					++k;
				}
				break;
			default:
				
			}
		}
	}
}
, 
primitiveFindFirstInString(aStringOop, inclusionMapOop, start) {
	let i;
	let stringSize;
	let aString;
	let inclusionMap;


	/* primitiveExternalCall */

	aString = aStringOop.storageType !== "bytes" ? (aStringOop.storageType !== "words" ? PrimitiveFailed.signal() : aStringOop.wordsAsUint8Array()) : BYTESOF(aStringOop);
	inclusionMap = inclusionMapOop.storageType !== "bytes" ? (inclusionMapOop.storageType !== "words" ? PrimitiveFailed.signal() : inclusionMapOop.wordsAsUint8Array()) : BYTESOF(inclusionMapOop);
	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	let ret1;
if (inclusionMap.length !== 256) {
		ret1 = 0;
	} else {
		i = start;
		stringSize = aString.length;
		while ((i <= stringSize) && (inclusionMap[(aString[i - 1] + 1) - 1] === 0)) {
			++i;
		}
		ret1 = (i > stringSize) ? 0 : i;
	};
throw Object.create(PrimitiveReturn).setPayload(ret1);;
}
, 

/*	Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter. */

primitiveFindSubstring(keyOop, bodyOop, start, matchTableOop) {
	let index;
	let startIndex;
	let key;
	let body;
	let matchTable;


	/* primitiveExternalCall */

	key = keyOop.storageType !== "bytes" ? (keyOop.storageType !== "words" ? PrimitiveFailed.signal() : keyOop.wordsAsUint8Array()) : BYTESOF(keyOop);
	body = bodyOop.storageType !== "bytes" ? (bodyOop.storageType !== "words" ? PrimitiveFailed.signal() : bodyOop.wordsAsUint8Array()) : BYTESOF(bodyOop);
	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	matchTable = matchTableOop.storageType !== "bytes" ? (matchTableOop.storageType !== "words" ? PrimitiveFailed.signal() : matchTableOop.wordsAsUint8Array()) : BYTESOF(matchTableOop);
	let ret1;
if (key.length === 0) {

		/* 
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
 */

		ret1 = 0;
	} else {
		startIndex = start;
		const startIndexLimiT = (body.length - key.length) + 1;
		for (; startIndex <= startIndexLimiT; startIndex++) {
			index = 1;
			while (matchTable[(body[startIndex + index - 2] + 1) - 1] === matchTable[(key[index - 1] + 1) - 1]) {
				if (index === key.length) {
					throw Object.create(PrimitiveReturn).setPayload(startIndex);
				} else {
					++index;
				}
			}
		}
		ret1 = 0;
	};
throw Object.create(PrimitiveReturn).setPayload(ret1);;
}
, 
primitiveIndexOfAsciiInString(anInteger, aStringOop, start) {
	let pos;
	let stringSize;
	let aString;


	/* primitiveExternalCall */

	if (!(typeof anInteger === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	aString = aStringOop.storageType !== "bytes" ? (aStringOop.storageType !== "words" ? PrimitiveFailed.signal() : aStringOop.wordsAsUint8Array()) : BYTESOF(aStringOop);
	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	stringSize = aString.length;
	for (pos = start; pos <= stringSize; pos++) {
		if (aString[pos - 1] === anInteger) {
			throw Object.create(PrimitiveReturn).setPayload(pos);
		}
	}
	throw Object.create(PrimitiveReturn).setPayload(0);
}
, 

/*	Answer the hash of a byte-indexed collection,
	using speciesHash as the initial value.
	See SmallInteger>>hashMultiply.

	The primitive should be renamed at a
	suitable point in the future */

primitiveStringHash(aByteArrayOop, speciesHash) {
	let byteArraySize;
	let hash;
	let low;
	let pos;
	let aByteArray;


	/* primitiveExternalCall */

	aByteArray = aByteArrayOop.storageType !== "bytes" ? (aByteArrayOop.storageType !== "words" ? PrimitiveFailed.signal() : aByteArrayOop.wordsAsUint8Array()) : BYTESOF(aByteArrayOop);
	if (!(typeof speciesHash === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	byteArraySize = aByteArray.length;
	hash = UBANDS(speciesHash, 268435455);
	for (pos = 1; pos <= byteArraySize; pos++) {

		/* Begin hashMultiply */

		hash += aByteArray[pos - 1];
		low = UBANDS(hash, 16383);
		hash = UBANDS(((9741 * low) + ((UBANDS(((9741 * (hash >>> 14)) + (101 * low)), 16383)) * 16384)), 268435455);
	}
	throw Object.create(PrimitiveReturn).setPayload(hash);
}
, 

/*	translate the characters in the string by the given table, in place */
/*	primitiveExternalCall */

primitiveTranslateStringWithTable(aStringOop, start, stop, tableOop) {
	let i;
	let aString;
	let table;

	aString = aStringOop.storageType !== "bytes" ? (aStringOop.storageType !== "words" ? PrimitiveFailed.signal() : aStringOop.wordsAsUint8Array()) : BYTESOF(aStringOop);
	if (!(typeof start === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	if (!(typeof stop === "number")) throw Object.create(PrimitiveFailed).setPayload(1);
	table = tableOop.storageType !== "bytes" ? (tableOop.storageType !== "words" ? PrimitiveFailed.signal() : tableOop.wordsAsUint8Array()) : BYTESOF(tableOop);
	for (i = start; i <= stop; i++) {
		aString[i - 1] = table[(aString[i - 1] + 1) - 1];
	}
}
, 
}