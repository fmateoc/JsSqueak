/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:13 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	DeflatePlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let readStreamInstSize = 0;let writeStreamInstSize = 0;let zipBaseDistance = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576];let zipBaseLength = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];let zipBitBuf = 0;let zipBitPos = 0;let zipBlockPos = 0;let zipCollection;let zipCollectionSize = 0;let zipCrcTable = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];let zipDistTable;let zipDistTableSize = 0;let zipDistanceCodes = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];let zipDistanceFreq;let zipDistances;let zipExtraDistanceBits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];let zipExtraLengthBits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];let zipHashHead;let zipHashTail;let zipHashValue = 0;let zipLitTable;let zipLitTableSize = 0;let zipLiteralCount = 0;let zipLiteralFreq;let zipLiteralSize = 0;let zipLiterals;let zipMatchCount = 0;let zipMatchLengthCodes = [257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284];let zipPosition = 0;let zipReadLimit = 0;let zipSource;let zipSourceLimit = 0;let zipSourcePos = 0;let zipState = 0;globalThis.ZipPlugin = {/*	Continue deflating the receiver's collection from blockPosition to lastIndex.	Note that lastIndex must be at least MaxMatch away from the end of collection */deflateBlockchainLengthgoodMatch(lastIndex, chainLength, goodMatch) {	let flushNeeded;	let hasMatch;	let here;	let hereLength;	let hereMatch;	let i;	let matchResult;	let newLength;	let newMatch;	let dist;	let distance;	let literal;	let lit;	let prevEntry;	let here1;	let prevEntry1;	let prevEntry2;	if (zipBlockPos > lastIndex) {		return false;	}	if (zipLiteralCount >= zipLiteralSize) {		return true;	}	hasMatch = false;	here = zipBlockPos;	while (here <= lastIndex) {		if (!hasMatch) {			/* Find the first match */			matchResult = ZipPlugin.findMatchlastLengthlastMatchchainLengthgoodMatch(here, 2, here, chainLength, goodMatch);			/* begin insertStringAt: */			zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[here + 2])), 32767);			prevEntry = zipHashHead[zipHashValue];			zipHashHead[zipHashValue] = here;			zipHashTail[UBANDS(here, 32767)] = prevEntry;			/* end insertStringAt: */			hereMatch = UBANDS(matchResult, 65535);			hereLength = matchResult >>> 16;		}		matchResult = ZipPlugin.findMatchlastLengthlastMatchchainLengthgoodMatch(here + 1, hereLength, hereMatch, chainLength, goodMatch);		newMatch = UBANDS(matchResult, 65535);		/* Now check if the next match is better than the current one.		If not, output the current match (provided that the current match		is at least MinMatch long) */		newLength = matchResult >>> 16;		if ((hereLength >= newLength) && (hereLength >= 3)) {			/* Encode the current match */			/* begin encodeMatch:distance: */			dist = here - hereMatch;			zipLiterals[zipLiteralCount] = (hereLength - 3);			zipDistances[zipLiteralCount] = dist;			literal = zipMatchLengthCodes[hereLength - 3];			zipLiteralFreq[literal]++;			distance = (dist < 257) ? zipDistanceCodes[dist - 1] : zipDistanceCodes[((dist - 1) >>> 7) + 256];			zipDistanceFreq[distance]++;			++zipLiteralCount;			++zipMatchCount;			if (zipLiteralCount === zipLiteralSize) {				flushNeeded = true;			} else {				flushNeeded = ((UBANDS(zipLiteralCount, 4095)) === 0) && ZipPlugin.shouldFlush();			}			/* end encodeMatch:distance: */			for (i = 1; i < hereLength; i++) {				/* begin insertStringAt: */				here1 = here = here + 1;				zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[here1 + 2])), 32767);				prevEntry1 = zipHashHead[zipHashValue];				zipHashHead[zipHashValue] = here1;				zipHashTail[UBANDS(here1, 32767)] = prevEntry1;				/* end insertStringAt: */			}			hasMatch = false;			++here;		} else {			/* Either the next match is better than the current one or we didn't			have a good match after all (e.g., current match length < MinMatch).			Output a single literal. */			/* begin encodeLiteral: */			lit = zipCollection[here];			zipLiterals[zipLiteralCount] = lit;			zipDistances[zipLiteralCount] = 0;			zipLiteralFreq[lit]++;			++zipLiteralCount;			if (zipLiteralCount === zipLiteralSize) {				flushNeeded = true;			} else {				flushNeeded = ((UBANDS(zipLiteralCount, 4095)) === 0) && ZipPlugin.shouldFlush();			}			/* end encodeLiteral: */			++here;			if ((here <= lastIndex) && (!flushNeeded)) {				/* Cache the results for the next round */				/* begin insertStringAt: */				zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[here + 2])), 32767);				prevEntry2 = zipHashHead[zipHashValue];				zipHashHead[zipHashValue] = here;				zipHashTail[UBANDS(here, 32767)] = prevEntry2;				/* end insertStringAt: */				hasMatch = true;				hereMatch = newMatch;				hereLength = newLength;			}		}		if (flushNeeded) {			zipBlockPos = here;			return true;		}	}	zipBlockPos = here;	return false;}, /*	Find the longest match for the string starting at here.	If there is no match longer than lastLength return lastMatch/lastLength.	Traverse at most maxChainLength entries in the hash table.	Stop if a match of at least goodMatch size has been found. */findMatchlastLengthlastMatchchainLengthgoodMatch(here, lastLength, lastMatch, maxChainLength, goodMatch) {	let bestLength;	let chainLength;	let distance;	let length;	let limit;	let matchPos;	let matchResult;	let length1;	/* Compute the default match result */	/* There is no way to find a better match than MaxMatch */	matchResult = UBOR((lastLength << 16 >>> 0), lastMatch);	if (lastLength >= 258) {		return matchResult;	}	/* Compute the distance to the (possible) match */	matchPos = zipHashHead[UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[here + 2])), 32767)];	/* Note: It is required that 0 < distance < MaxDistance */	distance = here - matchPos;	if (!((distance > 0) && (distance < 32768))) {		return matchResult;	}	/* Max. nr of match chain to search */	chainLength = maxChainLength;	/* Best match length so far (current match must be larger to take effect) */	limit = (here > 32768) ? (here - 32768) : 0;	bestLength = lastLength;	while (true) {		/* Compare the current string with the string at match position */		/* begin compare:with:min: */		if (zipCollection[here + bestLength] === zipCollection[matchPos + bestLength]) {			if (zipCollection[(here + bestLength) - 1] === zipCollection[(matchPos + bestLength) - 1]) {				if (zipCollection[here] === zipCollection[matchPos]) {					if (zipCollection[here + 1] === zipCollection[matchPos + 1]) {						length1 = 2;						while ((length1 < 258) && (zipCollection[here + length1] === zipCollection[matchPos + length1])) {							++length1;						}						length = length1;					} else {						length = 1;					}				} else {					length = 0;				}			} else {				length = 0;			}		} else {			length = 0;		}		/* end compare:with:min: */		if ((here + length) > zipPosition) {			length = zipPosition - here;		}		if ((length === 3) && ((here - matchPos) > (8192))) {			length = 2;		}		if (length > bestLength) {			/* We have a new (better) match than before */			/* Compute the new match result */			matchResult = UBOR((length << 16 >>> 0), matchPos);			/* There is no way to find a better match than MaxMatch */			bestLength = length;			if (bestLength >= 258) {				return matchResult;			}			if (bestLength > goodMatch) {				return matchResult;			}		}		if (((--chainLength)) <= 0) {			return matchResult;		}		matchPos = zipHashTail[UBANDS(matchPos, 32767)];		if (matchPos <= limit) {			return matchResult;		}	}}, loadDeflateStreamFrom(rcvr) {	let oop;	let sq_class;	if (!((rcvr.storageType === "pointers") && (SIZEOF(rcvr) >= 15))) {		return false;	}	oop = rcvr.pointers[0];	if ((oop.storageType !== "bytes")) {		return false;	}	if (writeStreamInstSize === 0) {		/* begin determineSizeOfWriteStream: */		sq_class = rcvr._class();		while ((sq_class !== nil) && (sq_class.prototype.instSize >= 7)) {			sq_class = sq_class.pointers[0];		}		if (sq_class === nil) {			return false;		} else {			writeStreamInstSize = sq_class.prototype.instSize;		}		/* end determineSizeOfWriteStream: */		if (SIZEOF(rcvr) < (writeStreamInstSize + 5)) {			writeStreamInstSize = 0;			return false;		}	}	zipCollection = BYTESOF(oop);	zipCollectionSize = BYTESIZEOF(oop);	zipPosition = rcvr.pointers[1];	/* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */	/* hashHead */	zipReadLimit = rcvr.pointers[2];	oop = rcvr.pointers[(writeStreamInstSize)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 32768))) {		return false;	}	/* hashTail */	zipHashHead = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 1)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 32768))) {		return false;	}	zipHashTail = oop.words;	zipHashValue = rcvr.pointers[(writeStreamInstSize + 2)];	/* zipBlockStart := interpreterProxy fetchInteger: writeStreamInstSize + 4 ofObject: rcvr. */	/* literals */	zipBlockPos = rcvr.pointers[(writeStreamInstSize + 3)];	oop = rcvr.pointers[(writeStreamInstSize + 5)];	if ((oop.storageType !== "bytes")) {		return false;	}	zipLiteralSize = SIZEOF(oop);	/* distances */	zipLiterals = BYTESOF(oop);	oop = rcvr.pointers[(writeStreamInstSize + 6)];	if (!((oop.storageType === "words") && (SIZEOF(oop) >= zipLiteralSize))) {		return false;	}	/* literalFreq */	zipDistances = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 7)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 286))) {		return false;	}	/* distanceFreq */	zipLiteralFreq = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 8)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 30))) {		return false;	}	zipDistanceFreq = oop.words;	zipLiteralCount = rcvr.pointers[(writeStreamInstSize + 9)];	zipMatchCount = rcvr.pointers[(writeStreamInstSize + 10)];	return true;}, loadZipEncoderFrom(rcvr) {	let oop;	let sq_class;	if (writeStreamInstSize === 0) {		/* begin determineSizeOfWriteStream: */		sq_class = rcvr._class();		while ((sq_class !== nil) && (sq_class.prototype.instSize >= 7)) {			sq_class = sq_class.pointers[0];		}		if (sq_class === nil) {			return false;		} else {			writeStreamInstSize = sq_class.prototype.instSize;		}		/* end determineSizeOfWriteStream: */		if (SIZEOF(rcvr) < (writeStreamInstSize + 3)) {			writeStreamInstSize = 0;			return false;		}	}	if (!((rcvr.storageType === "pointers") && (SIZEOF(rcvr) >= (writeStreamInstSize + 3)))) {		return false;	}	oop = rcvr.pointers[0];	if ((oop.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipCollection = BYTESOF(oop);	zipCollectionSize = BYTESIZEOF(oop);	zipPosition = rcvr.pointers[1];	/* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */	zipReadLimit = rcvr.pointers[2];	zipBitBuf = rcvr.pointers[writeStreamInstSize];	zipBitPos = rcvr.pointers[(writeStreamInstSize + 1)];	return true;}, /*	Primitive. Deflate the current contents of the receiver. */primitiveDeflateBlock(lastIndex, chainLength, goodMatch) {	let result;	if (arguments.length !== 3) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(typeof goodMatch === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof chainLength === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof lastIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof this === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!ZipPlugin.loadDeflateStreamFrom(this)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	result = ZipPlugin.deflateBlockchainLengthgoodMatch(lastIndex, chainLength, goodMatch);	this.pointers[(writeStreamInstSize + 2)] = zipHashValue;	this.pointers[(writeStreamInstSize + 3)] = zipBlockPos;	this.pointers[(writeStreamInstSize + 9)] = zipLiteralCount;	this.pointers[(writeStreamInstSize + 10)] = zipMatchCount;	throw Object.create(PrimitiveReturn).setPayload((typeof result === "boolean" ? result : PrimitiveFailed.signal()));}, /*	Primitive. Update the hash tables after data has been moved by delta. */primitiveDeflateUpdateHashTable(table, delta) {	let entry;	let i;	let tablePtr;	let tableSize;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(typeof delta === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof table === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((table.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	tableSize = SIZEOF(table);	tablePtr = table.wordsAsInt32Array();	for (i = 0; i < tableSize; i++) {		entry = tablePtr[i];		if (entry >= delta) {			tablePtr[i] = (entry - delta);		} else {			tablePtr[i] = 0;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Inflate a single block. */primitiveInflateDecompressBlock(oop, oop1) {	let collection;	let source;	let sq_class;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((oop1.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipDistTable = oop1.words;	/* literal table */	zipDistTableSize = SIZEOF(oop1);	if ((oop.storageType !== "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipLitTable = oop.words;	/* Receiver (InflateStream) */	zipLitTableSize = SIZEOF(oop);	if ((this.storageType !== "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (readStreamInstSize === 0) {		/* begin determineSizeOfReadStream: */		sq_class = this._class();		while ((sq_class !== nil) && (sq_class.prototype.instSize >= 13)) {			sq_class = sq_class.pointers[0];		}		if (sq_class === nil) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			readStreamInstSize = sq_class.prototype.instSize;		}		/* end determineSizeOfReadStream: */		if (SIZEOF(this) < (readStreamInstSize + 8)) {			readStreamInstSize = 0;			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (SIZEOF(this) < (readStreamInstSize + 8)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipReadLimit = this.pointers[2];	zipState = this.pointers[(readStreamInstSize)];	zipBitBuf = this.pointers[(readStreamInstSize + 1)];	zipBitPos = this.pointers[(readStreamInstSize + 2)];	zipSourcePos = this.pointers[(readStreamInstSize + 4)];	zipSourceLimit = this.pointers[(readStreamInstSize + 5)];	--zipReadLimit;	--zipSourcePos;	--zipSourceLimit;	collection = this.pointers[0];	if ((collection.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipCollection = BYTESOF(collection);	zipCollectionSize = BYTESIZEOF(collection);	source = this.pointers[(readStreamInstSize + 3)];	if ((source.storageType !== "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* do the primitive */	zipSource = BYTESOF(source);	ZipPlugin.zipDecompressBlock.apply(this, arguments);	const origReadLimit = this.pointers[2];collection.string = (origReadLimit === 0 ? "" : collection.string) + String.fromCodePoint(...zipCollection.subarray(origReadLimit, zipReadLimit + 1));collection.dirty = false;;	this.pointers[2] = (zipReadLimit + 1);	this.pointers[(readStreamInstSize)] = zipState;	this.pointers[(readStreamInstSize + 1)] = zipBitBuf;	this.pointers[(readStreamInstSize + 2)] = zipBitPos;	this.pointers[(readStreamInstSize + 4)] = (zipSourcePos + 1);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Update a 32bit CRC value. */primitiveUpdateAdler32(_arg1, startIndex, stopIndex, collection) {	let adler32;	let b;	let bytePtr;	let i;	let length;	let s1;	let s2;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof collection === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof stopIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	adler32 = (_arg1 >>> 0) === _arg1.valueOf() ? _arg1 : PrimitiveFailed.signal();	if (!((collection.storageType === "bytes") && ((stopIndex >= startIndex) && (startIndex > 0)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(collection);	if (stopIndex > length) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	bytePtr = BYTESOF(collection);	--startIndex;	--stopIndex;	s1 = UBANDS(adler32, 65535);	s2 = UBANDS((adler32 >>> 16), 65535);	for (i = startIndex; i <= stopIndex; i++) {		b = bytePtr[i];		s1 = MOD((s1 + b), 65521);		s2 = MOD((s2 + s1), 65521);	}	adler32 = (s2 << 16 >>> 0) + s1;	throw Object.create(PrimitiveReturn).setPayload(((adler32 >>> 0) !== adler32.valueOf() ? PrimitiveFailed.signal() : (adler32 >= 0 ? adler32 : 4294967296 + adler32)));}, /*	Primitive. Update a 32bit CRC value. */primitiveUpdateGZipCrc32(_arg1, startIndex, stopIndex, collection) {	let bytePtr;	let crc;	let i;	let length;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof collection === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof stopIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof startIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	crc = (_arg1 >>> 0) === _arg1.valueOf() ? _arg1 : PrimitiveFailed.signal();	if (!((collection.storageType === "bytes") && ((stopIndex >= startIndex) && (startIndex > 0)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(collection);	if (stopIndex > length) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	bytePtr = BYTESOF(collection);	--startIndex;	--stopIndex;	for (i = startIndex; i <= stopIndex; i++) {		crc = UBXOR(zipCrcTable[UBANDS((UBXOR(crc, bytePtr[i])), 255)], (crc >>> 8));	}	throw Object.create(PrimitiveReturn).setPayload(((crc >>> 0) !== crc.valueOf() ? PrimitiveFailed.signal() : (crc >= 0 ? crc : 4294967296 + crc)));}, primitiveZipSendBlock(litStream, distStream, litTree, distTree) {	let result;	let code;	let dist;	let distArray;	let distBitLengths;	let distBlCount;	let distCodes;	let extra;	let lit;	let litArray;	let litBlCount;	let litLimit;	let litPos;	let llBitLengths;	let llCodes;	let oop;	let sum;	let nBits;	let value;	let nBits1;	let value1;	let nBits2;	let value2;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (typeof distTree === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof litTree === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof distStream === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof litStream === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof this === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (!ZipPlugin.loadZipEncoderFrom(this)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((distTree.storageType === "pointers") && (SIZEOF(distTree) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((litTree.storageType === "pointers") && (SIZEOF(litTree) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((litStream.storageType === "pointers") && (SIZEOF(litStream) >= 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((distStream.storageType === "pointers") && (SIZEOF(distStream) >= 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin sendBlock:with:with:with: */	oop = litStream.pointers[0];	litPos = litStream.pointers[1];	litLimit = litStream.pointers[2];	if ((litPos <= litLimit) && ((oop.storageType === "bytes") && (litLimit <= BYTESIZEOF(oop)))) {		litArray = BYTESOF(oop);		oop = distStream.pointers[0];		if ((oop.storageType === "words") && ((litLimit <= SIZEOF(oop)) && ((distStream.pointers[1] === litPos) && (distStream.pointers[2] === litLimit)))) {			distArray = oop.words;			oop = litTree.pointers[0];			if ((oop.storageType === "words")) {				litBlCount = SIZEOF(oop);				llBitLengths = oop.words;				oop = litTree.pointers[1];				if ((oop.storageType === "words") && (litBlCount === SIZEOF(oop))) {					llCodes = oop.words;					oop = distTree.pointers[0];					if ((oop.storageType === "words")) {						distBlCount = SIZEOF(oop);						distBitLengths = oop.words;						oop = distTree.pointers[1];						if ((oop.storageType === "words") && (distBlCount === SIZEOF(oop))) {							distCodes = oop.words;							/* begin nextZipBits:put: */													zipBitBuf = UBOR(zipBitBuf, (SHL(0, zipBitPos)));						zipBitPos += 0;						while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {							zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));							++zipPosition;							zipBitBuf = zipBitBuf >>> 8;							zipBitPos -= 8;						}							/* end nextZipBits:put: */							sum = 0;							while ((litPos < litLimit) && ((zipPosition + 4) < zipCollectionSize)) {								lit = litArray[litPos];								dist = distArray[litPos];								++litPos;								if (dist === 0) {									++sum;									if (lit < litBlCount) {										/* begin nextZipBits:put: */										nBits = llBitLengths[lit];										value = llCodes[lit];										if ((value >= 0) && ((SHL(1, nBits)) > value)) {											zipBitBuf = UBOR(zipBitBuf, (SHL(value, zipBitPos)));											zipBitPos += nBits;											while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {												zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));												++zipPosition;												zipBitBuf = zipBitBuf >>> 8;												zipBitPos -= 8;											}										} else {											throw Object.create(PrimitiveFailed).setPayload(1);										}										/* end nextZipBits:put: */									} else {										throw Object.create(PrimitiveFailed).setPayload(1);									}								} else {									sum = (sum + lit) + 3;									if (lit < 256) {										code = zipMatchLengthCodes[lit];										if (code < litBlCount) {											/* begin nextZipBits:put: */											nBits2 = llBitLengths[code];											value2 = llCodes[code];											if ((value2 >= 0) && ((SHL(1, nBits2)) > value2)) {												zipBitBuf = UBOR(zipBitBuf, (SHL(value2, zipBitPos)));												zipBitPos += nBits2;												while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {													zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));													++zipPosition;													zipBitBuf = zipBitBuf >>> 8;													zipBitPos -= 8;												}											} else {												throw Object.create(PrimitiveFailed).setPayload(1);											}											/* end nextZipBits:put: */											extra = zipExtraLengthBits[code - 257];											if (extra !== 0) {												lit -= zipBaseLength[code - 257];												/* begin nextZipBits:put: */												if ((lit >= 0) && ((SHL(1, extra)) > lit)) {													zipBitBuf = UBOR(zipBitBuf, (SHL(lit, zipBitPos)));													zipBitPos += extra;													while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {														zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));														++zipPosition;														zipBitBuf = zipBitBuf >>> 8;														zipBitPos -= 8;													}												} else {													throw Object.create(PrimitiveFailed).setPayload(1);												}												/* end nextZipBits:put: */											}											--dist;											if (dist < 32768) {												code = (dist < 256) ? zipDistanceCodes[dist] : zipDistanceCodes[(dist >>> 7) + 256];												if (code < distBlCount) {													/* begin nextZipBits:put: */													nBits1 = distBitLengths[code];													value1 = distCodes[code];													if ((value1 >= 0) && ((SHL(1, nBits1)) > value1)) {														zipBitBuf = UBOR(zipBitBuf, (SHL(value1, zipBitPos)));														zipBitPos += nBits1;														while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {															zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));															++zipPosition;															zipBitBuf = zipBitBuf >>> 8;															zipBitPos -= 8;														}													} else {														throw Object.create(PrimitiveFailed).setPayload(1);													}													/* end nextZipBits:put: */													extra = zipExtraDistanceBits[code];													if (extra !== 0) {														dist -= zipBaseDistance[code];														/* begin nextZipBits:put: */														if ((dist >= 0) && ((SHL(1, extra)) > dist)) {															zipBitBuf = UBOR(zipBitBuf, (SHL(dist, zipBitPos)));															zipBitPos += extra;															while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {																zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));																++zipPosition;																zipBitBuf = zipBitBuf >>> 8;																zipBitPos -= 8;															}														} else {															throw Object.create(PrimitiveFailed).setPayload(1);														}														/* end nextZipBits:put: */													}												} else {													throw Object.create(PrimitiveFailed).setPayload(1);												}											} else {												throw Object.create(PrimitiveFailed).setPayload(1);											}										} else {											throw Object.create(PrimitiveFailed).setPayload(1);										}									} else {										throw Object.create(PrimitiveFailed).setPayload(1);									}								}							}							litStream.pointers[1] = litPos;							distStream.pointers[1] = litPos;							result = sum;						} else {							throw Object.create(PrimitiveFailed).setPayload(1);						}					} else {						throw Object.create(PrimitiveFailed).setPayload(1);					}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end sendBlock:with:with:with: */	this.pointers[1] = zipPosition;	this.pointers[writeStreamInstSize] = zipBitBuf;	this.pointers[(writeStreamInstSize + 1)] = zipBitPos;	throw Object.create(PrimitiveReturn).setPayload(((typeof result === "number") ? result : PrimitiveFailed.signal()));}, /*	Check if we should flush the current block.	Flushing can be useful if the input characteristics change. */shouldFlush() {	let nLits;	if (zipLiteralCount === zipLiteralSize) {		return true;	}	if ((UBANDS(zipLiteralCount, 4095)) !== 0) {		return false;	}	if ((zipMatchCount * 10) <= zipLiteralCount) {		/* This is basically random data. 		There is no need to flush early since the overhead		for encoding the trees will add to the overall size */		return false;	}	nLits = zipLiteralCount - zipMatchCount;	return nLits > zipMatchCount && ((nLits * 4) <= zipMatchCount);}, zipDecompressBlock() {	let distance;	let dstPos;	let extra;	let i;	let length;	let max;	let oldBitPos;	let oldBits;	let oldPos;	let srcPos;	let value;	let arg11;	let bits;	let byte;	let arg12;	let bits1;	let byte1;	let bits2;	let bitsNeeded;	let index;	let tableIndex;	let value1;	let bits11;	let byte2;	let brokenFromLoop_zipDecodeValueFromsize_3403;	let bits3;	let bitsNeeded1;	let index1;	let tableIndex1;	let value2;	let bits12;	let byte3;	let brokenFromLoop_zipDecodeValueFromsize_2835;	max = zipCollectionSize - 1;	while ((zipReadLimit < max) && (zipSourcePos <= zipSourceLimit)) {		/* Back up stuff if we're running out of space */		oldBits = zipBitBuf;		oldBitPos = zipBitPos;		oldPos = zipSourcePos;		/* begin zipDecodeValueFrom:size: */		bitsNeeded1 = zipLitTable[0] >>> 24;		if (bitsNeeded1 > 16) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			tableIndex1 = 2;			brokenFromLoop_zipDecodeValueFromsize_2835 = false;			while (true) {				/* begin zipNextBits: */				while (zipBitPos < bitsNeeded1) {					byte3 = zipSource[(++zipSourcePos)];					zipBitBuf += SHL(byte3, zipBitPos);					zipBitPos += 8;				}				bits12 = UBAND(zipBitBuf, ((SHL(1, bitsNeeded1)) - 1));				zipBitBuf = SHR(zipBitBuf, bitsNeeded1);				zipBitPos -= bitsNeeded1;				bits3 = bits12;				/* end zipNextBits: */				index1 = (tableIndex1 + bits3) - 1;				if (index1 >= zipLitTableSize) {					throw Object.create(PrimitiveFailed).setPayload(1);				} else {					value2 = zipLitTable[index1];					if ((UBANDS(value2, 1056964608)) === 0) {						value = value2;						brokenFromLoop_zipDecodeValueFromsize_2835 = true;						break;					} else {						tableIndex1 = UBANDS(value2, 65535);						bitsNeeded1 = UBANDS((value2 >>> 24), 255);						if (bitsNeeded1 > 16) {							throw Object.create(PrimitiveFailed).setPayload(1);						}					}				}			}			value = brokenFromLoop_zipDecodeValueFromsize_2835 ? value : 0;		}		/* end zipDecodeValueFrom:size: */		if (value < 256) {			/* A literal */			zipCollection[(++zipReadLimit)] = value;		} else {			/* length/distance or end of block */			if (value === 256) {				/* End of block */				zipState = UBANDS(zipState, 1);				return 0;			}			extra = (value >>> 16) - 1;			length = UBANDS(value, 65535);			if (extra > 0) {				/* begin zipNextBits: */				while (zipBitPos < extra) {					byte = zipSource[(++zipSourcePos)];					zipBitBuf += SHL(byte, zipBitPos);					zipBitPos += 8;				}				bits = UBAND(zipBitBuf, ((SHL(1, extra)) - 1));				zipBitBuf = SHR(zipBitBuf, extra);				zipBitPos -= extra;				arg11 = bits;				/* end zipNextBits: */				length += arg11;			}			/* begin zipDecodeValueFrom:size: */			bitsNeeded = zipDistTable[0] >>> 24;			if (bitsNeeded > 16) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				tableIndex = 2;				brokenFromLoop_zipDecodeValueFromsize_3403 = false;				while (true) {					/* begin zipNextBits: */					while (zipBitPos < bitsNeeded) {						byte2 = zipSource[(++zipSourcePos)];						zipBitBuf += SHL(byte2, zipBitPos);						zipBitPos += 8;					}					bits11 = UBAND(zipBitBuf, ((SHL(1, bitsNeeded)) - 1));					zipBitBuf = SHR(zipBitBuf, bitsNeeded);					zipBitPos -= bitsNeeded;					bits2 = bits11;					/* end zipNextBits: */					index = (tableIndex + bits2) - 1;					if (index >= zipDistTableSize) {						throw Object.create(PrimitiveFailed).setPayload(1);					} else {						value1 = zipDistTable[index];						if ((UBANDS(value1, 1056964608)) === 0) {							value = value1;							brokenFromLoop_zipDecodeValueFromsize_3403 = true;							break;						} else {							tableIndex = UBANDS(value1, 65535);							bitsNeeded = UBANDS((value1 >>> 24), 255);							if (bitsNeeded > 16) {								throw Object.create(PrimitiveFailed).setPayload(1);							}						}					}				}				value = brokenFromLoop_zipDecodeValueFromsize_3403 ? value : 0;			}			/* end zipDecodeValueFrom:size: */			extra = value >>> 16;			distance = UBANDS(value, 65535);			if (extra > 0) {				/* begin zipNextBits: */				while (zipBitPos < extra) {					byte1 = zipSource[(++zipSourcePos)];					zipBitBuf += SHL(byte1, zipBitPos);					zipBitPos += 8;				}				bits1 = UBAND(zipBitBuf, ((SHL(1, extra)) - 1));				zipBitBuf = SHR(zipBitBuf, extra);				zipBitPos -= extra;				arg12 = bits1;				/* end zipNextBits: */				distance += arg12;			}			if ((zipReadLimit + length) >= max) {				zipBitBuf = oldBits;				zipBitPos = oldBitPos;				zipSourcePos = oldPos;				return 0;			}			dstPos = zipReadLimit;			srcPos = zipReadLimit - distance;			for (i = 1; i <= length; i++) {				zipCollection[dstPos + i] = zipCollection[srcPos + i];			}			zipReadLimit += length;		}	}}, }