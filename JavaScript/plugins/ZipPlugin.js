/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 26 July 2023 12:01:55 am *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	DeflatePlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let readStreamInstSize = 0;let writeStreamInstSize = 0;let zipBaseDistance = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576];let zipBaseLength = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];let zipBitBuf = 0;let zipBitPos = 0;let zipBlockPos = 0;let zipBlockStart = 0;let zipCollection;let zipCollectionSize = 0;let zipCrcTable = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];let zipDistTable;let zipDistTableSize = 0;let zipDistanceCodes = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];let zipDistanceFreq;let zipDistances;let zipExtraDistanceBits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];let zipExtraLengthBits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];let zipHashHead;let zipHashTail;let zipHashValue = 0;let zipLitTable;let zipLitTableSize = 0;let zipLiteralCount = 0;let zipLiteralFreq;let zipLiteralSize = 0;let zipLiterals;let zipMatchCount = 0;let zipMatchLengthCodes = [257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284];let zipPosition = 0;let zipReadLimit = 0;let zipSource;let zipSourceLimit = 0;let zipSourcePos = 0;let zipState = 0;globalThis.ZipPlugin = {/*	Continue deflating the receiver's collection from blockPosition to lastIndex.	Note that lastIndex must be at least MaxMatch away from the end of collection */deflateBlockchainLengthgoodMatch(lastIndex, chainLength, goodMatch) {	let flushNeeded;	let hasMatch;	let here;	let hereLength;	let hereMatch;	let i;	let matchResult;	let newLength;	let newMatch;	let dist;	let distance;	let literal;	let lit;	let prevEntry;	let here1;	let prevEntry1;	let prevEntry2;	if (zipBlockPos > lastIndex) {		return false;	}	if (zipLiteralCount >= zipLiteralSize) {		return true;	}	hasMatch = false;	here = zipBlockPos;	while (here <= lastIndex) {		if (!hasMatch) {			/* Find the first match */			matchResult = ZipPlugin.findMatchlastLengthlastMatchchainLengthgoodMatch(here, 2, here, chainLength, goodMatch);			/* begin insertStringAt: */			zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[(here + 3) - 1])), 32767);			prevEntry = zipHashHead[zipHashValue];			zipHashHead[zipHashValue] = here;			zipHashTail[UBANDS(here, 32767)] = prevEntry;			/* end insertStringAt: */			hereMatch = UBANDS(matchResult, 65535);			hereLength = matchResult >>> 16;		}		matchResult = ZipPlugin.findMatchlastLengthlastMatchchainLengthgoodMatch(here + 1, hereLength, hereMatch, chainLength, goodMatch);		newMatch = UBANDS(matchResult, 65535);		/* Now check if the next match is better than the current one.		If not, output the current match (provided that the current match		is at least MinMatch long) */		newLength = matchResult >>> 16;		if ((hereLength >= newLength) && (hereLength >= 3)) {			/* Encode the current match */			/* begin encodeMatch:distance: */			dist = here - hereMatch;			zipLiterals[zipLiteralCount] = (hereLength - 3);			zipDistances[zipLiteralCount] = dist;			literal = zipMatchLengthCodes[hereLength - 3];			zipLiteralFreq[literal]++;			distance = (dist < 257) ? zipDistanceCodes[dist - 1] : zipDistanceCodes[256 + ((dist - 1) >>> 7)];			zipDistanceFreq[distance]++;			++zipLiteralCount;			++zipMatchCount;			flushNeeded = (zipLiteralCount === zipLiteralSize) || (((UBANDS(zipLiteralCount, 4095)) === 0) && (ZipPlugin.shouldFlush()));			/* end encodeMatch:distance: */			for (i = 1; i < hereLength; i++) {				/* begin insertStringAt: */				here1 = (++here);				zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[(here1 + 3) - 1])), 32767);				prevEntry1 = zipHashHead[zipHashValue];				zipHashHead[zipHashValue] = here1;				zipHashTail[UBANDS(here1, 32767)] = prevEntry1;				/* end insertStringAt: */			}			hasMatch = false;			++here;		} else {			/* Either the next match is better than the current one or we didn't			have a good match after all (e.g., current match length < MinMatch).			Output a single literal. */			/* begin encodeLiteral: */			lit = zipCollection[here];			zipLiterals[zipLiteralCount] = lit;			zipDistances[zipLiteralCount] = 0;			zipLiteralFreq[lit]++;			++zipLiteralCount;			flushNeeded = (zipLiteralCount === zipLiteralSize) || (((UBANDS(zipLiteralCount, 4095)) === 0) && (ZipPlugin.shouldFlush()));			/* end encodeLiteral: */			++here;			if ((here <= lastIndex) && (!flushNeeded)) {				/* Cache the results for the next round */				/* begin insertStringAt: */				zipHashValue = UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[(here + 3) - 1])), 32767);				prevEntry2 = zipHashHead[zipHashValue];				zipHashHead[zipHashValue] = here;				zipHashTail[UBANDS(here, 32767)] = prevEntry2;				/* end insertStringAt: */				hasMatch = true;				hereMatch = newMatch;				hereLength = newLength;			}		}		if (flushNeeded) {			zipBlockPos = here;			return true;		}	}	zipBlockPos = here;	return false;}, /*	Determine the inst size of the class above InflateStream by	 looking for the first class whose inst size is less than 13. */determineSizeOfReadStream(rcvr) {	let sq_class;	sq_class = rcvr._class();	while ((sq_class !== nil) && (sq_class.prototype.instSize >= 13)) {		sq_class = sq_class.pointers[0];	}	if (sq_class === nil) {		return false;	} else {		readStreamInstSize = sq_class.prototype.instSize;		return true;	}}, /*	Determine the inst size of the class above DeflateStream or	 ZipEncoder by looking for the first class whose inst size is less than 7. */determineSizeOfWriteStream(rcvr) {	let sq_class;	sq_class = rcvr._class();	while ((sq_class !== nil) && (sq_class.prototype.instSize >= 7)) {		sq_class = sq_class.pointers[0];	}	if (sq_class === nil) {		return false;	} else {		writeStreamInstSize = sq_class.prototype.instSize;		return true;	}}, /*	Find the longest match for the string starting at here.	If there is no match longer than lastLength return lastMatch/lastLength.	Traverse at most maxChainLength entries in the hash table.	Stop if a match of at least goodMatch size has been found. */findMatchlastLengthlastMatchchainLengthgoodMatch(here, lastLength, lastMatch, maxChainLength, goodMatch) {	let bestLength;	let chainLength;	let distance;	let length;	let limit;	let matchPos;	let matchResult;	let length1;	let zzzTemp;	let zzzTemp1;	let zzzTemp2;	/* Compute the default match result */	/* There is no way to find a better match than MaxMatch */	matchResult = UBOR((lastLength << 16 >>> 0), lastMatch);	if (lastLength >= 258) {		return matchResult;	}	/* Compute the distance to the (possible) match */	matchPos = zipHashHead[UBANDS((UBXOR((zipHashValue << 5 >>> 0), zipCollection[(here + 3) - 1])), 32767)];	/* Note: It is required that 0 < distance < MaxDistance */	distance = here - matchPos;	if (!((distance > 0) && (distance < 32768))) {		return matchResult;	}	/* Max. nr of match chain to search */	chainLength = maxChainLength;	/* Best match length so far (current match must be larger to take effect) */	limit = (here > 32768) ? (here - 32768) : 0;	bestLength = lastLength;	while (true) {		/* Compare the current string with the string at match position */		/* begin compare:with:min: */		if (zipCollection[here + bestLength] === zipCollection[matchPos + bestLength]) {			if (zipCollection[(here + bestLength) - 1] === zipCollection[(matchPos + bestLength) - 1]) {				if (zipCollection[here] === zipCollection[matchPos]) {					if (zipCollection[here + 1] === zipCollection[matchPos + 1]) {						length1 = 2;						while ((length1 < 258) && (zipCollection[here + length1] === zipCollection[matchPos + length1])) {							++length1;						}						zzzTemp2 = length1;					} else {						zzzTemp2 = 1;					}					zzzTemp1 = zzzTemp2;				} else {					zzzTemp1 = 0;				}				zzzTemp = zzzTemp1;			} else {				zzzTemp = 0;			}			length = zzzTemp;		} else {			length = 0;		}		/* end compare:with:min: */		if ((here + length) > zipPosition) {			length = zipPosition - here;		}		if ((length === 3) && ((here - matchPos) > (8192))) {			length = 2;		}		if (length > bestLength) {			/* We have a new (better) match than before */			/* Compute the new match result */			matchResult = UBOR((length << 16 >>> 0), matchPos);			/* There is no way to find a better match than MaxMatch */			bestLength = length;			if (bestLength >= 258) {				return matchResult;			}			if (bestLength > goodMatch) {				return matchResult;			}		}		if (!(((--chainLength)) > 0)) {			return matchResult;		}		matchPos = zipHashTail[UBANDS(matchPos, 32767)];		if (matchPos <= limit) {			return matchResult;		}	}}, loadDeflateStreamFrom(rcvr) {	let oop;	if (!((rcvr.storageType === "pointers") && (SIZEOF(rcvr) >= 15))) {		return false;	}	oop = rcvr.pointers[0];	if (!(oop.storageType === "bytes")) {		return false;	}	if (writeStreamInstSize === 0) {		if (!ZipPlugin.determineSizeOfWriteStream(rcvr)) {			return false;		}		if (SIZEOF(rcvr) < (writeStreamInstSize + 5)) {			writeStreamInstSize = 0;			return false;		}	}	zipCollection = BYTESOF(oop);	zipCollectionSize = BYTESIZEOF(oop);	zipPosition = rcvr.pointers[1];	/* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */	/* hashHead */	zipReadLimit = rcvr.pointers[2];	oop = rcvr.pointers[(writeStreamInstSize + 0)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 32768))) {		return false;	}	/* hashTail */	zipHashHead = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 1)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 32768))) {		return false;	}	zipHashTail = oop.words;	zipHashValue = rcvr.pointers[(writeStreamInstSize + 2)];	/* zipBlockStart := interpreterProxy fetchInteger: writeStreamInstSize + 4 ofObject: rcvr. */	/* literals */	zipBlockPos = rcvr.pointers[(writeStreamInstSize + 3)];	oop = rcvr.pointers[(writeStreamInstSize + 5)];	if (!(oop.storageType === "bytes")) {		return false;	}	zipLiteralSize = SIZEOF(oop);	/* distances */	zipLiterals = BYTESOF(oop);	oop = rcvr.pointers[(writeStreamInstSize + 6)];	if (!((oop.storageType === "words") && (SIZEOF(oop) >= zipLiteralSize))) {		return false;	}	/* literalFreq */	zipDistances = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 7)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 286))) {		return false;	}	/* distanceFreq */	zipLiteralFreq = oop.words;	oop = rcvr.pointers[(writeStreamInstSize + 8)];	if (!((oop.storageType === "words") && (SIZEOF(oop) === 30))) {		return false;	}	zipDistanceFreq = oop.words;	zipLiteralCount = rcvr.pointers[(writeStreamInstSize + 9)];	zipMatchCount = rcvr.pointers[(writeStreamInstSize + 10)];	return true;}, loadZipEncoderFrom(rcvr) {	let oop;	if (writeStreamInstSize === 0) {		if (!ZipPlugin.determineSizeOfWriteStream(rcvr)) {			return false;		}		if (SIZEOF(rcvr) < (writeStreamInstSize + 3)) {			writeStreamInstSize = 0;			return false;		}	}	if (!((rcvr.storageType === "pointers") && (SIZEOF(rcvr) >= (writeStreamInstSize + 3)))) {		return false;	}	oop = rcvr.pointers[0];	if (!(oop.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipCollection = BYTESOF(oop);	zipCollectionSize = BYTESIZEOF(oop);	zipPosition = rcvr.pointers[1];	/* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */	zipReadLimit = rcvr.pointers[2];	zipBitBuf = rcvr.pointers[writeStreamInstSize];	zipBitPos = rcvr.pointers[(writeStreamInstSize + 1)];	return true;}, /*	Primitive. Deflate the current contents of the receiver. */primitiveDeflateBlock(lastIndex, chainLength, goodMatch) {	let result;	if (arguments.length !== 3) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof goodMatch === "number") ? goodMatch : PrimitiveFailed.signal());	((typeof chainLength === "number") ? chainLength : PrimitiveFailed.signal());	((typeof lastIndex === "number") ? lastIndex : PrimitiveFailed.signal());	((typeof this === "number") ? PrimitiveFailed.signal() : this);	;	;	if (!ZipPlugin.loadDeflateStreamFrom(this)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	result = ZipPlugin.deflateBlockchainLengthgoodMatch(lastIndex, chainLength, goodMatch);	/* Store back modified values */this.pointers[(writeStreamInstSize + 2)] = zipHashValue;this.pointers[(writeStreamInstSize + 3)] = zipBlockPos;this.pointers[(writeStreamInstSize + 9)] = zipLiteralCount;this.pointers[(writeStreamInstSize + 10)] = zipMatchCount;	throw Object.create(PrimitiveReturn).setPayload((typeof result === "boolean" ? result : PrimitiveFailed.signal()));	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Update the hash tables after data has been moved by delta. */primitiveDeflateUpdateHashTable(table, delta) {	let entry;	let i;	let tablePtr;	let tableSize;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof delta === "number") ? delta : PrimitiveFailed.signal());	((typeof table === "number") ? PrimitiveFailed.signal() : table);	;	if (!(table.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	tableSize = SIZEOF(table);	tablePtr = table.wordsAsInt32Array();	for (i = 0; i < tableSize; i++) {		entry = tablePtr[i];		if (entry >= delta) {			tablePtr[i] = (entry - delta);		} else {			tablePtr[i] = 0;		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Inflate a single block. */primitiveInflateDecompressBlock(oop, oop1) {	let collection;	let source;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(oop1.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipDistTable = oop1.words;	/* literal table */	zipDistTableSize = SIZEOF(oop1);	if (!(oop.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipLitTable = oop.words;	/* Receiver (InflateStream) */	zipLitTableSize = SIZEOF(oop);	if (!(this.storageType === "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (readStreamInstSize === 0) {		if (!ZipPlugin.determineSizeOfReadStream(this)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		if (SIZEOF(this) < (readStreamInstSize + 8)) {			readStreamInstSize = 0;			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	if (SIZEOF(this) < (readStreamInstSize + 8)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipReadLimit = this.pointers[2];	zipState = this.pointers[(readStreamInstSize + 0)];	zipBitBuf = this.pointers[(readStreamInstSize + 1)];	zipBitPos = this.pointers[(readStreamInstSize + 2)];	zipSourcePos = this.pointers[(readStreamInstSize + 4)];	zipSourceLimit = this.pointers[(readStreamInstSize + 5)];	;	--zipReadLimit;	--zipSourcePos;	--zipSourceLimit;	collection = this.pointers[0];	if (!(collection.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	zipCollection = BYTESOF(collection);	zipCollectionSize = BYTESIZEOF(collection);	source = this.pointers[(readStreamInstSize + 3)];	if (!(source.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* do the primitive */	zipSource = BYTESOF(source);	ZipPlugin.zipDecompressBlock.apply(this, arguments);	/* store modified values back */const origReadLimit = this.pointers[2];collection.string = (origReadLimit === 0 ? "" : collection.string) + String.fromCodePoint(...zipCollection.subarray(origReadLimit, zipReadLimit + 1));collection.dirty = false;;this.pointers[2] = (zipReadLimit + 1);this.pointers[(readStreamInstSize + 0)] = zipState;this.pointers[(readStreamInstSize + 1)] = zipBitBuf;this.pointers[(readStreamInstSize + 2)] = zipBitPos;this.pointers[(readStreamInstSize + 4)] = (zipSourcePos + 1);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Primitive. Update a 32bit CRC value. */primitiveUpdateAdler32(_arg1, startIndex, stopIndex, collection) {	let adler32;	let b;	let bytePtr;	let i;	let length;	let s1;	let s2;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof collection === "number") ? PrimitiveFailed.signal() : collection);	((typeof stopIndex === "number") ? stopIndex : PrimitiveFailed.signal());	((typeof startIndex === "number") ? startIndex : PrimitiveFailed.signal());	adler32 = (_arg1 >>> 0) === _arg1.valueOf() ? _arg1 : PrimitiveFailed.signal();	;	if (!((collection.storageType === "bytes") && ((stopIndex >= startIndex) && (startIndex > 0)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(collection);	if (!(stopIndex <= length)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	bytePtr = BYTESOF(collection);	--startIndex;	--stopIndex;	s1 = UBANDS(adler32, 65535);	s2 = UBANDS((adler32 >>> 16), 65535);	for (i = startIndex; i <= stopIndex; i++) {		b = bytePtr[i];		s1 = MOD((s1 + b), 65521);		s2 = MOD((s2 + s1), 65521);	}	adler32 = (s2 << 16 >>> 0) + s1;	throw Object.create(PrimitiveReturn).setPayload(((adler32 >>> 0) !== adler32.valueOf() ? PrimitiveFailed.signal() : (adler32 >= 0 ? adler32 : 4294967296 + adler32)));}, /*	Primitive. Update a 32bit CRC value. */primitiveUpdateGZipCrc32(_arg1, startIndex, stopIndex, collection) {	let bytePtr;	let crc;	let i;	let length;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof collection === "number") ? PrimitiveFailed.signal() : collection);	((typeof stopIndex === "number") ? stopIndex : PrimitiveFailed.signal());	((typeof startIndex === "number") ? startIndex : PrimitiveFailed.signal());	crc = (_arg1 >>> 0) === _arg1.valueOf() ? _arg1 : PrimitiveFailed.signal();	;	if (!((collection.storageType === "bytes") && ((stopIndex >= startIndex) && (startIndex > 0)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	length = BYTESIZEOF(collection);	if (!(stopIndex <= length)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	bytePtr = BYTESOF(collection);	;	--startIndex;	--stopIndex;	for (i = startIndex; i <= stopIndex; i++) {		crc = UBXOR(zipCrcTable[UBANDS((UBXOR(crc, bytePtr[i])), 255)], (crc >>> 8));	}	throw Object.create(PrimitiveReturn).setPayload(((crc >>> 0) !== crc.valueOf() ? PrimitiveFailed.signal() : (crc >= 0 ? crc : 4294967296 + crc)));}, primitiveZipSendBlock(litStream, distStream, litTree, distTree) {	let result;	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof distTree === "number") ? PrimitiveFailed.signal() : distTree);	((typeof litTree === "number") ? PrimitiveFailed.signal() : litTree);	((typeof distStream === "number") ? PrimitiveFailed.signal() : distStream);	((typeof litStream === "number") ? PrimitiveFailed.signal() : litStream);	((typeof this === "number") ? PrimitiveFailed.signal() : this);	;	if (!ZipPlugin.loadZipEncoderFrom(this)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((distTree.storageType === "pointers") && (SIZEOF(distTree) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((litTree.storageType === "pointers") && (SIZEOF(litTree) >= 2))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((litStream.storageType === "pointers") && (SIZEOF(litStream) >= 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((distStream.storageType === "pointers") && (SIZEOF(distStream) >= 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	;	result = ZipPlugin.sendBlockwithwithwith(litStream, distStream, litTree, distTree);	this.pointers[1] = zipPosition;this.pointers[writeStreamInstSize] = zipBitBuf;this.pointers[(writeStreamInstSize + 1)] = zipBitPos;	throw Object.create(PrimitiveReturn).setPayload(((typeof result === "number") ? result : PrimitiveFailed.signal()));	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Require: 		zipCollection, zipCollectionSize, zipPosition,		zipBitBuf, zipBitPos.	 */sendBlockwithwithwith(literalStream, distanceStream, litTree, distTree) {	let code;	let dist;	let distArray;	let distBitLengths;	let distBlCount;	let distCodes;	let extra;	let lit;	let litArray;	let litBlCount;	let litLimit;	let litPos;	let llBitLengths;	let llCodes;	let oop;	let sum;	let nBits;	let value;	let nBits1;	let value1;	let nBits2;	let value2;	oop = literalStream.pointers[0];	litPos = literalStream.pointers[1];	litLimit = literalStream.pointers[2];	if (!((litPos <= litLimit) && ((oop.storageType === "bytes") && (litLimit <= BYTESIZEOF(oop))))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	litArray = BYTESOF(oop);	oop = distanceStream.pointers[0];	if (!((oop.storageType === "words") && ((litLimit <= SIZEOF(oop)) && ((distanceStream.pointers[1] === litPos) && (distanceStream.pointers[2] === litLimit))))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	distArray = oop.words;	oop = litTree.pointers[0];	if (!(oop.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	litBlCount = SIZEOF(oop);	llBitLengths = oop.words;	oop = litTree.pointers[1];	if (!((oop.storageType === "words") && (litBlCount === SIZEOF(oop)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	llCodes = oop.words;	oop = distTree.pointers[0];	if (!(oop.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	distBlCount = SIZEOF(oop);	distBitLengths = oop.words;	oop = distTree.pointers[1];	if (!((oop.storageType === "words") && (distBlCount === SIZEOF(oop)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	distCodes = oop.words;	/* begin nextZipBits:put: */	zipBitBuf = UBOR(zipBitBuf, (SHL(0, zipBitPos)));zipBitPos += 0;while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {	zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));	++zipPosition;	zipBitBuf = zipBitBuf >>> 8;	zipBitPos -= 8;}	/* end nextZipBits:put: */	sum = 0;	while ((litPos < litLimit) && ((zipPosition + 4) < zipCollectionSize)) {		lit = litArray[litPos];		dist = distArray[litPos];		++litPos;		if (dist === 0) {			/* literal */			++sum;			if (!(lit < litBlCount)) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* begin nextZipBits:put: */			nBits = llBitLengths[lit];			value = llCodes[lit];			if ((value >= 0) && ((SHL(1, nBits)) > value)) {				zipBitBuf = UBOR(zipBitBuf, (SHL(value, zipBitPos)));				zipBitPos += nBits;				while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {					zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));					++zipPosition;					zipBitBuf = zipBitBuf >>> 8;					zipBitPos -= 8;				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* end nextZipBits:put: */		} else {			/* match */			sum = (sum + lit) + 3;			if (!(lit < 256)) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			code = zipMatchLengthCodes[lit];			if (!(code < litBlCount)) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* begin nextZipBits:put: */			nBits1 = llBitLengths[code];			value1 = llCodes[code];			if ((value1 >= 0) && ((SHL(1, nBits1)) > value1)) {				zipBitBuf = UBOR(zipBitBuf, (SHL(value1, zipBitPos)));				zipBitPos += nBits1;				while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {					zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));					++zipPosition;					zipBitBuf = zipBitBuf >>> 8;					zipBitPos -= 8;				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* end nextZipBits:put: */			extra = zipExtraLengthBits[code - 257];			if (extra !== 0) {				lit -= zipBaseLength[code - 257];				/* begin nextZipBits:put: */				if ((lit >= 0) && ((SHL(1, extra)) > lit)) {					zipBitBuf = UBOR(zipBitBuf, (SHL(lit, zipBitPos)));					zipBitPos += extra;					while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {						zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));						++zipPosition;						zipBitBuf = zipBitBuf >>> 8;						zipBitPos -= 8;					}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}				/* end nextZipBits:put: */			}			--dist;			if (!(dist < 32768)) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			code = (dist < 256) ? zipDistanceCodes[dist] : zipDistanceCodes[256 + (dist >>> 7)];			if (!(code < distBlCount)) {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* begin nextZipBits:put: */			nBits2 = distBitLengths[code];			value2 = distCodes[code];			if ((value2 >= 0) && ((SHL(1, nBits2)) > value2)) {				zipBitBuf = UBOR(zipBitBuf, (SHL(value2, zipBitPos)));				zipBitPos += nBits2;				while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {					zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));					++zipPosition;					zipBitBuf = zipBitBuf >>> 8;					zipBitPos -= 8;				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}			/* end nextZipBits:put: */			extra = zipExtraDistanceBits[code];			if (extra !== 0) {				dist -= zipBaseDistance[code];				/* begin nextZipBits:put: */				if ((dist >= 0) && ((SHL(1, extra)) > dist)) {					zipBitBuf = UBOR(zipBitBuf, (SHL(dist, zipBitPos)));					zipBitPos += extra;					while ((zipBitPos >= 8) && (zipPosition < zipCollectionSize)) {						zipCollection[zipPosition] = (UBANDS(zipBitBuf, 255));						++zipPosition;						zipBitBuf = zipBitBuf >>> 8;						zipBitPos -= 8;					}				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}				/* end nextZipBits:put: */			}		}	}	;	literalStream.pointers[1] = litPos;	distanceStream.pointers[1] = litPos;	return sum;}, /*	Check if we should flush the current block.	Flushing can be useful if the input characteristics change. */shouldFlush() {	let nLits;	if (zipLiteralCount === zipLiteralSize) {		return true;	}	if ((UBANDS(zipLiteralCount, 4095)) !== 0) {		return false;	}	if ((zipMatchCount * 10) <= zipLiteralCount) {		/* This is basically random data. 		There is no need to flush early since the overhead		for encoding the trees will add to the overall size */		return false;	}	nLits = zipLiteralCount - zipMatchCount;	return (nLits <= zipMatchCount) ? false : ((nLits * 4) <= zipMatchCount);}, /*	Decode the next value in the receiver using the given huffman table. */zipDecodeValueFromsize(table, tableSize) {	let bits;	let bitsNeeded;	let index;	let tableIndex;	let value;	let bits1;	let byte;	/* Initial bits needed */	bitsNeeded = table[0] >>> 24;	if (bitsNeeded > 16) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		/* First real table */		tableIndex = 2;		while (true) {			/* begin zipNextBits: */			while (zipBitPos < bitsNeeded) {				byte = zipSource[(++zipSourcePos)];				zipBitBuf += SHL(byte, zipBitPos);				zipBitPos += 8;			}			bits1 = UBAND(zipBitBuf, ((SHL(1, bitsNeeded)) - 1));			zipBitBuf = SHR(zipBitBuf, bitsNeeded);			zipBitPos -= bitsNeeded;			bits = bits1;			/* end zipNextBits: */			index = (tableIndex + bits) - 1;			if (index >= tableSize) {				throw Object.create(PrimitiveFailed).setPayload(1);				return 0;			} else {				value = table[index];				if ((UBANDS(value, 1056964608)) === 0) {					return value;				} else {					tableIndex = UBANDS(value, 65535);					bitsNeeded = UBANDS((value >>> 24), 255);					if (bitsNeeded > 16) {						throw Object.create(PrimitiveFailed).setPayload(1);						return 0;					}				}			}		}	}	return 0;}, zipDecompressBlock() {	let distance;	let dstPos;	let extra;	let i;	let length;	let max;	let oldBitPos;	let oldBits;	let oldPos;	let srcPos;	let value;	max = zipCollectionSize - 1;	while ((zipReadLimit < max) && (zipSourcePos <= zipSourceLimit)) {		/* Back up stuff if we're running out of space */		oldBits = zipBitBuf;		oldBitPos = zipBitPos;		oldPos = zipSourcePos;		value = ZipPlugin.zipDecodeValueFromsize(zipLitTable, zipLitTableSize);		if (value < 256) {			/* A literal */			zipCollection[(++zipReadLimit)] = value;		} else {			/* length/distance or end of block */			if (value === 256) {				/* End of block */				zipState = UBANDS(zipState, 1);				return 0;			}			extra = (value >>> 16) - 1;			length = UBANDS(value, 65535);			if (extra > 0) {				length += ZipPlugin.zipNextBits(extra);			}			value = ZipPlugin.zipDecodeValueFromsize(zipDistTable, zipDistTableSize);			extra = value >>> 16;			distance = UBANDS(value, 65535);			if (extra > 0) {				distance += ZipPlugin.zipNextBits(extra);			}			if ((zipReadLimit + length) >= max) {				zipBitBuf = oldBits;				zipBitPos = oldBitPos;				zipSourcePos = oldPos;				return 0;			}			dstPos = zipReadLimit;			srcPos = zipReadLimit - distance;			for (i = 1; i <= length; i++) {				zipCollection[dstPos + i] = zipCollection[srcPos + i];			}			zipReadLimit += length;		}	}}, zipNextBits(n) {	let bits;	let byte;	while (zipBitPos < n) {		byte = zipSource[(++zipSourcePos)];		zipBitBuf += SHL(byte, zipBitPos);		zipBitPos += 8;	}	bits = UBAND(zipBitBuf, ((SHL(1, n)) - 1));	zipBitBuf = SHR(zipBitBuf, n);	zipBitPos -= n;	return bits;}, }