/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 26 July 2023 12:02:06 am *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	Matrix2x3Plugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let m23ArgX = 0;let m23ArgY = 0;let m23ResultX = 0;let m23ResultY = 0;globalThis.Matrix2x3Plugin = {/*	Load the argument point into m23ArgX and m23ArgY */loadArgumentPoint(point) {	let isInt;	let oop;	if (point._class() === SmalltalkGlobals._Point) {	oop = point.pointers[0];	isInt = (typeof oop === "number");	if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {		/* Load Y value */		m23ArgX = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		oop = point.pointers[1];		isInt = (typeof oop === "number");		if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());			return this;		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}}, /*	Multiply matrix m1 with m2 and store the result into m3. */matrix2x3ComposeMatrixwithinto(m1, m2, m3) {	let a11;	let a12;	let a13;	let a21;	let a22;	let a23;	a11 = (m1[0] * m2[0]) + (m1[1] * m2[3]);	a12 = (m1[0] * m2[1]) + (m1[1] * m2[4]);	a13 = ((m1[0] * m2[2]) + (m1[1] * m2[5])) + m1[2];	a21 = (m1[3] * m2[0]) + (m1[4] * m2[3]);	a22 = (m1[3] * m2[1]) + (m1[4] * m2[4]);	a23 = ((m1[3] * m2[2]) + (m1[4] * m2[5])) + m1[5];	m3[0] = a11;	m3[1] = a12;	m3[2] = a13;	m3[3] = a21;	m3[4] = a22;	m3[5] = a23;}, /*	Invert the pre-loaded argument point by the given matrix */matrix2x3InvertPoint(m) {	let det;	let detX;	let detY;	let x;	let y;	x = m23ArgX - m[2];	y = m23ArgY - m[5];	det = (m[0] * m[4]) - (m[1] * m[3]);	if (det === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	det = 1.0 / det;	detX = (x * m[4]) - (m[1] * y);	detY = (m[0] * y) - (x * m[3]);	m23ResultX = detX * det;	m23ResultY = detY * det;}, /*	Transform the pre-loaded argument point by the given matrix */matrix2x3TransformPoint(m) {	m23ResultX = ((m23ArgX * m[0]) + (m23ArgY * m[1])) + m[2];	m23ResultY = ((m23ArgX * m[3]) + (m23ArgY * m[4])) + m[5];}, primitiveComposeMatrix(matrix2, matrix1, result) {	let m1;	let m2;	let m3;	let matrix;	;	/* begin loadArgumentMatrix: */	matrix = ((typeof result === "number") ? PrimitiveFailed.signal() : result);	if ((matrix.storageType === "words") && (SIZEOF(matrix) === 6)) {	m3 = matrix.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	m3 = null;}	/* end loadArgumentMatrix: */	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	m2 = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	m2 = null;}	/* end loadArgumentMatrix: */	/* begin loadArgumentMatrix: */	((typeof matrix2 === "number") ? PrimitiveFailed.signal() : matrix2);	if ((matrix2.storageType === "words") && (SIZEOF(matrix2) === 6)) {	m1 = matrix2.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	m1 = null;}	/* end loadArgumentMatrix: */	;	Matrix2x3Plugin.matrix2x3ComposeMatrixwithinto(m1, m2, m3);	throw Object.create(PrimitiveReturn).setPayload(result);}, primitiveInvertPoint(matrix1, _arg2) {	let matrix;	if (typeof _arg2 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	Matrix2x3Plugin.loadArgumentPoint(_arg2);	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	Matrix2x3Plugin.matrix2x3InvertPoint(matrix);	Matrix2x3Plugin.roundAndStoreResultPoint(2);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveInvertRectInto(matrix1, srcOop, dstOop) {	let cornerX;	let cornerY;	let matrix;	let maxX;	let maxY;	let minX;	let minY;	let originX;	let originY;	((typeof dstOop === "number") ? PrimitiveFailed.signal() : dstOop);	((typeof srcOop === "number") ? PrimitiveFailed.signal() : srcOop);	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	if (srcOop._class() !== dstOop._class()) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(srcOop.storageType === "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(srcOop) !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	Matrix2x3Plugin.loadArgumentPoint(srcOop.pointers[0]);	;	originX = m23ArgX;	originY = m23ArgY;	Matrix2x3Plugin.matrix2x3InvertPoint(matrix);	minX = (maxX = m23ResultX);	/* Load bottom-right point */	minY = (maxY = m23ResultY);	Matrix2x3Plugin.loadArgumentPoint(srcOop.pointers[1]);	;	cornerX = m23ArgX;	cornerY = m23ArgY;	Matrix2x3Plugin.matrix2x3InvertPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load top-right point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = cornerX;	m23ArgY = originY;	Matrix2x3Plugin.matrix2x3InvertPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load bottom-left point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = originX;	m23ArgY = cornerY;	Matrix2x3Plugin.matrix2x3InvertPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	maxY = Math.max(maxY, m23ResultY);	dstOop = Matrix2x3Plugin.roundAndStoreResultRectx0y0x1y1(dstOop, minX, minY, maxX, maxY);	throw Object.create(PrimitiveReturn).setPayload(dstOop);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveIsIdentity(matrix1) {	let matrix;	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	throw Object.create(PrimitiveReturn).setPayload(CHECKEDBOOLEAN(((((((matrix[0] === 1.0) && (matrix[1] === 0.0)) && (matrix[2] === 0.0)) && (matrix[3] === 0.0)) && (matrix[4] === 1.0)) && (matrix[5] === 0.0))));}, primitiveIsPureTranslation(matrix1) {	let matrix;	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	throw Object.create(PrimitiveReturn).setPayload(CHECKEDBOOLEAN(((((matrix[0] === 1.0) && (matrix[1] === 0.0)) && (matrix[3] === 0.0)) && (matrix[4] === 1.0))));}, primitiveTransformPoint(matrix1, _arg2) {	let matrix;	if (typeof _arg2 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	Matrix2x3Plugin.loadArgumentPoint(_arg2);	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	Matrix2x3Plugin.matrix2x3TransformPoint(matrix);	Matrix2x3Plugin.roundAndStoreResultPoint(2);	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveTransformRectInto(matrix1, srcOop, dstOop) {	let cornerX;	let cornerY;	let matrix;	let maxX;	let maxY;	let minX;	let minY;	let originX;	let originY;	((typeof dstOop === "number") ? PrimitiveFailed.signal() : dstOop);	((typeof srcOop === "number") ? PrimitiveFailed.signal() : srcOop);	/* begin loadArgumentMatrix: */	((typeof matrix1 === "number") ? PrimitiveFailed.signal() : matrix1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);	matrix = null;}	/* end loadArgumentMatrix: */	;	if (srcOop._class() !== dstOop._class()) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(srcOop.storageType === "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(srcOop) !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	Matrix2x3Plugin.loadArgumentPoint(srcOop.pointers[0]);	;	originX = m23ArgX;	originY = m23ArgY;	Matrix2x3Plugin.matrix2x3TransformPoint(matrix);	minX = (maxX = m23ResultX);	/* Load bottom-right point */	minY = (maxY = m23ResultY);	Matrix2x3Plugin.loadArgumentPoint(srcOop.pointers[1]);	;	cornerX = m23ArgX;	cornerY = m23ArgY;	Matrix2x3Plugin.matrix2x3TransformPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load top-right point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = cornerX;	m23ArgY = originY;	Matrix2x3Plugin.matrix2x3TransformPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load bottom-left point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = originX;	m23ArgY = cornerY;	Matrix2x3Plugin.matrix2x3TransformPoint(matrix);	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	maxY = Math.max(maxY, m23ResultY);	dstOop = Matrix2x3Plugin.roundAndStoreResultRectx0y0x1y1(dstOop, minX, minY, maxX, maxY);	throw Object.create(PrimitiveReturn).setPayload(dstOop);	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Store the result of a previous operation.	Fail if we cannot represent the result as SmallInteger */roundAndStoreResultPoint(nItemsToPop) {	m23ResultX += 0.5;	m23ResultY += 0.5;	if (!((m23ResultX >= -1073741824) && (m23ResultX <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((m23ResultY >= -1073741824) && (m23ResultY <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	SmalltalkVM.popthenPush(nItemsToPop, SmalltalkVM.makePointwithxValueyValue((m23ResultX | 0), (m23ResultY | 0)));}, /*	Check, round and store the result of a rectangle operation */roundAndStoreResultRectx0y0x1y1(dstOop, x0, y0, x1, y1) {	let cornerOop;	let maxX;	let maxY;	let minX;	let minY;	let originOop;	let rectOop;	minX = x0 + 0.5;	if (!((minX >= -1073741824) && (minX <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	maxX = x1 + 0.5;	if (!((maxX >= -1073741824) && (maxX <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	minY = y0 + 0.5;	if (!((minY >= -1073741824) && (minY <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	maxY = y1 + 0.5;	if (!((maxY >= -1073741824) && (maxY <= 1073741823))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	SmalltalkVM.pushRemappableOop(dstOop);	originOop = SmalltalkVM.makePointwithxValueyValue((minX | 0), (minY | 0));	SmalltalkVM.pushRemappableOop(originOop);	cornerOop = SmalltalkVM.makePointwithxValueyValue((maxX | 0), (maxY | 0));	originOop = SmalltalkVM.popRemappableOop();	rectOop = SmalltalkVM.popRemappableOop();	rectOop.pointers[0] = originOop;	rectOop.pointers[1] = cornerOop;	return rectOop;}, }