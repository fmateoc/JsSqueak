/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:25 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	Matrix2x3Plugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let m23ArgX = 0;let m23ArgY = 0;let m23ResultX = 0;let m23ResultY = 0;globalThis.Matrix2x3Plugin = {primitiveComposeMatrix(matrix2, matrix1, result) {	let m1;	let m2;	let m3;	let matrix;	let a11;	let a12;	let a13;	let a21;	let a22;	let a23;	/* begin loadArgumentMatrix: */	matrix = ((typeof result === "number") ? PrimitiveFailed.signal() : result);	if ((matrix.storageType === "words") && (SIZEOF(matrix) === 6)) {	m3 = matrix.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	m2 = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	/* begin loadArgumentMatrix: */	if (typeof matrix2 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix2.storageType === "words") && (SIZEOF(matrix2) === 6)) {	m1 = matrix2.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	/* begin matrix2x3ComposeMatrix:with:into: */	a11 = (m1[0] * m2[0]) + (m1[1] * m2[3]);	a12 = (m1[0] * m2[1]) + (m1[1] * m2[4]);	a13 = ((m1[0] * m2[2]) + (m1[1] * m2[5])) + m1[2];	a21 = (m1[3] * m2[0]) + (m1[4] * m2[3]);	a22 = (m1[3] * m2[1]) + (m1[4] * m2[4]);	a23 = ((m1[3] * m2[2]) + (m1[4] * m2[5])) + m1[5];	m3[0] = a11;	m3[1] = a12;	m3[2] = a13;	m3[3] = a21;	m3[4] = a22;	m3[5] = a23;	/* end matrix2x3ComposeMatrix:with:into: */	throw Object.create(PrimitiveReturn).setPayload(result);}, primitiveInvertPoint(matrix1, point) {	let matrix;	let isInt;	let oop;	let det;	let detX;	let detY;	let x;	let y;	/* begin loadArgumentPoint: */	if (typeof point === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (point._class() === SmalltalkGlobals._Point) {	oop = point.pointers[0];	isInt = (typeof oop === "number");	if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		oop = point.pointers[1];		isInt = (typeof oop === "number");		if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	/* begin matrix2x3InvertPoint: */	x = m23ArgX - matrix[2];	y = m23ArgY - matrix[5];	det = (matrix[0] * matrix[4]) - (matrix[1] * matrix[3]);	if (det === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		det = 1.0 / det;		detX = (x * matrix[4]) - (matrix[1] * y);		detY = (matrix[0] * y) - (x * matrix[3]);		m23ResultX = detX * det;		m23ResultY = detY * det;	}	/* end matrix2x3InvertPoint: */	/* begin roundAndStoreResultPoint: */	m23ResultX += 0.5;	m23ResultY += 0.5;	if ((m23ResultX >= -1073741824) && (m23ResultX <= 1073741823)) {		if ((m23ResultY >= -1073741824) && (m23ResultY <= 1073741823)) {			throw Object.create(PrimitiveReturn).setPayload(SmalltalkVM.makePointwithxValueyValue((m23ResultX | 0), (m23ResultY | 0)));		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end roundAndStoreResultPoint: */}, primitiveInvertRectInto(matrix1, srcOop, dstOop) {	let cornerX;	let cornerY;	let matrix;	let maxX;	let maxY;	let minX;	let minY;	let originX;	let originY;	let point;	let isInt;	let oop;	let det;	let detX;	let detY;	let x;	let y;	let point1;	let isInt1;	let oop1;	let det1;	let detX1;	let detY1;	let x1;	let y1;	let det2;	let detX2;	let detY2;	let x2;	let y2;	let det3;	let detX3;	let detY3;	let x3;	let y3;	let cornerOop;	let maxX1;	let maxY1;	let minX1;	let minY1;	let originOop;	let rectOop;	if (typeof dstOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof srcOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	if (srcOop._class() !== dstOop._class()) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((srcOop.storageType !== "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(srcOop) !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin loadArgumentPoint: */	point = srcOop.pointers[0];	if (point._class() === SmalltalkGlobals._Point) {	oop = point.pointers[0];	isInt = (typeof oop === "number");	if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		oop = point.pointers[1];		isInt = (typeof oop === "number");		if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	originX = m23ArgX;	originY = m23ArgY;	/* begin matrix2x3InvertPoint: */	x = m23ArgX - matrix[2];	y = m23ArgY - matrix[5];	det = (matrix[0] * matrix[4]) - (matrix[1] * matrix[3]);	if (det === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		det = 1.0 / det;		detX = (x * matrix[4]) - (matrix[1] * y);		detY = (matrix[0] * y) - (x * matrix[3]);		m23ResultX = detX * det;		m23ResultY = detY * det;	}	/* end matrix2x3InvertPoint: */	maxX = minX = m23ResultX;	/* Load bottom-right point */	maxY = minY = m23ResultY;	/* begin loadArgumentPoint: */	point1 = srcOop.pointers[1];	if (point1._class() === SmalltalkGlobals._Point) {	oop1 = point1.pointers[0];	isInt1 = (typeof oop1 === "number");	if (isInt1 || ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt1 ? oop1 : ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float) ? oop1.valueOf() : PrimitiveFailed.signal());		oop1 = point1.pointers[1];		isInt1 = (typeof oop1 === "number");		if (isInt1 || ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt1 ? oop1 : ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float) ? oop1.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	cornerX = m23ArgX;	cornerY = m23ArgY;	/* begin matrix2x3InvertPoint: */	x1 = m23ArgX - matrix[2];	y1 = m23ArgY - matrix[5];	det1 = (matrix[0] * matrix[4]) - (matrix[1] * matrix[3]);	if (det1 === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		det1 = 1.0 / det1;		detX1 = (x1 * matrix[4]) - (matrix[1] * y1);		detY1 = (matrix[0] * y1) - (x1 * matrix[3]);		m23ResultX = detX1 * det1;		m23ResultY = detY1 * det1;	}	/* end matrix2x3InvertPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load top-right point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = cornerX;	m23ArgY = originY;	/* begin matrix2x3InvertPoint: */	x2 = m23ArgX - matrix[2];	y2 = m23ArgY - matrix[5];	det2 = (matrix[0] * matrix[4]) - (matrix[1] * matrix[3]);	if (det2 === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		det2 = 1.0 / det2;		detX2 = (x2 * matrix[4]) - (matrix[1] * y2);		detY2 = (matrix[0] * y2) - (x2 * matrix[3]);		m23ResultX = detX2 * det2;		m23ResultY = detY2 * det2;	}	/* end matrix2x3InvertPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load bottom-left point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = originX;	m23ArgY = cornerY;	/* begin matrix2x3InvertPoint: */	x3 = m23ArgX - matrix[2];	y3 = m23ArgY - matrix[5];	det3 = (matrix[0] * matrix[4]) - (matrix[1] * matrix[3]);	if (det3 === 0.0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		det3 = 1.0 / det3;		detX3 = (x3 * matrix[4]) - (matrix[1] * y3);		detY3 = (matrix[0] * y3) - (x3 * matrix[3]);		m23ResultX = detX3 * det3;		m23ResultY = detY3 * det3;	}	/* end matrix2x3InvertPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	maxY = Math.max(maxY, m23ResultY);	/* begin roundAndStoreResultRect:x0:y0:x1:y1: */	minX1 = minX + 0.5;	if ((minX1 >= -1073741824) && (minX1 <= 1073741823)) {		maxX1 = maxX + 0.5;		if ((maxX1 >= -1073741824) && (maxX1 <= 1073741823)) {			minY1 = minY + 0.5;			if ((minY1 >= -1073741824) && (minY1 <= 1073741823)) {				maxY1 = maxY + 0.5;				if ((maxY1 >= -1073741824) && (maxY1 <= 1073741823)) {					SmalltalkVM.pushRemappableOop(dstOop);					originOop = SmalltalkVM.makePointwithxValueyValue((minX1 | 0), (minY1 | 0));					SmalltalkVM.pushRemappableOop(originOop);					cornerOop = SmalltalkVM.makePointwithxValueyValue((maxX1 | 0), (maxY1 | 0));					originOop = SmalltalkVM.popRemappableOop();					rectOop = SmalltalkVM.popRemappableOop();					rectOop.pointers[0] = originOop;					rectOop.pointers[1] = cornerOop;					dstOop = rectOop;				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end roundAndStoreResultRect:x0:y0:x1:y1: */	throw Object.create(PrimitiveReturn).setPayload(dstOop);}, primitiveIsIdentity(matrix1) {	let matrix;	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	throw Object.create(PrimitiveReturn).setPayload(CHECKEDBOOLEAN(((function() {const _a = ((function() {const _a = ((function() {const _a = ((function() {const _a = ((function() {const _a = (matrix[0] === 1.0); const _b = (matrix[1] === 0.0); return _a && _b})()); const _b = (matrix[2] === 0.0); return _a && _b})()); const _b = (matrix[3] === 0.0); return _a && _b})()); const _b = (matrix[4] === 1.0); return _a && _b})()); const _b = (matrix[5] === 0.0); return _a && _b})())));}, primitiveIsPureTranslation(matrix1) {	let matrix;	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	throw Object.create(PrimitiveReturn).setPayload(CHECKEDBOOLEAN(((function() {const _a = ((function() {const _a = ((function() {const _a = (matrix[0] === 1.0); const _b = (matrix[1] === 0.0); return _a && _b})()); const _b = (matrix[3] === 0.0); return _a && _b})()); const _b = (matrix[4] === 1.0); return _a && _b})())));}, primitiveTransformPoint(matrix1, point) {	let matrix;	let isInt;	let oop;	/* begin loadArgumentPoint: */	if (typeof point === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (point._class() === SmalltalkGlobals._Point) {	oop = point.pointers[0];	isInt = (typeof oop === "number");	if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		oop = point.pointers[1];		isInt = (typeof oop === "number");		if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	/* begin matrix2x3TransformPoint: */	m23ResultX = ((m23ArgX * matrix[0]) + (m23ArgY * matrix[1])) + matrix[2];	m23ResultY = ((m23ArgX * matrix[3]) + (m23ArgY * matrix[4])) + matrix[5];	/* end matrix2x3TransformPoint: */	/* begin roundAndStoreResultPoint: */	m23ResultX += 0.5;	m23ResultY += 0.5;	if ((m23ResultX >= -1073741824) && (m23ResultX <= 1073741823)) {		if ((m23ResultY >= -1073741824) && (m23ResultY <= 1073741823)) {			throw Object.create(PrimitiveReturn).setPayload(SmalltalkVM.makePointwithxValueyValue((m23ResultX | 0), (m23ResultY | 0)));		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end roundAndStoreResultPoint: */}, primitiveTransformRectInto(matrix1, srcOop, dstOop) {	let cornerX;	let cornerY;	let matrix;	let maxX;	let maxY;	let minX;	let minY;	let originX;	let originY;	let point;	let isInt;	let oop;	let point1;	let isInt1;	let oop1;	let cornerOop;	let maxX1;	let maxY1;	let minX1;	let minY1;	let originOop;	let rectOop;	if (typeof dstOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof srcOop === "number") throw Object.create(PrimitiveFailed).setPayload(1);	/* begin loadArgumentMatrix: */	if (typeof matrix1 === "number") throw Object.create(PrimitiveFailed).setPayload(1);	if ((matrix1.storageType === "words") && (SIZEOF(matrix1) === 6)) {	matrix = matrix1.wordsAsFloat32Array();} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentMatrix: */	if (srcOop._class() !== dstOop._class()) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((srcOop.storageType !== "pointers")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(srcOop) !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin loadArgumentPoint: */	point = srcOop.pointers[0];	if (point._class() === SmalltalkGlobals._Point) {	oop = point.pointers[0];	isInt = (typeof oop === "number");	if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		oop = point.pointers[1];		isInt = (typeof oop === "number");		if (isInt || ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt ? oop : ((typeof oop === "number" && (oop | 0) !== oop && !Number.isSafeInteger(oop) || oop._class() === SmalltalkGlobals._Float) ? oop.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	originX = m23ArgX;	originY = m23ArgY;	/* begin matrix2x3TransformPoint: */	m23ResultX = ((m23ArgX * matrix[0]) + (m23ArgY * matrix[1])) + matrix[2];	m23ResultY = ((m23ArgX * matrix[3]) + (m23ArgY * matrix[4])) + matrix[5];	/* end matrix2x3TransformPoint: */	maxX = minX = m23ResultX;	/* Load bottom-right point */	maxY = minY = m23ResultY;	/* begin loadArgumentPoint: */	point1 = srcOop.pointers[1];	if (point1._class() === SmalltalkGlobals._Point) {	oop1 = point1.pointers[0];	isInt1 = (typeof oop1 === "number");	if (isInt1 || ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float))) {		m23ArgX = isInt1 ? oop1 : ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float) ? oop1.valueOf() : PrimitiveFailed.signal());		oop1 = point1.pointers[1];		isInt1 = (typeof oop1 === "number");		if (isInt1 || ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float))) {			m23ArgY = isInt1 ? oop1 : ((typeof oop1 === "number" && (oop1 | 0) !== oop1 && !Number.isSafeInteger(oop1) || oop1._class() === SmalltalkGlobals._Float) ? oop1.valueOf() : PrimitiveFailed.signal());		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}} else {	throw Object.create(PrimitiveFailed).setPayload(1);}	/* end loadArgumentPoint: */	cornerX = m23ArgX;	cornerY = m23ArgY;	/* begin matrix2x3TransformPoint: */	m23ResultX = ((m23ArgX * matrix[0]) + (m23ArgY * matrix[1])) + matrix[2];	m23ResultY = ((m23ArgX * matrix[3]) + (m23ArgY * matrix[4])) + matrix[5];	/* end matrix2x3TransformPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load top-right point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = cornerX;	m23ArgY = originY;	/* begin matrix2x3TransformPoint: */	m23ResultX = ((m23ArgX * matrix[0]) + (m23ArgY * matrix[1])) + matrix[2];	m23ResultY = ((m23ArgX * matrix[3]) + (m23ArgY * matrix[4])) + matrix[5];	/* end matrix2x3TransformPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	/* Load bottom-left point */	maxY = Math.max(maxY, m23ResultY);	m23ArgX = originX;	m23ArgY = cornerY;	/* begin matrix2x3TransformPoint: */	m23ResultX = ((m23ArgX * matrix[0]) + (m23ArgY * matrix[1])) + matrix[2];	m23ResultY = ((m23ArgX * matrix[3]) + (m23ArgY * matrix[4])) + matrix[5];	/* end matrix2x3TransformPoint: */	minX = Math.min(minX, m23ResultX);	maxX = Math.max(maxX, m23ResultX);	minY = Math.min(minY, m23ResultY);	maxY = Math.max(maxY, m23ResultY);	/* begin roundAndStoreResultRect:x0:y0:x1:y1: */	minX1 = minX + 0.5;	if ((minX1 >= -1073741824) && (minX1 <= 1073741823)) {		maxX1 = maxX + 0.5;		if ((maxX1 >= -1073741824) && (maxX1 <= 1073741823)) {			minY1 = minY + 0.5;			if ((minY1 >= -1073741824) && (minY1 <= 1073741823)) {				maxY1 = maxY + 0.5;				if ((maxY1 >= -1073741824) && (maxY1 <= 1073741823)) {					SmalltalkVM.pushRemappableOop(dstOop);					originOop = SmalltalkVM.makePointwithxValueyValue((minX1 | 0), (minY1 | 0));					SmalltalkVM.pushRemappableOop(originOop);					cornerOop = SmalltalkVM.makePointwithxValueyValue((maxX1 | 0), (maxY1 | 0));					originOop = SmalltalkVM.popRemappableOop();					rectOop = SmalltalkVM.popRemappableOop();					rectOop.pointers[0] = originOop;					rectOop.pointers[1] = cornerOop;					dstOop = rectOop;				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end roundAndStoreResultRect:x0:y0:x1:y1: */	throw Object.create(PrimitiveReturn).setPayload(dstOop);}, }