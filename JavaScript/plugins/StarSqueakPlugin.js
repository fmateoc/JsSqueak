/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:41 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	StarSqueakPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let interpreterProxy;let moduleName = "StarSqueakPlugin 7 February 2022 (e)";globalThis.StarSqueakPlugin = {/*	Diffuse the integer values of the source patch variable Bitmap into the output Bitmap. Each cell of the output is the average of the NxN area around it in the source, where N = (2 * delta) + 1. */primitiveDiffuseFromToWidthHeightDelta(srcOop, dstOop, width, height, delta) {	let area;	let dst;	let endX;	let endY;	let rowStart;	let src;	let startX;	let startY;	let sum;	let x;	let x2;	let y;	let y2;	((typeof width === "number") ? width : PrimitiveFailed.signal());	((typeof height === "number") ? height : PrimitiveFailed.signal());	((typeof delta === "number") ? delta : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(srcOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	src = srcOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(dstOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	dst = dstOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(srcOop) !== SIZEOF(dstOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (SIZEOF(srcOop) !== (width * height)) throw Object.create(PrimitiveFailed).setPayload(1);	;	area = ((2 * delta) + 1) * ((2 * delta) + 1);	for (y = 0; y <= (height - 1); y++) {		startY = y - delta;		if (startY < 0) {			startY = 0;		}		endY = y + delta;		if (endY >= height) {			endY = height - 1;		}		for (x = 0; x <= (width - 1); x++) {			startX = x - delta;			if (startX < 0) {				startX = 0;			}			endX = x + delta;			if (endX >= width) {				endX = width - 1;			}			sum = 0;			for (y2 = startY; y2 <= endY; y2++) {				rowStart = y2 * width;				for (x2 = startX; x2 <= endX; x2++) {					sum += src[rowStart + x2];				}			}			dst[(y * width) + x] = (Math.trunc(sum / area));		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Evaporate the integer values of the source Bitmap at the given rate. The rate is an integer between 0 and 1024, where 1024 is a scale factor of 1.0 (i.e., no evaporation). */primitiveEvaporateRate(patchVarOop, rate) {	let i;	let patchVar;	let sz;	((typeof rate === "number") ? rate : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(patchVarOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	patchVar = patchVarOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(patchVarOop);	;	for (i = 0; i <= (sz - 1); i++) {		patchVar[i] = ((patchVar[i] * rate) >>> 10);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift(srcOop, dstOop, w, h, patchSize, rgbFlags, shiftAmount) {	let dst;	let dstIndex;	let level;	let offset;	let pixel;	let rgbMult;	let rowStart;	let src;	let srcIndex;	let x;	let y;	let zzzTemp;	((typeof w === "number") ? w : PrimitiveFailed.signal());	((typeof h === "number") ? h : PrimitiveFailed.signal());	((typeof patchSize === "number") ? patchSize : PrimitiveFailed.signal());	((typeof rgbFlags === "number") ? rgbFlags : PrimitiveFailed.signal());	((typeof shiftAmount === "number") ? shiftAmount : PrimitiveFailed.signal());	/* begin checkedUnsignedIntPtrOf: */	if (!(srcOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	src = srcOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if (!(dstOop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	dst = dstOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(dstOop) !== (w * h)) throw Object.create(PrimitiveFailed).setPayload(1);	if (SIZEOF(dstOop) !== ((SIZEOF(srcOop) * patchSize) * patchSize)) throw Object.create(PrimitiveFailed).setPayload(1);	;	rgbMult = 0;	if ((UBANDS(rgbFlags, 4)) > 0) {		rgbMult += 65536;	}	if ((UBANDS(rgbFlags, 2)) > 0) {		rgbMult += 256;	}	if ((UBANDS(rgbFlags, 1)) > 0) {		++rgbMult;	}	srcIndex = -1;	for (y = 0; y <= ((Math.trunc(h / patchSize)) - 1); y++) {		for (x = 0; x <= ((Math.trunc(w / patchSize)) - 1); x++) {			level = SHIFT(src[(++srcIndex)], shiftAmount);			if (level > 255) {				level = 255;			}			/* fill a patchSize x patchSize square with the pixel value */			pixel = (level <= 0) ? 1 : (level * rgbMult);			offset = ((y * w) + x) * patchSize;			for (rowStart = offset; rowStart <= (offset + ((patchSize - 1) * w)); rowStart += w) {				zzzTemp = rowStart;				for (dstIndex = zzzTemp; dstIndex <= ((rowStart + patchSize) - 1); dstIndex++) {					dst[dstIndex] = pixel;				}			}		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, }