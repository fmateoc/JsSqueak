/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:26 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	StarSqueakPlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/globalThis.StarSqueakPlugin = {/*	Diffuse the integer values of the source patch variable Bitmap into the output Bitmap. Each cell of the output is the average of the NxN area around it in the source, where N = (2 * delta) + 1. */primitiveDiffuseFromToWidthHeightDelta(srcOop, dstOop, width, height, delta) {	let area;	let dst;	let endX;	let endY;	let rowStart;	let src;	let startX;	let startY;	let sum;	let x;	let x2;	let y;	let y2;	if (!(typeof width === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof height === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof delta === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin checkedUnsignedIntPtrOf: */	if ((srcOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	src = srcOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if ((dstOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	dst = dstOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(srcOop) !== SIZEOF(dstOop)) throw Object.create(PrimitiveFailed).setPayload(1);	if (SIZEOF(srcOop) !== (width * height)) throw Object.create(PrimitiveFailed).setPayload(1);	area = ((2 * delta) + 1) * ((2 * delta) + 1);	for (y = 0; y < height; y++) {		startY = y - delta;		if (startY < 0) {			startY = 0;		}		endY = y + delta;		if (endY >= height) {			endY = height - 1;		}		for (x = 0; x < width; x++) {			startX = x - delta;			if (startX < 0) {				startX = 0;			}			endX = x + delta;			if (endX >= width) {				endX = width - 1;			}			sum = 0;			for (y2 = startY; y2 <= endY; y2++) {				rowStart = y2 * width;				for (x2 = startX; x2 <= endX; x2++) {					sum += src[rowStart + x2];				}			}			dst[(y * width) + x] = (Math.trunc(sum / area));		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Evaporate the integer values of the source Bitmap at the given rate. The rate is an integer between 0 and 1024, where 1024 is a scale factor of 1.0 (i.e., no evaporation). */primitiveEvaporateRate(patchVarOop, rate) {	let i;	let patchVar;	let sz;	if (!(typeof rate === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin checkedUnsignedIntPtrOf: */	if ((patchVarOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	patchVar = patchVarOop.words;	/* end checkedUnsignedIntPtrOf: */	sz = SIZEOF(patchVarOop);	for (i = 0; i < sz; i++) {		patchVar[i] = ((patchVar[i] * rate) >>> 10);	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift(srcOop, dstOop, w, h, patchSize, rgbFlags, shiftAmount) {	let dst;	let dstIndex;	let level;	let offset;	let pixel;	let rgbMult;	let rowStart;	let src;	let srcIndex;	let x;	let y;	let zzzTemp;	if (!(typeof w === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof h === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof patchSize === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof rgbFlags === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof shiftAmount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin checkedUnsignedIntPtrOf: */	if ((srcOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	src = srcOop.words;	/* end checkedUnsignedIntPtrOf: */	/* begin checkedUnsignedIntPtrOf: */	if ((dstOop.storageType !== "words")) throw Object.create(PrimitiveFailed).setPayload(1);	dst = dstOop.words;	/* end checkedUnsignedIntPtrOf: */	if (SIZEOF(dstOop) !== (w * h)) throw Object.create(PrimitiveFailed).setPayload(1);	if (SIZEOF(dstOop) !== ((SIZEOF(srcOop) * patchSize) * patchSize)) throw Object.create(PrimitiveFailed).setPayload(1);	rgbMult = 0;	if ((UBANDS(rgbFlags, 4)) > 0) {		rgbMult += 65536;	}	if ((UBANDS(rgbFlags, 2)) > 0) {		rgbMult += 256;	}	if ((UBANDS(rgbFlags, 1)) > 0) {		++rgbMult;	}	srcIndex = -1;	const yLimiT = Math.trunc(h / patchSize);	for (y = 0; y < yLimiT; y++) {		const xLimiT = Math.trunc(w / patchSize);		for (x = 0; x < xLimiT; x++) {			level = SHIFT(src[(++srcIndex)], shiftAmount);			if (level > 255) {				level = 255;			}			/* fill a patchSize x patchSize square with the pixel value */			pixel = (level <= 0) ? 1 : (level * rgbMult);			offset = ((y * w) + x) * patchSize;			for (rowStart = offset; rowStart <= (offset + ((patchSize - 1) * w)); rowStart += w) {				zzzTemp = rowStart;				dstIndex = zzzTemp;				const dstIndexLimiT = rowStart + patchSize;				for (; dstIndex < dstIndexLimiT; dstIndex++) {					dst[dstIndex] = pixel;				}			}		}	}	throw Object.create(PrimitiveReturn).setPayload(this);}, }