/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:28 pm *//* Automatically generated by	JSSmartSyntaxPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	BitBltSimulation * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let affectedB = 0;let affectedL = 0;let affectedR = 0;let affectedT = 0;let bbH = 0;let bbW = 0;let bitBltOop = 0;let bitCount = 0;let clipHeight = 0;let clipWidth = 0;let clipX = 0;let clipY = 0;let cmBitsPerColor = 0;let cmFlags = 0;let cmLookupTable;let cmMask = 0;let cmMaskTable;let cmShiftTable;let combinationRule = 0;let componentAlphaModeAlpha = 0;let componentAlphaModeColor = 0;let destBits = 0;let destDelta = 0;let destDepth = 0;let destForm = 0;let destHeight = 0;let destIndex = 0;let destMSB = 0;let destMask = 0;let destPPW = 0;let destPitch = 0;let destWidth = 0;let destX = 0;let destY = 0;let dither8Lookup = new Array(4096);let ditherMatrix4x4 = [0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5];let ditherThresholds16 = [ 0, 2, 4, 6, 8, 12, 14, 16 ];let ditherValues16 = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30];let dstBitShift = 0;let dx = 0;let dy = 0;let gammaLookupTable;let hDir = 0;let halftoneBase = 0;let halftoneForm = 0;let halftoneHeight = 0;let hasSurfaceLock = 0;let height = 0;let interpreterProxy;let isWarping = 0;let lockSurfaceFn;let mask1 = 0;let mask2 = 0;let maskTable = [0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1];let moduleName = "BitBltPlugin 7 February 2022 (e)";let nWords = 0;let noHalftone = 0;let noSource = 0;let opTable = new Array(43);let preload = 0;let querySurfaceFn;let simulator = 0;let skew = 0;let sourceAlpha = 0;let sourceBits = 0;let sourceDelta = 0;let sourceDepth = 0;let sourceForm = 0;let sourceHeight = 0;let sourceIndex = 0;let sourceMSB = 0;let sourcePPW = 0;let sourcePitch = 0;let sourceWidth = 0;let sourceX = 0;let sourceY = 0;let srcBitShift = 0;let sx = 0;let sy = 0;let ungammaLookupTable;let unlockSurfaceFn;let vDir = 0;let warpAlignMask = 0;let warpAlignShift = 0;let warpBitShiftTable = new Array(32);let warpSrcMask = 0;let warpSrcShift = 0;let width = 0;globalThis.BitBltPlugin = {/*	Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes. */OLDrgbDiffwith(sourceWord, destinationWord) {	let diff;	let pixMask;	if (destDepth < 16) {		/* Just xor and count differing bits if not RGB */		diff = UBXOR(sourceWord, destinationWord);		pixMask = maskTable[destDepth];		while (!(diff === 0)) {			if ((UBAND(diff, pixMask)) !== 0) {				++bitCount;			}			diff = SHR(diff, destDepth);		}		return destinationWord;	}	if (destDepth === 16) {		diff = BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3);		bitCount = ((bitCount + (UBANDS(diff, 31))) + (UBANDS((diff >>> 5), 31))) + (UBANDS((diff >>> 10), 31));		diff = BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3);		bitCount = ((bitCount + (UBANDS(diff, 31))) + (UBANDS((diff >>> 5), 31))) + (UBANDS((diff >>> 10), 31));	} else {		diff = BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 3);		bitCount = ((bitCount + (UBANDS(diff, 255))) + (UBANDS((diff >>> 8), 255))) + (UBANDS((diff >>> 16), 255));	}	return destinationWord;}, /*	Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes. */OLDtallyIntoMapwith(sourceWord, destinationWord) {	let pixMask;	let mapIndex;	let i;	let shiftWord;	let sourcePixel;	let d;	let destPix;	let srcPix;	let zzzTemp1;	let mask;	let zzzTemp;	let sourcePixel1;	let d1;	let destPix1;	let srcPix1;	let zzzTemp11;	let mask3;	let zzzTemp2;	let d2;	let destPix2;	let srcPix2;	let zzzTemp12;	let mask4;	let zzzTemp3;	if ((UBAND(cmFlags, (5))) === (5)) {		if (destDepth < 16) {			/* loop through all packed pixels. */			pixMask = UBAND(maskTable[destDepth], cmMask);			shiftWord = destinationWord;			for (i = 1; i <= destPPW; i++) {				mapIndex = UBAND(shiftWord, pixMask);				cmLookupTable[UBAND(mapIndex, cmMask)]++;				shiftWord = SHR(shiftWord, destDepth);			}		} else {			if (destDepth === 16) {				/* begin rgbMap:from:to: */				sourcePixel = UBANDS(destinationWord, 65535);				if (((d = cmBitsPerColor - 5)) > 0) {					mask = 31;					srcPix = SHL(sourcePixel, d);					mask = SHL(mask, d);					destPix = UBAND(srcPix, mask);					mask = SHL(mask, cmBitsPerColor);					srcPix = SHL(srcPix, d);					mapIndex = (destPix + (UBAND(srcPix, mask))) + (UBAND((SHL(srcPix, d)), (SHL(mask, cmBitsPerColor))));				} else {					if (d === 0) {						zzzTemp = (UBANDS(sourcePixel, 32767));					} else {						if (sourcePixel === 0) {							zzzTemp1 = sourcePixel;						} else {							d = 5 - cmBitsPerColor;							mask = (SHL(1, cmBitsPerColor)) - 1;							srcPix = SHR(sourcePixel, d);							destPix = UBAND(srcPix, mask);							mask = SHL(mask, cmBitsPerColor);							srcPix = SHR(srcPix, d);							destPix = (destPix + (UBAND(srcPix, mask))) + (UBAND((SHR(srcPix, d)), (SHL(mask, cmBitsPerColor))));							zzzTemp1 = (destPix === 0) ? 1 : destPix;						}						zzzTemp = zzzTemp1;					}					mapIndex = zzzTemp;				}				/* end rgbMap:from:to: */				cmLookupTable[UBAND(mapIndex, cmMask)]++;				/* begin rgbMap:from:to: */				sourcePixel1 = destinationWord >>> 16;				if (((d1 = cmBitsPerColor - 5)) > 0) {					mask3 = 31;					srcPix1 = SHL(sourcePixel1, d1);					mask3 = SHL(mask3, d1);					destPix1 = UBAND(srcPix1, mask3);					mask3 = SHL(mask3, cmBitsPerColor);					srcPix1 = SHL(srcPix1, d1);					mapIndex = (destPix1 + (UBAND(srcPix1, mask3))) + (UBAND((SHL(srcPix1, d1)), (SHL(mask3, cmBitsPerColor))));				} else {					if (d1 === 0) {						zzzTemp2 = (UBANDS(sourcePixel1, 32767));					} else {						if (sourcePixel1 === 0) {							zzzTemp11 = sourcePixel1;						} else {							d1 = 5 - cmBitsPerColor;							mask3 = (SHL(1, cmBitsPerColor)) - 1;							srcPix1 = SHR(sourcePixel1, d1);							destPix1 = UBAND(srcPix1, mask3);							mask3 = SHL(mask3, cmBitsPerColor);							srcPix1 = SHR(srcPix1, d1);							destPix1 = (destPix1 + (UBAND(srcPix1, mask3))) + (UBAND((SHR(srcPix1, d1)), (SHL(mask3, cmBitsPerColor))));							zzzTemp11 = (destPix1 === 0) ? 1 : destPix1;						}						zzzTemp2 = zzzTemp11;					}					mapIndex = zzzTemp2;				}				/* end rgbMap:from:to: */			} else {				/* begin rgbMap:from:to: */				if (((d2 = cmBitsPerColor - 8)) > 0) {					mask4 = 255;					srcPix2 = SHL(destinationWord, d2);					mask4 = SHL(mask4, d2);					destPix2 = UBAND(srcPix2, mask4);					mask4 = SHL(mask4, cmBitsPerColor);					srcPix2 = SHL(srcPix2, d2);					mapIndex = (destPix2 + (UBAND(srcPix2, mask4))) + (UBAND((SHL(srcPix2, d2)), (SHL(mask4, cmBitsPerColor))));				} else {					if (d2 === 0) {						zzzTemp3 = ((UBANDS(destinationWord, 16777215)));					} else {						if (destinationWord === 0) {							zzzTemp12 = destinationWord;						} else {							d2 = 8 - cmBitsPerColor;							mask4 = (SHL(1, cmBitsPerColor)) - 1;							srcPix2 = SHR(destinationWord, d2);							destPix2 = UBAND(srcPix2, mask4);							mask4 = SHL(mask4, cmBitsPerColor);							srcPix2 = SHR(srcPix2, d2);							destPix2 = (destPix2 + (UBAND(srcPix2, mask4))) + (UBAND((SHR(srcPix2, d2)), (SHL(mask4, cmBitsPerColor))));							zzzTemp12 = (destPix2 === 0) ? 1 : destPix2;						}						zzzTemp3 = zzzTemp12;					}					mapIndex = zzzTemp3;				}				/* end rgbMap:from:to: */			}			cmLookupTable[UBAND(mapIndex, cmMask)]++;		}	}	/* For no effect on dest */	return destinationWord;}, addWordwith(sourceWord, destinationWord) {	return sourceWord + destinationWord;}, /*	Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0. */alphaBlendwith(sourceWord, destinationWord) {	let unAlpha;	let blendRB;	let blendAG;	let result;	let alpha;	/* High 8 bits of source pixel */	alpha = sourceWord >>> 24;	if (alpha === 0) {		return destinationWord;	}	if (alpha === 255) {		return sourceWord;	}	unAlpha = 255 - alpha;	/* blend red and blue */	blendRB = (((UBANDS(sourceWord, 16711935)) * alpha) + ((UBANDS(destinationWord, 16711935)) * unAlpha)) + 16711935;	/* blend alpha and green */	blendAG = (((UBANDS((UBORS((sourceWord >>> 8), 16711680)), 16711935)) * alpha) + ((UBANDS((destinationWord >>> 8), 16711935)) * unAlpha)) + 16711935;	/* divide by 255 */	blendRB = UBANDS(((blendRB + (UBANDS(((blendRB - 65537) >>> 8), 16711935))) >>> 8), 16711935);	blendAG = UBANDS(((blendAG + (UBANDS(((blendAG - 65537) >>> 8), 16711935))) >>> 8), 16711935);	result = UBOR(blendRB, (blendAG << 8 >>> 0));	return result;}, alphaBlendConstwith(sourceWord, destinationWord) {	return BitBltPlugin.alphaBlendConstwithpaintMode(sourceWord, destinationWord, false);}, /*	Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero. *//*	This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt. */alphaBlendConstwithpaintMode(sourceWord, destinationWord, paintMode) {	let rgbMask;	let pixMask;	let pixBlend;	let j;	let sourceShifted;	let result;	let shift;	let sourcePixVal;	let i;	let unAlpha;	let destPixVal;	let blendRB;	let blendAG;	let bitsPerColor;	let blend;	let destShifted;	let maskShifted;	if (destDepth < 16) {		return destinationWord;	}	unAlpha = 255 - sourceAlpha;	result = destinationWord;	if (destPPW === 1) {		/* 32bpp blends include alpha */		if (!(paintMode && (sourceWord === 0))) {			blendRB = (((UBANDS(sourceWord, 16711935)) * sourceAlpha) + ((UBANDS(destinationWord, 16711935)) * unAlpha)) + 16711935;			blendAG = (((UBANDS((sourceWord >>> 8), 16711935)) * sourceAlpha) + ((UBANDS((destinationWord >>> 8), 16711935)) * unAlpha)) + 16711935;			blendRB = UBANDS(((blendRB + (UBANDS(((blendRB - 65537) >>> 8), 16711935))) >>> 8), 16711935);			blendAG = UBANDS(((blendAG + (UBANDS(((blendAG - 65537) >>> 8), 16711935))) >>> 8), 16711935);			result = UBOR(blendRB, (blendAG << 8 >>> 0));		}	} else {		pixMask = maskTable[destDepth];		bitsPerColor = 5;		rgbMask = 31;		maskShifted = destMask;		destShifted = destinationWord;		sourceShifted = sourceWord;		for (j = 1; j <= destPPW; j++) {			sourcePixVal = UBAND(sourceShifted, pixMask);			if (!(((UBAND(maskShifted, pixMask)) === 0) || (paintMode && (sourcePixVal === 0)))) {				destPixVal = UBAND(destShifted, pixMask);				pixBlend = 0;				for (i = 1; i <= 3; i++) {					shift = (i - 1) * bitsPerColor;					blend = UBAND((Math.trunc(((((UBAND((SHR(sourcePixVal, shift)), rgbMask)) * sourceAlpha) + ((UBAND((SHR(destPixVal, shift)), rgbMask)) * unAlpha)) + 254) / 255)), rgbMask);					pixBlend = UBOR(pixBlend, (SHL(blend, shift)));				}				result = UBOR((UBAND(result, (~((SHL(pixMask, ((j - 1) * 16)))) >>> 0))), (SHL(pixBlend, ((j - 1) * 16))));			}			maskShifted = SHR(maskShifted, destDepth);			sourceShifted = SHR(sourceShifted, destDepth);			destShifted = SHR(destShifted, destDepth);		}	}	return result;}, /*	Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled. */alphaBlendScaledwith(sourceWord, destinationWord) {	let unAlpha;	let rb;	let ag;	/* Do NOT inline this into optimized loops */	/* High 8 bits of source pixel is source opacity (ARGB format) */	unAlpha = 255 - (sourceWord >>> 24);	/* blend red and blue components */	rb = (UBANDS((((UBANDS(destinationWord, 16711935)) * unAlpha) >>> 8), 16711935)) + (UBANDS(sourceWord, 16711935));	/* blend alpha and green components */	ag = (UBANDS((((UBANDS((destinationWord >>> 8), 16711935)) * unAlpha) >>> 8), 16711935)) + (UBANDS((sourceWord >>> 8), 16711935));	/* saturate red and blue components if there is a carry */	rb = UBOR((UBANDS(rb, 16711935)), (((UBANDS(rb, 16777472)) * 255) >>> 8));	/* saturate alpha and green components if there is a carry */	ag = UBOR(((UBANDS(ag, 16711935)) << 8 >>> 0), ((UBANDS(ag, 16777472)) * 255));	return UBOR(ag, rb);}, alphaPaintConstwith(sourceWord, destinationWord) {	return (sourceWord === 0) ? destinationWord : BitBltPlugin.alphaBlendConstwithpaintMode(sourceWord, destinationWord, true);}, /*	This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	 */alphaSourceBlendBits16() {	let ditherBase;	let ditherThreshold;	let srcShift;	let sourceWord;	let srcIndex;	let deltaX;	let dstIndex;	let srcAlpha;	let dstMask;	let deltaY;	let srcY;	let destWord;	let dstY;	let ditherIndex;	let addThreshold;	let dstValue;	let addThreshold1;	let dstValue1;	/* This particular method should be optimized in itself */	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	dstY = dy;	srcShift = (UBANDS(dx, 1)) * 16;	if (destMSB) {		srcShift = 16 - srcShift;	}	/* This is the outer loop */	mask1 = SHL(65535, (16 - srcShift));	while (((--deltaY)) !== 0) {		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + ((dx >> 1) * 4);		ditherBase = (UBANDS(dstY, 3)) * 4;		/* For pre-increment */		ditherIndex = (UBANDS(sx, 3)) - 1;		/* So we can pre-decrement */		deltaX = bbW + 1;		dstMask = mask1;		/* This is the inner loop */		srcShift = (dstMask === 65535) ? 16 : 0;		while (((--deltaX)) !== 0) {			ditherThreshold = ditherMatrix4x4[ditherBase + ((ditherIndex = UBANDS((ditherIndex + 1), 3)))];			sourceWord = sourceBits[srcIndex >>> 2];			srcAlpha = sourceWord >>> 24;			if (srcAlpha === 255) {				/* Dither from 32 to 16 bit */				/* begin dither32To16:threshold: */				addThreshold = ditherThreshold << 8 >>> 0;				sourceWord = ((dither8Lookup[addThreshold + (UBANDS((sourceWord >>> 16), 255))] << 10 >>> 0) + (dither8Lookup[addThreshold + (UBANDS((sourceWord >>> 8), 255))] << 5 >>> 0)) + dither8Lookup[addThreshold + (UBANDS(sourceWord, 255))];				/* end dither32To16:threshold: */				/* Store masked value */				sourceWord = (sourceWord === 0) ? (SHL(1, srcShift)) : (SHL(sourceWord, srcShift));				/* begin dstLongAt:put:mask: */				dstValue = destBits[dstIndex >>> 2];				dstValue = UBAND(dstValue, dstMask);				dstValue = UBOR(dstValue, sourceWord);				destBits[dstIndex >>> 2] = dstValue;				/* end dstLongAt:put:mask: */			} else {				/* srcAlpha ~= 255 */				if (srcAlpha !== 0) {					destWord = destBits[dstIndex >>> 2];					destWord = UBAND(destWord, (~(dstMask) >>> 0));					destWord = SHR(destWord, srcShift);					destWord = UBOR((UBOR(((UBANDS(destWord, 31744)) << 9 >>> 0), ((UBANDS(destWord, 992)) << 6 >>> 0))), (UBORM(((UBANDS(destWord, 31)) << 3 >>> 0), 2130706432)));					sourceWord = BitBltPlugin.alphaBlendScaledwith(sourceWord, destWord);					/* begin dither32To16:threshold: */					addThreshold1 = ditherThreshold << 8 >>> 0;					sourceWord = ((dither8Lookup[addThreshold1 + (UBANDS((sourceWord >>> 16), 255))] << 10 >>> 0) + (dither8Lookup[addThreshold1 + (UBANDS((sourceWord >>> 8), 255))] << 5 >>> 0)) + dither8Lookup[addThreshold1 + (UBANDS(sourceWord, 255))];					/* end dither32To16:threshold: */					sourceWord = (sourceWord === 0) ? (SHL(1, srcShift)) : (SHL(sourceWord, srcShift));					/* begin dstLongAt:put:mask: */					dstValue1 = destBits[dstIndex >>> 2];					dstValue1 = UBAND(dstValue1, dstMask);					dstValue1 = UBOR(dstValue1, sourceWord);					destBits[dstIndex >>> 2] = dstValue1;					/* end dstLongAt:put:mask: */				}			}			srcIndex += 4;			if (destMSB) {				if (srcShift === 0) {					dstIndex += 4;				}			} else {				if (srcShift !== 0) {					dstIndex += 4;				}			}			/* Toggle between 0 and 16 */			srcShift = UBXORS(srcShift, 16);			dstMask = (~(dstMask) >>> 0);		}		++srcY;		++dstY;	}}, /*	This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	 */alphaSourceBlendBits32() {	let sourceWord;	let srcIndex;	let deltaX;	let dstIndex;	let srcAlpha;	let deltaY;	let srcY;	let destWord;	let dstY;	/* This particular method should be optimized in itself */	/* Give the compile a couple of hints */	/* The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does) */	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	/* This is the outer loop */	dstY = dy;	while (((--deltaY)) !== 0) {		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + (dx * 4);		/* So we can pre-decrement */		/* This is the inner loop */		deltaX = bbW + 1;		while (((--deltaX)) !== 0) {			sourceWord = sourceBits[srcIndex >>> 2];			srcAlpha = sourceWord >>> 24;			if (srcAlpha === 255) {				destBits[dstIndex >>> 2] = sourceWord;				srcIndex += 4;				/* Now copy as many words as possible with alpha = 255 */				dstIndex += 4;				while ((((--deltaX)) !== 0) && ((((sourceWord = sourceBits[srcIndex >>> 2])) >>> 24) === 255)) {					destBits[dstIndex >>> 2] = sourceWord;					srcIndex += 4;					dstIndex += 4;				}				++deltaX;			} else {				/* srcAlpha ~= 255 */				if (srcAlpha === 0) {					srcIndex += 4;					/* Now skip as many words as possible, */					dstIndex += 4;					while ((((--deltaX)) !== 0) && ((((sourceWord = sourceBits[srcIndex >>> 2])) >>> 24) === 0)) {						srcIndex += 4;						dstIndex += 4;					}					++deltaX;				} else {					/* 0 < srcAlpha < 255 */					/* If we have to mix colors then just copy a single word */					destWord = destBits[dstIndex >>> 2];					destWord = BitBltPlugin.alphaBlendScaledwith(sourceWord, destWord);					destBits[dstIndex >>> 2] = destWord;					srcIndex += 4;					dstIndex += 4;				}			}		}		++srcY;		++dstY;	}}, /*	This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	 */alphaSourceBlendBits8() {	let srcShift;	let sourceWord;	let srcIndex;	let deltaX;	let mappingTable;	let dstIndex;	let adjust;	let mapperFlags;	let srcAlpha;	let dstMask;	let deltaY;	let srcY;	let destWord;	let dstY;	let pv;	let dstValue;	let val;	mappingTable = BitBltPlugin.default8To32Table.apply(this, arguments);	mapperFlags = UBAND(cmFlags, 4294967287);	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	dstY = dy;	mask1 = (UBANDS(dx, 3)) * 8;	if (destMSB) {		mask1 = 24 - mask1;	}	mask2 = UBXORM((SHL(255, mask1)), 2147483647);	adjust = ((UBANDS(dx, 1)) === 0) ? 0 : 522133279;	if ((UBANDS(dy, 1)) === 0) {		adjust = UBXORS(adjust, 522133279);	}	while (((--deltaY)) !== 0) {		adjust = UBXORS(adjust, 522133279);		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + ((dx >> 2) * 4);		/* So we can pre-decrement */		deltaX = bbW + 1;		srcShift = mask1;		/* This is the inner loop */		dstMask = mask2;		while (((--deltaX)) !== 0) {			sourceWord = (UBAND(sourceBits[srcIndex >>> 2], (~(adjust) >>> 0))) + adjust;			srcAlpha = sourceWord >>> 24;			if (srcAlpha > 31) {				/* Everything below 31 is transparent */				if (srcAlpha < 224) {					/* Everything above 224 is opaque */					destWord = destBits[dstIndex >>> 2];					destWord = UBAND(destWord, (~(dstMask) >>> 0));					destWord = SHR(destWord, srcShift);					destWord = mappingTable[destWord];					sourceWord = BitBltPlugin.alphaBlendScaledwith(sourceWord, destWord);				}				/* begin mapPixel:flags: */				pv = sourceWord;				if ((UBANDS(mapperFlags, 1)) !== 0) {					if ((UBANDS(mapperFlags, 2)) !== 0) {						/* begin rgbMapPixel:flags: */						val = SHIFT((UBAND(sourceWord, cmMaskTable[0])), cmShiftTable[0]);						val = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[1])), cmShiftTable[1])));						val = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[2])), cmShiftTable[2])));						pv = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[3])), cmShiftTable[3])));						/* end rgbMapPixel:flags: */						if ((pv === 0) && (sourceWord !== 0)) {							pv = 1;						}					}					if ((UBANDS(mapperFlags, 4)) !== 0) {						pv = cmLookupTable[UBAND(pv, cmMask)];					}				}				sourceWord = pv;				/* end mapPixel:flags: */				/* Store back */				sourceWord = SHL(sourceWord, srcShift);				/* begin dstLongAt:put:mask: */				dstValue = destBits[dstIndex >>> 2];				dstValue = UBAND(dstValue, dstMask);				dstValue = UBOR(dstValue, sourceWord);				destBits[dstIndex >>> 2] = dstValue;				/* end dstLongAt:put:mask: */			}			srcIndex += 4;			if (destMSB) {				if (srcShift === 0) {					dstIndex += 4;					srcShift = 24;					dstMask = 16777215;				} else {					srcShift -= 8;					dstMask = UBORM((dstMask >>> 8), 2130706432);				}			} else {				if (srcShift === 24) {					dstIndex += 4;					srcShift = 0;					dstMask = 4294967040;				} else {					srcShift += 8;					dstMask = UBORS((dstMask << 8 >>> 0), 255);				}			}			adjust = UBXORS(adjust, 522133279);		}		++srcY;		++dstY;	}}, bitAndwith(sourceWord, destinationWord) {	return UBAND(sourceWord, destinationWord);}, bitAndInvertwith(sourceWord, destinationWord) {	return UBAND(sourceWord, (~(destinationWord) >>> 0));}, bitInvertAndwith(sourceWord, destinationWord) {	return UBAND((~(sourceWord) >>> 0), destinationWord);}, bitInvertAndInvertwith(sourceWord, destinationWord) {	return UBAND((~(sourceWord) >>> 0), (~(destinationWord) >>> 0));}, bitInvertDestinationwith(sourceWord, destinationWord) {	return (~(destinationWord) >>> 0);}, bitInvertOrwith(sourceWord, destinationWord) {	return UBOR((~(sourceWord) >>> 0), destinationWord);}, bitInvertOrInvertwith(sourceWord, destinationWord) {	return UBOR((~(sourceWord) >>> 0), (~(destinationWord) >>> 0));}, bitInvertSourcewith(sourceWord, destinationWord) {	return (~(sourceWord) >>> 0);}, bitInvertXorwith(sourceWord, destinationWord) {	return UBXOR((~(sourceWord) >>> 0), destinationWord);}, bitOrwith(sourceWord, destinationWord) {	return UBOR(sourceWord, destinationWord);}, bitOrInvertwith(sourceWord, destinationWord) {	return UBOR(sourceWord, (~(destinationWord) >>> 0));}, bitXorwith(sourceWord, destinationWord) {	return UBXOR(sourceWord, destinationWord);}, clearWordwith(source, destination) {	return 0;}, /*	clip and adjust source origin and extent appropriately *//*	first in x */clipRange() {	if (destX >= clipX) {		sx = sourceX;		dx = destX;		bbW = width;	} else {		sx = sourceX + (clipX - destX);		bbW = width - (clipX - destX);		dx = clipX;	}	if ((dx + bbW) > (clipX + clipWidth)) {		bbW -= (dx + bbW) - (clipX + clipWidth);	}	if (destY >= clipY) {		sy = sourceY;		dy = destY;		bbH = height;	} else {		sy = (sourceY + clipY) - destY;		bbH = height - (clipY - destY);		dy = clipY;	}	if ((dy + bbH) > (clipY + clipHeight)) {		bbH -= (dy + bbH) - (clipY + clipHeight);	}	if (noSource) {		return null;	} else {		if (sx < 0) {			dx -= sx;			bbW += sx;			sx = 0;		}		if ((sx + bbW) > sourceWidth) {			bbW -= (sx + bbW) - sourceWidth;		}		if (sy < 0) {			dy -= sy;			bbH += sy;			sy = 0;		}		if ((sy + bbH) > sourceHeight) {			bbH -= (sy + bbH) - sourceHeight;		}	}}, /*	This function is exported for the Balloon engine */copyBits() {	BitBltPlugin.clipRange.apply(this, arguments);	if ((bbW <= 0) || (bbH <= 0)) {		/* zero width or height; noop */		affectedL = (affectedR = (affectedT = (affectedB = 0)));		return null;	}	if (!BitBltPlugin.lockSurfaces.apply(this, arguments)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	// skipping ifdef ENABLE_FAST_BLT	BitBltPlugin.copyBitsLockedAndClipped.apply(this, arguments);	BitBltPlugin.unlockSurfaces.apply(this, arguments);}, /*	Recover from the fast path specialised code saying Help-I-cant-cope */copyBitsFallback(op, flags) {	let done;	let zzzTemp6;	let zzzTemp3;	let zzzTemp7;	let zzzTemp4;	let zzzTemp1;	let zzzTemp8;	let zzzTemp5;	let zzzTemp;	let zzzTemp2;	let t;	let endBits;	let startBits;	let pixPerM1;	let dxLowBits;	let sxLowBits;	let dWid;	let pixPerM11;	// skipping ifdef ENABLE_FAST_BLT}, /*	Perform the actual copyBits operation using the fast path specialised code; fail some cases by falling back to normal code.	Assume: Surfaces have been locked and clipping was performed. */copyBitsFastPathSpecialised(arg1) {	// skipping ifdef ENABLE_FAST_BLT}, /*	Support for the balloon engine. */copyBitsFromtoat(startX, stopX, yValue) {	destX = startX;	destY = yValue;	sourceX = startX;	width = stopX - startX;	BitBltPlugin.copyBits.apply(this, arguments);	/* begin showDisplayBits */	SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);	/* end showDisplayBits */}, /*	Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed. */copyBitsLockedAndClipped(arg1) {	let done;	let zzzTemp6;	let zzzTemp3;	let zzzTemp7;	let zzzTemp4;	let zzzTemp1;	let zzzTemp8;	let zzzTemp5;	let zzzTemp;	let zzzTemp2;	let t;	let endBits;	let startBits;	let pixPerM1;	let dxLowBits;	let sxLowBits;	let dWid;	let pixPerM11;	BitBltPlugin.copyBitsRule41Test.apply(this, arguments);	;	/* begin tryCopyingBitsQuickly */	if (noSource) {		done = false;	} else {		if ((combinationRule === 34) || (combinationRule === 41)) {			if (sourceDepth === 32) {				if (sourceForm === destForm) {					zzzTemp2 = false;				} else {					if (combinationRule === 41) {						if (destDepth === 32) {							BitBltPlugin.rgbComponentAlpha32.apply(this, arguments);							affectedL = dx;							affectedR = dx + bbW;							affectedT = dy;							affectedB = dy + bbH;							zzzTemp4 = true;						} else {							if (destDepth === 16) {								BitBltPlugin.rgbComponentAlpha16.apply(this, arguments);								affectedL = dx;								affectedR = dx + bbW;								affectedT = dy;								affectedB = dy + bbH;								zzzTemp6 = true;							} else {								if (destDepth === 8) {									BitBltPlugin.rgbComponentAlpha8.apply(this, arguments);									affectedL = dx;									affectedR = dx + bbW;									affectedT = dy;									affectedB = dy + bbH;									zzzTemp8 = true;								} else {									zzzTemp8 = false;								}								zzzTemp6 = zzzTemp8;							}							zzzTemp4 = zzzTemp6;						}						zzzTemp3 = zzzTemp4;					} else {						if (destDepth < 8) {							zzzTemp5 = false;						} else {							if ((destDepth === 8) && ((UBANDS(cmFlags, 1)) === 0)) {								zzzTemp7 = false;							} else {								if (destDepth === 32) {									BitBltPlugin.alphaSourceBlendBits32.apply(this, arguments);								}								if (destDepth === 16) {									BitBltPlugin.alphaSourceBlendBits16.apply(this, arguments);								}								if (destDepth === 8) {									BitBltPlugin.alphaSourceBlendBits8.apply(this, arguments);								}								affectedL = dx;								affectedR = dx + bbW;								affectedT = dy;								affectedB = dy + bbH;								zzzTemp7 = true;							}							zzzTemp5 = zzzTemp7;						}						zzzTemp3 = zzzTemp5;					}					zzzTemp2 = zzzTemp3;				}				zzzTemp1 = zzzTemp2;			} else {				zzzTemp1 = false;			}			zzzTemp = zzzTemp1;		} else {			zzzTemp = false;		}		done = zzzTemp;	}	/* end tryCopyingBitsQuickly */	if (done) {		return null;	}	if ((combinationRule === 30) || (combinationRule === 31)) {		/* Check and fetch source alpha parameter for alpha blend */		if (arguments.length === 1) {			sourceAlpha = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());			if (!((sourceAlpha >= 0) && (sourceAlpha <= 255))) {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	/* Choose and perform the actual copy loop. */	bitCount = 0;	/* begin performCopyLoop */	/* begin destMaskAndPointerInit */	pixPerM1 = destPPW - 1;	startBits = destPPW - (UBAND(dx, pixPerM1));	mask1 = destMSB ? (SHR(4294967295, (32 - (startBits * destDepth)))) : (SHL(4294967295, (32 - (startBits * destDepth))));	endBits = (UBAND(((dx + bbW) - 1), pixPerM1)) + 1;	mask2 = destMSB ? (SHL(4294967295, (32 - (endBits * destDepth)))) : (SHR(4294967295, (32 - (endBits * destDepth))));	if (bbW < startBits) {		mask1 = UBAND(mask1, mask2);		mask2 = 0;		nWords = 1;	} else {		nWords = (Math.trunc(((bbW - startBits) + pixPerM1) / destPPW)) + 1;	}	hDir = (vDir = 1);	destIndex = ((dy * destPitch)) + ((Math.trunc(dx / destPPW)) * 4);	destDelta = (destPitch * vDir) - (4 * (nWords * hDir));	/* end destMaskAndPointerInit */	if (noSource) {		BitBltPlugin.copyLoopNoSource.apply(this, arguments);	} else {		/* begin checkSourceOverlap */		if ((sourceForm === destForm) && (dy >= sy)) {			if (dy > sy) {				vDir = -1;				sy = (sy + bbH) - 1;				dy = (dy + bbH) - 1;			} else {				if ((dy === sy) && (dx > sx)) {					hDir = -1;					sx = (sx + bbW) - 1;					dx = (dx + bbW) - 1;					if (nWords > 1) {						t = mask1;						mask1 = mask2;						mask2 = t;					}				}			}			destIndex = ((dy * destPitch)) + ((Math.trunc(dx / destPPW)) * 4);			destDelta = (destPitch * vDir) - (4 * (nWords * hDir));		}		/* end checkSourceOverlap */		if ((sourceDepth !== destDepth) || ((cmFlags !== 0) || (sourceMSB !== destMSB))) {			BitBltPlugin.copyLoopPixMap.apply(this, arguments);		} else {			/* begin sourceSkewAndPointerInit */			pixPerM11 = destPPW - 1;			sxLowBits = UBAND(sx, pixPerM11);			dxLowBits = UBAND(dx, pixPerM11);			if (hDir > 0) {				dWid = Math.min(bbW, (destPPW - dxLowBits));				preload = (sxLowBits + dWid) > pixPerM11;			} else {				dWid = Math.min(bbW, (dxLowBits + 1));				preload = ((sxLowBits - dWid) + 1) < 0;			}			skew = sourceMSB ? ((sxLowBits - dxLowBits) * destDepth) : ((dxLowBits - sxLowBits) * destDepth);			if (preload) {				skew = (skew < 0) ? (skew + 32) : (skew - 32);			}			sourceIndex = ((sy * sourcePitch)) + ((Math.trunc(sx / (Math.trunc(32 / sourceDepth)))) * 4);			sourceDelta = (sourcePitch * vDir) - (4 * (nWords * hDir));			if (preload) {				sourceDelta -= 4 * hDir;			}			/* end sourceSkewAndPointerInit */			BitBltPlugin.copyLoop.apply(this, arguments);		}	}	/* end performCopyLoop */	if ((combinationRule === 22) || (combinationRule === 32)) {		/* zero width and height; return the count */		affectedL = (affectedR = (affectedT = (affectedB = 0)));	}	if (hDir > 0) {		affectedL = dx;		affectedR = dx + bbW;	} else {		affectedL = (dx - bbW) + 1;		affectedR = dx + 1;	}	if (vDir > 0) {		affectedT = dy;		affectedB = dy + bbH;	} else {		affectedT = (dy - bbH) + 1;		affectedB = dy + 1;	}}, /*	Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables */copyBitsRule41Test() {	if (combinationRule === 41) {		/* fetch the forecolor into componentAlphaModeColor. */		if (arguments.length >= 4) {			BitBltPlugin.copyBitsRule41Test4.apply(this, arguments);		} else {			gammaLookupTable = null;			ungammaLookupTable = null;			if (arguments.length < 2) {				componentAlphaModeAlpha = 255;				BitBltPlugin.copyBitsRule41Test1.apply(this, arguments);			} else {				if (arguments.length > 1) {					BitBltPlugin.copyBitsRule41Test2.apply(this, arguments);				} else {					throw Object.create(PrimitiveFailed).setPayload(1);				}			}		}	}}, /*	Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables */copyBitsRule41Test1(arg1) {	if (arguments.length === 1) {		componentAlphaModeColor = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());		;	}}, /*	Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables */copyBitsRule41Test2(arg1, arg2) {	if (arguments.length === 2) {		componentAlphaModeColor = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());		;		componentAlphaModeAlpha = ((typeof arg2 === "number") ? arg2 : PrimitiveFailed.signal());		;	}}, /*	Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables */copyBitsRule41Test4(arg1, arg2, gammaLookupTableOop, ungammaLookupTableOop) {	if (arguments.length === 4) {		componentAlphaModeColor = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());		;		componentAlphaModeAlpha = ((typeof arg2 === "number") ? arg2 : PrimitiveFailed.signal());		;		((typeof gammaLookupTableOop === "number") ? PrimitiveFailed.signal() : gammaLookupTableOop);		if ((gammaLookupTableOop.storageType === "bytes")) {			gammaLookupTable = BYTESOF(gammaLookupTableOop);		}		((typeof ungammaLookupTableOop === "number") ? PrimitiveFailed.signal() : ungammaLookupTableOop);		if ((ungammaLookupTableOop.storageType === "bytes")) {			ungammaLookupTable = BYTESOF(ungammaLookupTableOop);		}	}}, /*	This version of the inner loop assumes noSource = false. */copyLoop() {	let mergeWord;	let skewWord;	let skewMask;	let halftoneWord;	let unskew;	let mergeFnwith;	let hInc;	let destWord;	let word;	let prevWord;	let y;	let i;	let thisWord;	let notSkewMask;	mergeFnwith = opTable[combinationRule + 1];	/* Byte delta */	/* degenerate skew fixed for Sparc. 10/20/96 ikp */	hInc = hDir * 4;	if (skew === -32) {		skew = (unskew = (skewMask = 0));	} else {		if (skew < 0) {			unskew = skew + 32;			skewMask = SHL(4294967295, (0 - skew));		} else {			if (skew === 0) {				unskew = 0;				skewMask = 4294967295;			} else {				unskew = skew - 32;				skewMask = SHR(4294967295, skew);			}		}	}	notSkewMask = (~(skewMask) >>> 0);	if (noHalftone) {		halftoneWord = 4294967295;		halftoneHeight = 0;	} else {		halftoneWord = halftoneBase[MOD(0, halftoneHeight)];	}	y = dy;	for (i = 1; i <= bbH; i++) {		/* here is the vertical loop */		if (halftoneHeight > 1) {			/* Otherwise, its always the same */			halftoneWord = halftoneBase[MOD(y, halftoneHeight)];			y += vDir;		}		if (preload) {			/* load the 64-bit shifter */			prevWord = sourceBits[sourceIndex >>> 2];			sourceIndex += hInc;		} else {			prevWord = 0;		}		destMask = mask1;		/* pick up next word */		thisWord = sourceBits[sourceIndex >>> 2];		sourceIndex += hInc;		/* 32-bit rotate */		skewWord = UBOR((SHIFT((UBAND(prevWord, notSkewMask)), unskew)), (SHIFT((UBAND(thisWord, skewMask)), skew)));		prevWord = thisWord;		destWord = destBits[destIndex >>> 2];		mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), destWord);		destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));		destBits[destIndex >>> 2] = destWord;		/* This central horizontal loop requires no store masking */		destIndex += hInc;		destMask = 4294967295;		if (combinationRule === 3) {			if ((skew === 0) && (halftoneWord === 4294967295)) {				if (hDir === -1) {					for (word = 2; word <= (nWords - 1); word++) {						thisWord = sourceBits[sourceIndex >>> 2];						sourceIndex += hInc;						destBits[destIndex >>> 2] = thisWord;						destIndex += hInc;					}				} else {					for (word = 2; word <= (nWords - 1); word++) {						destBits[destIndex >>> 2] = prevWord;						destIndex += hInc;						prevWord = sourceBits[sourceIndex >>> 2];						sourceIndex += hInc;					}				}			} else {				for (word = 2; word <= (nWords - 1); word++) {					thisWord = sourceBits[sourceIndex >>> 2];					sourceIndex += hInc;					skewWord = UBOR((SHIFT((UBAND(prevWord, notSkewMask)), unskew)), (SHIFT((UBAND(thisWord, skewMask)), skew)));					prevWord = thisWord;					destBits[destIndex >>> 2] = UBAND(skewWord, halftoneWord);					destIndex += hInc;				}			}		} else {			for (word = 2; word <= (nWords - 1); word++) {				thisWord = sourceBits[sourceIndex >>> 2];				sourceIndex += hInc;				skewWord = UBOR((SHIFT((UBAND(prevWord, notSkewMask)), unskew)), (SHIFT((UBAND(thisWord, skewMask)), skew)));				prevWord = thisWord;				mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), destBits[destIndex >>> 2]);				destBits[destIndex >>> 2] = mergeWord;				destIndex += hInc;			}		}		if (nWords > 1) {			destMask = mask2;			/* pick up next word */			thisWord = sourceBits[sourceIndex >>> 2];			sourceIndex += hInc;			/* 32-bit rotate */			skewWord = UBOR((SHIFT((UBAND(prevWord, notSkewMask)), unskew)), (SHIFT((UBAND(thisWord, skewMask)), skew)));			destWord = destBits[destIndex >>> 2];			mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), destWord);			destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));			destBits[destIndex >>> 2] = destWord;			destIndex += hInc;		}		sourceIndex += sourceDelta;		destIndex += destDelta;	}}, /*	Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused */copyLoopNoSource() {	let mergeWord;	let halftoneWord;	let mergeFnwith;	let destWord;	let word;	let i;	mergeFnwith = opTable[combinationRule + 1];	for (i = 1; i <= bbH; i++) {		/* here is the vertical loop */		/* Note: the horizontal loop has been expanded into three parts for speed: */		/* This first section requires masking of the destination store... */		halftoneWord = noHalftone ? 4294967295 : halftoneBase[MOD(((dy + i) - 1), halftoneHeight)];		destMask = mask1;		destWord = destBits[destIndex >>> 2];		mergeWord = mergeFnwith(halftoneWord, destWord);		destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));		destBits[destIndex >>> 2] = destWord;		/* This central horizontal loop requires no store masking */		destIndex += 4;		destMask = 4294967295;		if (combinationRule === 3) {			/* Special inner loop for STORE */			destWord = halftoneWord;			for (word = 2; word <= (nWords - 1); word++) {				destBits[destIndex >>> 2] = destWord;				destIndex += 4;			}		} else {			/* Normal inner loop does merge */			for (word = 2; word <= (nWords - 1); word++) {				/* Normal inner loop does merge */				destWord = destBits[destIndex >>> 2];				mergeWord = mergeFnwith(halftoneWord, destWord);				destBits[destIndex >>> 2] = mergeWord;				destIndex += 4;			}		}		if (nWords > 1) {			destMask = mask2;			destWord = destBits[destIndex >>> 2];			mergeWord = mergeFnwith(halftoneWord, destWord);			destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));			destBits[destIndex >>> 2] = destWord;			destIndex += 4;		}		destIndex += destDelta;	}}, /*	This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop. *//*	ar 12/7/1999:	The loop has been rewritten to use only one pickSourcePixels call.	The idea is that the call itself could be inlined. If we decide not	to inline pickSourcePixels we could optimize the loop instead. */copyLoopPixMap() {	let mapperFlags;	let srcShiftInc;	let dstShiftLeft;	let sourcePixMask;	let nSourceIncs;	let skewWord;	let words;	let destWord;	let startBits;	let mergeFnwith;	let dstShift;	let i;	let halftoneWord;	let mergeWord;	let destPixMask;	let dstShiftInc;	let srcShift;	let endBits;	let nPix;	let scrStartBits;	let sourcePix;	let srcShift1;	let sourceWord;	let dstShift1;	let destPix;	let nPix1;	let destWord1;	let pv;	let val;	mergeFnwith = opTable[combinationRule + 1];	sourcePPW = Math.trunc(32 / sourceDepth);	sourcePixMask = maskTable[sourceDepth];	destPixMask = maskTable[destDepth];	mapperFlags = UBAND(cmFlags, 4294967287);	sourceIndex = ((sy * sourcePitch)) + ((Math.trunc(sx / sourcePPW)) * 4);	scrStartBits = sourcePPW - (UBAND(sx, (sourcePPW - 1)));	nSourceIncs = (bbW < scrStartBits) ? 0 : ((Math.trunc((bbW - scrStartBits) / sourcePPW)) + 1);	/* Note following two items were already calculated in destmask setup! */	sourceDelta = sourcePitch - (nSourceIncs * 4);	startBits = destPPW - (UBAND(dx, (destPPW - 1)));	endBits = (UBAND(((dx + bbW) - 1), (destPPW - 1))) + 1;	if (bbW < startBits) {		startBits = bbW;	}	srcShift = (UBAND(sx, (sourcePPW - 1))) * sourceDepth;	dstShift = (UBAND(dx, (destPPW - 1))) * destDepth;	srcShiftInc = sourceDepth;	dstShiftInc = destDepth;	dstShiftLeft = 0;	if (sourceMSB) {		srcShift = (32 - sourceDepth) - srcShift;		srcShiftInc = 0 - srcShiftInc;	}	if (destMSB) {		dstShift = (32 - destDepth) - dstShift;		dstShiftInc = 0 - dstShiftInc;		dstShiftLeft = 32 - destDepth;	}	for (i = 1; i <= bbH; i++) {		/* here is the vertical loop */		/* *** is it possible at all that noHalftone == false? *** */		/* setup first load */		halftoneWord = noHalftone ? 4294967295 : halftoneBase[MOD(((dy + i) - 1), halftoneHeight)];		srcBitShift = srcShift;		dstBitShift = dstShift;		destMask = mask1;		/* Here is the horizontal loop... */		nPix = startBits;		words = nWords;		do {			/* pick up the word */			/* begin pickSourcePixels:flags:srcMask:destMask:srcShiftInc:dstShiftInc: */			sourceWord = sourceBits[sourceIndex >>> 2];			destWord1 = 0;			srcShift1 = srcBitShift;			dstShift1 = dstBitShift;			nPix1 = nPix;			if (mapperFlags === (5)) {				do {					sourcePix = UBAND((SHR(sourceWord, srcShift1)), sourcePixMask);					destPix = cmLookupTable[UBAND(sourcePix, cmMask)];					destWord1 = UBOR(destWord1, (SHL((UBAND(destPix, destPixMask)), dstShift1)));					dstShift1 += dstShiftInc;					if ((UBANDM(((srcShift1 += srcShiftInc)), 2147483616)) !== 0) {						srcShift1 = sourceMSB ? (srcShift1 + 32) : (srcShift1 - 32);						sourceWord = sourceBits[(sourceIndex += 4) >>> 2];					}				} while(!(((--nPix1)) === 0));			} else {				do {					sourcePix = UBAND((SHR(sourceWord, srcShift1)), sourcePixMask);					/* begin mapPixel:flags: */					pv = sourcePix;					if ((UBANDS(mapperFlags, 1)) !== 0) {						if ((UBANDS(mapperFlags, 2)) !== 0) {							/* begin rgbMapPixel:flags: */							val = SHIFT((UBAND(sourcePix, cmMaskTable[0])), cmShiftTable[0]);							val = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[1])), cmShiftTable[1])));							val = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[2])), cmShiftTable[2])));							pv = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[3])), cmShiftTable[3])));							/* end rgbMapPixel:flags: */							if ((pv === 0) && (sourcePix !== 0)) {								pv = 1;							}						}						if ((UBANDS(mapperFlags, 4)) !== 0) {							pv = cmLookupTable[UBAND(pv, cmMask)];						}					}					destPix = pv;					/* end mapPixel:flags: */					destWord1 = UBOR(destWord1, (SHL((UBAND(destPix, destPixMask)), dstShift1)));					dstShift1 += dstShiftInc;					if ((UBANDM(((srcShift1 += srcShiftInc)), 2147483616)) !== 0) {						srcShift1 = sourceMSB ? (srcShift1 + 32) : (srcShift1 - 32);						sourceWord = sourceBits[(sourceIndex += 4) >>> 2];					}				} while(!(((--nPix1)) === 0));			}			srcBitShift = srcShift1;			skewWord = destWord1;			/* end pickSourcePixels:flags:srcMask:destMask:srcShiftInc:dstShiftInc: */			dstBitShift = dstShiftLeft;			if (destMask === 4294967295) {				/* avoid read-modify-write */				mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), destBits[destIndex >>> 2]);				destBits[destIndex >>> 2] = UBAND(destMask, mergeWord);			} else {				/* General version using dest masking */				destWord = destBits[destIndex >>> 2];				mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), UBAND(destWord, destMask));				destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));				destBits[destIndex >>> 2] = destWord;			}			destIndex += 4;			if (words === 2) {				/* e.g., is the next word the last word? */				/* set mask for last word in this row */				destMask = mask2;				nPix = endBits;			} else {				/* use fullword mask for inner loop */				destMask = 4294967295;				nPix = destPPW;			}		} while(!(((--words)) === 0));		sourceIndex += sourceDelta;		destIndex += destDelta;	}}, /*	Return the default translation table from 1..8 bit indexed colors to 32bit *//*	The table has been generated by the following statements *//*	| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs := (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex := (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]. */default8To32Table() {	let theTable = [ 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF];;	return theTable;}, destinationWordwith(sourceWord, destinationWord) {	return destinationWord;}, /*	This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y: */drawLoopXY(xDelta, yDelta) {	let P;	let affT;	let dx1;	let px;	let affR;	let affL;	let py;	let i;	let affB;	let dy1;	if (xDelta > 0) {		dx1 = 1;	} else {		dx1 = (xDelta === 0) ? 0 : -1;	}	if (yDelta > 0) {		dy1 = 1;	} else {		dy1 = (yDelta === 0) ? 0 : -1;	}	px = Math.abs(yDelta);	py = Math.abs(xDelta);	/* init null rectangle */	affL = (affT = 9999);	affR = (affB = -9999);	if (py > px) {		/* more horizontal */		P = py >> 1;		for (i = 1; i <= py; i++) {			destX += dx1;			if (((P -= px)) < 0) {				destY += dy1;				P += py;			}			if (i < py) {				BitBltPlugin.copyBits.apply(this, arguments);				;				if ((affectedL < affectedR) && (affectedT < affectedB)) {					/* Affected rectangle grows along the line */					affL = Math.min(affL, affectedL);					affR = Math.max(affR, affectedR);					affT = Math.min(affT, affectedT);					affB = Math.max(affB, affectedB);					if (((affR - affL) * (affB - affT)) > 4000) {						/* If affected rectangle gets large, update it in chunks */						affectedL = affL;						affectedR = affR;						affectedT = affT;						affectedB = affB;						/* begin showDisplayBits */						SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);						/* end showDisplayBits */						/* init null rectangle */						affL = (affT = 9999);						affR = (affB = -9999);					}				}			}		}	} else {		/* more vertical */		P = px >> 1;		for (i = 1; i <= px; i++) {			destY += dy1;			if (((P -= py)) < 0) {				destX += dx1;				P += px;			}			if (i < px) {				BitBltPlugin.copyBits.apply(this, arguments);				;				if ((affectedL < affectedR) && (affectedT < affectedB)) {					/* Affected rectangle grows along the line */					affL = Math.min(affL, affectedL);					affR = Math.max(affR, affectedR);					affT = Math.min(affT, affectedT);					affB = Math.max(affB, affectedB);					if (((affR - affL) * (affB - affT)) > 4000) {						/* If affected rectangle gets large, update it in chunks */						affectedL = affL;						affectedR = affR;						affectedT = affT;						affectedB = affB;						/* begin showDisplayBits */						SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);						/* end showDisplayBits */						/* init null rectangle */						affL = (affT = 9999);						affR = (affB = -9999);					}				}			}		}	}	affectedL = affL;	affectedR = affR;	affectedT = affT;	/* store destX, Y back */	affectedB = affB;	bitBltOop.pointers[4] = destX;	bitBltOop.pointers[5] = destY;}, /*	Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers. */fetchIntOrFloatofObject(fieldIndex, objectPointer) {	let floatValue;	let fieldOop;	fieldOop = objectPointer.pointers[fieldIndex];	if ((typeof fieldOop === "number")) {		return fieldOop;	} else {		floatValue = ((typeof fieldOop === "number" && (fieldOop | 0) !== fieldOop && !Number.isSafeInteger(fieldOop) || fieldOop._class() === SmalltalkGlobals._Float) ? fieldOop.valueOf() : PrimitiveFailed.signal());		if ((-2.147483648e9 <= floatValue) && (floatValue <= 2.147483647e9)) {			return (floatValue | 0);		} else {			throw Object.create(PrimitiveFailed).setPayload(1);			return 0;		}	}}, /*	Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers. */fetchIntOrFloatofObjectifNil(fieldIndex, objectPointer, defaultValue) {	let floatValue;	let fieldOop;	fieldOop = objectPointer.pointers[fieldIndex];	if ((typeof fieldOop === "number")) {		return fieldOop;	} else {		if (fieldOop === nil) {			return defaultValue;		} else {			floatValue = ((typeof fieldOop === "number" && (fieldOop | 0) !== fieldOop && !Number.isSafeInteger(fieldOop) || fieldOop._class() === SmalltalkGlobals._Float) ? fieldOop.valueOf() : PrimitiveFailed.signal());			if ((-2.147483648e9 <= floatValue) && (floatValue <= 2.147483647e9)) {				return (floatValue | 0);			} else {				throw Object.create(PrimitiveFailed).setPayload(1);				return 0;			}		}	}}, /*	For any non-zero pixel value in destinationWord with zero alpha channel take the alpha from sourceWord and fill it in. Intended for fixing alpha channels left at zero during 16->32 bpp conversions. */fixAlphawith(sourceWord, destinationWord) {	return (destDepth === 32) ? ((destinationWord === 0) ? 0 : (((UBANDM(destinationWord, 2130706432)) === 0) ? (UBOR(destinationWord, (UBANDM(sourceWord, 2130706432)))) : destinationWord)) : destinationWord;}, initBBOpTable() {	opTable[0+1] = this.clearWordwith;	opTable[1+1] = this.bitAndwith;	opTable[2+1] = this.bitAndInvertwith;	opTable[3+1] = this.sourceWordwith;	opTable[4+1] = this.bitInvertAndwith;	opTable[5+1] = this.destinationWordwith;	opTable[6+1] = this.bitXorwith;	opTable[7+1] = this.bitOrwith;	opTable[8+1] = this.bitInvertAndInvertwith;	opTable[9+1] = this.bitInvertXorwith;	opTable[10+1] = this.bitInvertDestinationwith;	opTable[11+1] = this.bitOrInvertwith;	opTable[12+1] = this.bitInvertSourcewith;	opTable[13+1] = this.bitInvertOrwith;	opTable[14+1] = this.bitInvertOrInvertwith;	opTable[15+1] = this.destinationWordwith;	opTable[16+1] = this.destinationWordwith;	opTable[17+1] = this.destinationWordwith;	opTable[18+1] = this.addWordwith;	opTable[19+1] = this.subWordwith;	opTable[20+1] = this.rgbAddwith;	opTable[21+1] = this.rgbSubwith;	opTable[22+1] = this.OLDrgbDiffwith;	opTable[23+1] = this.OLDtallyIntoMapwith;	opTable[24+1] = this.alphaBlendwith;	opTable[25+1] = this.pixPaintwith;	opTable[26+1] = this.pixMaskwith;	opTable[27+1] = this.rgbMaxwith;	opTable[28+1] = this.rgbMinwith;	opTable[29+1] = this.rgbMinInvertwith;	opTable[30+1] = this.alphaBlendConstwith;	opTable[31+1] = this.alphaPaintConstwith;	opTable[32+1] = this.rgbDiffwith;	opTable[33+1] = this.tallyIntoMapwith;	opTable[34+1] = this.alphaBlendScaledwith;	opTable[35+1] = this.alphaBlendScaledwith;	opTable[36+1] = this.alphaBlendScaledwith;	opTable[37+1] = this.rgbMulwith;	opTable[38+1] = this.pixSwapwith;	opTable[39+1] = this.pixClearwith;	opTable[40+1] = this.fixAlphawith;	opTable[41+1] = this.rgbComponentAlphawith;}, initDither8Lookup() {	let t;	let b;	let value;	let pv;	let threshold;	let value1;	let out;	for (b = 0; b <= 255; b++) {		for (t = 0; t <= 15; t++) {			/* begin expensiveDither32To16:threshold: */			pv = UBANDS(b, 255);			threshold = ditherThresholds16[UBANDS(pv, 7)];			value1 = ditherValues16[pv >>> 3];			out = (t < threshold) ? (value1 + 1) : value1;			pv = UBANDS((b >>> 8), 255);			threshold = ditherThresholds16[UBANDS(pv, 7)];			value1 = ditherValues16[pv >>> 3];			out = (t < threshold) ? (UBOR(out, ((value1 + 1) << 5 >>> 0))) : (UBOR(out, (value1 << 5 >>> 0)));			pv = UBANDS((b >>> 16), 255);			threshold = ditherThresholds16[UBANDS(pv, 7)];			value1 = ditherValues16[pv >>> 3];			out = (t < threshold) ? (UBOR(out, ((value1 + 1) << 10 >>> 0))) : (UBOR(out, (value1 << 10 >>> 0)));			value = out;			/* end expensiveDither32To16:threshold: */			dither8Lookup[(t << 8 >>> 0) + b] = value;		}	}}, initialiseModule() {	BitBltPlugin.initBBOpTable.apply(this, arguments);	BitBltPlugin.initDither8Lookup.apply(this, arguments);	// skipping ifdef ENABLE_FAST_BLT	return true;}, /*	Return true if shiftTable/maskTable define an identity mapping. */isIdentityMapwith(shifts, masks) {	return ((!shifts) || (!masks)) ? true : (((shifts[0] === 0) && ((shifts[1] === 0) && ((shifts[2] === 0) && ((shifts[3] === 0) && ((masks[0] === 16711680) && ((masks[1] === 65280) && ((masks[2] === 255) && (masks[3] === 4278190080)))))))) ? true : false);}, /*	Load BitBlt from the oop.	This function is exported for the Balloon engine. */loadBitBltFrom(bbObj) {	return BitBltPlugin.loadBitBltFromwarping(bbObj, false);}, /*	Load context from BitBlt instance.  Return false if anything is amiss *//*	NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works! */loadBitBltFromwarping(bbObj, aBool) {	let ok;	let zzzTemp1;	let zzzTemp;	let sourceBitsSize;	let zzzTemp2;	let zzzTemp11;	let destBitsSize;	let zzzTemp4;	let zzzTemp21;	bitBltOop = bbObj;	isWarping = aBool;	combinationRule = bitBltOop.pointers[3];	if ((combinationRule < 0) || (combinationRule > (41))) {		return false;	}	if ((combinationRule >= 16) && (combinationRule <= 17)) {		return false;	}	sourceForm = bitBltOop.pointers[1];	noSource = (sourceForm === nil) ? true : ((combinationRule === 0) ? true : ((combinationRule === 5) ? true : ((combinationRule === 10) ? true : ((combinationRule === 15) ? true : false))));	halftoneForm = bitBltOop.pointers[2];	noHalftone = (halftoneForm === nil) ? true : ((combinationRule === 0) ? true : ((combinationRule === 5) ? true : ((combinationRule === 10) ? true : ((combinationRule === 15) ? true : false))));	destForm = bbObj.pointers[0];	if (!((destForm.storageType === "pointers") && (SIZEOF(destForm) >= 4))) {		return false;	}	/* begin loadBitBltDestForm */	destBits = destForm.pointers[0];	destWidth = destForm.pointers[1];	destHeight = destForm.pointers[2];	if ((destWidth >= 0) && (destHeight >= 0)) {		destDepth = destForm.pointers[3];		destMSB = destDepth > 0;		if (destDepth < 0) {			destDepth = 0 - destDepth;		}		if ((typeof destBits === "number")) {			if (BitBltPlugin.queryDestSurface(destBits)) {				destPPW = Math.trunc(32 / destDepth);				destBits = (destPitch = 0);				zzzTemp11 = true;			} else {				zzzTemp11 = false;			}			zzzTemp4 = zzzTemp11;		} else {			destPPW = Math.trunc(32 / destDepth);			destPitch = (Math.trunc((destWidth + (destPPW - 1)) / destPPW)) * 4;			destBitsSize = BYTESIZEOF(destBits);			if ((["words", "bytes"].indexOf(destBits.storageType) !== -1) && (destBitsSize >= (destPitch * destHeight))) {				destBits = destBits.wordsOrBytes();				zzzTemp21 = true;			} else {				zzzTemp21 = false;			}			zzzTemp4 = zzzTemp21;		}		ok = zzzTemp4;	} else {		ok = false;	}	/* end loadBitBltDestForm */	if (!ok) {		return false;	}	destX = BitBltPlugin.fetchIntOrFloatofObjectifNil(4, bitBltOop, 0);	destY = BitBltPlugin.fetchIntOrFloatofObjectifNil(5, bitBltOop, 0);	width = BitBltPlugin.fetchIntOrFloatofObjectifNil(6, bitBltOop, destWidth);	height = BitBltPlugin.fetchIntOrFloatofObjectifNil(7, bitBltOop, destHeight);	;	if (noSource) {		sourceX = (sourceY = 0);	} else {		if (!((sourceForm.storageType === "pointers") && (SIZEOF(sourceForm) >= 4))) {			return false;		}		/* begin loadBitBltSourceForm */		sourceBits = sourceForm.pointers[0];		sourceWidth = BitBltPlugin.fetchIntOrFloatofObject(1, sourceForm);		sourceHeight = BitBltPlugin.fetchIntOrFloatofObject(2, sourceForm);		if ((sourceWidth >= 0) && (sourceHeight >= 0)) {			sourceDepth = sourceForm.pointers[3];			sourceMSB = sourceDepth > 0;			if (sourceDepth < 0) {				sourceDepth = 0 - sourceDepth;			}			if ((typeof sourceBits === "number")) {				if (BitBltPlugin.querySourceSurface(sourceBits)) {					sourcePPW = Math.trunc(32 / sourceDepth);					sourceBits = (sourcePitch = 0);					zzzTemp1 = true;				} else {					zzzTemp1 = false;				}				zzzTemp = zzzTemp1;			} else {				sourcePPW = Math.trunc(32 / sourceDepth);				sourcePitch = (Math.trunc((sourceWidth + (sourcePPW - 1)) / sourcePPW)) * 4;				sourceBitsSize = BYTESIZEOF(sourceBits);				if ((["words", "bytes"].indexOf(sourceBits.storageType) !== -1) && (sourceBitsSize >= (sourcePitch * sourceHeight))) {					sourceBits = sourceBits.wordsOrBytes();					zzzTemp2 = true;				} else {					zzzTemp2 = false;				}				zzzTemp = zzzTemp2;			}			ok = zzzTemp;		} else {			ok = false;		}		/* end loadBitBltSourceForm */		if (!ok) {			return false;		}		ok = BitBltPlugin.loadColorMap.apply(this, arguments);		if (!ok) {			return false;		}		if ((UBANDS(cmFlags, 8)) === 0) {			BitBltPlugin.setupColorMasks.apply(this, arguments);		}		sourceX = BitBltPlugin.fetchIntOrFloatofObjectifNil(8, bitBltOop, 0);		sourceY = BitBltPlugin.fetchIntOrFloatofObjectifNil(9, bitBltOop, 0);	}	ok = BitBltPlugin.loadHalftoneForm.apply(this, arguments);	if (!ok) {		return false;	}	clipX = BitBltPlugin.fetchIntOrFloatofObjectifNil(10, bitBltOop, 0);	clipY = BitBltPlugin.fetchIntOrFloatofObjectifNil(11, bitBltOop, 0);	clipWidth = BitBltPlugin.fetchIntOrFloatofObjectifNil(12, bitBltOop, destWidth);	clipHeight = BitBltPlugin.fetchIntOrFloatofObjectifNil(13, bitBltOop, destHeight);	;	if (clipX < 0) {		clipWidth += clipX;		clipX = 0;	}	if (clipY < 0) {		clipHeight += clipY;		clipY = 0;	}	if ((clipX + clipWidth) > destWidth) {		clipWidth = destWidth - clipX;	}	if ((clipY + clipHeight) > destHeight) {		clipHeight = destHeight - clipY;	}	return true;}, /*	ColorMap, if not nil, must be longWords, and 	2^N long, where N = sourceDepth for 1, 2, 4, 8 bits, 	or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits. */loadColorMap() {	let oop;	let cmOop;	let cmSize;	let oldStyle;	let zzzTemp;	cmFlags = (cmMask = (cmBitsPerColor = 0));	cmShiftTable = null;	cmMaskTable = null;	cmLookupTable = null;	cmOop = bitBltOop.pointers[14];	if (cmOop === nil) {		return true;	} else {		/* even if identity or somesuch - may be cleared later */		cmFlags = 1;		oldStyle = false;		if ((cmOop.storageType === "words")) {			/* This is an old-style color map (indexed only, with implicit RGBA conversion) */			cmSize = SIZEOF(cmOop);			cmLookupTable = cmOop.words;			oldStyle = true;		} else {			/* A new-style color map (fully qualified) */			if ((cmOop.storageType === "pointers") && (SIZEOF(cmOop) >= 3)) {				cmShiftTable = BitBltPlugin.loadColorMapShiftOrMaskFrom(cmOop.pointers[0]);				cmMaskTable = BitBltPlugin.loadColorMapShiftOrMaskFrom(cmOop.pointers[1]);				oop = cmOop.pointers[2];				if (oop === nil) {					cmSize = 0;				} else {					if ((oop.storageType === "words")) {						cmSize = SIZEOF(oop);						cmLookupTable = oop.words;					} else {						return false;					}				}				cmFlags = UBORS(cmFlags, 8);				;			} else {				return false;			}		}		if ((UBAND(cmSize, (cmSize - 1))) === 0) {			cmMask = cmSize - 1;			cmBitsPerColor = 0;						switch (cmSize) {			case 512:								cmBitsPerColor = 3;				break;			case 4096:								cmBitsPerColor = 4;				break;			case 32768:								cmBitsPerColor = 5;				break;			default:								null;			}			if (cmSize === 0) {				cmLookupTable = null;				cmMask = 0;			} else {				cmFlags = UBORS(cmFlags, 4);			}			if (oldStyle) {				/* needs implicit conversion */				BitBltPlugin.setupColorMasks.apply(this, arguments);			}			if (BitBltPlugin.isIdentityMapwith(cmShiftTable, cmMaskTable)) {				cmMaskTable = null;				cmShiftTable = null;			} else {				cmFlags = UBORS(cmFlags, 2);			}			zzzTemp = true;		} else {			zzzTemp = false;		}		return zzzTemp;	}}, loadColorMapShiftOrMaskFrom(mapOop) {	if (mapOop === nil) {		return null;	} else {		if ((typeof mapOop === "number")) {			throw Object.create(PrimitiveFailed).setPayload(1);			return null;		} else {			if ((mapOop.storageType === "words") && (SIZEOF(mapOop) === 4)) {				return mapOop.words;			} else {				throw Object.create(PrimitiveFailed).setPayload(1);				return null;			}		}	}}, /*	Load the halftone form */loadHalftoneForm() {	let halftoneBits;	if (noHalftone) {		halftoneBase = null;	} else {		if ((halftoneForm.storageType === "pointers") && (SIZEOF(halftoneForm) >= 4)) {			/* Old-style 32xN monochrome halftone Forms */			halftoneBits = halftoneForm.pointers[0];			halftoneHeight = halftoneForm.pointers[2];			if (!(halftoneBits.storageType === "words")) {				noHalftone = true;			}		} else {			/* New spec accepts, basically, a word array */			if (!(halftoneForm.storageType === "pointers") && ((halftoneForm.storageType === "words"))) {				halftoneBits = halftoneForm;				halftoneHeight = SIZEOF(halftoneBits);			} else {				return false;			}		}		halftoneBase = halftoneBits.wordsOrBytes();	}	return true;}, /*	Load the surface support plugin */loadSurfacePlugin() {	querySurfaceFn = SmalltalkVM.ioLoadFunctionFrom("ioGetSurfaceFormat", "SurfacePlugin");	lockSurfaceFn = SmalltalkVM.ioLoadFunctionFrom("ioLockSurface", "SurfacePlugin");	unlockSurfaceFn = SmalltalkVM.ioLoadFunctionFrom("ioUnlockSurface", "SurfacePlugin");	return (!!querySurfaceFn) && ((!!lockSurfaceFn) && (!!unlockSurfaceFn));}, /*	Get a pointer to the bits of any OS surfaces. *//*	Notes: 	* For equal source/dest handles only one locking operation is performed.	This is to prevent locking of overlapping areas which does not work with	certain APIs (as an example, DirectDraw prevents locking of overlapping areas). 	A special case for non-overlapping but equal source/dest handle would 	be possible but we would have to transfer this information over to 	unlockSurfaces somehow (currently, only one unlock operation is 	performed for equal source and dest handles). Also, this would require	a change in the notion of ioLockSurface() which is right now interpreted	as a hint and not as a requirement to lock only the specific portion of	the surface.	* The arguments in ioLockSurface() provide the implementation with	an explicit hint what area is affected. It can be very useful to	know the max. affected area beforehand if getting the bits requires expensive	copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).	However, the returned pointer *MUST* point to the virtual origin of the surface	and not to the beginning of the rectangle. The promise made by BitBlt	is to never access data outside the given rectangle (aligned to 4byte boundaries!)	so it is okay to return a pointer to the virtual origin that is actually outside	the valid memory area.	* The area provided in ioLockSurface() is already clipped (e.g., it will always	be inside the source and dest boundingBox) but it is not aligned to word boundaries	yet. It is up to the support code to compute accurate alignment if necessary.	* Warping always requires the entire source surface to be locked because	there is no beforehand knowledge about what area will actually be traversed.	 */lockSurfaces() {	let destHandle;	let sourceHandle;	let t;	let fn;	let r;	let b;	let l;	hasSurfaceLock = false;	if (destBits === 0) {		/* Blitting *to* OS surface */		if (!lockSurfaceFn) {			if (!BitBltPlugin.loadSurfacePlugin.apply(this, arguments)) {				return null;			}		}		fn = lockSurfaceFn;		destHandle = destForm.pointers[0];		if ((sourceBits === 0) && (!noSource)) {			/* Handle the special case of equal source and dest handles */			sourceHandle = sourceForm.pointers[0];			if (sourceHandle === destHandle) {				/* If we have overlapping source/dest we lock the entire area				so that there is only one area transmitted */				if (isWarping) {					/* Otherwise use overlapping area */					l = Math.min(sx, dx);					r = Math.max(sx, dx) + bbW;					t = Math.min(sy, dy);					b = Math.max(sy, dy) + bbH;					sourceBits = fn(sourceHandle, function(p){sourcePitch = p}, l, t, r-l, b-t);				} else {					/* When warping we always need the entire surface for the source */					sourceBits = fn(sourceHandle, function(p){sourcePitch = p}, 0,0, sourceWidth, sourceHeight);				}				destBits = sourceBits;				destPitch = sourcePitch;				hasSurfaceLock = true;				return destBits !== 0;			}		}		destBits = fn(destHandle, function(p){destPitch = p}, dx, dy, bbW, bbH);		hasSurfaceLock = true;	}	if ((sourceBits === 0) && (!noSource)) {		/* Blitting *from* OS surface */		sourceHandle = sourceForm.pointers[0];		if (!lockSurfaceFn) {			if (!BitBltPlugin.loadSurfacePlugin.apply(this, arguments)) {				return null;			}		}		/* Warping requiring the entire surface */		fn = lockSurfaceFn;		sourceBits = isWarping ? fn(sourceHandle, function(p){sourcePitch = p}, 0, 0, sourceWidth, sourceHeight) : fn(sourceHandle, function(p){sourcePitch = p}, sx, sy, bbW, bbH);		hasSurfaceLock = true;	}	return (destBits !== 0) && ((sourceBits !== 0) || (noSource));}, /*	The module with the given name was just unloaded.	Make sure we have no dangling references. */moduleUnloaded(aModuleName) {	if (strcmp(aModuleName, "SurfacePlugin") === 0) {		/* The surface plugin just shut down. How nasty. */		querySurfaceFn = (lockSurfaceFn = (unlockSurfaceFn = 0));	}}, /*	AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color */partitionedANDtonBitsnPartitions(word1, word2, nBits, nParts) {	let result;	let i;	let mask;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= nParts; i++) {		if ((UBAND(word1, mask)) === mask) {			result = UBOR(result, (UBAND(word2, mask)));		}		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, /*	Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors *//*	Use unsigned int everywhere because it has a well known arithmetic model without undefined behavior w.r.t. overflow and shifts */partitionedAddtonBitscomponentMaskcarryOverflowMask(word1, word2, nBits, componentMask, carryOverflowMask) {	let w2;	let carryOverflow;	let sum;	let w1;	/* mask to remove high bit of each component */	w1 = UBAND(word1, carryOverflowMask);	w2 = UBAND(word2, carryOverflowMask);	/* sum without high bit to avoid overflowing over next component */	sum = (UBXOR(word1, w1)) + (UBXOR(word2, w2));	/* detect overflow condition for saturating */	carryOverflow = UBOR((UBAND(w1, w2)), (UBAND((UBOR(w1, w2)), sum)));	return UBOR((UBXOR((UBXOR(sum, w1)), w2)), ((SHR(carryOverflow, (nBits - 1))) * componentMask));}, /*	Max word1 to word2 as nParts partitions of nBits each *//*	In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv) */partitionedMaxwithnBitsnPartitions(word1, word2, nBits, nParts) {	let result;	let i;	let mask;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= nParts; i++) {		result = UBOR(result, Math.max((UBAND(word2, mask)), (UBAND(word1, mask))));		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, /*	Min word1 to word2 as nParts partitions of nBits each *//*	In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv) */partitionedMinwithnBitsnPartitions(word1, word2, nBits, nParts) {	let result;	let i;	let mask;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= nParts; i++) {		result = UBOR(result, Math.min((UBAND(word2, mask)), (UBAND(word1, mask))));		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, /*	Multiply word1 with word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors.	Bug in loop version when non-white background *//*	In C, integer multiplication might answer a wrong value if the unsigned values are declared as signed.	This problem does not affect this method, because the most significant bit (i.e. the sign bit) will	always be zero (jmv) */partitionedMulwithnBitsnPartitions(word1, word2, nBits, nParts) {	let dMask;	let result;	let product;	let sMask;	/* partition mask starts at the right */	sMask = maskTable[nBits];	dMask = SHL(sMask, nBits);	/* optimized first step */	result = SHR((UBAND(((((UBAND(word1, sMask)) + 1) * ((UBAND(word2, sMask)) + 1)) - 1), dMask)), nBits);	if (nParts !== 1) {		product = UBAND(((((UBAND((SHR(word1, nBits)), sMask)) + 1) * ((UBAND((SHR(word2, nBits)), sMask)) + 1)) - 1), dMask);		result = UBOR(result, product);		if (nParts !== 2) {			product = UBAND(((((UBAND((SHR(word1, (2 * nBits))), sMask)) + 1) * ((UBAND((SHR(word2, (2 * nBits))), sMask)) + 1)) - 1), dMask);			result = UBOR(result, (SHL(product, nBits)));			if (nParts !== 3) {				product = UBAND(((((UBAND((SHR(word1, (3 * nBits))), sMask)) + 1) * ((UBAND((SHR(word2, (3 * nBits))), sMask)) + 1)) - 1), dMask);				result = UBOR(result, (SHL(product, (2 * nBits))));			}		}	}	/* 	| sMask product result dMask |	sMask := maskTable at: nBits.  'partition mask starts at the right'	dMask :=  sMask << nBits.	result := (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	'optimized first step'	nBits to: nBits * (nParts-1) by: nBits do: [:ofs |		product := (((word1>>ofs bitAnd: sMask)+1) * ((word2>>ofs bitAnd: sMask)+1) - 1 bitAnd: dMask).		result := result bitOr: (product bitAnd: dMask) << (ofs-nBits)].	^ result */	return result;}, partitionedRgbComponentAlphadestnBitsnPartitions(sourceWord, destWord, nBits, nParts) {	let p2;	let result;	let p1;	let i;	let v;	let mask;	let d;	let destPix;	let srcPix;	let zzzTemp1;	let mask3;	let zzzTemp;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= nParts; i++) {		p1 = SHR((UBAND(sourceWord, mask)), ((i - 1) * nBits));		p2 = SHR((UBAND(destWord, mask)), ((i - 1) * nBits));		if (nBits !== 32) {			if (nBits === 16) {				p1 = UBORM((UBOR((UBOR(((UBANDS(p1, 31)) << 3 >>> 0), ((UBANDS(p1, 992)) << 6 >>> 0))), ((UBANDS(p1, 31744)) << 9 >>> 0))), 2130706432);				p2 = UBORM((UBOR((UBOR(((UBANDS(p2, 31)) << 3 >>> 0), ((UBANDS(p2, 992)) << 6 >>> 0))), ((UBANDS(p2, 31744)) << 9 >>> 0))), 2130706432);			} else {				p1 = UBORM(BitBltPlugin.rgbMapfromto(p1, nBits, 32), 2130706432);				p2 = UBORM(BitBltPlugin.rgbMapfromto(p2, nBits, 32), 2130706432);			}		}		v = BitBltPlugin.rgbComponentAlpha32with(p1, p2);		if (nBits !== 32) {			/* begin rgbMap:from:to: */			if (((d = nBits - 32)) > 0) {				mask3 = 4294967295;				srcPix = SHL(v, d);				mask3 = SHL(mask3, d);				destPix = UBAND(srcPix, mask3);				mask3 = SHL(mask3, nBits);				srcPix = SHL(srcPix, d);				v = (destPix + (UBAND(srcPix, mask3))) + (UBAND((SHL(srcPix, d)), (SHL(mask3, nBits))));			} else {				if (d === 0) {					zzzTemp = (v);				} else {					if (v === 0) {						zzzTemp1 = v;					} else {						d = 32 - nBits;						mask3 = (SHL(1, nBits)) - 1;						srcPix = SHR(v, d);						destPix = UBAND(srcPix, mask3);						mask3 = SHL(mask3, nBits);						srcPix = SHR(srcPix, d);						destPix = (destPix + (UBAND(srcPix, mask3))) + (UBAND((SHR(srcPix, d)), (SHL(mask3, nBits))));						zzzTemp1 = (destPix === 0) ? 1 : destPix;					}					zzzTemp = zzzTemp1;				}				v = zzzTemp;			}			/* end rgbMap:from:to: */		}		result = UBOR(result, (SHL(v, ((i - 1) * nBits))));		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, /*	Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors *//*	In C, most arithmetic operations answer the same bit pattern regardless of the operands being signed or unsigned ints	(this is due to the way 2's complement numbers work). However, comparisions might fail. Add the proper declaration of	words as unsigned int in those cases where comparisions are done (jmv) */partitionedSubfromnBitsnPartitions(word1, word2, nBits, nParts) {	let p2;	let result;	let p1;	let i;	let mask;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= nParts; i++) {		p1 = UBAND(word1, mask);		p2 = UBAND(word2, mask);		result = (p1 < p2) ? (UBOR(result, (p2 - p1))) : (UBOR(result, (p1 - p2)));		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, /*	Clear all pixels in destinationWord for which the pixels of sourceWord have the same values. Used to clear areas of some constant color to zero. */pixClearwith(sourceWord, destinationWord) {	let pv;	let nBits;	let result;	let i;	let mask;	if (destDepth === 32) {		return (sourceWord === destinationWord) ? 0 : destinationWord;	}	nBits = destDepth;	/* partition mask starts at the right */	mask = maskTable[nBits];	result = 0;	for (i = 1; i <= destPPW; i++) {		pv = UBAND(destinationWord, mask);		if ((UBAND(sourceWord, mask)) === pv) {			pv = 0;		}		result = UBOR(result, pv);		/* slide left to next partition */		mask = SHL(mask, nBits);	}	return result;}, pixMaskwith(sourceWord, destinationWord) {	let result;	let i;	let mask;	/* begin partitionedAND:to:nBits:nPartitions: */	mask = maskTable[destDepth];	result = 0;	for (i = 1; i <= destPPW; i++) {		if ((UBAND((~(sourceWord) >>> 0), mask)) === mask) {			result = UBOR(result, (UBAND(destinationWord, mask)));		}		mask = SHL(mask, destDepth);	}	return result;	/* end partitionedAND:to:nBits:nPartitions: */}, pixPaintwith(sourceWord, destinationWord) {	return (sourceWord === 0) ? destinationWord : (UBOR(sourceWord, BitBltPlugin.partitionedANDtonBitsnPartitions((~(sourceWord) >>> 0), destinationWord, destDepth, destPPW)));}, /*	Swap the pixels in destWord */pixSwapwith(sourceWord, destWord) {	let result;	let shift;	let lowMask;	let highMask;	let i;	if (destPPW === 1) {		return destWord;	}	result = 0;	/* mask low pixel */	lowMask = (SHL(1, destDepth)) - 1;	/* mask high pixel */	highMask = SHL(lowMask, ((destPPW - 1) * destDepth));	shift = 32 - destDepth;	result = UBOR(result, (UBOR((SHL((UBAND(destWord, lowMask)), shift)), (SHR((UBAND(destWord, highMask)), shift)))));	if (destPPW <= 2) {		return result;	}	for (i = 2; i <= (destPPW >> 1); i++) {		lowMask = SHL(lowMask, destDepth);		highMask = SHR(highMask, destDepth);		shift -= destDepth * 2;		result = UBOR(result, (UBOR((SHL((UBAND(destWord, lowMask)), shift)), (SHR((UBAND(destWord, highMask)), shift)))));	}	return result;}, /*	Invoke the copyBits primitive. If the destination is the display, then copy it to the screen. */primitiveCopyBits() {	if (!BitBltPlugin.loadBitBltFromwarping(this, false)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	BitBltPlugin.copyBits.apply(this, arguments);	;	/* begin showDisplayBits */	SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);	/* end showDisplayBits */	;	if ((combinationRule === 22) || (combinationRule === 32)) {		throw Object.create(PrimitiveReturn).setPayload(((typeof bitCount === "number") ? bitCount : PrimitiveFailed.signal()));	}	throw Object.create(PrimitiveReturn).setPayload(this);}, primitiveDisplayString(sourceString, startIndex, stopIndex, glyphMap, xTable, kernDelta) {	let charIndex;	let sourcePtr;	let maxGlyph;	let quickBlt;	let glyphIndex;	let left;	let ascii;	let endBits;	let startBits;	let pixPerM1;	if (arguments.length !== 6) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof kernDelta === "number") ? kernDelta : PrimitiveFailed.signal());	((typeof xTable === "number") ? PrimitiveFailed.signal() : xTable);	((typeof glyphMap === "number") ? PrimitiveFailed.signal() : glyphMap);	if (!((xTable._class() === SmalltalkGlobals._Array) && (glyphMap._class() === SmalltalkGlobals._Array))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(glyphMap) !== 256) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	;	maxGlyph = SIZEOF(xTable) - 2;	((typeof stopIndex === "number") ? stopIndex : PrimitiveFailed.signal());	((typeof startIndex === "number") ? startIndex : PrimitiveFailed.signal());	((typeof sourceString === "number") ? PrimitiveFailed.signal() : sourceString);	if (!(sourceString.storageType === "bytes")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((startIndex > 0) && ((stopIndex > 0) && (stopIndex <= BYTESIZEOF(sourceString))))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof this === "number") ? PrimitiveFailed.signal() : this);	if (!BitBltPlugin.loadBitBltFromwarping(this, false)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((combinationRule === 30) || (combinationRule === 31)) {		/* needs extra source alpha */		throw Object.create(PrimitiveFailed).setPayload(1);	}	quickBlt = (destBits !== 0) && ((sourceBits !== 0) && ((noSource === false) && ((sourceForm !== destForm) && ((cmFlags !== 0) || ((sourceMSB !== destMSB) || (sourceDepth !== destDepth))))));	left = destX;	sourcePtr = BYTESOF(sourceString);	for (charIndex = startIndex; charIndex <= stopIndex; charIndex++) {		ascii = sourcePtr[charIndex - 1];		glyphIndex = glyphMap.pointers[ascii];		if ((glyphIndex < 0) || (glyphIndex > maxGlyph)) {			throw Object.create(PrimitiveFailed).setPayload(1);		}		sourceX = xTable.pointers[glyphIndex];		width = xTable.pointers[(glyphIndex + 1)] - sourceX;		;		BitBltPlugin.clipRange.apply(this, arguments);		if ((bbW > 0) && (bbH > 0)) {			if (quickBlt) {				/* begin destMaskAndPointerInit */				pixPerM1 = destPPW - 1;				startBits = destPPW - (UBAND(dx, pixPerM1));				mask1 = destMSB ? (SHR(4294967295, (32 - (startBits * destDepth)))) : (SHL(4294967295, (32 - (startBits * destDepth))));				endBits = (UBAND(((dx + bbW) - 1), pixPerM1)) + 1;				mask2 = destMSB ? (SHL(4294967295, (32 - (endBits * destDepth)))) : (SHR(4294967295, (32 - (endBits * destDepth))));				if (bbW < startBits) {					mask1 = UBAND(mask1, mask2);					mask2 = 0;					nWords = 1;				} else {					nWords = (Math.trunc(((bbW - startBits) + pixPerM1) / destPPW)) + 1;				}				hDir = (vDir = 1);				destIndex = ((dy * destPitch)) + ((Math.trunc(dx / destPPW)) * 4);				destDelta = (destPitch * vDir) - (4 * (nWords * hDir));				/* end destMaskAndPointerInit */				BitBltPlugin.copyLoopPixMap.apply(this, arguments);				affectedL = dx;				affectedR = dx + bbW;				affectedT = dy;				affectedB = dy + bbH;			} else {				BitBltPlugin.copyBits.apply(this, arguments);			}		}		;		destX = (destX + width) + kernDelta;	}	affectedL = left;	/* begin showDisplayBits */	SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);	/* end showDisplayBits */	this.pointers[4] = destX;	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Invoke the line drawing primitive. */primitiveDrawLoop(xDelta, yDelta) {	((typeof xDelta === "number") ? xDelta : PrimitiveFailed.signal());	((typeof yDelta === "number") ? yDelta : PrimitiveFailed.signal());	if (!BitBltPlugin.loadBitBltFromwarping(this, false)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	BitBltPlugin.drawLoopXY(xDelta, yDelta);/* begin showDisplayBits */SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);/* end showDisplayBits */	;	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	returns the single pixel at x@y.	It does not handle LSB bitmaps right now.	If x or y are < 0, return 0 to indicate transparent (cf BitBlt>bitPeekerFromForm: usage).	Likewise if x>width or y>depth.	Fail if the rcvr doesn't seem to be a Form, or x|y seem wrong */primitivePixelValueAt(xVal, yVal) {	let pixel;	let rcvr;	let shift;	let depth;	let bitmap;	let ppW;	let word;	let stride;	let bitsSize;	let mask;	if (!(typeof xVal === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof yVal === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	rcvr = this;	if ((xVal < 0) || (yVal < 0)) {		throw Object.create(PrimitiveReturn).setPayload(0);	} else {		if ((rcvr.storageType === "pointers") && (SIZEOF(rcvr) >= 4)) {			bitmap = rcvr.pointers[0];			if ((["words", "bytes"].indexOf(bitmap.storageType) !== -1)) {				width = rcvr.pointers[1];				height = rcvr.pointers[2];				/* if width/height/depth are not integer, fail */				depth = rcvr.pointers[3];							if ((xVal >= width) || (yVal >= height)) {				throw Object.create(PrimitiveReturn).setPayload(0);			} else {				if (depth < 0) {					throw Object.create(PrimitiveFailed).setPayload(1);				} else {					/* pixels in each word */					ppW = Math.trunc(32 / depth);					/* how many words per row of pixels */					stride = Math.trunc((width + (ppW - 1)) / ppW);					bitsSize = BYTESIZEOF(bitmap);					if (bitsSize === ((stride * height) * 4)) {						/* load the word that contains our target */						word = bitmap.words[((yVal * stride) + (Math.trunc(xVal / ppW)))];						/* make a mask to isolate the pixel within that word */						mask = SHR(4294967295, (32 - depth));						/* this is the tricky MSB part - we mask the xVal to find how far into the word we need, then add 1 for the pixel we're looking for, then * depth to get the bit shift */						shift = 32 - (((UBAND(xVal, (ppW - 1))) + 1) * depth);						/* shift, mask and dim the lights */						pixel = UBAND((SHR(word, shift)), mask);						throw Object.create(PrimitiveReturn).setPayload(pixel >= 0 ? pixel : 4294967296 + pixel);					} else {						/* bytes per word */						throw Object.create(PrimitiveFailed).setPayload(1);					}				}			}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}}, /*	Invoke the warpBits primitive. If the destination is the display, then copy it to the screen. */primitiveWarpBits() {	let ns;	let endBits;	let startBits;	let pixPerM1;	if (!BitBltPlugin.loadBitBltFromwarping(this, true)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin warpBits */	ns = noSource;	noSource = true;	BitBltPlugin.clipRange.apply(this, arguments);	noSource = ns;	if (noSource || ((bbW <= 0) || (bbH <= 0))) {		affectedL = (affectedR = (affectedT = (affectedB = 0)));	} else {		if (BitBltPlugin.lockSurfaces.apply(this, arguments)) {			/* begin destMaskAndPointerInit */			pixPerM1 = destPPW - 1;			startBits = destPPW - (UBAND(dx, pixPerM1));			mask1 = destMSB ? (SHR(4294967295, (32 - (startBits * destDepth)))) : (SHL(4294967295, (32 - (startBits * destDepth))));			endBits = (UBAND(((dx + bbW) - 1), pixPerM1)) + 1;			mask2 = destMSB ? (SHL(4294967295, (32 - (endBits * destDepth)))) : (SHR(4294967295, (32 - (endBits * destDepth))));			if (bbW < startBits) {				mask1 = UBAND(mask1, mask2);				mask2 = 0;				nWords = 1;			} else {				nWords = (Math.trunc(((bbW - startBits) + pixPerM1) / destPPW)) + 1;			}			hDir = (vDir = 1);			destIndex = ((dy * destPitch)) + ((Math.trunc(dx / destPPW)) * 4);			destDelta = (destPitch * vDir) - (4 * (nWords * hDir));			/* end destMaskAndPointerInit */			BitBltPlugin.warpLoop.apply(this, arguments);			if (hDir > 0) {				affectedL = dx;				affectedR = dx + bbW;			} else {				affectedL = (dx - bbW) + 1;				affectedR = dx + 1;			}			if (vDir > 0) {				affectedT = dy;				affectedB = dy + bbH;			} else {				affectedT = (dy - bbH) + 1;				affectedB = dy + 1;			}			BitBltPlugin.unlockSurfaces.apply(this, arguments);		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	}	/* end warpBits */	;	/* begin showDisplayBits */	SmalltalkVM.showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);	/* end showDisplayBits */	;	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller. */queryDestSurface(handle) {	return (!querySurfaceFn) ? (BitBltPlugin.loadSurfacePlugin.apply(this, arguments) ? querySurfaceFn(handle, function(w, h, d, m){destWidth = w; destHeight = h; destDepth = d; destMSB = m; }) : false) : querySurfaceFn(handle, function(w, h, d, m){destWidth = w; destHeight = h; destDepth = d; destMSB = m; });}, /*	Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller. */querySourceSurface(handle) {	return (!querySurfaceFn) ? (BitBltPlugin.loadSurfacePlugin.apply(this, arguments) ? querySurfaceFn(handle, function(w, h, d, m){sourceWidth = w; sourceHeight = h; sourceDepth = d; sourceMSB = m; }) : false) : querySurfaceFn(handle, function(w, h, d, m){sourceWidth = w; sourceHeight = h; sourceDepth = d; sourceMSB = m; });}, rgbAddwith(sourceWord, destinationWord) {	let carryOverflowMask;	let componentMask;	if (destDepth < 16) {		/* Add each pixel separately */		componentMask = (SHL(1, destDepth)) - 1;		carryOverflowMask = SHL((Math.trunc(4294967295 / componentMask)), (destDepth - 1));		return BitBltPlugin.partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, destDepth, componentMask, carryOverflowMask);	}	if (destDepth === 16) {		/* Add RGB components of each pixel separately */		componentMask = 31;		carryOverflowMask = 1108361744;		/* make sure that the unused bit is at 0 */		return BitBltPlugin.partitionedAddtonBitscomponentMaskcarryOverflowMask(UBANDS(sourceWord, 2147450879), UBANDS(destinationWord, 2147450879), 5, componentMask, carryOverflowMask);	} else {		/* Add RGBA components of the pixel separately */		componentMask = 255;		carryOverflowMask = 2155905152;		return BitBltPlugin.partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, 8, componentMask, carryOverflowMask);	}}, /*	This version assumes 		combinationRule = 41		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	 *//*	This particular method should be optimized in itself */rgbComponentAlpha16() {	let ditherBase;	let ditherThreshold;	let srcShift;	let sourceWord;	let srcIndex;	let deltaX;	let dstIndex;	let srcAlpha;	let dstMask;	let deltaY;	let srcY;	let destWord;	let dstY;	let ditherIndex;	let addThreshold;	let dstValue;	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	dstY = dy;	srcShift = (UBANDS(dx, 1)) * 16;	if (destMSB) {		srcShift = 16 - srcShift;	}	/* This is the outer loop */	mask1 = SHL(65535, (16 - srcShift));	while (((--deltaY)) !== 0) {		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + ((dx >> 1) * 4);		ditherBase = (UBANDS(dstY, 3)) * 4;		/* For pre-increment */		ditherIndex = (UBANDS(sx, 3)) - 1;		/* So we can pre-decrement */		deltaX = bbW + 1;		dstMask = mask1;		/* This is the inner loop */		srcShift = (dstMask === 65535) ? 16 : 0;		while (((--deltaX)) !== 0) {			ditherThreshold = ditherMatrix4x4[ditherBase + ((ditherIndex = UBANDS((ditherIndex + 1), 3)))];			sourceWord = sourceBits[srcIndex >>> 2];			srcAlpha = UBANDS(sourceWord, 16777215);			if (srcAlpha !== 0) {				/* 0 < srcAlpha */				/* If we have to mix colors then just copy a single word */				destWord = destBits[dstIndex >>> 2];				destWord = UBAND(destWord, (~(dstMask) >>> 0));				/* Expand from 16 to 32 bit by adding zero bits */				destWord = SHR(destWord, srcShift);				/* Mix colors */				destWord = UBOR((UBOR(((UBANDS(destWord, 31744)) << 9 >>> 0), ((UBANDS(destWord, 992)) << 6 >>> 0))), (UBORM(((UBANDS(destWord, 31)) << 3 >>> 0), 2130706432)));				/* And dither */				sourceWord = BitBltPlugin.rgbComponentAlpha32with(sourceWord, destWord);				/* begin dither32To16:threshold: */				addThreshold = ditherThreshold << 8 >>> 0;				sourceWord = ((dither8Lookup[addThreshold + (UBANDS((sourceWord >>> 16), 255))] << 10 >>> 0) + (dither8Lookup[addThreshold + (UBANDS((sourceWord >>> 8), 255))] << 5 >>> 0)) + dither8Lookup[addThreshold + (UBANDS(sourceWord, 255))];				/* end dither32To16:threshold: */				/* Store back */				sourceWord = (sourceWord === 0) ? (SHL(1, srcShift)) : (SHL(sourceWord, srcShift));				/* begin dstLongAt:put:mask: */				dstValue = destBits[dstIndex >>> 2];				dstValue = UBAND(dstValue, dstMask);				dstValue = UBOR(dstValue, sourceWord);				destBits[dstIndex >>> 2] = dstValue;				/* end dstLongAt:put:mask: */			}			srcIndex += 4;			if (destMSB) {				if (srcShift === 0) {					dstIndex += 4;				}			} else {				if (srcShift !== 0) {					dstIndex += 4;				}			}			/* Toggle between 0 and 16 */			srcShift = UBXORS(srcShift, 16);			dstMask = (~(dstMask) >>> 0);		}		++srcY;		++dstY;	}}, /*	This version assumes 		combinationRule = 41		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special case of aR = aG = aB = 0 	 */rgbComponentAlpha32() {	let sourceWord;	let srcIndex;	let deltaX;	let dstIndex;	let srcAlpha;	let deltaY;	let srcY;	let destWord;	let dstY;	/* This particular method should be optimized in itself */	/* Give the compile a couple of hints */	/* The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does) */	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	/* This is the outer loop */	dstY = dy;	while (((--deltaY)) !== 0) {		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + (dx * 4);		/* So we can pre-decrement */		/* This is the inner loop */		deltaX = bbW + 1;		while (((--deltaX)) !== 0) {			sourceWord = sourceBits[srcIndex >>> 2];			srcAlpha = UBANDS(sourceWord, 16777215);			if (srcAlpha === 0) {				srcIndex += 4;				/* Now skip as many words as possible, */				dstIndex += 4;				while ((((--deltaX)) !== 0) && ((UBANDS(((sourceWord = sourceBits[srcIndex >>> 2])), 16777215)) === 0)) {					srcIndex += 4;					dstIndex += 4;				}				++deltaX;			} else {				/* 0 < srcAlpha */				/* If we have to mix colors then just copy a single word */				destWord = destBits[dstIndex >>> 2];				destWord = BitBltPlugin.rgbComponentAlpha32with(sourceWord, destWord);				destBits[dstIndex >>> 2] = destWord;				srcIndex += 4;				dstIndex += 4;			}		}		++srcY;		++dstY;	}}, /*		componentAlphaModeColor is the color,	sourceWord contains an alpha value for each component of RGB	each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 .	the rule is...		color = componentAlphaModeColor.	colorAlpha = componentAlphaModeAlpha.	mask = sourceWord.	dst.A =  colorAlpha + (1 - colorAlpha) * dst.A      dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R * colorAlpha)) * dst.R      dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G      dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B	 *//*	Do NOT inline this into optimized loops */rgbComponentAlpha32with(sourceWord, destinationWord) {	let g;	let srcColor;	let aG;	let a;	let aA;	let aR;	let d;	let dstMask;	let srcAlpha;	let r;	let b;	let aB;	let alpha;	let answer;	let s;	alpha = sourceWord;	if (alpha === 0) {		return destinationWord;	}	srcColor = componentAlphaModeColor;	srcAlpha = UBANDS(componentAlphaModeAlpha, 255);	aB = UBANDS(alpha, 255);	alpha = alpha >>> 8;	aG = UBANDS(alpha, 255);	alpha = alpha >>> 8;	aR = UBANDS(alpha, 255);	alpha = alpha >>> 8;	aA = UBANDS(alpha, 255);	if (srcAlpha !== 255) {		aA = (aA * srcAlpha) >>> 8;		aR = (aR * srcAlpha) >>> 8;		aG = (aG * srcAlpha) >>> 8;		aB = (aB * srcAlpha) >>> 8;	}	dstMask = destinationWord;	d = UBANDS(dstMask, 255);	s = UBANDS(srcColor, 255);	if (!!ungammaLookupTable) {		d = ungammaLookupTable[d];		s = ungammaLookupTable[s];	}	b = ((d * (255 - aB)) >>> 8) + ((s * aB) >>> 8);	if (b > 255) {		b = 255;	}	if (!!gammaLookupTable) {		b = gammaLookupTable[b];	}	dstMask = dstMask >>> 8;	srcColor = srcColor >>> 8;	d = UBANDS(dstMask, 255);	s = UBANDS(srcColor, 255);	if (!!ungammaLookupTable) {		d = ungammaLookupTable[d];		s = ungammaLookupTable[s];	}	g = ((d * (255 - aG)) >>> 8) + ((s * aG) >>> 8);	if (g > 255) {		g = 255;	}	if (!!gammaLookupTable) {		g = gammaLookupTable[g];	}	dstMask = dstMask >>> 8;	srcColor = srcColor >>> 8;	d = UBANDS(dstMask, 255);	s = UBANDS(srcColor, 255);	if (!!ungammaLookupTable) {		d = ungammaLookupTable[d];		s = ungammaLookupTable[s];	}	r = ((d * (255 - aR)) >>> 8) + ((s * aR) >>> 8);	if (r > 255) {		r = 255;	}	if (!!gammaLookupTable) {		r = gammaLookupTable[r];	}	dstMask = dstMask >>> 8;	srcColor = srcColor >>> 8;	/* no need to gamma correct alpha value ? */	a = (((UBANDS(dstMask, 255)) * (255 - aA)) >>> 8) + aA;	if (a > 255) {		a = 255;	}	answer = (((((a << 8 >>> 0) + r) << 8 >>> 0) + g) << 8 >>> 0) + b;	return answer;}, /*	This version assumes 		combinationRule = 41		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	 */rgbComponentAlpha8() {	let srcShift;	let sourceWord;	let srcIndex;	let deltaX;	let mappingTable;	let dstIndex;	let adjust;	let mapperFlags;	let srcAlpha;	let dstMask;	let deltaY;	let srcY;	let destWord;	let dstY;	let pv;	let dstValue;	let val;	/* This particular method should be optimized in itself */	mappingTable = BitBltPlugin.default8To32Table.apply(this, arguments);	mapperFlags = UBAND(cmFlags, 4294967287);	/* So we can pre-decrement */	deltaY = bbH + 1;	srcY = sy;	dstY = dy;	mask1 = (UBANDS(dx, 3)) * 8;	if (destMSB) {		mask1 = 24 - mask1;	}	mask2 = UBXORM((SHL(255, mask1)), 2147483647);	adjust = ((UBANDS(dx, 1)) === 0) ? 0 : 522133279;	if ((UBANDS(dy, 1)) === 0) {		adjust = UBXORS(adjust, 522133279);	}	while (((--deltaY)) !== 0) {		adjust = UBXORS(adjust, 522133279);		srcIndex = ((srcY * sourcePitch)) + (sx * 4);		dstIndex = ((dstY * destPitch)) + ((dx >> 2) * 4);		/* So we can pre-decrement */		deltaX = bbW + 1;		srcShift = mask1;		/* This is the inner loop */		dstMask = mask2;		while (((--deltaX)) !== 0) {			sourceWord = (UBAND(sourceBits[srcIndex >>> 2], (~(adjust) >>> 0))) + adjust;			/* set srcAlpha to the average of the 3 separate aR,Ag,AB values */			srcAlpha = UBANDS(sourceWord, 16777215);			srcAlpha = Math.trunc((((srcAlpha >>> 16) + (UBANDS((srcAlpha >>> 8), 255))) + (UBANDS(srcAlpha, 255))) / 3);			if (srcAlpha > 31) {				/* Everything below 31 is transparent */				if (srcAlpha > 224) {					/* treat everything above 224 as opaque */					sourceWord = 4294967295;				}				destWord = destBits[dstIndex >>> 2];				destWord = UBAND(destWord, (~(dstMask) >>> 0));				destWord = SHR(destWord, srcShift);				destWord = mappingTable[destWord];				sourceWord = BitBltPlugin.rgbComponentAlpha32with(sourceWord, destWord);				/* begin mapPixel:flags: */				pv = sourceWord;				if ((UBANDS(mapperFlags, 1)) !== 0) {					if ((UBANDS(mapperFlags, 2)) !== 0) {						/* begin rgbMapPixel:flags: */						val = SHIFT((UBAND(sourceWord, cmMaskTable[0])), cmShiftTable[0]);						val = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[1])), cmShiftTable[1])));						val = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[2])), cmShiftTable[2])));						pv = UBOR(val, (SHIFT((UBAND(sourceWord, cmMaskTable[3])), cmShiftTable[3])));						/* end rgbMapPixel:flags: */						if ((pv === 0) && (sourceWord !== 0)) {							pv = 1;						}					}					if ((UBANDS(mapperFlags, 4)) !== 0) {						pv = cmLookupTable[UBAND(pv, cmMask)];					}				}				sourceWord = pv;				/* end mapPixel:flags: */				/* Store back */				sourceWord = SHL(sourceWord, srcShift);				/* begin dstLongAt:put:mask: */				dstValue = destBits[dstIndex >>> 2];				dstValue = UBAND(dstValue, dstMask);				dstValue = UBOR(dstValue, sourceWord);				destBits[dstIndex >>> 2] = dstValue;				/* end dstLongAt:put:mask: */			}			srcIndex += 4;			if (destMSB) {				if (srcShift === 0) {					dstIndex += 4;					srcShift = 24;					dstMask = 16777215;				} else {					srcShift -= 8;					dstMask = UBORM((dstMask >>> 8), 2130706432);				}			} else {				if (srcShift === 32) {					dstIndex += 4;					srcShift = 0;					dstMask = 4294967040;				} else {					srcShift += 8;					dstMask = UBORS((dstMask << 8 >>> 0), 255);				}			}			adjust = UBXORS(adjust, 522133279);		}		++srcY;		++dstY;	}}, /*		componentAlphaModeColor is the color,	sourceWord contains an alpha value for each component of RGB	each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 .	the rule is...		color = componentAlphaModeColor.	colorAlpha = componentAlphaModeAlpha.	mask = sourceWord.	dst.A =  colorAlpha + (1 - colorAlpha) * dst.A      dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R * colorAlpha)) * dst.R      dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G      dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B	 *//*	Do NOT inline this into optimized loops */rgbComponentAlphawith(sourceWord, destinationWord) {	let alpha;	alpha = sourceWord;	return (alpha === 0) ? destinationWord : BitBltPlugin.partitionedRgbComponentAlphadestnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);}, /*	Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels. */rgbDiffwith(sourceWord, destinationWord) {	let sourcePixVal;	let bitsPerColor;	let diff;	let sourceShifted;	let pixMask;	let rgbMask;	let destShifted;	let i;	let maskShifted;	let destPixVal;	pixMask = maskTable[destDepth];	if (destDepth === 16) {		bitsPerColor = 5;		rgbMask = 31;	} else {		bitsPerColor = 8;		rgbMask = 255;	}	maskShifted = destMask;	destShifted = destinationWord;	sourceShifted = sourceWord;	for (i = 1; i <= destPPW; i++) {		if ((UBAND(maskShifted, pixMask)) > 0) {			/* Only tally pixels within the destination rectangle */			destPixVal = UBAND(destShifted, pixMask);			sourcePixVal = UBAND(sourceShifted, pixMask);			if (destDepth < 16) {				diff = (sourcePixVal === destPixVal) ? 0 : 1;			} else {				diff = BitBltPlugin.partitionedSubfromnBitsnPartitions(sourcePixVal, destPixVal, bitsPerColor, 3);				diff = ((UBAND(diff, rgbMask)) + (UBAND((SHR(diff, bitsPerColor)), rgbMask))) + (UBAND((SHR((SHR(diff, bitsPerColor)), bitsPerColor)), rgbMask));			}			bitCount += diff;		}		maskShifted = SHR(maskShifted, destDepth);		sourceShifted = SHR(sourceShifted, destDepth);		destShifted = SHR(destShifted, destDepth);	}	return destinationWord;}, /*	Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8. */rgbMapfromto(sourcePixel, nBitsIn, nBitsOut) {	let d;	let destPix;	let srcPix;	let zzzTemp1;	let mask;	let zzzTemp;	if (((d = nBitsOut - nBitsIn)) > 0) {		/* Expand to more bits by zero-fill */		/* Transfer mask */		mask = (SHL(1, nBitsIn)) - 1;		srcPix = SHL(sourcePixel, d);		mask = SHL(mask, d);		destPix = UBAND(srcPix, mask);		mask = SHL(mask, nBitsOut);		srcPix = SHL(srcPix, d);		return (destPix + (UBAND(srcPix, mask))) + (UBAND((SHL(srcPix, d)), (SHL(mask, nBitsOut))));	} else {		/* Compress to fewer bits by truncation */		if (d === 0) {			zzzTemp = (nBitsIn === 5) ? (UBANDS(sourcePixel, 32767)) : ((nBitsIn === 8) ? (UBANDS(sourcePixel, 16777215)) : sourcePixel);		} else {			if (sourcePixel === 0) {				zzzTemp1 = sourcePixel;			} else {				d = nBitsIn - nBitsOut;				/* Transfer mask */				mask = (SHL(1, nBitsOut)) - 1;				srcPix = SHR(sourcePixel, d);				destPix = UBAND(srcPix, mask);				mask = SHL(mask, nBitsOut);				srcPix = SHR(srcPix, d);				destPix = (destPix + (UBAND(srcPix, mask))) + (UBAND((SHR(srcPix, d)), (SHL(mask, nBitsOut))));				/* Dont fall into transparent by truncation */				zzzTemp1 = (destPix === 0) ? 1 : destPix;			}			zzzTemp = zzzTemp1;		}		return zzzTemp;	}}, rgbMaxwith(sourceWord, destinationWord) {	return (destDepth < 16) ? BitBltPlugin.partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW) : ((destDepth === 16) ? (BitBltPlugin.partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) + (BitBltPlugin.partitionedMaxwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16 >>> 0)) : BitBltPlugin.partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 8, 4));}, rgbMinwith(sourceWord, destinationWord) {	return (destDepth < 16) ? BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW) : ((destDepth === 16) ? (BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) + (BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16 >>> 0)) : BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4));}, rgbMinInvertwith(wordToInvert, destinationWord) {	let sourceWord;	sourceWord = (~(wordToInvert) >>> 0);	return (destDepth < 16) ? BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW) : ((destDepth === 16) ? (BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) + (BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16 >>> 0)) : BitBltPlugin.partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4));}, rgbMulwith(sourceWord, destinationWord) {	return (destDepth < 16) ? BitBltPlugin.partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW) : ((destDepth === 16) ? (BitBltPlugin.partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) + (BitBltPlugin.partitionedMulwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16 >>> 0)) : BitBltPlugin.partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 8, 4));}, rgbSubwith(sourceWord, destinationWord) {	return (destDepth < 16) ? BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW) : ((destDepth === 16) ? (BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3) + (BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16 >>> 0)) : BitBltPlugin.partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 4));}, /*	WARNING: For WarpBlt w/ smoothing the source depth is wrong here! */setupColorMasks() {	let bits;	let targetBits;	bits = (targetBits = 0);	if (sourceDepth <= 8) {		return null;	} else {		if (sourceDepth === 16) {			bits = 5;		}		if (sourceDepth === 32) {			bits = 8;		}		if (cmBitsPerColor === 0) {			/* Convert to destDepth */			if (destDepth <= 8) {				return null;			} else {				if (destDepth === 16) {					targetBits = 5;				}				if (destDepth === 32) {					targetBits = 8;				}			}		} else {			targetBits = cmBitsPerColor;		}		BitBltPlugin.setupColorMasksFromto(bits, targetBits);	}}, /*	Setup color masks for converting an incoming RGB pixel value from srcBits to targetBits. */setupColorMasksFromto(srcBits, targetBits) {	let shifts = [0, 0, 0, 0];	let masks = [0, 0, 0, 0];	let deltaBits;	let mask;	;	deltaBits = targetBits - srcBits;	if (deltaBits === 0) {		return 0;	} else {		if (deltaBits <= 0) {			/* Mask for extracting a color part of the source */			mask = (SHL(1, targetBits)) - 1;			masks[0] = (SHL(mask, ((srcBits * 2) - deltaBits)));			masks[1] = (SHL(mask, (srcBits - deltaBits)));			masks[2] = (SHL(mask, (0 - deltaBits)));			masks[3] = 0;		} else {			/* Mask for extracting a color part of the source */			mask = (SHL(1, srcBits)) - 1;			masks[0] = (SHL(mask, (srcBits * 2)));			masks[1] = (SHL(mask, srcBits));			masks[2] = mask;		}		shifts[0] = (deltaBits * 3);		shifts[1] = (deltaBits * 2);		shifts[2] = deltaBits;		shifts[3] = 0;		cmShiftTable = shifts;		cmMaskTable = masks;		cmFlags = UBOR(cmFlags, (3));	}}, sourceWordwith(sourceWord, destinationWord) {	return sourceWord;}, subWordwith(sourceWord, destinationWord) {	return sourceWord - destinationWord;}, /*	Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup. */tallyIntoMapwith(sourceWord, destinationWord) {	let pixMask;	let mapIndex;	let destShifted;	let i;	let maskShifted;	let pixVal;	if ((UBAND(cmFlags, (5))) !== (5)) {		return destinationWord;	}	pixMask = maskTable[destDepth];	destShifted = destinationWord;	maskShifted = destMask;	for (i = 1; i <= destPPW; i++) {		if ((UBAND(maskShifted, pixMask)) !== 0) {			/* Only tally pixels within the destination rectangle */			pixVal = UBAND(destShifted, pixMask);			mapIndex = (destDepth < 16) ? pixVal : ((destDepth === 16) ? BitBltPlugin.rgbMapfromto(pixVal, 5, cmBitsPerColor) : BitBltPlugin.rgbMapfromto(pixVal, 8, cmBitsPerColor));			cmLookupTable[UBAND(mapIndex, cmMask)]++;		}		maskShifted = SHR(maskShifted, destDepth);		destShifted = SHR(destShifted, destDepth);	}	return destinationWord;}, /*	Unlock the bits of any OS surfaces. *//*	See the comment in lockSurfaces. Similar rules apply. That is, the area provided in ioUnlockSurface can be used to determine the dirty region after drawing. If a source is unlocked, then the area will be (0,0,0,0) to indicate that no portion is dirty. */unlockSurfaces() {	let destHandle;	let sourceHandle;	let fn;	let destLocked;	if (hasSurfaceLock) {		if (!unlockSurfaceFn) {			if (!BitBltPlugin.loadSurfacePlugin.apply(this, arguments)) {				return null;			}		}		fn = unlockSurfaceFn;		destLocked = false;		destHandle = destForm.pointers[0];		if ((typeof destHandle === "number")) {			/* The destBits are always assumed to be dirty */			destHandle = destHandle;			fn(destHandle, affectedL, affectedT, affectedR-affectedL, affectedB-affectedT);			destBits = (destPitch = 0);			destLocked = true;		}		if (!noSource) {			sourceHandle = sourceForm.pointers[0];			if ((typeof sourceHandle === "number")) {				/* Only unlock sourceHandle if different from destHandle */				sourceHandle = sourceHandle;				if (!(destLocked && (sourceHandle === destHandle))) {					fn(sourceHandle, 0, 0, 0, 0);				}				sourceBits = (sourcePitch = 0);			}		}		hasSurfaceLock = false;	}}, /*	This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation. */warpLoop(smoothingCount, sourceMapOop) {	let mapperFlags;	let dstShiftLeft;	let skewWord;	let words;	let nSteps;	let deltaP43y;	let destWord;	let startBits;	let mergeFnwith;	let deltaP43x;	let pBy;	let i;	let yDelta;	let halftoneWord;	let mergeWord;	let pAy;	let dstShiftInc;	let pBx;	let xDelta;	let pAx;	let deltaP12y;	let endBits;	let nPix;	let deltaP12x;	let i1;	let words1;	mergeFnwith = opTable[combinationRule + 1];	if (!(SIZEOF(bitBltOop) >= (27))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	nSteps = height - 1;	if (nSteps <= 0) {		nSteps = 1;	}	pAx = BitBltPlugin.fetchIntOrFloatofObject(15, bitBltOop);	words = BitBltPlugin.fetchIntOrFloatofObject(18, bitBltOop);	deltaP12x = (words > pAx) ? ((Math.trunc(((words - pAx) + 16384) / (nSteps + 1))) + 1) : ((words === pAx) ? 0 : (0 - ((Math.trunc(((pAx - words) + 16384) / (nSteps + 1))) + 1)));	if (deltaP12x < 0) {		pAx = words - (nSteps * deltaP12x);	}	pAy = BitBltPlugin.fetchIntOrFloatofObject(16, bitBltOop);	words = BitBltPlugin.fetchIntOrFloatofObject(19, bitBltOop);	deltaP12y = (words > pAy) ? ((Math.trunc(((words - pAy) + 16384) / (nSteps + 1))) + 1) : ((words === pAy) ? 0 : (0 - ((Math.trunc(((pAy - words) + 16384) / (nSteps + 1))) + 1)));	if (deltaP12y < 0) {		pAy = words - (nSteps * deltaP12y);	}	pBx = BitBltPlugin.fetchIntOrFloatofObject(24, bitBltOop);	words = BitBltPlugin.fetchIntOrFloatofObject(21, bitBltOop);	deltaP43x = (words > pBx) ? ((Math.trunc(((words - pBx) + 16384) / (nSteps + 1))) + 1) : ((words === pBx) ? 0 : (0 - ((Math.trunc(((pBx - words) + 16384) / (nSteps + 1))) + 1)));	if (deltaP43x < 0) {		pBx = words - (nSteps * deltaP43x);	}	pBy = BitBltPlugin.fetchIntOrFloatofObject(25, bitBltOop);	words = BitBltPlugin.fetchIntOrFloatofObject(22, bitBltOop);	deltaP43y = (words > pBy) ? ((Math.trunc(((words - pBy) + 16384) / (nSteps + 1))) + 1) : ((words === pBy) ? 0 : (0 - ((Math.trunc(((pBy - words) + 16384) / (nSteps + 1))) + 1)));	if (deltaP43y < 0) {		pBy = words - (nSteps * deltaP43y);	}	;	if (arguments.length === 2) {		((typeof smoothingCount === "number") ? smoothingCount : PrimitiveFailed.signal());		if (sourceMapOop === nil) {			if (sourceDepth < 16) {				/* color map is required to smooth non-RGB dest */				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			if (SIZEOF(sourceMapOop) < (SHL(1, sourceDepth))) {				/* sourceMap must be long enough for sourceDepth */				throw Object.create(PrimitiveFailed).setPayload(1);			}			sourceMapOop = sourceMapOop.wordsOrBytes();		}	} else {		smoothingCount = 1;		sourceMapOop = nil;	}	nSteps = width - 1;	if (nSteps <= 0) {		nSteps = 1;	}	startBits = destPPW - (UBAND(dx, (destPPW - 1)));	endBits = (UBAND(((dx + bbW) - 1), (destPPW - 1))) + 1;	if (bbW < startBits) {		startBits = bbW;	}	if (destY < clipY) {		/* Advance increments if there was clipping in y */		pAx += (clipY - destY) * deltaP12x;		pAy += (clipY - destY) * deltaP12y;		pBx += (clipY - destY) * deltaP43x;		pBy += (clipY - destY) * deltaP43y;	}	/* begin warpLoopSetup */	warpSrcShift = 0;	words1 = sourceDepth;	while (!(words1 === 1)) {		++warpSrcShift;		words1 = words1 >>> 1;	}	warpSrcMask = maskTable[sourceDepth];	warpAlignShift = 5 - warpSrcShift;	warpAlignMask = (SHL(1, warpAlignShift)) - 1;	for (i1 = 0; i1 <= warpAlignMask; i1++) {		if (sourceMSB) {			warpBitShiftTable[i1] = (32 - (SHL((i1 + 1), warpSrcShift)));		} else {			warpBitShiftTable[i1] = (SHL(i1, warpSrcShift));		}	}	/* end warpLoopSetup */	if ((smoothingCount > 1) && ((UBANDS(cmFlags, 8)) === 0)) {		if (!cmLookupTable) {			if (destDepth === 16) {				BitBltPlugin.setupColorMasksFromto(8, 5);			}		} else {			BitBltPlugin.setupColorMasksFromto(8, cmBitsPerColor);		}	}	mapperFlags = UBAND(cmFlags, 4294967287);	if (destMSB) {		dstShiftInc = 0 - destDepth;		dstShiftLeft = 32 - destDepth;	} else {		dstShiftInc = destDepth;		dstShiftLeft = 0;	}	for (i = 1; i <= bbH; i++) {		/* here is the vertical loop... */		xDelta = (pBx > pAx) ? ((Math.trunc(((pBx - pAx) + 16384) / (nSteps + 1))) + 1) : ((pBx === pAx) ? 0 : (0 - ((Math.trunc(((pAx - pBx) + 16384) / (nSteps + 1))) + 1)));		sx = (xDelta >= 0) ? pAx : (pBx - (nSteps * xDelta));		yDelta = (pBy > pAy) ? ((Math.trunc(((pBy - pAy) + 16384) / (nSteps + 1))) + 1) : ((pBy === pAy) ? 0 : (0 - ((Math.trunc(((pAy - pBy) + 16384) / (nSteps + 1))) + 1)));		sy = (yDelta >= 0) ? pAy : (pBy - (nSteps * yDelta));		dstBitShift = destMSB ? (32 - (((UBAND(dx, (destPPW - 1))) + 1) * destDepth)) : ((UBAND(dx, (destPPW - 1))) * destDepth);		if (destX < clipX) {			/* Advance increments if there was clipping in x */			sx += (clipX - destX) * xDelta;			sy += (clipX - destX) * yDelta;		}		halftoneWord = noHalftone ? 4294967295 : halftoneBase[MOD(((dy + i) - 1), halftoneHeight)];		destMask = mask1;		/* Here is the inner loop... */		nPix = startBits;		words = nWords;		do {			/* pick up word */			/* align next word access to left most pixel */			skewWord = (smoothingCount === 1) ? BitBltPlugin.warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(nPix, xDelta, yDelta, deltaP12x, deltaP12y, dstShiftInc, mapperFlags) : BitBltPlugin.warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(nPix, xDelta, yDelta, deltaP12x, deltaP12y, sourceMapOop, smoothingCount, dstShiftInc);			dstBitShift = dstShiftLeft;			if (destMask === 4294967295) {				/* avoid read-modify-write */				mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), destBits[destIndex >>> 2]);				destBits[destIndex >>> 2] = UBAND(destMask, mergeWord);			} else {				/* General version using dest masking */				destWord = destBits[destIndex >>> 2];				mergeWord = mergeFnwith(UBAND(skewWord, halftoneWord), UBAND(destWord, destMask));				destWord = UBOR((UBAND(destMask, mergeWord)), (UBAND(destWord, (~(destMask) >>> 0))));				destBits[destIndex >>> 2] = destWord;			}			destIndex += 4;			if (words === 2) {				/* e.g., is the next word the last word? */				/* set mask for last word in this row */				destMask = mask2;				nPix = endBits;			} else {				/* use fullword mask for inner loop */				destMask = 4294967295;				nPix = destPPW;			}		} while(!(((--words)) === 0));		pAx += deltaP12x;		pAy += deltaP12y;		pBx += deltaP43x;		pBy += deltaP43y;		destIndex += destDelta;	}}, /*	Pick n (sub-) pixels from the source form, mapped by sourceMap,	average the RGB values, map by colorMap and return the new word.	This version is only called from WarpBlt with smoothingCount > 1 */warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(nPixels, xDeltah, yDeltah, xDeltav, yDeltav, sourceMap, n, dstShiftInc) {	let k;	let destWord;	let xdh;	let j;	let ydh;	let i;	let xdv;	let dstMask;	let ydv;	let rgb;	let y;	let b;	let yy;	let g;	let x;	let a;	let r;	let nPix;	let xx;	let sourcePix;	let sourceWord;	let srcIndex;	let x1;	let y1;	let pv;	let val;	/* nope - too much stuff in here */	dstMask = maskTable[destDepth];	destWord = 0;	if (n === 2) {		/* Try avoiding divides for most common n (divide by 2 is generated as shift) */		xdh = xDeltah >> 1;		ydh = yDeltah >> 1;		xdv = xDeltav >> 1;		ydv = yDeltav >> 1;	} else {		xdh = Math.trunc(xDeltah / n);		ydh = Math.trunc(yDeltah / n);		xdv = Math.trunc(xDeltav / n);		ydv = Math.trunc(yDeltav / n);	}	i = nPixels;	do {		x = sx;		y = sy;		/* Pick and average n*n subpixels */		a = (r = (g = (b = 0)));		/* actual number of pixels (not clipped and not transparent) */		nPix = 0;		j = n;		do {			xx = x;			yy = y;			k = n;			do {				/* get a single subpixel */				/* begin pickWarpPixelAtX:y: */				if ((xx < 0) || ((yy < 0) || ((((x1 = xx >>> 14)) >= sourceWidth) || (((y1 = yy >>> 14)) >= sourceHeight)))) {					rgb = 0;				} else {					srcIndex = ((y1 * sourcePitch)) + ((SHR(x1, warpAlignShift)) * 4);					sourceWord = sourceBits[srcIndex >>> 2];					srcBitShift = warpBitShiftTable[UBAND(x1, warpAlignMask)];					sourcePix = UBAND((SHR(sourceWord, srcBitShift)), warpSrcMask);					rgb = sourcePix;				}				/* end pickWarpPixelAtX:y: */				if (!((combinationRule === 25) && (rgb === 0))) {					/* If not clipped and not transparent, then tally rgb values */					++nPix;					if (sourceDepth < 16) {						/* Get RGBA values from sourcemap table */						rgb = sourceMap[rgb];					} else {						/* Already in RGB format */						rgb = (sourceDepth === 16) ? (UBOR((UBOR(((UBANDS(rgb, 31)) << 3 >>> 0), ((UBANDS(rgb, 992)) << 6 >>> 0))), ((UBANDS(rgb, 31744)) << 9 >>> 0))) : rgb;					}					b += UBANDS(rgb, 255);					g += UBANDS((rgb >>> 8), 255);					r += UBANDS((rgb >>> 16), 255);					a += rgb >>> 24;				}				xx += xdh;				yy += ydh;			} while(!(((--k)) === 0));			x += xdv;			y += ydv;		} while(!(((--j)) === 0));		if ((nPix === 0) || ((combinationRule === 25) && (nPix < ((n * n) >> 1)))) {			/* All pixels were 0, or most were transparent */			rgb = 0;		} else {			/* normalize rgba sums */			if (nPix === 4) {				/* Try to avoid divides for most common n */				r = r >>> 2;				g = g >>> 2;				b = b >>> 2;				a = a >>> 2;			} else {				r = Math.trunc(r / nPix);				g = Math.trunc(g / nPix);				b = Math.trunc(b / nPix);				a = Math.trunc(a / nPix);			}			/* map the pixel */			rgb = (((a << 24 >>> 0) + (r << 16 >>> 0)) + (g << 8 >>> 0)) + b;			if (rgb === 0) {				/* only generate zero if pixel is really transparent */				if ((((r + g) + b) + a) > 0) {					rgb = 1;				}			}			/* begin mapPixel:flags: */			pv = rgb;			if ((UBANDS(cmFlags, 1)) !== 0) {				if ((UBANDS(cmFlags, 2)) !== 0) {					/* begin rgbMapPixel:flags: */					val = SHIFT((UBAND(rgb, cmMaskTable[0])), cmShiftTable[0]);					val = UBOR(val, (SHIFT((UBAND(rgb, cmMaskTable[1])), cmShiftTable[1])));					val = UBOR(val, (SHIFT((UBAND(rgb, cmMaskTable[2])), cmShiftTable[2])));					pv = UBOR(val, (SHIFT((UBAND(rgb, cmMaskTable[3])), cmShiftTable[3])));					/* end rgbMapPixel:flags: */					if ((pv === 0) && (rgb !== 0)) {						pv = 1;					}				}				if ((UBANDS(cmFlags, 4)) !== 0) {					pv = cmLookupTable[UBAND(pv, cmMask)];				}			}			rgb = pv;			/* end mapPixel:flags: */		}		destWord = UBOR(destWord, (SHL((UBAND(rgb, dstMask)), dstBitShift)));		dstBitShift += dstShiftInc;		sx += xDeltah;		sy += yDeltah;	} while(!(((--i)) === 0));	return destWord;}, /*	Pick n pixels from the source form,	map by colorMap and return aligned by dstBitShift.	This version is only called from WarpBlt with smoothingCount = 1 */warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(nPixels, xDeltah, yDeltah, xDeltav, yDeltav, dstShiftInc, mapperFlags) {	let sourcePix;	let nPix;	let destPix;	let dstMask;	let destWord;	let sourcePix1;	let sourceWord;	let srcIndex;	let x;	let y;	let sourcePix2;	let sourceWord1;	let srcIndex1;	let x1;	let y1;	let pv;	let val;	/* Yepp - this should go into warpLoop */	dstMask = maskTable[destDepth];	destWord = 0;	nPix = nPixels;	if (mapperFlags === (5)) {		/* a little optimization for (pretty crucial) blits using indexed lookups only */		/* grab, colormap and mix in pixel */		do {			/* begin pickWarpPixelAtX:y: */			if ((sx < 0) || ((sy < 0) || ((((x = sx >>> 14)) >= sourceWidth) || (((y = sy >>> 14)) >= sourceHeight)))) {				sourcePix = 0;			} else {				srcIndex = ((y * sourcePitch)) + ((SHR(x, warpAlignShift)) * 4);				sourceWord = sourceBits[srcIndex >>> 2];				srcBitShift = warpBitShiftTable[UBAND(x, warpAlignMask)];				sourcePix1 = UBAND((SHR(sourceWord, srcBitShift)), warpSrcMask);				sourcePix = sourcePix1;			}			/* end pickWarpPixelAtX:y: */			destPix = cmLookupTable[UBAND(sourcePix, cmMask)];			destWord = UBOR(destWord, (SHL((UBAND(destPix, dstMask)), dstBitShift)));			dstBitShift += dstShiftInc;			sx += xDeltah;			sy += yDeltah;		} while(!(((--nPix)) === 0));	} else {		/* grab, colormap and mix in pixel */		do {			/* begin pickWarpPixelAtX:y: */			if ((sx < 0) || ((sy < 0) || ((((x1 = sx >>> 14)) >= sourceWidth) || (((y1 = sy >>> 14)) >= sourceHeight)))) {				sourcePix = 0;			} else {				srcIndex1 = ((y1 * sourcePitch)) + ((SHR(x1, warpAlignShift)) * 4);				sourceWord1 = sourceBits[srcIndex1 >>> 2];				srcBitShift = warpBitShiftTable[UBAND(x1, warpAlignMask)];				sourcePix2 = UBAND((SHR(sourceWord1, srcBitShift)), warpSrcMask);				sourcePix = sourcePix2;			}			/* end pickWarpPixelAtX:y: */			/* begin mapPixel:flags: */			pv = sourcePix;			if ((UBANDS(mapperFlags, 1)) !== 0) {				if ((UBANDS(mapperFlags, 2)) !== 0) {					/* begin rgbMapPixel:flags: */					val = SHIFT((UBAND(sourcePix, cmMaskTable[0])), cmShiftTable[0]);					val = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[1])), cmShiftTable[1])));					val = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[2])), cmShiftTable[2])));					pv = UBOR(val, (SHIFT((UBAND(sourcePix, cmMaskTable[3])), cmShiftTable[3])));					/* end rgbMapPixel:flags: */					if ((pv === 0) && (sourcePix !== 0)) {						pv = 1;					}				}				if ((UBANDS(mapperFlags, 4)) !== 0) {					pv = cmLookupTable[UBAND(pv, cmMask)];				}			}			destPix = pv;			/* end mapPixel:flags: */			destWord = UBOR(destWord, (SHL((UBAND(destPix, dstMask)), dstBitShift)));			dstBitShift += dstShiftInc;			sx += xDeltah;			sy += yDeltah;		} while(!(((--nPix)) === 0));	}	return destWord;}, }