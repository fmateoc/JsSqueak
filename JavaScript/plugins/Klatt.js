/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:39 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	KlattSynthesizerPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let a1 = 0;let a2 = 0;let b1 = 0;let c1 = 0;let cascade = 0;let frame;let glast = 0;let interpreterProxy;let moduleName = "Klatt 7 February 2022 (e)";let nlast = 0;let nmod = 0;let nopen = 0;let nper = 0;let periodCount = 0;let pitch = 0;let resonators;let samplesCount = 0;let samplesPerFrame = 0;let samplingRate = 0;let seed = 0;let t0 = 0;let vlast = 0;let x1 = 0;let x2 = 0;globalThis.Klatt = {/*	Add F0 flutter, as specified in:		'Analysis, synthesis and perception of voice quality variations among		female and male talkers' D.H. Klatt and L.C. Klatt JASA 87(2) February 1990.	Flutter is added by applying a quasi-random element constructed from three	slowly varying sine waves. */addFlutter() {	let asin;	let bsin;	let csin;	let deltaF0;	let timeCount;	timeCount = samplesCount / samplingRate;	asin = Math.sin((79.79645340118074) * timeCount);	bsin = Math.sin((44.61061568097506) * timeCount);	csin = Math.sin((29.530970943744055) * timeCount);	deltaF0 = (((frame[1] * 2.0) * frame[0]) / 100.0) * ((asin + bsin) + csin);	pitch += deltaF0;}, /*	Set up an anti-resonator */antiResonatorfrequencybandwidth(index, freq, bw) {	let a;	let arg;	let b;	let c;	let r;	arg = ((-3.141592653589793) / samplingRate) * bw;	r = Math.exp(arg);	c = 0.0 - (r * r);	arg = ((6.283185307179586) / samplingRate) * freq;	b = (r * Math.cos(arg)) * 2.0;	a = (1.0 - b) - c;	a = 1.0 / a;	b = (0.0 - b) * a;	c = (0.0 - c) * a;	/* begin resonatorA:put: */	resonators[(index * 5) - 5] = a;	/* end resonatorA:put: */	/* begin resonatorB:put: */	resonators[(index * 5) - 4] = b;	/* end resonatorB:put: */	/* begin resonatorC:put: */	resonators[(index * 5) - 3] = c;	/* end resonatorC:put: */}, loadFrom(klattOop) {	let oop;	if (SIZEOF(klattOop) !== 22) throw Object.create(PrimitiveFailed).setPayload(1);	oop = klattOop.pointers[0];/* begin checkedFloatPtrOf: */if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);resonators = oop.wordsAsFloat32Array();/* end checkedFloatPtrOf: */pitch = klattOop.pointers[2];t0 = klattOop.pointers[3];nper = klattOop.pointers[4];nopen = klattOop.pointers[5];nmod = klattOop.pointers[6];a1 = klattOop.pointers[7];a2 = klattOop.pointers[8];x1 = klattOop.pointers[9];x2 = klattOop.pointers[10];b1 = klattOop.pointers[11];c1 = klattOop.pointers[12];glast = klattOop.pointers[13];vlast = klattOop.pointers[14];nlast = klattOop.pointers[15];periodCount = klattOop.pointers[16];samplesCount = klattOop.pointers[17];seed = klattOop.pointers[18];cascade = klattOop.pointers[19];samplesPerFrame = klattOop.pointers[20];samplingRate = klattOop.pointers[21];return false === false;}, /*	Answer a random number between 0 and 65535. */nextRandom() {	seed = UBANDS(((seed * 1309) + 13849), 65535);	return seed;}, primitiveSynthesizeFrameIntoStartingAt(oop, bufferOop, startIndex) {	let aKlattFrame;	let buffer;	let oop1;	/* begin checkedFloatPtrOf: */	if (!(oop.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	aKlattFrame = oop.wordsAsFloat32Array();	/* end checkedFloatPtrOf: */	/* begin checkedShortPtrOf: */	oop1 = bufferOop;	if (!(oop1.storageType === "words")) throw Object.create(PrimitiveFailed).setPayload(1);	buffer = oop1.wordsAsInt16Array();	/* end checkedShortPtrOf: */	((typeof startIndex === "number") ? startIndex : PrimitiveFailed.signal());	;	((typeof this === "number") ? PrimitiveFailed.signal() : this);	if (!Klatt.loadFrom(this)) {		return null;	}	if (!((SIZEOF(bufferOop) * 2) >= samplesPerFrame)) throw Object.create(PrimitiveFailed).setPayload(1);	;	Klatt.synthesizeFrameintostartingAt(aKlattFrame, buffer, startIndex);	if (!Klatt.saveTo(this)) {		return null;	}	throw Object.create(PrimitiveReturn).setPayload(this);}, quphicosphisinphirphid(u, phi, cosphi, sinphi, rphid) {	let expuphi;	expuphi = Math.exp(u * phi);	return (expuphi * ((((rphid * ((u * u) + 1.0)) + u) * sinphi) - cosphi)) + 1.0;}, /*	Convert formant frequencies and bandwidth into	resonator difference equation coefficients. */resonatorfrequencybandwidth(index, freq, bw) {	let a;	let arg;	let b;	let c;	let r;	arg = ((-3.141592653589793) / samplingRate) * bw;	r = Math.exp(arg);	c = 0.0 - (r * r);	arg = ((6.283185307179586) / samplingRate) * freq;	b = (r * Math.cos(arg)) * 2.0;	a = (1.0 - b) - c;	/* begin resonatorA:put: */	resonators[(index * 5) - 5] = a;	/* end resonatorA:put: */	/* begin resonatorB:put: */	resonators[(index * 5) - 4] = b;	/* end resonatorB:put: */	/* begin resonatorC:put: */	resonators[(index * 5) - 3] = c;	/* end resonatorC:put: */}, /*	Convert formant frequencies and bandwidth into	resonator difference equation coefficients. */resonatorfrequencybandwidthgain(index, freq, bw, gain) {	Klatt.resonatorfrequencybandwidth(index, freq, bw);	/* begin resonatorA:put: */	resonators[(index * 5) - 5] = (resonators[(index * 5) - 5] * gain);	/* end resonatorA:put: */}, resonatorvalue(index, aFloat) {	let answer;	let p1;	/* (p1 between: -100000 and: 100000) ifFalse: [self halt].	(answer between: -100000 and: 100000) ifFalse: [self halt]. */	answer = ((resonators[(index * 5) - 5] * aFloat) + (resonators[(index * 5) - 4] * ((p1 = resonators[(index * 5) - 2])))) + (resonators[(index * 5) - 3] * resonators[(index * 5) - 1]);	/* begin resonatorP2:put: */	resonators[(index * 5) - 1] = p1;	/* end resonatorP2:put: */	/* begin resonatorP1:put: */	resonators[(index * 5) - 2] = answer;	/* end resonatorP1:put: */	return answer;}, rorark(roNumber, raNumber, rkNumber) {	let cosphi;	let d;	let gamma;	let gammapwr;	let phi;	let r;	let ra;	let rho;	let rk;	let ro;	let rphid;	let sinphi;	let te;	let theta;	let u;	let ingore;	let s0;	let s1;	let s2;	te = ((t0 * roNumber) | 0);	ro = te / t0;	rk = rkNumber;	ra = raNumber;	if (ra <= 0.0) {		d = 1.0;	} else {		r = (1.0 - ro) / ra;		d = 1.0 - (r / (Math.exp(r) - 1.0));	}	phi = 3.141592653589793 * (rk + 1.0);	cosphi = Math.cos(phi);	sinphi = Math.sin(phi);	rphid = ((ra / ro) * phi) * d;	u = Klatt.zeroQphicosphisinphirphid(phi, cosphi, sinphi, rphid);	theta = phi / te;	rho = Math.exp(u * theta);	a1 = (2.0 * Math.cos(theta)) * rho;	a2 = 0.0 - (rho * rho);	x2 = 0.0;	x1 = rho * Math.sin(theta);	gamma = Math.exp(-1.0 / (ra * t0));	gammapwr = Math.pow(gamma,(t0 - te));	b1 = gamma;	c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);	/* begin normalizeGlottalPulse */	s0 = 0.0;	s1 = x1;	s2 = x2;	for (ingore = 1; ingore <= nopen; ingore++) {		s0 = (a1 * s1) + (a2 * s2);		s2 = s1;		s1 = s0;	}	if (s0 !== 0.0) {		x1 = (x1 / s0) * 10000.0;	}	/* end normalizeGlottalPulse */}, saveTo(origKlattOop) {	let a1Oop;	let a2Oop;	let b1Oop;	let c1Oop;	let glastOop;	let klattOop;	let nlastOop;	let pitchOop;	let vlastOop;	let x1Oop;	let x2Oop;	SmalltalkVM.pushRemappableOop(origKlattOop);	SmalltalkVM.pushRemappableOop(typeof pitch.valueOf() !== "number" ? PrimitiveFailed.signal() : ((pitch.valueOf() | 0 === pitch.valueOf()) || Number.isSafeInteger(pitch) ? new Float(pitch) : pitch.valueOf()));	SmalltalkVM.pushRemappableOop(typeof a1.valueOf() !== "number" ? PrimitiveFailed.signal() : ((a1.valueOf() | 0 === a1.valueOf()) || Number.isSafeInteger(a1) ? new Float(a1) : a1.valueOf()));	SmalltalkVM.pushRemappableOop(typeof a2.valueOf() !== "number" ? PrimitiveFailed.signal() : ((a2.valueOf() | 0 === a2.valueOf()) || Number.isSafeInteger(a2) ? new Float(a2) : a2.valueOf()));	SmalltalkVM.pushRemappableOop(typeof x1.valueOf() !== "number" ? PrimitiveFailed.signal() : ((x1.valueOf() | 0 === x1.valueOf()) || Number.isSafeInteger(x1) ? new Float(x1) : x1.valueOf()));	SmalltalkVM.pushRemappableOop(typeof x2.valueOf() !== "number" ? PrimitiveFailed.signal() : ((x2.valueOf() | 0 === x2.valueOf()) || Number.isSafeInteger(x2) ? new Float(x2) : x2.valueOf()));	SmalltalkVM.pushRemappableOop(typeof b1.valueOf() !== "number" ? PrimitiveFailed.signal() : ((b1.valueOf() | 0 === b1.valueOf()) || Number.isSafeInteger(b1) ? new Float(b1) : b1.valueOf()));	SmalltalkVM.pushRemappableOop(typeof c1.valueOf() !== "number" ? PrimitiveFailed.signal() : ((c1.valueOf() | 0 === c1.valueOf()) || Number.isSafeInteger(c1) ? new Float(c1) : c1.valueOf()));	SmalltalkVM.pushRemappableOop(typeof glast.valueOf() !== "number" ? PrimitiveFailed.signal() : ((glast.valueOf() | 0 === glast.valueOf()) || Number.isSafeInteger(glast) ? new Float(glast) : glast.valueOf()));	SmalltalkVM.pushRemappableOop(typeof vlast.valueOf() !== "number" ? PrimitiveFailed.signal() : ((vlast.valueOf() | 0 === vlast.valueOf()) || Number.isSafeInteger(vlast) ? new Float(vlast) : vlast.valueOf()));	nlastOop = typeof nlast.valueOf() !== "number" ? PrimitiveFailed.signal() : ((nlast.valueOf() | 0 === nlast.valueOf()) || Number.isSafeInteger(nlast) ? new Float(nlast) : nlast.valueOf());	vlastOop = SmalltalkVM.popRemappableOop();	glastOop = SmalltalkVM.popRemappableOop();	c1Oop = SmalltalkVM.popRemappableOop();	b1Oop = SmalltalkVM.popRemappableOop();	x2Oop = SmalltalkVM.popRemappableOop();	x1Oop = SmalltalkVM.popRemappableOop();	a2Oop = SmalltalkVM.popRemappableOop();	a1Oop = SmalltalkVM.popRemappableOop();	pitchOop = SmalltalkVM.popRemappableOop();	klattOop = SmalltalkVM.popRemappableOop();	klattOop.pointers[2] = pitchOop;klattOop.pointers[3] = t0;klattOop.pointers[4] = nper;klattOop.pointers[5] = nopen;klattOop.pointers[6] = nmod;klattOop.pointers[7] = a1Oop;klattOop.pointers[8] = a2Oop;klattOop.pointers[9] = x1Oop;klattOop.pointers[10] = x2Oop;klattOop.pointers[11] = b1Oop;klattOop.pointers[12] = c1Oop;klattOop.pointers[13] = glastOop;klattOop.pointers[14] = vlastOop;klattOop.pointers[15] = nlastOop;klattOop.pointers[16] = periodCount;klattOop.pointers[17] = samplesCount;klattOop.pointers[18] = seed;return false === false;}, setCurrentFrame(aKlattFrame) {	let ampF1V;	let ampF2F;	let ampF2V;	let ampF3F;	let ampF3V;	let ampF4F;	let ampF4V;	let ampF5F;	let ampF6F;	let ampFNV;	let ampFTV;	/* Fudge factors... */	frame = aKlattFrame;	/* -4.44 dB */	ampFNV = (Math.pow(2.0,((frame[45] - 87.0) / 6.0)) * 32.767) * 0.6;	/* -4.44 dB */	ampFTV = (Math.pow(2.0,((frame[50] - 87.0) / 6.0)) * 32.767) * 0.6;	/* -7.96 dB */	ampF1V = (Math.pow(2.0,((frame[46] - 87.0) / 6.0)) * 32.767) * 0.4;	/* -16.5 dB */	ampF2V = (Math.pow(2.0,((frame[47] - 87.0) / 6.0)) * 32.767) * 0.15;	/* -24.4 dB */	ampF3V = (Math.pow(2.0,((frame[48] - 87.0) / 6.0)) * 32.767) * 0.06;	/* -28.0 dB */	ampF4V = (Math.pow(2.0,((frame[49] - 87.0) / 6.0)) * 32.767) * 0.04;	/* -16.5 dB */	ampF2F = (Math.pow(2.0,((frame[34] - 87.0) / 6.0)) * 32.767) * 0.15;	/* -24.4 dB */	ampF3F = (Math.pow(2.0,((frame[35] - 87.0) / 6.0)) * 32.767) * 0.06;	/* -28.0 dB */	ampF4F = (Math.pow(2.0,((frame[36] - 87.0) / 6.0)) * 32.767) * 0.04;	/* -33.2 dB */	ampF5F = (Math.pow(2.0,((frame[37] - 87.0) / 6.0)) * 32.767) * 0.022;	/* -30.5 dB */	/* Set coefficients of variable cascade resonators */	ampF6F = (Math.pow(2.0,((frame[38] - 87.0) / 6.0)) * 32.767) * 0.03;	if (cascade >= 8) {		if (samplingRate >= 16000) {			/* Inside Nyquist rate? */			Klatt.resonatorfrequencybandwidth(19, 7500, 600);		} else {			cascade = 6;		}	}	if (cascade >= 7) {		if (samplingRate >= 16000) {			/* Inside Nyquist rate? */			Klatt.resonatorfrequencybandwidth(18, 6500, 500);		} else {			cascade = 6;		}	}	if (cascade >= 6) {		Klatt.resonatorfrequencybandwidth(17, frame[24], frame[25]);	}	if (cascade >= 5) {		Klatt.resonatorfrequencybandwidth(16, frame[22], frame[23]);	}	Klatt.resonatorfrequencybandwidth(15, frame[20], frame[21]);	Klatt.resonatorfrequencybandwidth(14, frame[18], frame[19]);	Klatt.resonatorfrequencybandwidth(13, frame[16], frame[17]);	Klatt.resonatorfrequencybandwidth(12, frame[12], frame[13]);	Klatt.resonatorfrequencybandwidth(20, frame[26], frame[27]);	Klatt.resonatorfrequencybandwidth(22, frame[30], frame[31]);	Klatt.antiResonatorfrequencybandwidth(21, frame[28], frame[29]);	Klatt.antiResonatorfrequencybandwidth(23, frame[32], frame[33]);	Klatt.resonatorfrequencybandwidthgain(1, frame[26], frame[27], ampFNV);	Klatt.resonatorfrequencybandwidthgain(2, frame[30], frame[31], ampFTV);	Klatt.resonatorfrequencybandwidthgain(3, frame[12], frame[13], ampF1V);	Klatt.resonatorfrequencybandwidthgain(4, frame[16], frame[17], ampF2V);	Klatt.resonatorfrequencybandwidthgain(5, frame[18], frame[19], ampF3V);	Klatt.resonatorfrequencybandwidthgain(6, frame[20], frame[21], ampF4V);	Klatt.resonatorfrequencybandwidthgain(7, frame[16], frame[40], ampF2F);	Klatt.resonatorfrequencybandwidthgain(8, frame[18], frame[41], ampF3F);	Klatt.resonatorfrequencybandwidthgain(9, frame[20], frame[42], ampF4F);	Klatt.resonatorfrequencybandwidthgain(10, frame[22], frame[43], ampF5F);	Klatt.resonatorfrequencybandwidthgain(11, frame[24], frame[44], ampF6F);}, synthesizeFrameintostartingAt(aKlattFrame, buffer, startIndex) {	let ampGain;	let aspiration;	let aspirationNoise;	let bypass;	let friction;	let frictionNoise;	let gain;	let glotout;	let index;	let noise;	let out;	let parGlotout;	let parVoicing;	let source;	let temp;	let top;	let turbulence;	let voice;	let voicing;	let x0;	let out1;	let answer;	let p1;	let answer1;	let p11;	let answer2;	let p12;	let answer3;	let p13;	let answer4;	let p14;	let answer5;	let p15;	let answer6;	let p16;	let answer7;	let p17;	let answer8;	let p18;	let answer9;	let p19;	let answer10;	let p110;	let answer11;	let p111;	let answer12;	let p112;	Klatt.setCurrentFrame(aKlattFrame);	if (pitch > 0) {		voicing = Math.pow(2.0,(((frame[5] - 7) - 87.0) / 6.0)) * 32.767;		parVoicing = Math.pow(2.0,((frame[5] - 87.0) / 6.0)) * 32.767;		turbulence = (Math.pow(2.0,((frame[11] - 87.0) / 6.0)) * 32.767) * 0.1;	} else {		voicing = (parVoicing = (turbulence = 0.0));	}	friction = (Math.pow(2.0,((frame[10] - 87.0) / 6.0)) * 32.767) * 0.25;	aspiration = (Math.pow(2.0,((frame[9] - 87.0) / 6.0)) * 32.767) * 0.05;	/* -26.0 dB */	/* Flod overall gain into output resonator (low-pass filter) */	bypass = (Math.pow(2.0,((frame[39] - 87.0) / 6.0)) * 32.767) * 0.05;	gain = frame[51] - 3;	if (gain <= 0) {		gain = 57;	}	ampGain = Math.pow(2.0,((gain - 87.0) / 6.0)) * 32.767;	Klatt.resonatorfrequencybandwidthgain(24, 0, samplingRate, ampGain);	noise = nlast;	index = startIndex;	top = (samplesPerFrame + startIndex) - 1;	while (index <= top) {		/* Get low-passed random number for aspiration and friction noise */		/* radom number between -8196.0 and 8196.0 */		/* Tilt down noise spectrum by soft low-pass filter having		 a pole near the origin in the z-plane. */		noise = (Klatt.nextRandom.apply(this, arguments) - 32768) / 4.0;		noise += 0.75 * nlast;		/* Amplitude modulate noise (reduce noise amplitude during second		 half of glottal period) if voicing  simultaneously present. */		nlast = noise;		if (nper > nmod) {			noise = noise * 0.5;		}		/* Compute voicing waveform. */		frictionNoise = friction * noise;		/* begin glottalSource */		if (t0 === 0) {			voice = 0;		} else {			if (nper < nopen) {				x0 = (a1 * x1) + (a2 * x2);				x2 = x1;			} else {				x0 = (b1 * x1) - c1;			}			x1 = x0;			if (nper >= t0) {				nper = 0;				/* begin pitchSynchronousReset */				if (frame[0] > 0) {					/* begin voicedPitchSynchronousReset */					pitch = frame[0];					Klatt.addFlutter.apply(this, arguments);					/* begin addJitter */					pitch += (((Klatt.nextRandom.apply(this, arguments) - 32767) * frame[2]) / 32768.0) * frame[0];					/* end addJitter */					/* begin addFrequencyDiplophonia */					pitch = ((MOD(periodCount, 2)) === 0) ? (pitch + ((frame[4] * frame[0]) * (1.0 - frame[6]))) : (pitch - ((frame[4] * frame[0]) * (1.0 - frame[6])));					/* end addFrequencyDiplophonia */					if (pitch < 0) {						pitch = 0;					}					t0 = ((samplingRate / pitch) | 0);					nmod = t0;					if (frame[5] > 0) {						nmod = nmod >> 1;					}					nopen = ((t0 * frame[6]) | 0);					Klatt.rorark(frame[6], frame[7], frame[8]);					/* begin addShimmer */					x1 += (((Klatt.nextRandom.apply(this, arguments) - 32767) * frame[3]) / 32768.0) * x1;					if (x1 > 0) {						x1 = 0;					}					/* end addShimmer */					/* begin addAmplitudeDiplophonia */					if ((MOD(periodCount, 2)) !== 0) {						x1 = x1 * (1.0 - frame[4]);						if (x1 > 0) {							x1 = 0;						}					}					/* end addAmplitudeDiplophonia */					/* end voicedPitchSynchronousReset */					periodCount = MOD((periodCount + 1), 65535);				} else {					t0 = 1;					nmod = t0;				}				/* end pitchSynchronousReset */			}			++nper;			voice = x0;		}		/* end glottalSource */		/* Add turbulence during glottal open phase.		 Use random rather than noise because noise is low-passed. */		vlast = voice;		if (nper < nopen) {			voice += (turbulence * (Klatt.nextRandom.apply(this, arguments) - 32768)) / 4.0;		}		glotout = voicing * voice;		/* Compute aspiration amplitude and add to voicing source. */		parGlotout = parVoicing * voice;		aspirationNoise = aspiration * noise;		glotout += aspirationNoise;		/* Cascade vocal tract, excited by laryngeal sources.		 Nasal antiresonator, nasal resonator, trachearl antirresonator,		 tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1. */		parGlotout += aspirationNoise;		/* begin cascadeBranch: */		if (cascade > 0) {			/* begin antiResonator:value: */			answer8 = ((resonators[100] * glotout) + (resonators[101] * ((p18 = resonators[103])))) + (resonators[102] * resonators[104]);			/* begin resonatorP2:put: */			resonators[104] = p18;			/* end resonatorP2:put: */			/* begin resonatorP1:put: */			resonators[103] = glotout;			/* end resonatorP1:put: */			out1 = answer8;			/* end antiResonator:value: */			/* begin resonator:value: */			answer9 = ((resonators[95] * out1) + (resonators[96] * ((p19 = resonators[98])))) + (resonators[97] * resonators[99]);			/* begin resonatorP2:put: */			resonators[99] = p19;			/* end resonatorP2:put: */			/* begin resonatorP1:put: */			resonators[98] = answer9;			/* end resonatorP1:put: */			out1 = answer9;			/* end resonator:value: */			/* begin antiResonator:value: */			answer10 = ((resonators[110] * out1) + (resonators[111] * ((p110 = resonators[113])))) + (resonators[112] * resonators[114]);			/* begin resonatorP2:put: */			resonators[114] = p110;			/* end resonatorP2:put: */			/* begin resonatorP1:put: */			resonators[113] = out1;			/* end resonatorP1:put: */			out1 = answer10;			/* end antiResonator:value: */			/* begin resonator:value: */			answer11 = ((resonators[105] * out1) + (resonators[106] * ((p111 = resonators[108])))) + (resonators[107] * resonators[109]);			/* begin resonatorP2:put: */			resonators[109] = p111;			/* end resonatorP2:put: */			/* begin resonatorP1:put: */			resonators[108] = answer11;			/* end resonatorP1:put: */			out1 = answer11;			/* end resonator:value: */			if (cascade >= 8) {				/* begin resonator:value: */				answer = ((resonators[90] * out1) + (resonators[91] * ((p1 = resonators[93])))) + (resonators[92] * resonators[94]);				/* begin resonatorP2:put: */				resonators[94] = p1;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[93] = answer;				/* end resonatorP1:put: */				out1 = answer;				/* end resonator:value: */			}			if (cascade >= 7) {				/* begin resonator:value: */				answer1 = ((resonators[85] * out1) + (resonators[86] * ((p11 = resonators[88])))) + (resonators[87] * resonators[89]);				/* begin resonatorP2:put: */				resonators[89] = p11;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[88] = answer1;				/* end resonatorP1:put: */				out1 = answer1;				/* end resonator:value: */			}			if (cascade >= 6) {				/* begin resonator:value: */				answer2 = ((resonators[80] * out1) + (resonators[81] * ((p12 = resonators[83])))) + (resonators[82] * resonators[84]);				/* begin resonatorP2:put: */				resonators[84] = p12;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[83] = answer2;				/* end resonatorP1:put: */				out1 = answer2;				/* end resonator:value: */			}			if (cascade >= 5) {				/* begin resonator:value: */				answer3 = ((resonators[75] * out1) + (resonators[76] * ((p13 = resonators[78])))) + (resonators[77] * resonators[79]);				/* begin resonatorP2:put: */				resonators[79] = p13;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[78] = answer3;				/* end resonatorP1:put: */				out1 = answer3;				/* end resonator:value: */			}			if (cascade >= 4) {				/* begin resonator:value: */				answer4 = ((resonators[70] * out1) + (resonators[71] * ((p14 = resonators[73])))) + (resonators[72] * resonators[74]);				/* begin resonatorP2:put: */				resonators[74] = p14;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[73] = answer4;				/* end resonatorP1:put: */				out1 = answer4;				/* end resonator:value: */			}			if (cascade >= 3) {				/* begin resonator:value: */				answer5 = ((resonators[65] * out1) + (resonators[66] * ((p15 = resonators[68])))) + (resonators[67] * resonators[69]);				/* begin resonatorP2:put: */				resonators[69] = p15;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[68] = answer5;				/* end resonatorP1:put: */				out1 = answer5;				/* end resonator:value: */			}			if (cascade >= 2) {				/* begin resonator:value: */				answer6 = ((resonators[60] * out1) + (resonators[61] * ((p16 = resonators[63])))) + (resonators[62] * resonators[64]);				/* begin resonatorP2:put: */				resonators[64] = p16;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[63] = answer6;				/* end resonatorP1:put: */				out1 = answer6;				/* end resonator:value: */			}			if (cascade >= 1) {				/* begin resonator:value: */				answer7 = ((resonators[55] * out1) + (resonators[56] * ((p17 = resonators[58])))) + (resonators[57] * resonators[59]);				/* begin resonatorP2:put: */				resonators[59] = p17;				/* end resonatorP2:put: */				/* begin resonatorP1:put: */				resonators[58] = answer7;				/* end resonatorP1:put: */				out1 = answer7;				/* end resonator:value: */			}			out = out1;		} else {			out = 0.0;		}		/* end cascadeBranch: */		/* Source is voicing plus aspiration. */		source = parGlotout;		/* Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,		 outputs added with alternating sign. Sound source for other		 parallel resonators is friction plus first difference of		 voicing waveform. */		out += ((((Klatt.resonatorvalue(3, source) + Klatt.resonatorvalue(4, source)) + Klatt.resonatorvalue(5, source)) + Klatt.resonatorvalue(6, source)) + Klatt.resonatorvalue(1, source)) + Klatt.resonatorvalue(2, source);		source = (frictionNoise + parGlotout) - glast;		glast = parGlotout;		/* Apply bypas and output low-pass filter */		out = ((((Klatt.resonatorvalue(7, source) - Klatt.resonatorvalue(8, source)) + Klatt.resonatorvalue(9, source)) - Klatt.resonatorvalue(10, source)) + Klatt.resonatorvalue(11, source)) - out;		out = (bypass * source) - out;		/* begin resonator:value: */		answer12 = ((resonators[115] * out) + (resonators[116] * ((p112 = resonators[118])))) + (resonators[117] * resonators[119]);		/* begin resonatorP2:put: */		resonators[119] = p112;		/* end resonatorP2:put: */		/* begin resonatorP1:put: */		resonators[118] = answer12;		/* end resonatorP1:put: */		out = answer12;		/* end resonator:value: */		temp = ((out * ampGain) | 0);		if (temp < -32768) {			temp = -32768;		}		if (temp > 32767) {			temp = 32767;		}		buffer[index - 1] = temp;		++index;		++samplesCount;	}}, zeroQphicosphisinphirphid(phi, cosphi, sinphi, rphid) {	let qa;	let qb;	let qc;	let qzero;	let ua;	let ub;	let uc;	qzero = Klatt.quphicosphisinphirphid(0, phi, cosphi, sinphi, rphid);	if (qzero > 0) {		ua = 0;		ub = 1;		qa = qzero;		qb = Klatt.quphicosphisinphirphid(ub, phi, cosphi, sinphi, rphid);		while (qb > 0) {			ua = ub;			qa = qb;			ub = ub * 2;			qb = Klatt.quphicosphisinphirphid(ub, phi, cosphi, sinphi, rphid);		}	} else {		ua = -1;		ub = 0;		qa = Klatt.quphicosphisinphirphid(ua, phi, cosphi, sinphi, rphid);		qb = qzero;		while (qa < 0) {			ub = ua;			qb = qa;			ua = ua * 2;			qa = Klatt.quphicosphisinphirphid(ua, phi, cosphi, sinphi, rphid);		}	}	while ((ub - ua) > 0.0001) {		uc = (ub + ua) / 2.0;		qc = Klatt.quphicosphisinphirphid(uc, phi, cosphi, sinphi, rphid);		if (qc > 0) {			ua = uc;			qa = qc;		} else {			ub = uc;			qb = qc;		}	}	return (ub + ua) / 2.0;}, }