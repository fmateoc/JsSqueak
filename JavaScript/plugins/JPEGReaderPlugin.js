/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:33 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	JPEGReaderPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let acTable;let acTableSize = 0;let cbBlocks = new Array(128);let cbComponent = new Array(11);let cbSampleStream = 0;let crBlocks = new Array(128);let crComponent = new Array(11);let crSampleStream = 0;let dcTable;let dcTableSize = 0;let ditherMask = 0;let interpreterProxy;let jpegBits;let jpegBitsSize = 0;let jpegNaturalOrder = [	0, 1, 8, 16, 9, 2, 3, 10, 	17, 24, 32, 25, 18, 11, 4, 5, 	12, 19, 26, 33, 40, 48, 41, 34, 	27, 20, 13, 6, 7, 14, 21, 28, 	35, 42, 49, 56, 57, 50, 43, 36, 	29, 22, 15, 23, 30, 37, 44, 51, 	58, 59, 52, 45, 38, 31, 39, 46, 	53, 60, 61, 54, 47, 55, 62, 63];let jsBitBuffer = 0;let jsBitCount = 0;let jsCollection;let jsPosition = 0;let jsReadLimit = 0;let moduleName = "JPEGReaderPlugin 7 February 2022 (e)";let residuals;let yBlocks = new Array(128);let yComponent = new Array(11);let ySampleStream = 0;globalThis.JPEGReaderPlugin = {cbColorComponentFrom(oop) {	return JPEGReaderPlugin.colorComponentfrom(cbComponent, oop) && (JPEGReaderPlugin.colorComponentBlocksfrom(cbBlocks, oop));}, colorComponentfrom(aColorComponent, oop) {	if ((typeof oop === "number")) {		return false;	} else {		if ((oop.storageType === "pointers")) {			if (SIZEOF(oop) < 11) {				return false;			} else {				aColorComponent[0] = oop.pointers[0];				aColorComponent[1] = oop.pointers[1];				aColorComponent[2] = oop.pointers[2];				aColorComponent[3] = oop.pointers[3];				aColorComponent[5] = oop.pointers[5];				aColorComponent[8] = oop.pointers[8];				aColorComponent[10] = oop.pointers[10];				return true;			}		} else {			return false;		}	}}, colorComponentBlocksfrom(blocks, oop) {	let arrayOop;	let blockOop;	let i;	let max;	if ((typeof oop === "number")) {		return false;	} else {		if ((oop.storageType === "pointers")) {			if (SIZEOF(oop) < 11) {				return false;			} else {				arrayOop = oop.pointers[4];				if ((typeof arrayOop === "number")) {					return false;				} else {					if ((arrayOop.storageType === "pointers")) {						max = SIZEOF(arrayOop);						if (max > 128) {							return false;						} else {							for (i = 0; i <= (max - 1); i++) {								blockOop = arrayOop.pointers[i];								if ((typeof blockOop === "number")) {									return false;								} else {									if ((blockOop.storageType === "words")) {										if (SIZEOF(blockOop) === 64) {											blocks[i] = blockOop.wordsAsInt32Array();										} else {											return false;										}									} else {										return false;									}								}							}							return true;						}					} else {						return false;					}				}			}		} else {			return false;		}	}}, crColorComponentFrom(oop) {	return JPEGReaderPlugin.colorComponentfrom(crComponent, oop) && (JPEGReaderPlugin.colorComponentBlocksfrom(crBlocks, oop));}, decodeBlockIntocomponent(anArray, aColorComponent) {	let bits;	let byte;	let i;	let index;	let zeroCount;	byte = JPEGReaderPlugin.jpegDecodeValueFromsize(dcTable, dcTableSize);	if (byte < 0) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		if (byte !== 0) {			bits = JPEGReaderPlugin.getBits(byte);			byte = (bits < (SHL(1, (byte - 1)))) ? ((bits - (SHL(1, byte))) + 1) : bits;		}		byte = aColorComponent[10] = (aColorComponent[10] + byte);		anArray[0] = byte;		for (i = 1; i <= (63); i++) {			anArray[i] = 0;		}		index = 1;		while (index < 64) {			byte = JPEGReaderPlugin.jpegDecodeValueFromsize(acTable, acTableSize);			if (byte < 0) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				zeroCount = byte >>> 4;				byte = UBANDS(byte, 15);				if (byte !== 0) {					index += zeroCount;					bits = JPEGReaderPlugin.getBits(byte);					byte = (bits < (SHL(1, (byte - 1)))) ? ((bits - (SHL(1, byte))) + 1) : bits;					if ((index < 0) || (index >= 64)) {						throw Object.create(PrimitiveFailed).setPayload(1);					} else {						anArray[jpegNaturalOrder[index]] = byte;					}				} else {					if (zeroCount === 15) {						index += zeroCount;					} else {						return null;					}				}				++index;			}		}	}}, fillBuffer() {	let byte;	while (jsBitCount <= 16) {		if (jsPosition < jsReadLimit) {			byte = jsCollection[jsPosition];			++jsPosition;			if (byte === 255) {				/* peek for 00 */				if ((jsPosition < jsReadLimit) && (jsCollection[jsPosition] === 0)) {					++jsPosition;				} else {					--jsPosition;					return jsBitCount;				}			}			jsBitBuffer = UBOR((jsBitBuffer << 8 >>> 0), byte);			jsBitCount += 8;		} else {			return jsBitCount;		}	}	return jsBitCount;}, getBits(requestedBits) {	let value;	if (requestedBits > jsBitCount) {		JPEGReaderPlugin.fillBuffer.apply(this, arguments);		if (requestedBits > jsBitCount) {			return -1;		}	}	jsBitCount -= requestedBits;	value = SHR(jsBitBuffer, jsBitCount);	jsBitBuffer = UBAND(jsBitBuffer, ((SHL(1, jsBitCount)) - 1));	return value;}, idctBlockIntqt(anArray, qt) {	let anACTerm;	let dcval;	let i;	let j;	let row;	let t0;	let t1;	let t10;	let t11;	let t12;	let t13;	let t2;	let t3;	let v;	let ws = new Array(64);	let z1;	let z2;	let z3;	let z4;	let z5;	;	for (i = 0; i <= (7); i++) {		anACTerm = -1;		for (row = 1; row <= (7); row++) {			if (anACTerm === -1) {				if (anArray[(row * 8) + i] !== 0) {					anACTerm = row;				}			}		}		if (anACTerm === -1) {			dcval = (anArray[i] * qt[0]) << 2 >>> 0;			for (j = 0; j <= (7); j++) {				ws[(j * 8) + i] = dcval;			}		} else {			z2 = anArray[(16) + i] * qt[(16) + i];			z3 = anArray[(48) + i] * qt[(48) + i];			z1 = (z2 + z3) * 4433;			t2 = z1 + (z3 * (-15137));			t3 = z1 + (z2 * 6270);			z2 = anArray[i] * qt[i];			z3 = anArray[(32) + i] * qt[(32) + i];			t0 = (z2 + z3) << 13 >>> 0;			t1 = (z2 - z3) << 13 >>> 0;			t10 = t0 + t3;			t13 = t0 - t3;			t11 = t1 + t2;			t12 = t1 - t2;			t0 = anArray[(56) + i] * qt[(56) + i];			t1 = anArray[(40) + i] * qt[(40) + i];			t2 = anArray[(24) + i] * qt[(24) + i];			t3 = anArray[8 + i] * qt[8 + i];			z1 = t0 + t3;			z2 = t1 + t2;			z3 = t0 + t2;			z4 = t1 + t3;			z5 = (z3 + z4) * 9633;			t0 = t0 * 2446;			t1 = t1 * 16819;			t2 = t2 * 25172;			t3 = t3 * 12299;			z1 = z1 * (-7373);			z2 = z2 * (-20995);			z3 = z3 * (-16069);			z4 = z4 * (-3196);			z3 += z5;			z4 += z5;			t0 = (t0 + z1) + z3;			t1 = (t1 + z2) + z4;			t2 = (t2 + z2) + z3;			t3 = (t3 + z1) + z4;			ws[i] = ((t10 + t3) >> 11);			ws[(56) + i] = ((t10 - t3) >> 11);			ws[(8) + i] = ((t11 + t2) >> 11);			ws[(48) + i] = ((t11 - t2) >> 11);			ws[(16) + i] = ((t12 + t1) >> 11);			ws[(40) + i] = ((t12 - t1) >> 11);			ws[(24) + i] = ((t13 + t0) >> 11);			ws[(32) + i] = ((t13 - t0) >> 11);		}	}	for (i = 0; i <= (56); i += 8) {		z2 = ws[i + 2];		z3 = ws[i + 6];		z1 = (z2 + z3) * 4433;		t2 = z1 + (z3 * (-15137));		t3 = z1 + (z2 * 6270);		t0 = (ws[i] + ws[i + 4]) << 13 >>> 0;		t1 = (ws[i] - ws[i + 4]) << 13 >>> 0;		t10 = t0 + t3;		t13 = t0 - t3;		t11 = t1 + t2;		t12 = t1 - t2;		t0 = ws[i + 7];		t1 = ws[i + 5];		t2 = ws[i + 3];		t3 = ws[i + 1];		z1 = t0 + t3;		z2 = t1 + t2;		z3 = t0 + t2;		z4 = t1 + t3;		z5 = (z3 + z4) * 9633;		t0 = t0 * 2446;		t1 = t1 * 16819;		t2 = t2 * 25172;		t3 = t3 * 12299;		z1 = z1 * (-7373);		z2 = z2 * (-20995);		z3 = z3 * (-16069);		z4 = z4 * (-3196);		z3 += z5;		z4 += z5;		t0 = (t0 + z1) + z3;		t1 = (t1 + z2) + z4;		t2 = (t2 + z2) + z3;		t3 = (t3 + z1) + z4;		v = ((t10 + t3) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i] = v;		v = ((t10 - t3) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 7] = v;		v = ((t11 + t2) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 1] = v;		v = ((t11 - t2) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 6] = v;		v = ((t12 + t1) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 2] = v;		v = ((t12 - t1) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 5] = v;		v = ((t13 + t0) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 3] = v;		v = ((t13 - t0) >> 18) + 127;		v = Math.min(v, 255);		v = Math.max(v, 0);		anArray[i + 4] = v;	}}, /*	Decode the next value in the receiver using the given huffman table. */jpegDecodeValueFromsize(table, tableSize) {	let bits;	let bitsNeeded;	let index;	let tableIndex;	let value;	/* Initial bits needed */	bitsNeeded = table[0] >>> 24;	if (!(bitsNeeded > 16)) {		/* First real table */		tableIndex = 2;		while (true) {			/* Get bits */			bits = JPEGReaderPlugin.getBits(bitsNeeded);			if (bits < 0) {				return -1;			} else {				index = (tableIndex + bits) - 1;				if (index >= tableSize) {					return -1;				} else {					/* Lookup entry in table */					value = table[index];					if ((UBANDS(value, 1056964608)) === 0) {						return value;					} else {						/* Table offset in low 16 bit */						tableIndex = UBANDS(value, 65535);						/* Additional bits in high 8 bit */						bitsNeeded = UBANDS((value >>> 24), 255);						if (bitsNeeded > 16) {							return -1;						}					}				}			}		}	}	return -1;}, loadJPEGStreamFrom(streamOop) {	let oop;	let sz;	if (SIZEOF(streamOop) < 5) {		return false;	} else {		if ((streamOop.storageType === "pointers")) {			oop = streamOop.pointers[0];			if ((typeof oop === "number")) {				return false;			} else {				if ((oop.storageType === "bytes")) {					jsCollection = BYTESOF(oop);					sz = BYTESIZEOF(oop);					jsPosition = streamOop.pointers[1];					jsReadLimit = streamOop.pointers[2];					jsBitBuffer = streamOop.pointers[3];					jsBitCount = streamOop.pointers[4];					return ((sz < jsReadLimit) ? false : (((jsPosition < 0) || (jsPosition >= jsReadLimit)) ? false : true));				} else {					return false;				}			}		} else {			return false;		}	}}, /*	Requires:		JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	 */primitiveColorConvertGrayscaleMCU(arrayOop1, arrayOop2, arrayOop3, arg1) {	let i;	let y;	let blockIndex;	let curX;	let dx;	let dy;	let sample;	let sampleIndex;	let sx;	let sy;	JPEGReaderPlugin.stInit.apply(this, arguments);	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	ditherMask = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());	((typeof arrayOop3 === "number") ? PrimitiveFailed.signal() : arrayOop3);	;	if (!((arrayOop3.storageType === "words") && (SIZEOF(arrayOop3) === 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	residuals = arrayOop3.wordsAsInt32Array();	((typeof arrayOop2 === "number") ? PrimitiveFailed.signal() : arrayOop2);	;	if (!(arrayOop2.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	jpegBitsSize = SIZEOF(arrayOop2);	jpegBits = arrayOop2.wordsAsInt32Array();	((typeof arrayOop1 === "number") ? PrimitiveFailed.signal() : arrayOop1);	;	if (!(JPEGReaderPlugin.colorComponentfrom(yComponent, arrayOop1) && (JPEGReaderPlugin.colorComponentBlocksfrom(yBlocks, arrayOop1)))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin colorConvertGrayscaleMCU */	yComponent[0] = 0;	yComponent[1] = 0;	for (i = 0; i <= (jpegBitsSize - 1); i++) {		/* begin nextSampleY */		dx = (curX = yComponent[0]);		dy = yComponent[1];		sx = yComponent[2];		sy = yComponent[3];		if ((sx !== 0) && (sy !== 0)) {			dx = Math.trunc(dx / sx);			dy = Math.trunc(dy / sy);		}		blockIndex = ((dy >>> 3) * yComponent[5]) + (dx >>> 3);		sampleIndex = ((UBANDS(dy, 7)) << 3 >>> 0) + (UBANDS(dx, 7));		sample = yBlocks[blockIndex][sampleIndex];		++curX;		if (curX < (yComponent[8] * 8)) {			yComponent[0] = curX;		} else {			yComponent[0] = 0;			yComponent[1]++;		}		y = sample;		/* end nextSampleY */		y += residuals[1];		y = Math.min(y, 255);		residuals[1] = (UBAND(y, ditherMask));		y = UBAND(y, (255 - ditherMask));		y = Math.max(y, 1);		jpegBits[i] = (((4278190080 + (y << 16 >>> 0)) + (y << 8 >>> 0)) + y);	}	/* end colorConvertGrayscaleMCU */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	Requires:		Array with: 3*JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	 */primitiveColorConvertMCU(arrayOop1, arrayOop2, arrayOop3, arg1) {	let blue;	let cb;	let cr;	let green;	let i;	let red;	let y;	let blockIndex;	let curX;	let dx;	let dy;	let sample;	let sampleIndex;	let sx;	let sy;	let blockIndex1;	let curX1;	let dx1;	let dy1;	let sample1;	let sampleIndex1;	let sx1;	let sy1;	let blockIndex2;	let curX2;	let dx2;	let dy2;	let sample2;	let sampleIndex2;	let sx2;	let sy2;	JPEGReaderPlugin.stInit.apply(this, arguments);	if (arguments.length !== 4) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	ditherMask = ((typeof arg1 === "number") ? arg1 : PrimitiveFailed.signal());	((typeof arrayOop3 === "number") ? PrimitiveFailed.signal() : arrayOop3);	;	if (!((arrayOop3.storageType === "words") && (SIZEOF(arrayOop3) === 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	residuals = arrayOop3.wordsAsInt32Array();	((typeof arrayOop2 === "number") ? PrimitiveFailed.signal() : arrayOop2);	;	if (!(arrayOop2.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	jpegBitsSize = SIZEOF(arrayOop2);	jpegBits = arrayOop2.wordsAsInt32Array();	((typeof arrayOop1 === "number") ? PrimitiveFailed.signal() : arrayOop1);	;	if (!((arrayOop1.storageType === "pointers") && (SIZEOF(arrayOop1) === 3))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!JPEGReaderPlugin.yColorComponentFrom(arrayOop1.pointers[0])) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!JPEGReaderPlugin.cbColorComponentFrom(arrayOop1.pointers[1])) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!JPEGReaderPlugin.crColorComponentFrom(arrayOop1.pointers[2])) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* begin colorConvertMCU */	yComponent[0] = 0;	yComponent[1] = 0;	cbComponent[0] = 0;	cbComponent[1] = 0;	crComponent[0] = 0;	crComponent[1] = 0;	for (i = 0; i <= (jpegBitsSize - 1); i++) {		/* begin nextSampleY */		dx = (curX = yComponent[0]);		dy = yComponent[1];		sx = yComponent[2];		sy = yComponent[3];		if ((sx !== 0) && (sy !== 0)) {			dx = Math.trunc(dx / sx);			dy = Math.trunc(dy / sy);		}		blockIndex = ((dy >>> 3) * yComponent[5]) + (dx >>> 3);		sampleIndex = ((UBANDS(dy, 7)) << 3 >>> 0) + (UBANDS(dx, 7));		sample = yBlocks[blockIndex][sampleIndex];		++curX;		if (curX < (yComponent[8] * 8)) {			yComponent[0] = curX;		} else {			yComponent[0] = 0;			yComponent[1]++;		}		y = sample;		/* end nextSampleY */		/* begin nextSampleCb */		dx1 = (curX1 = cbComponent[0]);		dy1 = cbComponent[1];		sx1 = cbComponent[2];		sy1 = cbComponent[3];		if ((sx1 !== 0) && (sy1 !== 0)) {			dx1 = Math.trunc(dx1 / sx1);			dy1 = Math.trunc(dy1 / sy1);		}		blockIndex1 = ((dy1 >>> 3) * cbComponent[5]) + (dx1 >>> 3);		sampleIndex1 = ((UBANDS(dy1, 7)) << 3 >>> 0) + (UBANDS(dx1, 7));		sample1 = cbBlocks[blockIndex1][sampleIndex1];		++curX1;		if (curX1 < (cbComponent[8] * 8)) {			cbComponent[0] = curX1;		} else {			cbComponent[0] = 0;			cbComponent[1]++;		}		cb = sample1;		/* end nextSampleCb */		cb -= 127;		/* begin nextSampleCr */		dx2 = (curX2 = crComponent[0]);		dy2 = crComponent[1];		sx2 = crComponent[2];		sy2 = crComponent[3];		if ((sx2 !== 0) && (sy2 !== 0)) {			dx2 = Math.trunc(dx2 / sx2);			dy2 = Math.trunc(dy2 / sy2);		}		blockIndex2 = ((dy2 >>> 3) * crComponent[5]) + (dx2 >>> 3);		sampleIndex2 = ((UBANDS(dy2, 7)) << 3 >>> 0) + (UBANDS(dx2, 7));		sample2 = crBlocks[blockIndex2][sampleIndex2];		++curX2;		if (curX2 < (crComponent[8] * 8)) {			crComponent[0] = curX2;		} else {			crComponent[0] = 0;			crComponent[1]++;		}		cr = sample2;		/* end nextSampleCr */		cr -= 127;		red = (y + ((91881 * cr) >> 16)) + residuals[0];		red = Math.min(red, 255);		red = Math.max(red, 0);		residuals[0] = (UBAND(red, ditherMask));		red = UBAND(red, (255 - ditherMask));		red = Math.max(red, 1);		green = ((y - ((22554 * cb) >> 16)) - ((46802 * cr) >> 16)) + residuals[1];		green = Math.min(green, 255);		green = Math.max(green, 0);		residuals[1] = (UBAND(green, ditherMask));		green = UBAND(green, (255 - ditherMask));		green = Math.max(green, 1);		blue = (y + ((116130 * cb) >> 16)) + residuals[2];		blue = Math.min(blue, 255);		blue = Math.max(blue, 0);		residuals[2] = (UBAND(blue, ditherMask));		blue = UBAND(blue, (255 - ditherMask));		blue = Math.max(blue, 1);		jpegBits[i] = (((4278190080 + (red << 16 >>> 0)) + (green << 8 >>> 0)) + blue);	}	/* end colorConvertMCU */	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	In:		anArray 		WordArray of: DCTSize2		aColorComponent JPEGColorComponent		dcTable			WordArray		acTable			WordArray		stream			JPEGStream	 */primitiveDecodeMCU(arrayOop1, oop1, arrayOop2, arrayOop3, oop2) {	let anArray;	let streamOop;	;	if (arguments.length !== 5) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof oop2 === "number") ? PrimitiveFailed.signal() : oop2);	;	if (!JPEGReaderPlugin.loadJPEGStreamFrom(oop2)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof arrayOop3 === "number") ? PrimitiveFailed.signal() : arrayOop3);	;	if (!(arrayOop3.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	acTableSize = SIZEOF(arrayOop3);	acTable = arrayOop3.wordsAsInt32Array();	((typeof arrayOop2 === "number") ? PrimitiveFailed.signal() : arrayOop2);	;	if (!(arrayOop2.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	dcTableSize = SIZEOF(arrayOop2);	dcTable = arrayOop2.wordsAsInt32Array();	((typeof oop1 === "number") ? PrimitiveFailed.signal() : oop1);	;	if (!JPEGReaderPlugin.colorComponentfrom(yComponent, oop1)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof arrayOop1 === "number") ? PrimitiveFailed.signal() : arrayOop1);	;	if (!(arrayOop1.storageType === "words")) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (SIZEOF(arrayOop1) !== 64) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	anArray = arrayOop1.wordsAsInt32Array();	;	JPEGReaderPlugin.decodeBlockIntocomponent(anArray, yComponent);	;	/* begin storeJPEGStreamOn: */	streamOop.pointers[1] = jsPosition;	streamOop.pointers[3] = jsBitBuffer;	streamOop.pointers[4] = jsBitCount;	/* end storeJPEGStreamOn: */	oop1.pointers[10] = yComponent[10];	throw Object.create(PrimitiveReturn).setPayload(this);}, /*	In:		anArray: IntegerArray new: DCTSize2		qt: IntegerArray new: DCTSize2.	 */primitiveIdctInt(arrayOop1, arrayOop2) {	let anArray;	let qt;	;	if (arguments.length !== 2) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	((typeof arrayOop2 === "number") ? PrimitiveFailed.signal() : arrayOop2);	;	if (!((arrayOop2.storageType === "words") && (SIZEOF(arrayOop2) === 64))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	qt = arrayOop2.wordsAsInt32Array();	((typeof arrayOop1 === "number") ? PrimitiveFailed.signal() : arrayOop1);	;	if (!((arrayOop1.storageType === "words") && (SIZEOF(arrayOop1) === 64))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	anArray = arrayOop1.wordsAsInt32Array();	JPEGReaderPlugin.idctBlockIntqt(anArray, qt);	throw Object.create(PrimitiveReturn).setPayload(this);}, stInit() {	;}, yColorComponentFrom(oop) {	return JPEGReaderPlugin.colorComponentfrom(yComponent, oop) && (JPEGReaderPlugin.colorComponentBlocksfrom(yBlocks, oop));}, }