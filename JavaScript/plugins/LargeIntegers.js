/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:39 pm *//* Automatically generated by	JSSmartSyntaxPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	LargeIntegersPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let andOpIndex = 0;let interpreterProxy;let moduleName = "LargeIntegers v1.5 (e)";let orOpIndex = 1;let simulator = 0;let xorOpIndex = 2;globalThis.LargeIntegers = {/*	Argument has to be aBytesOop! *//*	Tests for any magnitude bits in the interval from start to stopArg. */anyBitOfLargeIntfromto(aBytesOop, start, stopArg) {	let lastByteIx;	let digit;	let magnitude;	let leftShift;	let rightShift;	let firstByteIx;	let stop;	let mask;	let ix;	;	if ((start < 1) || (stopArg < 1)) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		magnitude = aBytesOop;		stop = Math.min(stopArg, LargeIntegers.cDigitHighBitlen(BYTESOF(magnitude), SIZEOF(magnitude)));		if (start > stop) {			return false;		} else {			firstByteIx = ((start - 1) >> 3) + 1;			lastByteIx = ((stop - 1) >> 3) + 1;			rightShift = MOD((start - 1), 8);			leftShift = 7 - (MOD((stop - 1), 8));			if (firstByteIx === lastByteIx) {				mask = UBAND((SHL(255, rightShift)), (SHR(255, leftShift)));				digit = (firstByteIx > SIZEOF(magnitude)) ? 0 : BYTESOF(magnitude)[firstByteIx - 1];				return (UBAND(digit, mask)) !== 0;			} else {				if ((SHR(((firstByteIx > SIZEOF(magnitude)) ? 0 : BYTESOF(magnitude)[firstByteIx - 1]), rightShift)) !== 0) {					return true;				} else {					for (ix = (firstByteIx + 1); ix <= (lastByteIx - 1); ix++) {						if (((ix > SIZEOF(magnitude)) ? 0 : BYTESOF(magnitude)[ix - 1]) !== 0) {							return true;						}					}					return ((UBANDS((SHL(((lastByteIx > SIZEOF(magnitude)) ? 0 : BYTESOF(magnitude)[lastByteIx - 1]), leftShift)), 255)) !== 0) ? true : false;				}			}		}	}}, /*	Precondition: bytesOop is not anInteger and a bytes object. *//*	Function #byteSizeOf: is used by the interpreter, be careful with name	clashes... */byteSizeOfBytes(bytesOop) {	return SIZEOF(bytesOop);}, /*	Attention: this method invalidates all oop's! Only newBytes is valid at return. *//*	Does not normalize. */bytesgrowTo(aBytesObject, newLen) {	let oldLen;	let newBytes;	let copyLen;	newBytes = (function(__size) {const result = aBytesObject._class().primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(newLen);	oldLen = BYTESIZEOF(aBytesObject);	copyLen = (oldLen < newLen) ? oldLen : newLen;	LargeIntegers.cDigitCopyFromtolen(BYTESOF(aBytesObject), BYTESOF(newBytes), copyLen);	return newBytes;}, cCopyIntValtoBytes(val, bytes) {	let pByte;	let ix;	let ixLimiT;	pByte = BYTESOF(bytes);	for (ix = 1, ixLimiT = LargeIntegers.cDigitLengthOfCSI(val); ix <= ixLimiT; ix++) {		pByte[ix - 1] = (UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255));	}}, /*	pByteRes len = longLen; returns over.. */cDigitAddlenwithleninto(pByteShort, shortLen, pByteLong, longLen, pByteRes) {	let i;	let limit;	let accum;	accum = 0;	limit = shortLen - 1;	for (i = 0; i <= limit; i++) {		accum = ((accum >>> 8) + pByteShort[i]) + pByteLong[i];		pByteRes[i] = (UBANDS(accum, 255));	}	limit = longLen - 1;	for (i = shortLen; i <= limit; i++) {		accum = (accum >>> 8) + pByteLong[i];		pByteRes[i] = (UBANDS(accum, 255));	}	return accum >>> 8;}, /*	Precondition: pFirst len = pSecond len. */cDigitComparewithlen(pFirst, pSecond, len) {	let firstDigit;	let secondDigit;	let ix;	ix = len - 1;	while (ix >= 0) {		if (((secondDigit = pSecond[ix])) !== ((firstDigit = pFirst[ix]))) {			return (secondDigit < firstDigit) ? 1 : -1;		} else {			--ix;		}	}	return 0;}, cDigitCopyFromtolen(pFrom, pTo, len) {	let limit;	let i;	;	limit = len - 1;	for (i = 0; i <= limit; i++) {		pTo[i] = pFrom[i];	}	return 0;}, cDigitDivlenremlenquolen(pDiv, divLen, pRem, remLen, pQuo, quoLen) {	let b;	let q;	let a;	let dnh;	let lo;	let hi;	let r3;	let mul;	let cond;	let l;	let k;	let j;	let i;	let dl;	let ql;	let r1r2;	let dh;	let t;	/* Last actual byte of data (ST ix) */	dl = divLen - 1;	ql = quoLen;	dh = pDiv[dl - 1];	dnh = (dl === 1) ? 0 : pDiv[dl - 2];	for (k = 1; k <= ql; k++) {		/* maintain quo*arg+rem=self */		/* Estimate rem/div by dividing the leading two digits of rem by dh. */		/* The estimate is q = qhi*16r100+qlo, where qhi and qlo are unsigned char. */		/* r1 := rem digitAt: j. */		j = (remLen + 1) - k;		if (pRem[j - 1] === dh) {			q = 255;		} else {			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh. */			/* r2 := (rem digitAt: j - 2). */			r1r2 = pRem[j - 1];			r1r2 = (r1r2 << 8 >>> 0) + pRem[j - 2];			t = MOD(r1r2, dh);			/* Next compute (hi,lo) := q*dnh */			q = Math.trunc(r1r2 / dh);			mul = q * dnh;			hi = mul >>> 8;			/* Correct overestimate of q.                				Max of 2 iterations through loop -- see Knuth vol. 2 */			lo = UBANDS(mul, 255);			r3 = (j < 3) ? 0 : pRem[j - 3];					while (true) {				if ((t < hi) || ((t === hi) && (r3 < lo))) {					/* i.e. (t,r3) < (hi,lo) */					--q;					if (hi === 0) {						/* since hi is unsigned we must have this guard */						cond = false;					} else {						if (lo < dnh) {							--hi;							lo = (lo + 256) - dnh;						} else {							lo -= dnh;						}						cond = hi >= dh;					}				} else {					cond = false;				}				if (!(cond)) break;				hi -= dh;			}		}		l = j - dl;		a = 0;		for (i = 1; i <= divLen; i++) {			hi = pDiv[i - 1] * (q >>> 8);			lo = pDiv[i - 1] * (UBANDS(q, 255));			b = (pRem[l - 1] - a) - (UBANDS(lo, 255));			pRem[l - 1] = (UBANDS(b, 255));			/* This is a possible replacement to simulate arithmetic shift (preserving sign of b) */			/* b := b >> 8 bitOr: (0 - (b >> ((interpreterProxy sizeof: b)*8 */			/* CHAR_BIT */			/* -1)) << 8). */			b = b >> 8;			a = (hi + (lo >>> 8)) - b;			++l;		}		if (a > 0) {			/* Add div back into rem, decrease q by 1 */			--q;			l = j - dl;			a = 0;			for (i = 1; i <= divLen; i++) {				a = ((a >>> 8) + pRem[l - 1]) + pDiv[i - 1];				pRem[l - 1] = (UBANDS(a, 255));				++l;			}		}		pQuo[quoLen - k] = q;	}	return 0;}, /*	Answer the index (in bits) of the high order bit of the receiver, or zero if the    	 receiver is zero. This method is allowed (and needed) for     	LargeNegativeIntegers as well, since Squeak's LargeIntegers are     	sign/magnitude. */cDigitHighBitlen(pByte, len) {	let lastDigit;	let realLength;	realLength = len;	while (((lastDigit = pByte[realLength - 1])) === 0) {		if (((--realLength)) === 0) {			return 0;		}	}	return LargeIntegers.cHighBit(lastDigit) + (8 * (realLength - 1));}, /*	Answer the number of bytes required to represent the value of a CSmallInteger. */cDigitLengthOfCSI(csi) {	return (csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((BYTES_PER_WORD === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((BYTES_PER_WORD === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))));}, /*	C indexed! */cDigitLshiftfromlentolen(shiftCount, pFrom, lenFrom, pTo, lenTo) {	let digitShift;	let carry;	let digit;	let i;	let bitShift;	let rshift;	let limit;	digitShift = shiftCount >> 3;	bitShift = MOD(shiftCount, 8);	limit = digitShift - 1;	for (i = 0; i <= limit; i++) {		pTo[i] = 0;	}	if (bitShift === 0) {		/* Fast version for digit-aligned shifts */		/* C indexed! */		return LargeIntegers.cDigitReplacefromtowithstartingAt(pTo, digitShift, lenTo - 1, pFrom, 0);	} else {		rshift = 8 - bitShift;		carry = 0;		limit = lenFrom - 1;		for (i = 0; i <= limit; i++) {			digit = pFrom[i];			pTo[i + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));			carry = SHR(digit, rshift);		}		if (carry !== 0) {			pTo[lenTo - 1] = carry;		}		return 0;	}}, cDigitMontgomerylentimeslenmodulolenmInvModBinto(pBytesFirst, firstLen, pBytesSecond, secondLen, pBytesThird, thirdLen, mInv, pBytesRes) {	let k;	let i;	let lastByte;	let limit3;	let limit2;	let limit1;	let u;	let accum;	limit1 = firstLen - 1;	limit2 = secondLen - 1;	limit3 = thirdLen - 1;	lastByte = 0;	for (i = 0; i <= limit1; i++) {		accum = pBytesRes[0] + (pBytesFirst[i] * pBytesSecond[0]);		u = UBANDS((accum * mInv), 255);		accum += u * pBytesThird[0];		for (k = 1; k <= limit2; k++) {			accum = (((accum >>> 8) + pBytesRes[k]) + (pBytesFirst[i] * pBytesSecond[k])) + (u * pBytesThird[k]);			pBytesRes[k - 1] = (UBANDS(accum, 255));		}		for (k = secondLen; k <= limit3; k++) {			accum = ((accum >>> 8) + pBytesRes[k]) + (u * pBytesThird[k]);			pBytesRes[k - 1] = (UBANDS(accum, 255));		}		accum = (accum >>> 8) + lastByte;		pBytesRes[limit3] = (UBANDS(accum, 255));		lastByte = accum >>> 8;	}	for (i = firstLen; i <= limit3; i++) {		accum = pBytesRes[0];		u = UBANDS((accum * mInv), 255);		accum += u * pBytesThird[0];		for (k = 1; k <= limit3; k++) {			accum = ((accum >>> 8) + pBytesRes[k]) + (u * pBytesThird[k]);			pBytesRes[k - 1] = (UBANDS(accum, 255));		}		accum = (accum >>> 8) + lastByte;		pBytesRes[limit3] = (UBANDS(accum, 255));		lastByte = accum >>> 8;	}	if (!((lastByte === 0) && (LargeIntegers.cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen) === 1))) {		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */		accum = 0;		for (i = 0; i <= limit3; i++) {			accum = (accum + pBytesRes[i]) - pBytesThird[i];			pBytesRes[i] = accum;			accum = accum >> 8;		}	}}, cDigitMultiplylenwithleninto(pByteShort, shortLen, pByteLong, longLen, pByteRes) {	let ab;	let j;	let digit;	let carry;	let i;	let limitLong;	let k;	let limitShort;	if (!((shortLen === 1) && (pByteShort[0] === 0))) {		if (!((longLen === 1) && (pByteLong[0] === 0))) {			limitShort = shortLen - 1;			limitLong = longLen - 1;			for (i = 0; i <= limitShort; i++) {				if (((digit = pByteShort[i])) !== 0) {					k = i;					/* Loop invariant: 0<=carry<=0377, k=i+j-1 (ST) */					/* -> Loop invariant: 0<=carry<=0377, k=i+j (C) (?) */					carry = 0;					for (j = 0; j <= limitLong; j++) {						ab = pByteLong[j];						ab = ((ab * digit) + carry) + pByteRes[k];						carry = ab >>> 8;						pByteRes[k] = (UBANDS(ab, 255));						++k;					}					pByteRes[k] = carry;				}			}		}	}	return 0;}, /*	pByteRes len = longLen. */cDigitOpshortlenlongleninto(opIndex, pByteShort, shortLen, pByteLong, longLen, pByteRes) {	let i;	let limit;	limit = shortLen - 1;	if (opIndex === andOpIndex) {		for (i = 0; i <= limit; i++) {			pByteRes[i] = (UBAND(pByteShort[i], pByteLong[i]));		}		limit = longLen - 1;		for (i = shortLen; i <= limit; i++) {			pByteRes[i] = 0;		}		return 0;	} else {		if (opIndex === orOpIndex) {			for (i = 0; i <= limit; i++) {				pByteRes[i] = (UBOR(pByteShort[i], pByteLong[i]));			}			limit = longLen - 1;			for (i = shortLen; i <= limit; i++) {				pByteRes[i] = pByteLong[i];			}			return 0;		} else {			if (opIndex === xorOpIndex) {				for (i = 0; i <= limit; i++) {					pByteRes[i] = (UBXOR(pByteShort[i], pByteLong[i]));				}				limit = longLen - 1;				for (i = shortLen; i <= limit; i++) {					pByteRes[i] = pByteLong[i];				}				return 0;			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}}, /*	C indexed! */cDigitReplacefromtowithstartingAt(pTo, start, stop, pFrom, repStart) {	return function() {		// inlining self cDigitCopyFrom: pFrom + repStart to: pTo + start len: stop - start + 1		var len = stop - start + 1;		for (var i = 0; i < len; i++) {			pTo[i + start] = pFrom[i + repStart];		}		return 0;	}();}, cDigitRshiftfromlentolen(shiftCount, pFrom, fromLen, pTo, toLen) {	let j;	let digitShift;	let carry;	let digit;	let bitShift;	let leftShift;	let limit;	let start;	digitShift = shiftCount >> 3;	bitShift = MOD(shiftCount, 8);	if (bitShift === 0) {		/* Fast version for byte-aligned shifts */		/* C indexed! */		return LargeIntegers.cDigitReplacefromtowithstartingAt(pTo, 0, toLen - 1, pFrom, digitShift);	} else {		leftShift = 8 - bitShift;		carry = SHR(pFrom[digitShift], bitShift);		start = digitShift + 1;		limit = fromLen - 1;		for (j = start; j <= limit; j++) {			digit = pFrom[j];			pTo[j - start] = (UBANDS((UBOR(carry, (SHL(digit, leftShift)))), 255));			carry = SHR(digit, bitShift);		}		if (carry !== 0) {			pTo[toLen - 1] = carry;		}		return 0;	}}, cDigitSublenwithleninto(pByteSmall, smallLen, pByteLarge, largeLen, pByteRes) {	let z;	let i;	/* Loop invariant is -1<=z<=1 */	z = 0;	for (i = 0; i <= (smallLen - 1); i++) {		z = (z + pByteLarge[i]) - pByteSmall[i];		pByteRes[i] = z;		z = z >> 8;	}	for (i = smallLen; i <= (largeLen - 1); i++) {		z += pByteLarge[i];		pByteRes[i] = z;		z = z >> 8;	}}, /*	Answer the index of the high order bit of the argument, or zero if the  	argument is zero. *//*	For 64 bit uints there could be added a 32-shift. */cHighBit(uint) {	let shifted;	let bitNo;	shifted = uint;	bitNo = 0;	if (!(shifted < (65536))) {		shifted = shifted >>> 16;		bitNo += 16;	}	if (!(shifted < (256))) {		shifted = shifted >>> 8;		bitNo += 8;	}	if (!(shifted < (16))) {		shifted = shifted >>> 4;		bitNo += 4;	}	if (!(shifted < (4))) {		shifted = shifted >>> 2;		bitNo += 2;	}	if (!(shifted < (2))) {		shifted = shifted >>> 1;		++bitNo;	}	return bitNo + shifted;}, /*	anOop has to be a SmallInteger! */createLargeFromSmallInteger(anOop) {	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	val = anOop;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = LargeIntegers.cDigitLengthOfCSI(val);	res = (function(__size) {const result = sq_class.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	return res;}, /*	Attention: this method invalidates all oop's! Only newBytes is valid at return. *//*	Does not normalize. */digitLshift(aBytesOop, shiftCount) {	let highBit;	let newBytes;	let oldLen;	let newLen;	oldLen = SIZEOF(aBytesOop);	if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(aBytesOop), oldLen))) === 0) {		return 0;	} else {		newLen = ((highBit + shiftCount) + 7) >> 3;			newBytes = (function(__size) {const result = aBytesOop._class().primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(newLen);		LargeIntegers.cDigitLshiftfromlentolen(shiftCount, BYTESOF(aBytesOop), oldLen, BYTESOF(newBytes), newLen);		return newBytes;	}}, /*	Attention: this method invalidates all oop's! Only newBytes is valid at return. *//*	Shift right shiftCount bits, 0<=shiftCount.         	Discard all digits beyond a, and all zeroes at or below a. *//*	Does not normalize. */digitRshiftlookfirst(aBytesOop, shiftCount, a) {	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	oldBitLen = LargeIntegers.cDigitHighBitlen(BYTESOF(aBytesOop), a);	oldDigitLen = (oldBitLen + 7) >> 3;	newBitLen = oldBitLen - shiftCount;	if (newBitLen <= 0) {		/* All bits lost */		return (function(__size) {const result = aBytesOop._class().primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(0);	} else {		newByteLen = (newBitLen + 7) >> 3;			newOop = (function(__size) {const result = aBytesOop._class().primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(newByteLen);		LargeIntegers.cDigitRshiftfromlentolen(shiftCount, BYTESOF(aBytesOop), oldDigitLen, BYTESOF(newOop), newByteLen);		return newOop;	}}, /*	Does not need to normalize! */digitAddLargewith(firstInteger, secondInteger) {	let sum;	let shortLen;	let over;	let shortInt;	let resClass;	let newSum;	let longLen;	let firstLen;	let secondLen;	let longInt;	firstLen = SIZEOF(firstInteger);	secondLen = SIZEOF(secondInteger);	resClass = firstInteger._class();	if (firstLen <= secondLen) {		shortInt = firstInteger;		shortLen = firstLen;		longInt = secondInteger;		longLen = secondLen;	} else {		shortInt = secondInteger;		shortLen = secondLen;		longInt = firstInteger;		longLen = firstLen;	}	sum = (function(__size) {const result = resClass.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(longLen);	over = LargeIntegers.cDigitAddlenwithleninto(BYTESOF(shortInt), shortLen, BYTESOF(longInt), longLen, BYTESOF(sum));	if (over > 0) {		/* sum := sum growby: 1. */			newSum = (function(__size) {const result = resClass.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})((longLen + 1));		LargeIntegers.cDigitCopyFromtolen(BYTESOF(sum), BYTESOF(newSum), longLen);		/* C index! */		sum = newSum;		BYTESOF(sum)[longLen] = over;	}	return sum;}, /*	Bit logic here is only implemented for positive integers or Zero;	if rec or arg is negative, it fails. */digitBitLogicwithopIndex(firstInteger, secondInteger, opIx) {	let shortLen;	let shortLarge;	let firstLarge;	let secondLarge;	let longLen;	let longLarge;	let firstLen;	let secondLen;	let result;	if ((typeof firstInteger === "number")) {		if (firstInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);		}	} else {		if (firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			firstLarge = firstInteger;		}	}	if ((typeof secondInteger === "number")) {		if (secondInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);		}	} else {		if (secondInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			secondLarge = secondInteger;		}	}	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen < secondLen) {		shortLen = firstLen;		shortLarge = firstLarge;		longLen = secondLen;		longLarge = secondLarge;	} else {		shortLen = secondLen;		shortLarge = secondLarge;		longLen = firstLen;		longLarge = firstLarge;	}	result = (function(__size) {const result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(longLen);	LargeIntegers.cDigitOpshortlenlongleninto(opIx, BYTESOF(shortLarge), shortLen, BYTESOF(longLarge), longLen, BYTESOF(result));	return LargeIntegers.normalizePositive(result);}, /*	Compare the magnitude of firstInteger with that of secondInteger.      	Return a code of 1, 0, -1 for firstInteger >, = , < secondInteger */digitCompareLargewith(firstInteger, secondInteger) {	let secondLen;	let firstLen;	firstLen = SIZEOF(firstInteger);	secondLen = SIZEOF(secondInteger);	return (secondLen !== firstLen) ? ((secondLen > firstLen) ? -1 : 1) : LargeIntegers.cDigitComparewithlen(BYTESOF(firstInteger), BYTESOF(secondInteger), firstLen);}, /*	Does not normalize. *//*	Division by zero has to be checked in caller. */digitDivLargewithnegative(firstInteger, secondInteger, neg) {	let resultClass;	let result;	let rem;	let div;	let quo;	let d;	let l;	let secondLen;	let firstLen;	firstLen = SIZEOF(firstInteger);	secondLen = SIZEOF(secondInteger);	resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	l = (firstLen - secondLen) + 1;	if (l <= 0) {			result = (function(__size) {const result = SmalltalkGlobals._Array.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(2);		result[1] = 0;		result[2] = firstInteger;	} else {		d = 8 - LargeIntegers.cHighBit(BYTESOF(secondInteger)[secondLen - 1]);			div = LargeIntegers.digitLshift(secondInteger, d);	div = LargeIntegers.largeIntOrIntgrowTo(div, ((typeof div === "number") ? LargeIntegers.cDigitLengthOfCSI(div) : SIZEOF(div)) + 1);			rem = LargeIntegers.digitLshift(firstInteger, d);	(((typeof rem === "number") ? LargeIntegers.cDigitLengthOfCSI(rem) : SIZEOF(rem)) === firstLen) ? ((rem = LargeIntegers.largeIntOrIntgrowTo(rem, firstLen + 1))) : null;			quo = (function(__size) {const result = resultClass.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(l);		LargeIntegers.cDigitDivlenremlenquolen(BYTESOF(div), (typeof div === "number") ? LargeIntegers.cDigitLengthOfCSI(div) : SIZEOF(div), BYTESOF(rem), (typeof rem === "number") ? LargeIntegers.cDigitLengthOfCSI(rem) : SIZEOF(rem), BYTESOF(quo), (typeof quo === "number") ? LargeIntegers.cDigitLengthOfCSI(quo) : SIZEOF(quo));			rem = LargeIntegers.digitRshiftlookfirst(rem, d, ((typeof div === "number") ? LargeIntegers.cDigitLengthOfCSI(div) : SIZEOF(div)) - 1);			result = (function(__size) {const result = SmalltalkGlobals._Array.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(2);		result[1] = quo;		result[2] = rem;	}	return result;}, digitMontgomerytimesmodulomInvModB(firstLarge, secondLarge, thirdLarge, mInv) {	let prod;	let thirdLen;	let firstLen;	let secondLen;	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	thirdLen = SIZEOF(thirdLarge);	if (!(firstLen <= thirdLen)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!(secondLen <= thirdLen)) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!((mInv >= 0) && (mInv <= 255))) {		throw Object.create(PrimitiveFailed).setPayload(1);	}	prod = (function(__size) {const result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(thirdLen);	LargeIntegers.cDigitMontgomerylentimeslenmodulolenmInvModBinto(BYTESOF(firstLarge), firstLen, BYTESOF(secondLarge), secondLen, BYTESOF(thirdLarge), thirdLen, mInv, BYTESOF(prod));	return LargeIntegers.normalizePositive(prod);}, /*	Normalizes. */digitMultiplyLargewithnegative(firstInteger, secondInteger, neg) {	let longInt;	let resultClass;	let shortLen;	let shortInt;	let longLen;	let prod;	let secondLen;	let firstLen;	firstLen = SIZEOF(firstInteger);	secondLen = SIZEOF(secondInteger);	if (firstLen <= secondLen) {		shortInt = firstInteger;		shortLen = firstLen;		longInt = secondInteger;		longLen = secondLen;	} else {		shortInt = secondInteger;		shortLen = secondLen;		longInt = firstInteger;		longLen = firstLen;	}	resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	prod = (function(__size) {const result = resultClass.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})((longLen + shortLen));	LargeIntegers.cDigitMultiplylenwithleninto(BYTESOF(shortInt), shortLen, BYTESOF(longInt), longLen, BYTESOF(prod));	/* begin normalize: */	;	return (prod._class() === SmalltalkGlobals._LargePositiveInteger) ? LargeIntegers.normalizePositive(prod) : LargeIntegers.normalizeNegative(prod);	/* end normalize: */}, /*	Normalizes. */digitSubLargewith(firstInteger, secondInteger) {	let smallerLen;	let larger;	let res;	let smaller;	let resLen;	let largerLen;	let firstNeg;	let firstLen;	let secondLen;	let neg;	firstNeg = firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger;	firstLen = SIZEOF(firstInteger);	secondLen = SIZEOF(secondInteger);	if (firstLen === secondLen) {		while ((firstLen > 1) && (((firstLen > SIZEOF(firstInteger)) ? 0 : BYTESOF(firstInteger)[firstLen - 1]) === ((firstLen > SIZEOF(secondInteger)) ? 0 : BYTESOF(secondInteger)[firstLen - 1]))) {			--firstLen;		}		secondLen = firstLen;	}	if ((firstLen < secondLen) || ((firstLen === secondLen) && (((firstLen > SIZEOF(firstInteger)) ? 0 : BYTESOF(firstInteger)[firstLen - 1]) < ((firstLen > SIZEOF(secondInteger)) ? 0 : BYTESOF(secondInteger)[firstLen - 1])))) {		larger = secondInteger;		largerLen = secondLen;		smaller = firstInteger;		smallerLen = firstLen;		neg = firstNeg === false;	} else {		larger = firstInteger;		largerLen = firstLen;		smaller = secondInteger;		smallerLen = secondLen;		neg = firstNeg;	}	resLen = largerLen;	res = (function(__size) {const result = (neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger).primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(resLen);	LargeIntegers.cDigitSublenwithleninto(BYTESOF(smaller), smallerLen, BYTESOF(larger), largerLen, BYTESOF(res));	return neg ? LargeIntegers.normalizeNegative(res) : LargeIntegers.normalizePositive(res);}, isNormalized(anInteger) {	let len;	let sLen;	let minVal;	let ix;	let maxVal;	if ((typeof anInteger === "number")) {		return true;	} else {		len = (typeof anInteger === "number") ? LargeIntegers.cDigitLengthOfCSI(anInteger) : SIZEOF(anInteger);		if (len === 0) {			return false;		} else {			if (BYTESOF(anInteger)[len - 1] === 0) {				return false;			} else {				/* maximal digitLength of aSmallInteger */				sLen = 4;				if (len > sLen) {					return true;				} else {					if (len < sLen) {						return false;					} else {						if (anInteger._class() === SmalltalkGlobals._LargePositiveInteger) {							/* SmallInteger maxVal */							/* all bytes of maxVal but the highest one are just FF's */							maxVal = 1073741823;							return BYTESOF(anInteger)[sLen - 1] > (UBANDS((SHR(((maxVal < 0) ? (0 - maxVal) : maxVal), ((sLen - 1) * 8))), 255));						} else {							/* SmallInteger minVal */							/* all bytes of minVal but the highest one are just 00's */							minVal = -1073741824;							if (!(BYTESOF(anInteger)[sLen - 1] < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255)))) {								/* if just one digit differs, then anInteger < minval (the corresponding digit byte is greater!)						and therefore a LargeNegativeInteger */								for (ix = 1; ix <= sLen; ix++) {									if (BYTESOF(anInteger)[ix - 1] !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((ix - 1) * 8))), 255))) {										return true;									}								}							}							return false;						}					}				}			}		}	}}, /*	Attention: this method invalidates all oop's! Only newBytes is valid at return. */largeIntOrIntgrowTo(oop, len) {	let sq_class;	let val;	let newBytes;	let oldLen;	let newBytes1;	let copyLen;	if ((typeof oop === "number")) {		val = oop;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		newBytes = (function(__size) {const result = sq_class.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(len);		LargeIntegers.cCopyIntValtoBytes(val, newBytes);	} else {		/* begin largeInt:growTo: */			newBytes1 = (function(__size) {const result = oop._class().primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(len);		oldLen = SIZEOF(oop);		copyLen = (oldLen < len) ? oldLen : len;		LargeIntegers.cDigitCopyFromtolen(BYTESOF(oop), BYTESOF(newBytes1), copyLen);		newBytes = newBytes1;		/* end largeInt:growTo: */	}	return newBytes;}, /*	Check for leading zeroes and return shortened copy if so. */normalize(aLargeInteger) {	;	return (aLargeInteger._class() === SmalltalkGlobals._LargePositiveInteger) ? LargeIntegers.normalizePositive(aLargeInteger) : LargeIntegers.normalizeNegative(aLargeInteger);}, /*	Check for leading zeroes and return shortened copy if so. *//*	First establish len = significant length. */normalizeNegative(aLargeNegativeInteger) {	let len;	let i;	let sLen;	let minVal;	let oldLen;	let val;	len = (oldLen = (typeof aLargeNegativeInteger === "number") ? LargeIntegers.cDigitLengthOfCSI(aLargeNegativeInteger) : SIZEOF(aLargeNegativeInteger));	while ((len !== 0) && (BYTESOF(aLargeNegativeInteger)[len - 1] === 0)) {		--len;	}	if (len === 0) {		return 0;	} else {		/* SmallInteger minVal digitLength */		sLen = 4;		if (len <= sLen) {			/* SmallInteger minVal */			minVal = -1073741824;			if ((len < sLen) || (((sLen > BYTESIZEOF(aLargeNegativeInteger)) ? 0 : BYTESOF(aLargeNegativeInteger)[sLen - 1]) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255)))) {				/* If high digit less, then can be small */				val = 0;				for (i = len; i >= 1; i += -1) {					val = (val * 256) - BYTESOF(aLargeNegativeInteger)[i - 1];				}				return val;			} else {				for (i = 1; i <= sLen; i++) {					/* If all digits same, then = minVal (sr: minVal digits 1 to 3 are 				          0) */					if (((i > BYTESIZEOF(aLargeNegativeInteger)) ? 0 : BYTESOF(aLargeNegativeInteger)[i - 1]) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i - 1) * 8))), 255))) {						/* Not so; return self shortened */						return (len < oldLen) ? LargeIntegers.bytesgrowTo(aLargeNegativeInteger, len) : aLargeNegativeInteger;					}				}				return minVal;			}		} else {			return (len < oldLen) ? LargeIntegers.bytesgrowTo(aLargeNegativeInteger, len) : aLargeNegativeInteger;		}	}}, /*	Check for leading zeroes and return shortened copy if so. *//*	First establish len = significant length. */normalizePositive(aLargePositiveInteger) {	let i;	let len;	let sLen;	let oldLen;	let val;	len = (oldLen = (typeof aLargePositiveInteger === "number") ? LargeIntegers.cDigitLengthOfCSI(aLargePositiveInteger) : SIZEOF(aLargePositiveInteger));	while ((len !== 0) && (BYTESOF(aLargePositiveInteger)[len - 1] === 0)) {		--len;	}	if (len === 0) {		return 0;	} else {		/* SmallInteger maxVal digitLength. */		sLen = 4;		if ((len <= sLen) && (((sLen > BYTESIZEOF(aLargePositiveInteger)) ? 0 : BYTESOF(aLargePositiveInteger)[sLen - 1]) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {			/* If so, return its SmallInt value */			val = 0;			for (i = len; i >= 1; i += -1) {				val = (val * 256) + BYTESOF(aLargePositiveInteger)[i - 1];			}			return val;		} else {			return (len < oldLen) ? LargeIntegers.bytesgrowTo(aLargePositiveInteger, len) : aLargePositiveInteger;		}	}}, primAnyBitFromTo(from, to) {	let integer;	let large;	if (!(typeof from === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof to === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	integer = this;	large = (typeof integer === "number") ? LargeIntegers.createLargeFromSmallInteger(integer) : integer;	throw Object.create(PrimitiveReturn).setPayload((LargeIntegers.anyBitOfLargeIntfromto(large, from, to)? interpreterProxy.trueObject() : interpreterProxy.falseObject()));}, /*	Converts a SmallInteger into a - non normalized! - LargeInteger;          	 aLargeInteger will be returned unchanged. *//*	Do not check for forced fail, because we need this conversion to test the 	plugin in ST during forced fail, too. */primAsLargeInteger(anInteger) {	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger;	;	throw Object.create(PrimitiveReturn).setPayload(((typeof anInteger === "number") ? LargeIntegers.createLargeFromSmallInteger(anInteger) : anInteger));}, /*	If calling this primitive fails, then C module does not exist. Do not check for forced fail, because we want to know if module exists during forced fail, too. */primCheckIfCModuleExists() {	throw Object.create(PrimitiveReturn).setPayload((true? interpreterProxy.trueObject() : interpreterProxy.falseObject()));}, _primDigitBitShift(anInteger, shiftCount) {	let aLarge;	let rShift;	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	aLarge = (typeof anInteger === "number") ? LargeIntegers.createLargeFromSmallInteger(anInteger) : anInteger;	if (shiftCount >= 0) {		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitLshift(aLarge, shiftCount));	} else {		rShift = 0 - shiftCount;		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.normalize(LargeIntegers.digitRshiftlookfirst(aLarge, rShift, SIZEOF(aLarge))));	}}, primDigitAdd(secondInteger) {	let firstLarge;	let firstInteger;	let secondLarge;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitAddLargewith(firstLarge, secondLarge));}, primDigitAddWith(firstInteger, secondInteger) {	let firstLarge;	let secondLarge;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitAddLargewith(firstLarge, secondLarge));}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitAnd(secondInteger) {	let firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitBitLogicwithopIndex(firstInteger, secondInteger, andOpIndex));}, /*	Bit logic here is only implemented for positive integers or Zero; if any arg is negative, it fails. */primDigitBitLogicWithOp(firstInteger, secondInteger, opIndex) {	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	if (!(typeof opIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitBitLogicwithopIndex(firstInteger, secondInteger, opIndex));}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitOr(secondInteger) {	let firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitBitLogicwithopIndex(firstInteger, secondInteger, orOpIndex));}, primDigitBitShift(shiftCount) {	let anInteger;	let rShift;	let aLarge;	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger = this;	aLarge = (typeof anInteger === "number") ? LargeIntegers.createLargeFromSmallInteger(anInteger) : anInteger;	if (shiftCount >= 0) {		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitLshift(aLarge, shiftCount));	} else {		rShift = 0 - shiftCount;		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.normalize(LargeIntegers.digitRshiftlookfirst(aLarge, rShift, SIZEOF(aLarge))));	}}, primDigitBitShiftMagnitude(shiftCount) {	let anInteger;	let rShift;	let aLarge;	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger = this;	aLarge = (typeof anInteger === "number") ? LargeIntegers.createLargeFromSmallInteger(anInteger) : anInteger;	if (shiftCount >= 0) {		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitLshift(aLarge, shiftCount));	} else {		rShift = 0 - shiftCount;		throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.normalize(LargeIntegers.digitRshiftlookfirst(aLarge, rShift, SIZEOF(aLarge))));	}}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitXor(secondInteger) {	let firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitBitLogicwithopIndex(firstInteger, secondInteger, xorOpIndex));}, primDigitCompare(secondInteger) {	let firstVal;	let firstInteger;	let secondVal;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	throw Object.create(PrimitiveReturn).setPayload(((typeof firstInteger === "number") ? ((typeof secondInteger === "number") ? ((((firstVal = firstInteger)) > ((secondVal = secondInteger))) ? 1 : ((firstVal < secondVal) ? -1 : 0)) : -1) : ((typeof secondInteger === "number") ? 1 : LargeIntegers.digitCompareLargewith(firstInteger, secondInteger))));}, primDigitCompareWith(firstInteger, secondInteger) {	let firstVal;	let secondVal;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	throw Object.create(PrimitiveReturn).setPayload(((typeof firstInteger === "number") ? ((typeof secondInteger === "number") ? ((((firstVal = firstInteger)) > ((secondVal = secondInteger))) ? 1 : ((firstVal < secondVal) ? -1 : 0)) : -1) : ((typeof secondInteger === "number") ? 1 : LargeIntegers.digitCompareLargewith(firstInteger, secondInteger))));}, /*	Answer the result of dividing firstInteger by secondInteger. 	Fail if parameters are not integers, not normalized or secondInteger is 	zero.  */primDigitDivNegative(secondInteger, neg) {	let firstAsLargeInteger;	let firstInteger;	let secondAsLargeInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	(typeof neg === "boolean" ? neg : PrimitiveFailed.signal());	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if (!LargeIntegers.isNormalized(firstInteger)) {		;		throw Object.create(PrimitiveFailed).setPayload(1);	}	if (!LargeIntegers.isNormalized(secondInteger)) {		;		throw Object.create(PrimitiveFailed).setPayload(1);	}	if ((typeof firstInteger === "number")) {		/* convert to LargeInteger */			firstAsLargeInteger = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstAsLargeInteger = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* check for zerodivide and convert to LargeInteger */		if (secondInteger === 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		}			secondAsLargeInteger = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondAsLargeInteger = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg));}, /*	Answer the result of dividing firstInteger by secondInteger.	Fail if parameters are not integers or secondInteger is zero. */primDigitDivWithNegative(firstInteger, secondInteger, neg) {	let firstAsLargeInteger;	let secondAsLargeInteger;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	(typeof neg === "boolean" ? neg : PrimitiveFailed.signal());	;	if ((typeof firstInteger === "number")) {		/* convert to LargeInteger */			firstAsLargeInteger = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstAsLargeInteger = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* check for zerodivide and convert to LargeInteger */		if (secondInteger === 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		}			secondAsLargeInteger = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondAsLargeInteger = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg));}, primDigitMultiplyNegative(secondInteger, neg) {	let firstLarge;	let firstInteger;	let secondLarge;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	(typeof neg === "boolean" ? neg : PrimitiveFailed.signal());	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitMultiplyLargewithnegative(firstLarge, secondLarge, neg));}, primDigitMultiplyWithNegative(firstInteger, secondInteger, neg) {	let firstLarge;	let secondLarge;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	(typeof neg === "boolean" ? neg : PrimitiveFailed.signal());	;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitMultiplyLargewithnegative(firstLarge, secondLarge, neg));}, primDigitSubtract(secondInteger) {	let firstLarge;	let firstInteger;	let secondLarge;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitSubLargewith(firstLarge, secondLarge));}, primDigitSubtractWith(firstInteger, secondInteger) {	let firstLarge;	let secondLarge;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondInteger;	;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondInteger);	} else {		secondLarge = secondInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitSubLargewith(firstLarge, secondLarge));}, /*	If calling this primitive fails, then C module does not exist. */primGetModuleName() {	let strLen;	let i;	let strOop;	;	strLen = LargeIntegers.strlen(LargeIntegers.getModuleName.apply(this, arguments));	strOop = (function(__size) {const result = SmalltalkGlobals._String.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})(strLen);	for (i = 0; i <= (strLen - 1); i++) {		SmalltalkVM.storeByteofObjectwithValue(i, strOop, LargeIntegers.getModuleName.apply(this, arguments)[i]);	}	throw Object.create(PrimitiveReturn).setPayload(strOop);}, primMontgomeryDigitLength() {	;	throw Object.create(PrimitiveReturn).setPayload(8);}, primMontgomeryTimesModulo(secondOperandInteger, thirdModuloInteger, smallInverseInteger) {	let firstLarge;	let secondLarge;	let firstInteger;	let thirdLarge;	if ((typeof secondOperandInteger !== "number" && typeof secondOperandInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	secondOperandInteger;	if ((typeof thirdModuloInteger !== "number" && typeof thirdModuloInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	thirdModuloInteger;	if (!(typeof smallInverseInteger === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	;	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			firstLarge = LargeIntegers.createLargeFromSmallInteger(firstInteger);	} else {		firstLarge = firstInteger;	}	if ((typeof secondOperandInteger === "number")) {		/* convert it to a not normalized LargeInteger */			secondLarge = LargeIntegers.createLargeFromSmallInteger(secondOperandInteger);	} else {		secondLarge = secondOperandInteger;	}	if ((typeof thirdModuloInteger === "number")) {		/* convert it to a not normalized LargeInteger */			thirdLarge = LargeIntegers.createLargeFromSmallInteger(thirdModuloInteger);	} else {		thirdLarge = thirdModuloInteger;	}	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.digitMontgomerytimesmodulomInvModB(firstLarge, secondLarge, thirdLarge, smallInverseInteger));}, /*	Parameter specification #(Integer) doesn't convert! */primNormalize(anInteger) {	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger;	;	throw Object.create(PrimitiveReturn).setPayload(((typeof anInteger === "number") ? anInteger : LargeIntegers.normalize(anInteger)));}, primNormalizeNegative() {	let rcvr;	;	if ((typeof this.valueOf() !== "bigint" || this.valueOf() >= 0)) throw Object.create(PrimitiveFailed).setPayload(1);	rcvr = this;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.normalizeNegative(rcvr));}, primNormalizePositive() {	let rcvr;	;	if ((typeof this.valueOf() !== "bigint" || this.valueOf() < 0)) throw Object.create(PrimitiveFailed).setPayload(1);	rcvr = this;	throw Object.create(PrimitiveReturn).setPayload(LargeIntegers.normalizePositive(rcvr));}, }