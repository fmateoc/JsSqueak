/* Smalltalk from Squeak4.5 with VMMaker 4.20.5 translated as JavaScript source on 4 November 2023 11:12:23 pm *//* Automatically generated by	JSSmartSyntaxPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	LargeIntegersPlugin * VMMaker-dtl.439 uuid: 2c8ef6e2-8460-4120-b973-009902597787 */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/*** Variables ***/let andOpIndex = 0;let orOpIndex = 1;let simulator = 0;let xorOpIndex = 2;globalThis.LargeIntegers = {/*	Argument has to be aBytesOop! *//*	Tests for any magnitude bits in the interval from start to stopArg. */anyBitOfLargeIntfromto(aBytesOop, start, stopArg) {	let lastByteIx;	let digit;	let magnitude;	let leftShift;	let rightShift;	let firstByteIx;	let stop;	let mask;	let ix;	let arg11;	let lastDigit;	let realLength;	let shifted;	let bitNo;	let brokenFromLoop_cDigitHighBitlen_3381;	if ((start < 1) || (stopArg < 1)) {		throw Object.create(PrimitiveFailed).setPayload(1);	} else {		magnitude = aBytesOop;		/* begin cDigitHighBit:len: */		realLength = SIZEOF(magnitude);		brokenFromLoop_cDigitHighBitlen_3381 = false;		while (((lastDigit = BYTESOF(magnitude)[realLength - 1])) === 0) {			if (((--realLength)) === 0) {				arg11 = 0;				brokenFromLoop_cDigitHighBitlen_3381 = true;				break;			}		}		if (!brokenFromLoop_cDigitHighBitlen_3381) {			/* begin cHighBit: */			shifted = lastDigit;			bitNo = 0;			if (shifted >= (65536)) {				shifted = shifted >>> 16;				bitNo += 16;			}			if (shifted >= (256)) {				shifted = shifted >>> 8;				bitNo += 8;			}			if (shifted >= (16)) {				shifted = shifted >>> 4;				bitNo += 4;			}			if (shifted >= (4)) {				shifted = shifted >>> 2;				bitNo += 2;			}			if (shifted >= (2)) {				shifted = shifted >>> 1;				++bitNo;			}			arg11 = (bitNo + shifted) + (8 * (realLength - 1));			/* end cHighBit: */		}		/* end cDigitHighBit:len: */		stop = Math.min(stopArg, arg11);		if (start > stop) {			return false;		} else {			firstByteIx = ((start - 1) >> 3) + 1;			lastByteIx = ((stop - 1) >> 3) + 1;			rightShift = MOD((start - 1), 8);			leftShift = 7 - (MOD((stop - 1), 8));			if (firstByteIx === lastByteIx) {				mask = UBAND((SHL(255, rightShift)), (SHR(255, leftShift)));				digit = (firstByteIx > SIZEOF(magnitude)) ? 0 : BYTESOF(magnitude)[firstByteIx - 1];				return (UBAND(digit, mask)) !== 0;			} else {				if ((SHR(((firstByteIx > SIZEOF(magnitude)	? 0	: BYTESOF(magnitude)[firstByteIx - 1])), rightShift)) !== 0) {					return true;				} else {					for (ix = firstByteIx + 1; ix < lastByteIx; ix++) {						if (((ix > SIZEOF(magnitude)	? 0	: BYTESOF(magnitude)[ix - 1])) !== 0) {							return true;						}					}					if ((UBANDS((SHL(((lastByteIx > SIZEOF(magnitude)	? 0	: BYTESOF(magnitude)[lastByteIx - 1])), leftShift)), 255)) !== 0) {						return true;					} else {						return false;					}				}			}		}	}}, /*	Precondition: bytesOop is not anInteger and a bytes object. *//*	Function #byteSizeOf: is used by the interpreter, be careful with name	clashes... */byteSizeOfBytes(bytesOop) {	return SIZEOF(bytesOop);}, cDigitCopyFromtolen(pFrom, pTo, len) {	let i;	let i1;	let limit;	limit = len - 1;	for (i1 = 0; i1 <= limit; i1++) {		pTo[i1] = pFrom[i1];	}	return 0;}, /*	Answer the index (in bits) of the high order bit of the receiver, or zero if the    	 receiver is zero. This method is allowed (and needed) for     	LargeNegativeIntegers as well, since Squeak's LargeIntegers are     	sign/magnitude. */cDigitHighBitlen(pByte, len) {	let lastDigit;	let realLength;	let shifted;	let bitNo;	realLength = len;	while (((lastDigit = pByte[realLength - 1])) === 0) {		if (((--realLength)) === 0) {			return 0;		}	}	/* begin cHighBit: */	shifted = lastDigit;	bitNo = 0;	if (shifted >= (65536)) {		shifted = shifted >>> 16;		bitNo += 16;	}	if (shifted >= (256)) {		shifted = shifted >>> 8;		bitNo += 8;	}	if (shifted >= (16)) {		shifted = shifted >>> 4;		bitNo += 4;	}	if (shifted >= (4)) {		shifted = shifted >>> 2;		bitNo += 2;	}	if (shifted >= (2)) {		shifted = shifted >>> 1;		++bitNo;	}	return (bitNo + shifted) + (8 * (realLength - 1));	/* end cHighBit: */}, /*	Answer the number of bytes required to represent the value of a CSmallInteger. */cDigitLengthOfCSI(csi) {	return (csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))));}, primAnyBitFromTo(from, to) {	let integer;	let large;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	if (!(typeof from === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof to === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	integer = this;	if ((typeof integer === "number")) {		/* convert it to a not normalized LargeInteger */		/* begin createLargeFromSmallInteger: */		val = integer;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		large = res;		/* end createLargeFromSmallInteger: */	} else {		large = integer;	}	throw Object.create(PrimitiveReturn).setPayload(!!(LargeIntegers.anyBitOfLargeIntfromto(large, from, to)));}, /*	Converts a SmallInteger into a - non normalized! - LargeInteger;          	 aLargeInteger will be returned unchanged. *//*	Do not check for forced fail, because we need this conversion to test the 	plugin in ST during forced fail, too. */primAsLargeInteger(anInteger) {	let arg11;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof anInteger === "number")) {		/* begin createLargeFromSmallInteger: */		val = anInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		arg11 = res;		/* end createLargeFromSmallInteger: */		throw Object.create(PrimitiveReturn).setPayload(arg11);	} else {		throw Object.create(PrimitiveReturn).setPayload(anInteger);	}}, /*	If calling this primitive fails, then C module does not exist. Do not check for forced fail, because we want to know if module exists during forced fail, too. */primCheckIfCModuleExists() {	throw Object.create(PrimitiveReturn).setPayload(!!(true));}, _primDigitBitShift(anInteger, shiftCount) {	let aLarge;	let rShift;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let arg11;	let highBit;	let newBytes;	let oldLen;	let newLen;	let pFrom;	let pTo;	let digitShift;	let carry;	let digit;	let i;	let i1;	let bitShift;	let rshift;	let limit;	let arg12;	let aLargeInteger;	let i3;	let len;	let sLen;	let oldLen4;	let val2;	let oldLen1;	let newBytes3;	let copyLen;	let len1;	let i2;	let i11;	let sLen1;	let minVal;	let oldLen3;	let val1;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	let pFrom1;	let pTo1;	let j;	let digitShift1;	let carry1;	let digit1;	let bitShift1;	let leftShift;	let limit1;	let start;	let lastDigit;	let realLength;	let shifted;	let bitNo;	let brokenFromLoop_cDigitHighBitlen_1220;	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof anInteger === "number")) {		/* convert it to a not normalized LargeInteger */		/* begin createLargeFromSmallInteger: */		val = anInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		aLarge = res;		/* end createLargeFromSmallInteger: */	} else {		aLarge = anInteger;	}	if (shiftCount >= 0) {		/* begin digit:Lshift: */		oldLen = SIZEOF(aLarge);		if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(aLarge), oldLen))) === 0) {			arg11 = 0;		} else {			newLen = ((highBit + shiftCount) + 7) >> 3;					newBytes = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);			/* begin cDigitLshift:from:len:to:len: */			pFrom = BYTESOF(aLarge);			pTo = BYTESOF(newBytes);			digitShift = shiftCount >> 3;			bitShift = MOD(shiftCount, 8);			limit = digitShift - 1;			for (i = 0; i <= limit; i++) {				pTo[i] = 0;			}			if (bitShift === 0) {				{				// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1				const len = newLen - digitShift				for (let i = 0; i < len; i++) 					pTo[i + digitShift] = pFrom[i];				}			} else {				rshift = 8 - bitShift;				carry = 0;				limit = oldLen - 1;				for (i1 = 0; i1 <= limit; i1++) {					digit = pFrom[i1];					pTo[i1 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));					carry = SHR(digit, rshift);				}				if (carry !== 0) {					pTo[newLen - 1] = carry;				}			}			/* end cDigitLshift:from:len:to:len: */			arg11 = newBytes;		}		/* end digit:Lshift: */		throw Object.create(PrimitiveReturn).setPayload(arg11);	} else {		rShift = 0 - shiftCount;		/* begin normalize: */		/* begin digit:Rshift:lookfirst: */		/* begin cDigitHighBit:len: */		realLength = SIZEOF(aLarge);		brokenFromLoop_cDigitHighBitlen_1220 = false;		while (((lastDigit = BYTESOF(aLarge)[realLength - 1])) === 0) {			if (((--realLength)) === 0) {				oldBitLen = 0;				brokenFromLoop_cDigitHighBitlen_1220 = true;				break;			}		}		if (!brokenFromLoop_cDigitHighBitlen_1220) {			/* begin cHighBit: */			shifted = lastDigit;			bitNo = 0;			if (shifted >= (65536)) {				shifted = shifted >>> 16;				bitNo += 16;			}			if (shifted >= (256)) {				shifted = shifted >>> 8;				bitNo += 8;			}			if (shifted >= (16)) {				shifted = shifted >>> 4;				bitNo += 4;			}			if (shifted >= (4)) {				shifted = shifted >>> 2;				bitNo += 2;			}			if (shifted >= (2)) {				shifted = shifted >>> 1;				++bitNo;			}			oldBitLen = (bitNo + shifted) + (8 * (realLength - 1));			/* end cHighBit: */		}		/* end cDigitHighBit:len: */		oldDigitLen = (oldBitLen + 7) >> 3;		newBitLen = oldBitLen - rShift;		if (newBitLen <= 0) {			aLargeInteger = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);		} else {			newByteLen = (newBitLen + 7) >> 3;					newOop = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);			/* begin cDigitRshift:from:len:to:len: */			pFrom1 = BYTESOF(aLarge);			pTo1 = BYTESOF(newOop);			digitShift1 = rShift >> 3;			bitShift1 = MOD(rShift, 8);			if (bitShift1 === 0) {				{				// inlining self cDigitCopyFrom: pFrom1 + digitShift1 to: pTo1 + 0 len: newByteLen - 1 - 0 + 1				for (let i = 0; i < newByteLen; i++) 					pTo1[i] = pFrom1[i + digitShift1];				}			} else {				leftShift = 8 - bitShift1;				carry1 = SHR(pFrom1[digitShift1], bitShift1);				start = digitShift1 + 1;				limit1 = oldDigitLen - 1;				for (j = start; j <= limit1; j++) {					digit1 = pFrom1[j];					pTo1[j - start] = (UBANDS((UBOR(carry1, (SHL(digit1, leftShift)))), 255));					carry1 = SHR(digit1, bitShift1);				}				if (carry1 !== 0) {					pTo1[newByteLen - 1] = carry1;				}			}			/* end cDigitRshift:from:len:to:len: */			aLargeInteger = newOop;		}		/* end digit:Rshift:lookfirst: */		if (aLargeInteger._class() === SmalltalkGlobals._LargePositiveInteger) {			/* begin normalizePositive: */			len = (typeof aLargeInteger === "number") ? ((oldLen4 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen4 = SIZEOF(aLargeInteger)));			while ((len !== 0) && (BYTESOF(aLargeInteger)[len - 1] === 0)) {				--len;			}			if (len === 0) {				arg12 = 0;			} else {				sLen = 4;				if ((len <= sLen) && (((sLen > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {					val2 = 0;					for (i3 = len; i3 >= 1; i3--) {						val2 = (val2 * 256) + BYTESOF(aLargeInteger)[i3 - 1];					}					arg12 = val2;				} else {					if (len < oldLen4) {						/* begin bytes:growTo: */											newBytes3 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);						oldLen1 = BYTESIZEOF(aLargeInteger);						copyLen = (oldLen1 < len) ? oldLen1 : len;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes3), copyLen);						arg12 = newBytes3;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizePositive: */		} else {			/* begin normalizeNegative: */			len1 = (typeof aLargeInteger === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen3 = SIZEOF(aLargeInteger)));			while ((len1 !== 0) && (BYTESOF(aLargeInteger)[len1 - 1] === 0)) {				--len1;			}			if (len1 === 0) {				arg12 = 0;			} else {				sLen1 = 4;				if (len1 <= sLen1) {					minVal = -1073741824;					if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {						val1 = 0;						for (i2 = len1; i2 >= 1; i2--) {							val1 = (val1 * 256) - BYTESOF(aLargeInteger)[i2 - 1];						}						arg12 = val1;					} else {						brokenFromLoop_normalizeNegative_2202 = false;						for (i11 = 1; i11 <= sLen1; i11++) {							if (((i11 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[i11 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i11 - 1) * 8))), 255))) {								if (len1 < oldLen3) {									/* begin bytes:growTo: */																	newBytes2 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);									oldLen11 = BYTESIZEOF(aLargeInteger);									copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;									LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes2), copyLen2);									returnValueFromLoop_normalizeNegative_2202 = newBytes2;									/* end bytes:growTo: */								} else {									returnValueFromLoop_normalizeNegative_2202 = aLargeInteger;								}								brokenFromLoop_normalizeNegative_2202 = true;								break;							}						}						arg12 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;					}				} else {					if (len1 < oldLen3) {						/* begin bytes:growTo: */											newBytes1 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);						oldLen2 = BYTESIZEOF(aLargeInteger);						copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes1), copyLen1);						arg12 = newBytes1;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizeNegative: */		}		/* end normalize: */		throw Object.create(PrimitiveReturn).setPayload(arg12);	}}, primDigitAdd(secondInteger) {	let firstLarge;	let firstInteger;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let sum;	let shortLen;	let over;	let shortInt;	let resClass;	let newSum;	let longLen;	let firstLen;	let secondLen;	let longInt;	let pByteLong;	let pByteRes;	let i;	let i1;	let limit;	let accum;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitAddLarge:with: */	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	resClass = firstLarge._class();	if (firstLen <= secondLen) {		shortInt = firstLarge;		shortLen = firstLen;		longInt = secondLarge;		longLen = secondLen;	} else {		shortInt = secondLarge;		shortLen = secondLen;		longInt = firstLarge;		longLen = firstLen;	}	sum = (function(__size) {const __result = resClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitAdd:len:with:len:into: */	pByteLong = BYTESOF(longInt);	pByteRes = BYTESOF(sum);	accum = 0;	limit = shortLen - 1;	for (i = 0; i <= limit; i++) {		accum = ((accum >>> 8) + BYTESOF(shortInt)[i]) + pByteLong[i];		pByteRes[i] = (UBANDS(accum, 255));	}	limit = longLen - 1;	for (i1 = shortLen; i1 <= limit; i1++) {		accum = (accum >>> 8) + pByteLong[i1];		pByteRes[i1] = (UBANDS(accum, 255));	}	over = accum >>> 8;	/* end cDigitAdd:len:with:len:into: */	if (over > 0) {			newSum = (function(__size) {const __result = resClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})((longLen + 1));		LargeIntegers.cDigitCopyFromtolen(BYTESOF(sum), BYTESOF(newSum), longLen);		sum = newSum;		BYTESOF(sum)[longLen] = over;	}	arg11 = sum;	/* end digitAddLarge:with: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitAddWith(firstInteger, secondInteger) {	let firstLarge;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let sum;	let shortLen;	let over;	let shortInt;	let resClass;	let newSum;	let longLen;	let firstLen;	let secondLen;	let longInt;	let pByteLong;	let pByteRes;	let i;	let i1;	let limit;	let accum;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitAddLarge:with: */	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	resClass = firstLarge._class();	if (firstLen <= secondLen) {		shortInt = firstLarge;		shortLen = firstLen;		longInt = secondLarge;		longLen = secondLen;	} else {		shortInt = secondLarge;		shortLen = secondLen;		longInt = firstLarge;		longLen = firstLen;	}	sum = (function(__size) {const __result = resClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitAdd:len:with:len:into: */	pByteLong = BYTESOF(longInt);	pByteRes = BYTESOF(sum);	accum = 0;	limit = shortLen - 1;	for (i = 0; i <= limit; i++) {		accum = ((accum >>> 8) + BYTESOF(shortInt)[i]) + pByteLong[i];		pByteRes[i] = (UBANDS(accum, 255));	}	limit = longLen - 1;	for (i1 = shortLen; i1 <= limit; i1++) {		accum = (accum >>> 8) + pByteLong[i1];		pByteRes[i1] = (UBANDS(accum, 255));	}	over = accum >>> 8;	/* end cDigitAdd:len:with:len:into: */	if (over > 0) {			newSum = (function(__size) {const __result = resClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})((longLen + 1));		LargeIntegers.cDigitCopyFromtolen(BYTESOF(sum), BYTESOF(newSum), longLen);		sum = newSum;		BYTESOF(sum)[longLen] = over;	}	arg11 = sum;	/* end digitAddLarge:with: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitAnd(secondInteger) {	let firstInteger;	let arg11;	let shortLen;	let shortLarge;	let firstLarge;	let secondLarge;	let longLen;	let longLarge;	let firstLen;	let secondLen;	let result;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let pByteShort;	let pByteLong;	let pByteRes;	let i2;	let i;	let i1;	let limit;	let i13;	let i12;	let i11;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	/* begin digitBitLogic:with:opIndex: */	if ((typeof firstInteger === "number")) {		if (firstInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val = firstInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		firstLarge = res;		/* end createLargeFromSmallInteger: */		}	} else {		if (firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			firstLarge = firstInteger;		}	}	if ((typeof secondInteger === "number")) {		if (secondInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val1 = secondInteger;		class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));		res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);		pByte1 = BYTESOF(res1);		for (ix1 = 1; ix1 <= size1; ix1++) {			byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);			pByte1[ix1 - 1] = byte1;		}		secondLarge = res1;		/* end createLargeFromSmallInteger: */		}	} else {		if (secondInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			secondLarge = secondInteger;		}	}	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen < secondLen) {		shortLen = firstLen;		shortLarge = firstLarge;		longLen = secondLen;		longLarge = secondLarge;	} else {		shortLen = secondLen;		shortLarge = secondLarge;		longLen = firstLen;		longLarge = firstLarge;	}	result = (function(__size) {const __result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitOp:short:len:long:len:into: */	pByteShort = BYTESOF(shortLarge);	pByteLong = BYTESOF(longLarge);	pByteRes = BYTESOF(result);	limit = shortLen - 1;	if (andOpIndex === andOpIndex) {		for (i = 0; i <= limit; i++) {			pByteRes[i] = (UBAND(pByteShort[i], pByteLong[i]));		}		limit = longLen - 1;		for (i1 = shortLen; i1 <= limit; i1++) {			pByteRes[i1] = 0;		}	} else {		if (andOpIndex === orOpIndex) {			for (i11 = 0; i11 <= limit; i11++) {				pByteRes[i11] = (UBOR(pByteShort[i11], pByteLong[i11]));			}			limit = longLen - 1;			for (i12 = shortLen; i12 <= limit; i12++) {				pByteRes[i12] = pByteLong[i12];			}		} else {			if (andOpIndex === xorOpIndex) {				for (i13 = 0; i13 <= limit; i13++) {					pByteRes[i13] = (UBXOR(pByteShort[i13], pByteLong[i13]));				}				limit = longLen - 1;				for (i2 = shortLen; i2 <= limit; i2++) {					pByteRes[i2] = pByteLong[i2];				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}	/* end cDigitOp:short:len:long:len:into: */	/* begin normalizePositive: */len = (typeof result === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(result))) : ((oldLen = SIZEOF(result)));while ((len !== 0) && (BYTESOF(result)[len - 1] === 0)) {	--len;}if (len === 0) {	arg11 = 0;} else {	sLen = 4;	if ((len <= sLen) && (((sLen > BYTESIZEOF(result)	? 0	: BYTESOF(result)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {		val2 = 0;		for (i3 = len; i3 >= 1; i3--) {			val2 = (val2 * 256) + BYTESOF(result)[i3 - 1];		}		arg11 = val2;	} else {		if (len < oldLen) {			/* begin bytes:growTo: */					newBytes = (function(__size) {const __result = result._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);			oldLen1 = BYTESIZEOF(result);			copyLen = (oldLen1 < len) ? oldLen1 : len;			LargeIntegers.cDigitCopyFromtolen(BYTESOF(result), BYTESOF(newBytes), copyLen);			arg11 = newBytes;			/* end bytes:growTo: */		} else {			arg11 = result;		}	}}/* end normalizePositive: */	/* end digitBitLogic:with:opIndex: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, /*	Bit logic here is only implemented for positive integers or Zero; if any arg is negative, it fails. */primDigitBitLogicWithOp(firstInteger, secondInteger, opIndex) {	let arg11;	let shortLen;	let shortLarge;	let firstLarge;	let secondLarge;	let longLen;	let longLarge;	let firstLen;	let secondLen;	let result;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let pByteShort;	let pByteLong;	let pByteRes;	let i2;	let i;	let i1;	let limit;	let i13;	let i12;	let i11;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof opIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	/* begin digitBitLogic:with:opIndex: */	if ((typeof firstInteger === "number")) {		if (firstInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val = firstInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		firstLarge = res;		/* end createLargeFromSmallInteger: */		}	} else {		if (firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			firstLarge = firstInteger;		}	}	if ((typeof secondInteger === "number")) {		if (secondInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val1 = secondInteger;		class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));		res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);		pByte1 = BYTESOF(res1);		for (ix1 = 1; ix1 <= size1; ix1++) {			byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);			pByte1[ix1 - 1] = byte1;		}		secondLarge = res1;		/* end createLargeFromSmallInteger: */		}	} else {		if (secondInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			secondLarge = secondInteger;		}	}	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen < secondLen) {		shortLen = firstLen;		shortLarge = firstLarge;		longLen = secondLen;		longLarge = secondLarge;	} else {		shortLen = secondLen;		shortLarge = secondLarge;		longLen = firstLen;		longLarge = firstLarge;	}	result = (function(__size) {const __result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitOp:short:len:long:len:into: */	pByteShort = BYTESOF(shortLarge);	pByteLong = BYTESOF(longLarge);	pByteRes = BYTESOF(result);	limit = shortLen - 1;	if (opIndex === andOpIndex) {		for (i = 0; i <= limit; i++) {			pByteRes[i] = (UBAND(pByteShort[i], pByteLong[i]));		}		limit = longLen - 1;		for (i1 = shortLen; i1 <= limit; i1++) {			pByteRes[i1] = 0;		}	} else {		if (opIndex === orOpIndex) {			for (i11 = 0; i11 <= limit; i11++) {				pByteRes[i11] = (UBOR(pByteShort[i11], pByteLong[i11]));			}			limit = longLen - 1;			for (i12 = shortLen; i12 <= limit; i12++) {				pByteRes[i12] = pByteLong[i12];			}		} else {			if (opIndex === xorOpIndex) {				for (i13 = 0; i13 <= limit; i13++) {					pByteRes[i13] = (UBXOR(pByteShort[i13], pByteLong[i13]));				}				limit = longLen - 1;				for (i2 = shortLen; i2 <= limit; i2++) {					pByteRes[i2] = pByteLong[i2];				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}	/* end cDigitOp:short:len:long:len:into: */	/* begin normalizePositive: */len = (typeof result === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(result))) : ((oldLen = SIZEOF(result)));while ((len !== 0) && (BYTESOF(result)[len - 1] === 0)) {	--len;}if (len === 0) {	arg11 = 0;} else {	sLen = 4;	if ((len <= sLen) && (((sLen > BYTESIZEOF(result)	? 0	: BYTESOF(result)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {		val2 = 0;		for (i3 = len; i3 >= 1; i3--) {			val2 = (val2 * 256) + BYTESOF(result)[i3 - 1];		}		arg11 = val2;	} else {		if (len < oldLen) {			/* begin bytes:growTo: */					newBytes = (function(__size) {const __result = result._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);			oldLen1 = BYTESIZEOF(result);			copyLen = (oldLen1 < len) ? oldLen1 : len;			LargeIntegers.cDigitCopyFromtolen(BYTESOF(result), BYTESOF(newBytes), copyLen);			arg11 = newBytes;			/* end bytes:growTo: */		} else {			arg11 = result;		}	}}/* end normalizePositive: */	/* end digitBitLogic:with:opIndex: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitOr(secondInteger) {	let firstInteger;	let arg11;	let shortLen;	let shortLarge;	let firstLarge;	let secondLarge;	let longLen;	let longLarge;	let firstLen;	let secondLen;	let result;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let pByteShort;	let pByteLong;	let pByteRes;	let i2;	let i;	let i1;	let limit;	let i13;	let i12;	let i11;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	/* begin digitBitLogic:with:opIndex: */	if ((typeof firstInteger === "number")) {		if (firstInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val = firstInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		firstLarge = res;		/* end createLargeFromSmallInteger: */		}	} else {		if (firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			firstLarge = firstInteger;		}	}	if ((typeof secondInteger === "number")) {		if (secondInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val1 = secondInteger;		class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));		res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);		pByte1 = BYTESOF(res1);		for (ix1 = 1; ix1 <= size1; ix1++) {			byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);			pByte1[ix1 - 1] = byte1;		}		secondLarge = res1;		/* end createLargeFromSmallInteger: */		}	} else {		if (secondInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			secondLarge = secondInteger;		}	}	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen < secondLen) {		shortLen = firstLen;		shortLarge = firstLarge;		longLen = secondLen;		longLarge = secondLarge;	} else {		shortLen = secondLen;		shortLarge = secondLarge;		longLen = firstLen;		longLarge = firstLarge;	}	result = (function(__size) {const __result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitOp:short:len:long:len:into: */	pByteShort = BYTESOF(shortLarge);	pByteLong = BYTESOF(longLarge);	pByteRes = BYTESOF(result);	limit = shortLen - 1;	if (orOpIndex === andOpIndex) {		for (i = 0; i <= limit; i++) {			pByteRes[i] = (UBAND(pByteShort[i], pByteLong[i]));		}		limit = longLen - 1;		for (i1 = shortLen; i1 <= limit; i1++) {			pByteRes[i1] = 0;		}	} else {		if (orOpIndex === orOpIndex) {			for (i11 = 0; i11 <= limit; i11++) {				pByteRes[i11] = (UBOR(pByteShort[i11], pByteLong[i11]));			}			limit = longLen - 1;			for (i12 = shortLen; i12 <= limit; i12++) {				pByteRes[i12] = pByteLong[i12];			}		} else {			if (orOpIndex === xorOpIndex) {				for (i13 = 0; i13 <= limit; i13++) {					pByteRes[i13] = (UBXOR(pByteShort[i13], pByteLong[i13]));				}				limit = longLen - 1;				for (i2 = shortLen; i2 <= limit; i2++) {					pByteRes[i2] = pByteLong[i2];				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}	/* end cDigitOp:short:len:long:len:into: */	/* begin normalizePositive: */len = (typeof result === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(result))) : ((oldLen = SIZEOF(result)));while ((len !== 0) && (BYTESOF(result)[len - 1] === 0)) {	--len;}if (len === 0) {	arg11 = 0;} else {	sLen = 4;	if ((len <= sLen) && (((sLen > BYTESIZEOF(result)	? 0	: BYTESOF(result)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {		val2 = 0;		for (i3 = len; i3 >= 1; i3--) {			val2 = (val2 * 256) + BYTESOF(result)[i3 - 1];		}		arg11 = val2;	} else {		if (len < oldLen) {			/* begin bytes:growTo: */					newBytes = (function(__size) {const __result = result._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);			oldLen1 = BYTESIZEOF(result);			copyLen = (oldLen1 < len) ? oldLen1 : len;			LargeIntegers.cDigitCopyFromtolen(BYTESOF(result), BYTESOF(newBytes), copyLen);			arg11 = newBytes;			/* end bytes:growTo: */		} else {			arg11 = result;		}	}}/* end normalizePositive: */	/* end digitBitLogic:with:opIndex: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitBitShift(shiftCount) {	let anInteger;	let rShift;	let aLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let arg11;	let highBit;	let newBytes;	let oldLen;	let newLen;	let pFrom;	let pTo;	let digitShift;	let carry;	let digit;	let i;	let i1;	let bitShift;	let rshift;	let limit;	let arg12;	let aLargeInteger;	let i3;	let len;	let sLen;	let oldLen4;	let val2;	let oldLen1;	let newBytes3;	let copyLen;	let len1;	let i2;	let i11;	let sLen1;	let minVal;	let oldLen3;	let val1;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	let pFrom1;	let pTo1;	let j;	let digitShift1;	let carry1;	let digit1;	let bitShift1;	let leftShift;	let limit1;	let start;	let lastDigit;	let realLength;	let shifted;	let bitNo;	let brokenFromLoop_cDigitHighBitlen_1220;	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger = this;	if ((typeof anInteger === "number")) {		/* convert it to a not normalized LargeInteger */		/* begin createLargeFromSmallInteger: */		val = anInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		aLarge = res;		/* end createLargeFromSmallInteger: */	} else {		aLarge = anInteger;	}	if (shiftCount >= 0) {		/* begin digit:Lshift: */		oldLen = SIZEOF(aLarge);		if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(aLarge), oldLen))) === 0) {			arg11 = 0;		} else {			newLen = ((highBit + shiftCount) + 7) >> 3;					newBytes = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);			/* begin cDigitLshift:from:len:to:len: */			pFrom = BYTESOF(aLarge);			pTo = BYTESOF(newBytes);			digitShift = shiftCount >> 3;			bitShift = MOD(shiftCount, 8);			limit = digitShift - 1;			for (i = 0; i <= limit; i++) {				pTo[i] = 0;			}			if (bitShift === 0) {				{				// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1				const len = newLen - digitShift				for (let i = 0; i < len; i++) 					pTo[i + digitShift] = pFrom[i];				}			} else {				rshift = 8 - bitShift;				carry = 0;				limit = oldLen - 1;				for (i1 = 0; i1 <= limit; i1++) {					digit = pFrom[i1];					pTo[i1 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));					carry = SHR(digit, rshift);				}				if (carry !== 0) {					pTo[newLen - 1] = carry;				}			}			/* end cDigitLshift:from:len:to:len: */			arg11 = newBytes;		}		/* end digit:Lshift: */		throw Object.create(PrimitiveReturn).setPayload(arg11);	} else {		rShift = 0 - shiftCount;		/* begin normalize: */		/* begin digit:Rshift:lookfirst: */		/* begin cDigitHighBit:len: */		realLength = SIZEOF(aLarge);		brokenFromLoop_cDigitHighBitlen_1220 = false;		while (((lastDigit = BYTESOF(aLarge)[realLength - 1])) === 0) {			if (((--realLength)) === 0) {				oldBitLen = 0;				brokenFromLoop_cDigitHighBitlen_1220 = true;				break;			}		}		if (!brokenFromLoop_cDigitHighBitlen_1220) {			/* begin cHighBit: */			shifted = lastDigit;			bitNo = 0;			if (shifted >= (65536)) {				shifted = shifted >>> 16;				bitNo += 16;			}			if (shifted >= (256)) {				shifted = shifted >>> 8;				bitNo += 8;			}			if (shifted >= (16)) {				shifted = shifted >>> 4;				bitNo += 4;			}			if (shifted >= (4)) {				shifted = shifted >>> 2;				bitNo += 2;			}			if (shifted >= (2)) {				shifted = shifted >>> 1;				++bitNo;			}			oldBitLen = (bitNo + shifted) + (8 * (realLength - 1));			/* end cHighBit: */		}		/* end cDigitHighBit:len: */		oldDigitLen = (oldBitLen + 7) >> 3;		newBitLen = oldBitLen - rShift;		if (newBitLen <= 0) {			aLargeInteger = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);		} else {			newByteLen = (newBitLen + 7) >> 3;					newOop = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);			/* begin cDigitRshift:from:len:to:len: */			pFrom1 = BYTESOF(aLarge);			pTo1 = BYTESOF(newOop);			digitShift1 = rShift >> 3;			bitShift1 = MOD(rShift, 8);			if (bitShift1 === 0) {				{				// inlining self cDigitCopyFrom: pFrom1 + digitShift1 to: pTo1 + 0 len: newByteLen - 1 - 0 + 1				for (let i = 0; i < newByteLen; i++) 					pTo1[i] = pFrom1[i + digitShift1];				}			} else {				leftShift = 8 - bitShift1;				carry1 = SHR(pFrom1[digitShift1], bitShift1);				start = digitShift1 + 1;				limit1 = oldDigitLen - 1;				for (j = start; j <= limit1; j++) {					digit1 = pFrom1[j];					pTo1[j - start] = (UBANDS((UBOR(carry1, (SHL(digit1, leftShift)))), 255));					carry1 = SHR(digit1, bitShift1);				}				if (carry1 !== 0) {					pTo1[newByteLen - 1] = carry1;				}			}			/* end cDigitRshift:from:len:to:len: */			aLargeInteger = newOop;		}		/* end digit:Rshift:lookfirst: */		if (aLargeInteger._class() === SmalltalkGlobals._LargePositiveInteger) {			/* begin normalizePositive: */			len = (typeof aLargeInteger === "number") ? ((oldLen4 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen4 = SIZEOF(aLargeInteger)));			while ((len !== 0) && (BYTESOF(aLargeInteger)[len - 1] === 0)) {				--len;			}			if (len === 0) {				arg12 = 0;			} else {				sLen = 4;				if ((len <= sLen) && (((sLen > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {					val2 = 0;					for (i3 = len; i3 >= 1; i3--) {						val2 = (val2 * 256) + BYTESOF(aLargeInteger)[i3 - 1];					}					arg12 = val2;				} else {					if (len < oldLen4) {						/* begin bytes:growTo: */											newBytes3 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);						oldLen1 = BYTESIZEOF(aLargeInteger);						copyLen = (oldLen1 < len) ? oldLen1 : len;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes3), copyLen);						arg12 = newBytes3;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizePositive: */		} else {			/* begin normalizeNegative: */			len1 = (typeof aLargeInteger === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen3 = SIZEOF(aLargeInteger)));			while ((len1 !== 0) && (BYTESOF(aLargeInteger)[len1 - 1] === 0)) {				--len1;			}			if (len1 === 0) {				arg12 = 0;			} else {				sLen1 = 4;				if (len1 <= sLen1) {					minVal = -1073741824;					if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {						val1 = 0;						for (i2 = len1; i2 >= 1; i2--) {							val1 = (val1 * 256) - BYTESOF(aLargeInteger)[i2 - 1];						}						arg12 = val1;					} else {						brokenFromLoop_normalizeNegative_2202 = false;						for (i11 = 1; i11 <= sLen1; i11++) {							if (((i11 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[i11 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i11 - 1) * 8))), 255))) {								if (len1 < oldLen3) {									/* begin bytes:growTo: */																	newBytes2 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);									oldLen11 = BYTESIZEOF(aLargeInteger);									copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;									LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes2), copyLen2);									returnValueFromLoop_normalizeNegative_2202 = newBytes2;									/* end bytes:growTo: */								} else {									returnValueFromLoop_normalizeNegative_2202 = aLargeInteger;								}								brokenFromLoop_normalizeNegative_2202 = true;								break;							}						}						arg12 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;					}				} else {					if (len1 < oldLen3) {						/* begin bytes:growTo: */											newBytes1 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);						oldLen2 = BYTESIZEOF(aLargeInteger);						copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes1), copyLen1);						arg12 = newBytes1;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizeNegative: */		}		/* end normalize: */		throw Object.create(PrimitiveReturn).setPayload(arg12);	}}, primDigitBitShiftMagnitude(shiftCount) {	let anInteger;	let rShift;	let aLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let arg11;	let highBit;	let newBytes;	let oldLen;	let newLen;	let pFrom;	let pTo;	let digitShift;	let carry;	let digit;	let i;	let i1;	let bitShift;	let rshift;	let limit;	let arg12;	let aLargeInteger;	let i3;	let len;	let sLen;	let oldLen4;	let val2;	let oldLen1;	let newBytes3;	let copyLen;	let len1;	let i2;	let i11;	let sLen1;	let minVal;	let oldLen3;	let val1;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	let pFrom1;	let pTo1;	let j;	let digitShift1;	let carry1;	let digit1;	let bitShift1;	let leftShift;	let limit1;	let start;	let lastDigit;	let realLength;	let shifted;	let bitNo;	let brokenFromLoop_cDigitHighBitlen_1220;	if (!(typeof shiftCount === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	anInteger = this;	if ((typeof anInteger === "number")) {		/* convert it to a not normalized LargeInteger */		/* begin createLargeFromSmallInteger: */		val = anInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		aLarge = res;		/* end createLargeFromSmallInteger: */	} else {		aLarge = anInteger;	}	if (shiftCount >= 0) {		/* begin digit:Lshift: */		oldLen = SIZEOF(aLarge);		if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(aLarge), oldLen))) === 0) {			arg11 = 0;		} else {			newLen = ((highBit + shiftCount) + 7) >> 3;					newBytes = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);			/* begin cDigitLshift:from:len:to:len: */			pFrom = BYTESOF(aLarge);			pTo = BYTESOF(newBytes);			digitShift = shiftCount >> 3;			bitShift = MOD(shiftCount, 8);			limit = digitShift - 1;			for (i = 0; i <= limit; i++) {				pTo[i] = 0;			}			if (bitShift === 0) {				{				// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1				const len = newLen - digitShift				for (let i = 0; i < len; i++) 					pTo[i + digitShift] = pFrom[i];				}			} else {				rshift = 8 - bitShift;				carry = 0;				limit = oldLen - 1;				for (i1 = 0; i1 <= limit; i1++) {					digit = pFrom[i1];					pTo[i1 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));					carry = SHR(digit, rshift);				}				if (carry !== 0) {					pTo[newLen - 1] = carry;				}			}			/* end cDigitLshift:from:len:to:len: */			arg11 = newBytes;		}		/* end digit:Lshift: */		throw Object.create(PrimitiveReturn).setPayload(arg11);	} else {		rShift = 0 - shiftCount;		/* begin normalize: */		/* begin digit:Rshift:lookfirst: */		/* begin cDigitHighBit:len: */		realLength = SIZEOF(aLarge);		brokenFromLoop_cDigitHighBitlen_1220 = false;		while (((lastDigit = BYTESOF(aLarge)[realLength - 1])) === 0) {			if (((--realLength)) === 0) {				oldBitLen = 0;				brokenFromLoop_cDigitHighBitlen_1220 = true;				break;			}		}		if (!brokenFromLoop_cDigitHighBitlen_1220) {			/* begin cHighBit: */			shifted = lastDigit;			bitNo = 0;			if (shifted >= (65536)) {				shifted = shifted >>> 16;				bitNo += 16;			}			if (shifted >= (256)) {				shifted = shifted >>> 8;				bitNo += 8;			}			if (shifted >= (16)) {				shifted = shifted >>> 4;				bitNo += 4;			}			if (shifted >= (4)) {				shifted = shifted >>> 2;				bitNo += 2;			}			if (shifted >= (2)) {				shifted = shifted >>> 1;				++bitNo;			}			oldBitLen = (bitNo + shifted) + (8 * (realLength - 1));			/* end cHighBit: */		}		/* end cDigitHighBit:len: */		oldDigitLen = (oldBitLen + 7) >> 3;		newBitLen = oldBitLen - rShift;		if (newBitLen <= 0) {			aLargeInteger = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);		} else {			newByteLen = (newBitLen + 7) >> 3;					newOop = (function(__size) {const __result = aLarge._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);			/* begin cDigitRshift:from:len:to:len: */			pFrom1 = BYTESOF(aLarge);			pTo1 = BYTESOF(newOop);			digitShift1 = rShift >> 3;			bitShift1 = MOD(rShift, 8);			if (bitShift1 === 0) {				{				// inlining self cDigitCopyFrom: pFrom1 + digitShift1 to: pTo1 + 0 len: newByteLen - 1 - 0 + 1				for (let i = 0; i < newByteLen; i++) 					pTo1[i] = pFrom1[i + digitShift1];				}			} else {				leftShift = 8 - bitShift1;				carry1 = SHR(pFrom1[digitShift1], bitShift1);				start = digitShift1 + 1;				limit1 = oldDigitLen - 1;				for (j = start; j <= limit1; j++) {					digit1 = pFrom1[j];					pTo1[j - start] = (UBANDS((UBOR(carry1, (SHL(digit1, leftShift)))), 255));					carry1 = SHR(digit1, bitShift1);				}				if (carry1 !== 0) {					pTo1[newByteLen - 1] = carry1;				}			}			/* end cDigitRshift:from:len:to:len: */			aLargeInteger = newOop;		}		/* end digit:Rshift:lookfirst: */		if (aLargeInteger._class() === SmalltalkGlobals._LargePositiveInteger) {			/* begin normalizePositive: */			len = (typeof aLargeInteger === "number") ? ((oldLen4 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen4 = SIZEOF(aLargeInteger)));			while ((len !== 0) && (BYTESOF(aLargeInteger)[len - 1] === 0)) {				--len;			}			if (len === 0) {				arg12 = 0;			} else {				sLen = 4;				if ((len <= sLen) && (((sLen > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {					val2 = 0;					for (i3 = len; i3 >= 1; i3--) {						val2 = (val2 * 256) + BYTESOF(aLargeInteger)[i3 - 1];					}					arg12 = val2;				} else {					if (len < oldLen4) {						/* begin bytes:growTo: */											newBytes3 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);						oldLen1 = BYTESIZEOF(aLargeInteger);						copyLen = (oldLen1 < len) ? oldLen1 : len;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes3), copyLen);						arg12 = newBytes3;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizePositive: */		} else {			/* begin normalizeNegative: */			len1 = (typeof aLargeInteger === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(aLargeInteger))) : ((oldLen3 = SIZEOF(aLargeInteger)));			while ((len1 !== 0) && (BYTESOF(aLargeInteger)[len1 - 1] === 0)) {				--len1;			}			if (len1 === 0) {				arg12 = 0;			} else {				sLen1 = 4;				if (len1 <= sLen1) {					minVal = -1073741824;					if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {						val1 = 0;						for (i2 = len1; i2 >= 1; i2--) {							val1 = (val1 * 256) - BYTESOF(aLargeInteger)[i2 - 1];						}						arg12 = val1;					} else {						brokenFromLoop_normalizeNegative_2202 = false;						for (i11 = 1; i11 <= sLen1; i11++) {							if (((i11 > BYTESIZEOF(aLargeInteger)	? 0	: BYTESOF(aLargeInteger)[i11 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i11 - 1) * 8))), 255))) {								if (len1 < oldLen3) {									/* begin bytes:growTo: */																	newBytes2 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);									oldLen11 = BYTESIZEOF(aLargeInteger);									copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;									LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes2), copyLen2);									returnValueFromLoop_normalizeNegative_2202 = newBytes2;									/* end bytes:growTo: */								} else {									returnValueFromLoop_normalizeNegative_2202 = aLargeInteger;								}								brokenFromLoop_normalizeNegative_2202 = true;								break;							}						}						arg12 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;					}				} else {					if (len1 < oldLen3) {						/* begin bytes:growTo: */											newBytes1 = (function(__size) {const __result = aLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);						oldLen2 = BYTESIZEOF(aLargeInteger);						copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(aLargeInteger), BYTESOF(newBytes1), copyLen1);						arg12 = newBytes1;						/* end bytes:growTo: */					} else {						arg12 = aLargeInteger;					}				}			}			/* end normalizeNegative: */		}		/* end normalize: */		throw Object.create(PrimitiveReturn).setPayload(arg12);	}}, /*	Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails. */primDigitBitXor(secondInteger) {	let firstInteger;	let arg11;	let shortLen;	let shortLarge;	let firstLarge;	let secondLarge;	let longLen;	let longLarge;	let firstLen;	let secondLen;	let result;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let pByteShort;	let pByteLong;	let pByteRes;	let i2;	let i;	let i1;	let limit;	let i13;	let i12;	let i11;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	/* begin digitBitLogic:with:opIndex: */	if ((typeof firstInteger === "number")) {		if (firstInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val = firstInteger;		sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));		res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);		pByte = BYTESOF(res);		for (ix = 1; ix <= size; ix++) {			byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);			pByte[ix - 1] = byte;		}		firstLarge = res;		/* end createLargeFromSmallInteger: */		}	} else {		if (firstInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			firstLarge = firstInteger;		}	}	if ((typeof secondInteger === "number")) {		if (secondInteger < 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {					/* begin createLargeFromSmallInteger: */		val1 = secondInteger;		class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));		res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);		pByte1 = BYTESOF(res1);		for (ix1 = 1; ix1 <= size1; ix1++) {			byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);			pByte1[ix1 - 1] = byte1;		}		secondLarge = res1;		/* end createLargeFromSmallInteger: */		}	} else {		if (secondInteger._class() === SmalltalkGlobals._LargeNegativeInteger) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			secondLarge = secondInteger;		}	}	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen < secondLen) {		shortLen = firstLen;		shortLarge = firstLarge;		longLen = secondLen;		longLarge = secondLarge;	} else {		shortLen = secondLen;		shortLarge = secondLarge;		longLen = firstLen;		longLarge = firstLarge;	}	result = (function(__size) {const __result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(longLen);	/* begin cDigitOp:short:len:long:len:into: */	pByteShort = BYTESOF(shortLarge);	pByteLong = BYTESOF(longLarge);	pByteRes = BYTESOF(result);	limit = shortLen - 1;	if (xorOpIndex === andOpIndex) {		for (i = 0; i <= limit; i++) {			pByteRes[i] = (UBAND(pByteShort[i], pByteLong[i]));		}		limit = longLen - 1;		for (i1 = shortLen; i1 <= limit; i1++) {			pByteRes[i1] = 0;		}	} else {		if (xorOpIndex === orOpIndex) {			for (i11 = 0; i11 <= limit; i11++) {				pByteRes[i11] = (UBOR(pByteShort[i11], pByteLong[i11]));			}			limit = longLen - 1;			for (i12 = shortLen; i12 <= limit; i12++) {				pByteRes[i12] = pByteLong[i12];			}		} else {			if (xorOpIndex === xorOpIndex) {				for (i13 = 0; i13 <= limit; i13++) {					pByteRes[i13] = (UBXOR(pByteShort[i13], pByteLong[i13]));				}				limit = longLen - 1;				for (i2 = shortLen; i2 <= limit; i2++) {					pByteRes[i2] = pByteLong[i2];				}			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		}	}	/* end cDigitOp:short:len:long:len:into: */	/* begin normalizePositive: */len = (typeof result === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(result))) : ((oldLen = SIZEOF(result)));while ((len !== 0) && (BYTESOF(result)[len - 1] === 0)) {	--len;}if (len === 0) {	arg11 = 0;} else {	sLen = 4;	if ((len <= sLen) && (((sLen > BYTESIZEOF(result)	? 0	: BYTESOF(result)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {		val2 = 0;		for (i3 = len; i3 >= 1; i3--) {			val2 = (val2 * 256) + BYTESOF(result)[i3 - 1];		}		arg11 = val2;	} else {		if (len < oldLen) {			/* begin bytes:growTo: */					newBytes = (function(__size) {const __result = result._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);			oldLen1 = BYTESIZEOF(result);			copyLen = (oldLen1 < len) ? oldLen1 : len;			LargeIntegers.cDigitCopyFromtolen(BYTESOF(result), BYTESOF(newBytes), copyLen);			arg11 = newBytes;			/* end bytes:growTo: */		} else {			arg11 = result;		}	}}/* end normalizePositive: */	/* end digitBitLogic:with:opIndex: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitCompare(secondInteger) {	let firstVal;	let firstInteger;	let secondVal;	let arg11;	let secondLen;	let firstLen;	let firstDigit;	let secondDigit;	let ix;	let returnValueFromLoop_cDigitComparewithlen_2304;	let brokenFromLoop_cDigitComparewithlen_2304;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* first */		if ((typeof secondInteger === "number")) {			/* second */			if (((firstVal = firstInteger)) > ((secondVal = secondInteger))) {				throw Object.create(PrimitiveReturn).setPayload(1);			} else {				if (firstVal < secondVal) {					throw Object.create(PrimitiveReturn).setPayload(-1);				} else {					throw Object.create(PrimitiveReturn).setPayload(0);				}			}		} else {			/* SECOND */			throw Object.create(PrimitiveReturn).setPayload(-1);		}	} else {		/* FIRST */		if ((typeof secondInteger === "number")) {			/* second */			throw Object.create(PrimitiveReturn).setPayload(1);		} else {			/* SECOND */			/* begin digitCompareLarge:with: */			firstLen = SIZEOF(firstInteger);			secondLen = SIZEOF(secondInteger);			if (secondLen !== firstLen) {				arg11 = (secondLen > firstLen) ? -1 : 1;			} else {				/* begin cDigitCompare:with:len: */				ix = firstLen - 1;				brokenFromLoop_cDigitComparewithlen_2304 = false;				while (ix >= 0) {					if (((secondDigit = BYTESOF(secondInteger)[ix])) !== ((firstDigit = BYTESOF(firstInteger)[ix]))) {						returnValueFromLoop_cDigitComparewithlen_2304 = (secondDigit < firstDigit) ? 1 : -1;						brokenFromLoop_cDigitComparewithlen_2304 = true;						break;					} else {						--ix;					}				}				arg11 = ((brokenFromLoop_cDigitComparewithlen_2304	? returnValueFromLoop_cDigitComparewithlen_2304	: 0));				/* end cDigitCompare:with:len: */			}			/* end digitCompareLarge:with: */			throw Object.create(PrimitiveReturn).setPayload(arg11);		}	}}, primDigitCompareWith(firstInteger, secondInteger) {	let firstVal;	let secondVal;	let arg11;	let secondLen;	let firstLen;	let firstDigit;	let secondDigit;	let ix;	let returnValueFromLoop_cDigitComparewithlen_2304;	let brokenFromLoop_cDigitComparewithlen_2304;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof firstInteger === "number")) {		/* first */		if ((typeof secondInteger === "number")) {			/* second */			if (((firstVal = firstInteger)) > ((secondVal = secondInteger))) {				throw Object.create(PrimitiveReturn).setPayload(1);			} else {				if (firstVal < secondVal) {					throw Object.create(PrimitiveReturn).setPayload(-1);				} else {					throw Object.create(PrimitiveReturn).setPayload(0);				}			}		} else {			/* SECOND */			throw Object.create(PrimitiveReturn).setPayload(-1);		}	} else {		/* FIRST */		if ((typeof secondInteger === "number")) {			/* second */			throw Object.create(PrimitiveReturn).setPayload(1);		} else {			/* SECOND */			/* begin digitCompareLarge:with: */			firstLen = SIZEOF(firstInteger);			secondLen = SIZEOF(secondInteger);			if (secondLen !== firstLen) {				arg11 = (secondLen > firstLen) ? -1 : 1;			} else {				/* begin cDigitCompare:with:len: */				ix = firstLen - 1;				brokenFromLoop_cDigitComparewithlen_2304 = false;				while (ix >= 0) {					if (((secondDigit = BYTESOF(secondInteger)[ix])) !== ((firstDigit = BYTESOF(firstInteger)[ix]))) {						returnValueFromLoop_cDigitComparewithlen_2304 = (secondDigit < firstDigit) ? 1 : -1;						brokenFromLoop_cDigitComparewithlen_2304 = true;						break;					} else {						--ix;					}				}				arg11 = ((brokenFromLoop_cDigitComparewithlen_2304	? returnValueFromLoop_cDigitComparewithlen_2304	: 0));				/* end cDigitCompare:with:len: */			}			/* end digitCompareLarge:with: */			throw Object.create(PrimitiveReturn).setPayload(arg11);		}	}}, /*	Answer the result of dividing firstInteger by secondInteger. 	Fail if parameters are not integers, not normalized or secondInteger is 	zero.  */primDigitDivNegative(secondInteger, neg) {	let firstAsLargeInteger;	let firstInteger;	let secondAsLargeInteger;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let len;	let sLen;	let minVal;	let ix2;	let maxVal;	let csi;	let returnValueFromLoop_isNormalized_3707;	let brokenFromLoop_isNormalized_3707;	let len1;	let sLen1;	let minVal1;	let ix3;	let maxVal1;	let csi1;	let returnValueFromLoop_isNormalized_3298;	let brokenFromLoop_isNormalized_3298;	let arg11;	let resultClass;	let result;	let rem;	let div;	let quo;	let d;	let l;	let secondLen;	let firstLen;	let csi6;	let csi11;	let csi2;	let csi3;	let csi4;	let csi5;	let arg111;	let shifted;	let bitNo;	let pDiv;	let divLen;	let pRem;	let remLen;	let quoLen;	let b;	let q;	let a;	let dnh;	let lo;	let hi;	let r3;	let mul;	let cond;	let l1;	let k;	let j;	let i;	let dl;	let ql;	let i1;	let r1r2;	let dh;	let t;	let highBit;	let newBytes;	let oldLen;	let newLen;	let pFrom;	let pTo;	let digitShift;	let carry;	let digit;	let i2;	let i11;	let bitShift;	let rshift;	let limit;	let highBit1;	let newBytes1;	let oldLen1;	let newLen1;	let pFrom1;	let pTo1;	let digitShift1;	let carry1;	let digit1;	let i3;	let i12;	let bitShift1;	let rshift1;	let limit1;	let len2;	let class2;	let val2;	let newBytes2;	let pByte2;	let ix4;	let oldLen2;	let newBytes11;	let copyLen;	let len11;	let class11;	let val11;	let newBytes3;	let pByte11;	let ix11;	let oldLen3;	let newBytes12;	let copyLen1;	let a1;	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	let pFrom2;	let pTo2;	let j1;	let digitShift2;	let carry2;	let digit2;	let bitShift2;	let leftShift;	let limit2;	let start;	let lastDigit;	let realLength;	let shifted1;	let bitNo1;	let brokenFromLoop_cDigitHighBitlen_1220;	let arg12;	let resultClass1;	let result1;	let rem1;	let div1;	let quo1;	let d1;	let l2;	let secondLen1;	let firstLen1;	let csi7;	let csi12;	let csi21;	let csi31;	let csi41;	let csi51;	let arg112;	let shifted2;	let bitNo2;	let pDiv1;	let divLen1;	let pRem1;	let remLen1;	let quoLen1;	let b1;	let q1;	let a2;	let dnh1;	let lo1;	let hi1;	let r31;	let mul1;	let cond1;	let l11;	let k1;	let j2;	let i4;	let dl1;	let ql1;	let i13;	let r1r21;	let dh1;	let t1;	let highBit2;	let newBytes4;	let oldLen4;	let newLen2;	let pFrom3;	let pTo3;	let digitShift3;	let carry3;	let digit3;	let i21;	let i111;	let bitShift3;	let rshift2;	let limit3;	let highBit11;	let newBytes13;	let oldLen11;	let newLen11;	let pFrom11;	let pTo11;	let digitShift11;	let carry11;	let digit11;	let i31;	let i121;	let bitShift11;	let rshift11;	let limit11;	let len3;	let class3;	let val3;	let newBytes21;	let pByte3;	let ix5;	let oldLen21;	let newBytes111;	let copyLen2;	let len12;	let class12;	let val12;	let newBytes31;	let pByte12;	let ix12;	let oldLen31;	let newBytes121;	let copyLen11;	let a11;	let newOop1;	let oldDigitLen1;	let newByteLen1;	let newBitLen1;	let oldBitLen1;	let pFrom21;	let pTo21;	let j11;	let digitShift21;	let carry21;	let digit21;	let bitShift21;	let leftShift1;	let limit21;	let start1;	let lastDigit1;	let realLength1;	let shifted11;	let bitNo11;	let brokenFromLoop_cDigitHighBitlen_12201;	let arg13;	let resultClass2;	let result2;	let rem2;	let div2;	let quo2;	let d2;	let l3;	let secondLen2;	let firstLen2;	let csi8;	let csi13;	let csi22;	let csi32;	let csi42;	let csi52;	let arg113;	let shifted3;	let bitNo3;	let pDiv2;	let divLen2;	let pRem2;	let remLen2;	let quoLen2;	let b2;	let q2;	let a3;	let dnh2;	let lo2;	let hi2;	let r32;	let mul2;	let cond2;	let l12;	let k2;	let j3;	let i5;	let dl2;	let ql2;	let i14;	let r1r22;	let dh2;	let t2;	let highBit3;	let newBytes5;	let oldLen5;	let newLen3;	let pFrom4;	let pTo4;	let digitShift4;	let carry4;	let digit4;	let i22;	let i112;	let bitShift4;	let rshift3;	let limit4;	let highBit12;	let newBytes14;	let oldLen12;	let newLen12;	let pFrom12;	let pTo12;	let digitShift12;	let carry12;	let digit12;	let i32;	let i122;	let bitShift12;	let rshift12;	let limit12;	let len4;	let class4;	let val4;	let newBytes22;	let pByte4;	let ix6;	let oldLen22;	let newBytes112;	let copyLen3;	let len13;	let class13;	let val13;	let newBytes32;	let pByte13;	let ix13;	let oldLen32;	let newBytes122;	let copyLen12;	let a12;	let newOop2;	let oldDigitLen2;	let newByteLen2;	let newBitLen2;	let oldBitLen2;	let pFrom22;	let pTo22;	let j12;	let digitShift22;	let carry22;	let digit22;	let bitShift22;	let leftShift2;	let limit22;	let start2;	let lastDigit2;	let realLength2;	let shifted12;	let bitNo12;	let brokenFromLoop_cDigitHighBitlen_12202;	let arg14;	let resultClass3;	let result3;	let rem3;	let div3;	let quo3;	let d3;	let l4;	let secondLen3;	let firstLen3;	let csi9;	let csi14;	let csi23;	let csi33;	let csi43;	let csi53;	let arg114;	let shifted4;	let bitNo4;	let pDiv3;	let divLen3;	let pRem3;	let remLen3;	let quoLen3;	let b3;	let q3;	let a4;	let dnh3;	let lo3;	let hi3;	let r33;	let mul3;	let cond3;	let l13;	let k3;	let j4;	let i6;	let dl3;	let ql3;	let i15;	let r1r23;	let dh3;	let t3;	let highBit4;	let newBytes6;	let oldLen6;	let newLen4;	let pFrom5;	let pTo5;	let digitShift5;	let carry5;	let digit5;	let i23;	let i113;	let bitShift5;	let rshift4;	let limit5;	let highBit13;	let newBytes15;	let oldLen13;	let newLen13;	let pFrom13;	let pTo13;	let digitShift13;	let carry13;	let digit13;	let i33;	let i123;	let bitShift13;	let rshift13;	let limit13;	let len5;	let class5;	let val5;	let newBytes23;	let pByte5;	let ix7;	let oldLen23;	let newBytes113;	let copyLen4;	let len14;	let class14;	let val14;	let newBytes33;	let pByte14;	let ix14;	let oldLen33;	let newBytes123;	let copyLen13;	let a13;	let newOop3;	let oldDigitLen3;	let newByteLen3;	let newBitLen3;	let oldBitLen3;	let pFrom23;	let pTo23;	let j13;	let digitShift23;	let carry23;	let digit23;	let bitShift23;	let leftShift3;	let limit23;	let start3;	let lastDigit3;	let realLength3;	let shifted13;	let bitNo13;	let brokenFromLoop_cDigitHighBitlen_12203;	let arg15;	let resultClass4;	let result4;	let rem4;	let div4;	let quo4;	let d4;	let l5;	let secondLen4;	let firstLen4;	let csi10;	let csi15;	let csi24;	let csi34;	let csi44;	let csi54;	let arg115;	let shifted5;	let bitNo5;	let pDiv4;	let divLen4;	let pRem4;	let remLen4;	let quoLen4;	let b4;	let q4;	let a5;	let dnh4;	let lo4;	let hi4;	let r34;	let mul4;	let cond4;	let l14;	let k4;	let j5;	let i7;	let dl4;	let ql4;	let i16;	let r1r24;	let dh4;	let t4;	let highBit5;	let newBytes7;	let oldLen7;	let newLen5;	let pFrom6;	let pTo6;	let digitShift6;	let carry6;	let digit6;	let i24;	let i114;	let bitShift6;	let rshift5;	let limit6;	let highBit14;	let newBytes16;	let oldLen14;	let newLen14;	let pFrom14;	let pTo14;	let digitShift14;	let carry14;	let digit14;	let i34;	let i124;	let bitShift14;	let rshift14;	let limit14;	let len6;	let class6;	let val6;	let newBytes24;	let pByte6;	let ix8;	let oldLen24;	let newBytes114;	let copyLen5;	let len15;	let class15;	let val15;	let newBytes34;	let pByte15;	let ix15;	let oldLen34;	let newBytes124;	let copyLen14;	let a14;	let newOop4;	let oldDigitLen4;	let newByteLen4;	let newBitLen4;	let oldBitLen4;	let pFrom24;	let pTo24;	let j14;	let digitShift24;	let carry24;	let digit24;	let bitShift24;	let leftShift4;	let limit24;	let start4;	let lastDigit4;	let realLength4;	let shifted14;	let bitNo14;	let brokenFromLoop_cDigitHighBitlen_12204;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof neg.valueOf() !== "boolean") throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	/* begin isNormalized: */	if ((typeof firstInteger === "number")) {		/* begin isNormalized: */		if ((typeof secondInteger === "number")) {			if ((typeof firstInteger === "number")) {				/* convert to LargeInteger */							/* begin createLargeFromSmallInteger: */			val = firstInteger;			sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;			size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));			res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);			pByte = BYTESOF(res);			for (ix = 1; ix <= size; ix++) {				byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);				pByte[ix - 1] = byte;			}			firstAsLargeInteger = res;			/* end createLargeFromSmallInteger: */			} else {				firstAsLargeInteger = firstInteger;			}			if ((typeof secondInteger === "number")) {				/* check for zerodivide and convert to LargeInteger */				if (secondInteger === 0) {					throw Object.create(PrimitiveFailed).setPayload(1);				}							/* begin createLargeFromSmallInteger: */			val1 = secondInteger;			class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;			size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));			res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);			pByte1 = BYTESOF(res1);			for (ix1 = 1; ix1 <= size1; ix1++) {				byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);				pByte1[ix1 - 1] = byte1;			}			secondAsLargeInteger = res1;			/* end createLargeFromSmallInteger: */			} else {				secondAsLargeInteger = secondInteger;			}			/* begin digitDivLarge:with:negative: */			firstLen = SIZEOF(firstAsLargeInteger);			secondLen = SIZEOF(secondAsLargeInteger);			resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;			l = (firstLen - secondLen) + 1;			if (l <= 0) {							result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);				result[1] = 0;				result[2] = firstAsLargeInteger;				arg11 = result;			} else {				/* begin cHighBit: */				shifted = BYTESOF(secondAsLargeInteger)[secondLen - 1];				bitNo = 0;				if (shifted >= (65536)) {					shifted = shifted >>> 16;					bitNo += 16;				}				if (shifted >= (256)) {					shifted = shifted >>> 8;					bitNo += 8;				}				if (shifted >= (16)) {					shifted = shifted >>> 4;					bitNo += 4;				}				if (shifted >= (4)) {					shifted = shifted >>> 2;					bitNo += 2;				}				if (shifted >= (2)) {					shifted = shifted >>> 1;					++bitNo;				}				arg111 = bitNo + shifted;				/* end cHighBit: */				d = 8 - arg111;							/* begin digit:Lshift: */			oldLen = SIZEOF(secondAsLargeInteger);			if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen))) === 0) {				div = 0;			} else {				newLen = ((highBit + d) + 7) >> 3;							newBytes = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);				/* begin cDigitLshift:from:len:to:len: */				pFrom = BYTESOF(secondAsLargeInteger);				pTo = BYTESOF(newBytes);				digitShift = d >> 3;				bitShift = MOD(d, 8);				limit = digitShift - 1;				for (i2 = 0; i2 <= limit; i2++) {					pTo[i2] = 0;				}				if (bitShift === 0) {					{					// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1					const len = newLen - digitShift					for (let i = 0; i < len; i++) 						pTo[i + digitShift] = pFrom[i];					}				} else {					rshift = 8 - bitShift;					carry = 0;					limit = oldLen - 1;					for (i11 = 0; i11 <= limit; i11++) {						digit = pFrom[i11];						pTo[i11 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));						carry = SHR(digit, rshift);					}					if (carry !== 0) {						pTo[newLen - 1] = carry;					}				}				/* end cDigitLshift:from:len:to:len: */				div = newBytes;			}			/* end digit:Lshift: */			/* begin largeIntOrInt:growTo: */			if ((typeof div === "number")) {				/* begin cDigitLengthOfCSI: */				csi6 = div;				len2 = ((csi6 >= 0) ? ((csi6 < 256) ? 1 : ((csi6 < 65536) ? 2 : ((csi6 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi6 < 4294967296) ? 4 : ((csi6 < 1099511627776) ? 5 : ((csi6 < 281474976710656) ? 6 : ((csi6 < 72057594037927936) ? 7 : 8)))))))) : ((csi6 > -256) ? 1 : ((csi6 > -65536) ? 2 : ((csi6 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi6 > -4294967296) ? 4 : ((csi6 > -1099511627776) ? 5 : ((csi6 > -281474976710656) ? 6 : ((csi6 > -72057594037927936) ? 7 : 8))))))))) + 1;				/* end cDigitLengthOfCSI: */			} else {				len2 = SIZEOF(div) + 1;			}			if ((typeof div === "number")) {				val2 = div;				class2 = (val2 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;				newBytes2 = (function(__size) {const __result = class2.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len2);				/* begin cCopyIntVal:toBytes: */				pByte2 = BYTESOF(newBytes2);				const ixLimiT = (val2 >= 0) ? ((val2 < 256) ? 1 : ((val2 < 65536) ? 2 : ((val2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val2 < 4294967296) ? 4 : ((val2 < 1099511627776) ? 5 : ((val2 < 281474976710656) ? 6 : ((val2 < 72057594037927936) ? 7 : 8)))))))) : ((val2 > -256) ? 1 : ((val2 > -65536) ? 2 : ((val2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val2 > -4294967296) ? 4 : ((val2 > -1099511627776) ? 5 : ((val2 > -281474976710656) ? 6 : ((val2 > -72057594037927936) ? 7 : 8))))))));				for (ix4 = 1; ix4 <= ixLimiT; ix4++) {					pByte2[ix4 - 1] = (UBANDS((SHR(((val2 < 0) ? (0 - val2) : val2), ((ix4 - 1) * 8))), 255));				}				/* end cCopyIntVal:toBytes: */			} else {				/* begin largeInt:growTo: */							newBytes11 = (function(__size) {const __result = div._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len2);				oldLen2 = SIZEOF(div);				copyLen = (oldLen2 < len2) ? oldLen2 : len2;				LargeIntegers.cDigitCopyFromtolen(BYTESOF(div), BYTESOF(newBytes11), copyLen);				newBytes2 = newBytes11;				/* end largeInt:growTo: */			}			div = newBytes2;			/* end largeIntOrInt:growTo: */							/* begin digit:Lshift: */			oldLen1 = SIZEOF(firstAsLargeInteger);			if (((highBit1 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen1))) === 0) {				rem = 0;			} else {				newLen1 = ((highBit1 + d) + 7) >> 3;							newBytes1 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen1);				/* begin cDigitLshift:from:len:to:len: */				pFrom1 = BYTESOF(firstAsLargeInteger);				pTo1 = BYTESOF(newBytes1);				digitShift1 = d >> 3;				bitShift1 = MOD(d, 8);				limit1 = digitShift1 - 1;				for (i3 = 0; i3 <= limit1; i3++) {					pTo1[i3] = 0;				}				if (bitShift1 === 0) {					{					// inlining self cDigitCopyFrom: pFrom1 + 0 to: pTo1 + digitShift1 len: newLen1 - 1 - digitShift1 + 1					const len = newLen1 - digitShift1					for (let i = 0; i < len; i++) 						pTo1[i + digitShift1] = pFrom1[i];					}				} else {					rshift1 = 8 - bitShift1;					carry1 = 0;					limit1 = oldLen1 - 1;					for (i12 = 0; i12 <= limit1; i12++) {						digit1 = pFrom1[i12];						pTo1[i12 + digitShift1] = (UBANDS((UBOR(carry1, (SHL(digit1, bitShift1)))), 255));						carry1 = SHR(digit1, rshift1);					}					if (carry1 !== 0) {						pTo1[newLen1 - 1] = carry1;					}				}				/* end cDigitLshift:from:len:to:len: */				rem = newBytes1;			}			/* end digit:Lshift: */			let rec1;if ((typeof rem === "number")) {				/* begin cDigitLengthOfCSI: */				csi11 = rem;				rec1 = ((csi11 >= 0) ? ((csi11 < 256) ? 1 : ((csi11 < 65536) ? 2 : ((csi11 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi11 < 4294967296) ? 4 : ((csi11 < 1099511627776) ? 5 : ((csi11 < 281474976710656) ? 6 : ((csi11 < 72057594037927936) ? 7 : 8)))))))) : ((csi11 > -256) ? 1 : ((csi11 > -65536) ? 2 : ((csi11 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi11 > -4294967296) ? 4 : ((csi11 > -1099511627776) ? 5 : ((csi11 > -281474976710656) ? 6 : ((csi11 > -72057594037927936) ? 7 : 8))))))))) === firstLen;				/* end cDigitLengthOfCSI: */			} else {				rec1 = SIZEOF(rem) === firstLen;			};if (rec1) {				/* begin largeIntOrInt:growTo: */				len11 = firstLen + 1;				if ((typeof rem === "number")) {					val11 = rem;					class11 = (val11 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;					newBytes3 = (function(__size) {const __result = class11.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len11);					/* begin cCopyIntVal:toBytes: */					pByte11 = BYTESOF(newBytes3);					const ixLimiT = (val11 >= 0) ? ((val11 < 256) ? 1 : ((val11 < 65536) ? 2 : ((val11 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val11 < 4294967296) ? 4 : ((val11 < 1099511627776) ? 5 : ((val11 < 281474976710656) ? 6 : ((val11 < 72057594037927936) ? 7 : 8)))))))) : ((val11 > -256) ? 1 : ((val11 > -65536) ? 2 : ((val11 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val11 > -4294967296) ? 4 : ((val11 > -1099511627776) ? 5 : ((val11 > -281474976710656) ? 6 : ((val11 > -72057594037927936) ? 7 : 8))))))));					for (ix11 = 1; ix11 <= ixLimiT; ix11++) {						pByte11[ix11 - 1] = (UBANDS((SHR(((val11 < 0) ? (0 - val11) : val11), ((ix11 - 1) * 8))), 255));					}					/* end cCopyIntVal:toBytes: */				} else {					/* begin largeInt:growTo: */									newBytes12 = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len11);					oldLen3 = SIZEOF(rem);					copyLen1 = (oldLen3 < len11) ? oldLen3 : len11;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem), BYTESOF(newBytes12), copyLen1);					newBytes3 = newBytes12;					/* end largeInt:growTo: */				}				rem = newBytes3;				/* end largeIntOrInt:growTo: */			}							quo = (function(__size) {const __result = resultClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l);				/* begin cDigitDiv:len:rem:len:quo:len: */				pDiv = BYTESOF(div);				if ((typeof div === "number")) {					/* begin cDigitLengthOfCSI: */					csi2 = div;					divLen = (csi2 >= 0) ? ((csi2 < 256) ? 1 : ((csi2 < 65536) ? 2 : ((csi2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 < 4294967296) ? 4 : ((csi2 < 1099511627776) ? 5 : ((csi2 < 281474976710656) ? 6 : ((csi2 < 72057594037927936) ? 7 : 8)))))))) : ((csi2 > -256) ? 1 : ((csi2 > -65536) ? 2 : ((csi2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 > -4294967296) ? 4 : ((csi2 > -1099511627776) ? 5 : ((csi2 > -281474976710656) ? 6 : ((csi2 > -72057594037927936) ? 7 : 8))))))));					/* end cDigitLengthOfCSI: */				} else {					divLen = SIZEOF(div);				}				pRem = BYTESOF(rem);				if ((typeof rem === "number")) {					/* begin cDigitLengthOfCSI: */					csi3 = rem;					remLen = (csi3 >= 0) ? ((csi3 < 256) ? 1 : ((csi3 < 65536) ? 2 : ((csi3 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 < 4294967296) ? 4 : ((csi3 < 1099511627776) ? 5 : ((csi3 < 281474976710656) ? 6 : ((csi3 < 72057594037927936) ? 7 : 8)))))))) : ((csi3 > -256) ? 1 : ((csi3 > -65536) ? 2 : ((csi3 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 > -4294967296) ? 4 : ((csi3 > -1099511627776) ? 5 : ((csi3 > -281474976710656) ? 6 : ((csi3 > -72057594037927936) ? 7 : 8))))))));					/* end cDigitLengthOfCSI: */				} else {					remLen = SIZEOF(rem);				}				if ((typeof quo === "number")) {					/* begin cDigitLengthOfCSI: */					csi4 = quo;					quoLen = (csi4 >= 0) ? ((csi4 < 256) ? 1 : ((csi4 < 65536) ? 2 : ((csi4 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 < 4294967296) ? 4 : ((csi4 < 1099511627776) ? 5 : ((csi4 < 281474976710656) ? 6 : ((csi4 < 72057594037927936) ? 7 : 8)))))))) : ((csi4 > -256) ? 1 : ((csi4 > -65536) ? 2 : ((csi4 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 > -4294967296) ? 4 : ((csi4 > -1099511627776) ? 5 : ((csi4 > -281474976710656) ? 6 : ((csi4 > -72057594037927936) ? 7 : 8))))))));					/* end cDigitLengthOfCSI: */				} else {					quoLen = SIZEOF(quo);				}				dl = divLen - 1;				ql = quoLen;				dh = pDiv[dl - 1];				dnh = (dl === 1) ? 0 : pDiv[dl - 2];				for (k = 1; k <= ql; k++) {					j = remLen + 1 - k;					if (pRem[j - 1] === dh) {						q = 255;					} else {						r1r2 = pRem[j - 1];						r1r2 = (r1r2 << 8 >>> 0) + pRem[j - 2];						t = MOD(r1r2, dh);						q = Math.trunc(r1r2 / dh);						mul = q * dnh;						hi = mul >>> 8;						lo = UBANDS(mul, 255);						r3 = (j < 3) ? 0 : pRem[j - 3];						while (true) {							if ((t < hi) || ((t === hi) && (r3 < lo))) {								--q;								if (hi === 0) {									cond = false;								} else {									if (lo < dnh) {										--hi;										lo = lo + 256 - dnh;									} else {										lo -= dnh;									}									cond = hi >= dh;								}							} else {								cond = false;							}														if (!(cond)) break;							hi -= dh;						}					}					l1 = j - dl;					a = 0;					for (i = 1; i <= divLen; i++) {						hi = pDiv[i - 1] * (q >>> 8);						lo = pDiv[i - 1] * (UBANDS(q, 255));						b = (pRem[l1 - 1] - a) - (UBANDS(lo, 255));						pRem[l1 - 1] = (UBANDS(b, 255));						b = b >> 8;						a = (hi + (lo >>> 8)) - b;						++l1;					}					if (a > 0) {						--q;						l1 = j - dl;						a = 0;						for (i1 = 1; i1 <= divLen; i1++) {							a = ((a >>> 8) + pRem[l1 - 1]) + pDiv[i1 - 1];							pRem[l1 - 1] = (UBANDS(a, 255));							++l1;						}					}					BYTESOF(quo)[quoLen - k] = q;				}				/* end cDigitDiv:len:rem:len:quo:len: */							/* begin digit:Rshift:lookfirst: */			if ((typeof div === "number")) {				/* begin cDigitLengthOfCSI: */				csi5 = div;				a1 = ((csi5 >= 0) ? ((csi5 < 256) ? 1 : ((csi5 < 65536) ? 2 : ((csi5 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 < 4294967296) ? 4 : ((csi5 < 1099511627776) ? 5 : ((csi5 < 281474976710656) ? 6 : ((csi5 < 72057594037927936) ? 7 : 8)))))))) : ((csi5 > -256) ? 1 : ((csi5 > -65536) ? 2 : ((csi5 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 > -4294967296) ? 4 : ((csi5 > -1099511627776) ? 5 : ((csi5 > -281474976710656) ? 6 : ((csi5 > -72057594037927936) ? 7 : 8))))))))) - 1;				/* end cDigitLengthOfCSI: */			} else {				a1 = SIZEOF(div) - 1;			}			/* begin cDigitHighBit:len: */			realLength = a1;			brokenFromLoop_cDigitHighBitlen_1220 = false;			while (((lastDigit = BYTESOF(rem)[realLength - 1])) === 0) {				if (((--realLength)) === 0) {					oldBitLen = 0;					brokenFromLoop_cDigitHighBitlen_1220 = true;					break;				}			}			if (!brokenFromLoop_cDigitHighBitlen_1220) {				/* begin cHighBit: */				shifted1 = lastDigit;				bitNo1 = 0;				if (shifted1 >= (65536)) {					shifted1 = shifted1 >>> 16;					bitNo1 += 16;				}				if (shifted1 >= (256)) {					shifted1 = shifted1 >>> 8;					bitNo1 += 8;				}				if (shifted1 >= (16)) {					shifted1 = shifted1 >>> 4;					bitNo1 += 4;				}				if (shifted1 >= (4)) {					shifted1 = shifted1 >>> 2;					bitNo1 += 2;				}				if (shifted1 >= (2)) {					shifted1 = shifted1 >>> 1;					++bitNo1;				}				oldBitLen = (bitNo1 + shifted1) + (8 * (realLength - 1));				/* end cHighBit: */			}			/* end cDigitHighBit:len: */			oldDigitLen = (oldBitLen + 7) >> 3;			newBitLen = oldBitLen - d;			if (newBitLen <= 0) {				rem = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);			} else {				newByteLen = (newBitLen + 7) >> 3;							newOop = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);				/* begin cDigitRshift:from:len:to:len: */				pFrom2 = BYTESOF(rem);				pTo2 = BYTESOF(newOop);				digitShift2 = d >> 3;				bitShift2 = MOD(d, 8);				if (bitShift2 === 0) {					{					// inlining self cDigitCopyFrom: pFrom2 + digitShift2 to: pTo2 + 0 len: newByteLen - 1 - 0 + 1					for (let i = 0; i < newByteLen; i++) 						pTo2[i] = pFrom2[i + digitShift2];					}				} else {					leftShift = 8 - bitShift2;					carry2 = SHR(pFrom2[digitShift2], bitShift2);					start = digitShift2 + 1;					limit2 = oldDigitLen - 1;					for (j1 = start; j1 <= limit2; j1++) {						digit2 = pFrom2[j1];						pTo2[j1 - start] = (UBANDS((UBOR(carry2, (SHL(digit2, leftShift)))), 255));						carry2 = SHR(digit2, bitShift2);					}					if (carry2 !== 0) {						pTo2[newByteLen - 1] = carry2;					}				}				/* end cDigitRshift:from:len:to:len: */				rem = newOop;			}			/* end digit:Rshift:lookfirst: */							result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);				result[1] = quo;				result[2] = rem;				arg11 = result;			}			/* end digitDivLarge:with:negative: */			throw Object.create(PrimitiveReturn).setPayload(arg11);		} else {			if ((typeof secondInteger === "number")) {				/* begin cDigitLengthOfCSI: */				csi = secondInteger;				len = (csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))));				/* end cDigitLengthOfCSI: */			} else {				len = SIZEOF(secondInteger);			}			if (len === 0) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				if (BYTESOF(secondInteger)[len - 1] === 0) {					throw Object.create(PrimitiveFailed).setPayload(1);				} else {					sLen = 4;					if (len > sLen) {						if ((typeof firstInteger === "number")) {							/* convert to LargeInteger */													/* begin createLargeFromSmallInteger: */						val = firstInteger;						sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;						size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));						res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);						pByte = BYTESOF(res);						for (ix = 1; ix <= size; ix++) {							byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);							pByte[ix - 1] = byte;						}						firstAsLargeInteger = res;						/* end createLargeFromSmallInteger: */						} else {							firstAsLargeInteger = firstInteger;						}						if ((typeof secondInteger === "number")) {							/* check for zerodivide and convert to LargeInteger */							if (secondInteger === 0) {								throw Object.create(PrimitiveFailed).setPayload(1);							}													/* begin createLargeFromSmallInteger: */						val1 = secondInteger;						class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;						size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));						res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);						pByte1 = BYTESOF(res1);						for (ix1 = 1; ix1 <= size1; ix1++) {							byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);							pByte1[ix1 - 1] = byte1;						}						secondAsLargeInteger = res1;						/* end createLargeFromSmallInteger: */						} else {							secondAsLargeInteger = secondInteger;						}						throw Object.create(PrimitiveReturn).setPayload(arg11);					} else {						if (len < sLen) {							throw Object.create(PrimitiveFailed).setPayload(1);						} else {							if (secondInteger._class() === SmalltalkGlobals._LargePositiveInteger) {								maxVal = 1073741823;								if (BYTESOF(secondInteger)[sLen - 1] > (UBANDS((SHR(((maxVal < 0) ? (0 - maxVal) : maxVal), ((sLen - 1) * 8))), 255))) {									if ((typeof firstInteger === "number")) {																			/* begin createLargeFromSmallInteger: */									val = firstInteger;									sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));									res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);									pByte = BYTESOF(res);									for (ix = 1; ix <= size; ix++) {										byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);										pByte[ix - 1] = byte;									}									firstAsLargeInteger = res;									/* end createLargeFromSmallInteger: */									} else {										firstAsLargeInteger = firstInteger;									}									if ((typeof secondInteger === "number")) {										if (secondInteger === 0) {											throw Object.create(PrimitiveFailed).setPayload(1);										}																			/* begin createLargeFromSmallInteger: */									val1 = secondInteger;									class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));									res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);									pByte1 = BYTESOF(res1);									for (ix1 = 1; ix1 <= size1; ix1++) {										byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);										pByte1[ix1 - 1] = byte1;									}									secondAsLargeInteger = res1;									/* end createLargeFromSmallInteger: */									} else {										secondAsLargeInteger = secondInteger;									}									/* begin digitDivLarge:with:negative: */									firstLen1 = SIZEOF(firstAsLargeInteger);									secondLen1 = SIZEOF(secondAsLargeInteger);									resultClass1 = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									l2 = (firstLen1 - secondLen1) + 1;									if (l2 <= 0) {																			result1 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);										result1[1] = 0;										result1[2] = firstAsLargeInteger;										arg12 = result1;									} else {										/* begin cHighBit: */										shifted2 = BYTESOF(secondAsLargeInteger)[secondLen1 - 1];										bitNo2 = 0;										if (shifted2 >= (65536)) {											shifted2 = shifted2 >>> 16;											bitNo2 += 16;										}										if (shifted2 >= (256)) {											shifted2 = shifted2 >>> 8;											bitNo2 += 8;										}										if (shifted2 >= (16)) {											shifted2 = shifted2 >>> 4;											bitNo2 += 4;										}										if (shifted2 >= (4)) {											shifted2 = shifted2 >>> 2;											bitNo2 += 2;										}										if (shifted2 >= (2)) {											shifted2 = shifted2 >>> 1;											++bitNo2;										}										arg112 = bitNo2 + shifted2;										/* end cHighBit: */										d1 = 8 - arg112;																			/* begin digit:Lshift: */									oldLen4 = SIZEOF(secondAsLargeInteger);									if (((highBit2 = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen4))) === 0) {										div1 = 0;									} else {										newLen2 = ((highBit2 + d1) + 7) >> 3;																			newBytes4 = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen2);										/* begin cDigitLshift:from:len:to:len: */										pFrom3 = BYTESOF(secondAsLargeInteger);										pTo3 = BYTESOF(newBytes4);										digitShift3 = d1 >> 3;										bitShift3 = MOD(d1, 8);										limit3 = digitShift3 - 1;										for (i21 = 0; i21 <= limit3; i21++) {											pTo3[i21] = 0;										}										if (bitShift3 === 0) {											{											// inlining self cDigitCopyFrom: pFrom3 + 0 to: pTo3 + digitShift3 len: newLen2 - 1 - digitShift3 + 1											const len = newLen2 - digitShift3											for (let i = 0; i < len; i++) 												pTo3[i + digitShift3] = pFrom3[i];											}										} else {											rshift2 = 8 - bitShift3;											carry3 = 0;											limit3 = oldLen4 - 1;											for (i111 = 0; i111 <= limit3; i111++) {												digit3 = pFrom3[i111];												pTo3[i111 + digitShift3] = (UBANDS((UBOR(carry3, (SHL(digit3, bitShift3)))), 255));												carry3 = SHR(digit3, rshift2);											}											if (carry3 !== 0) {												pTo3[newLen2 - 1] = carry3;											}										}										/* end cDigitLshift:from:len:to:len: */										div1 = newBytes4;									}									/* end digit:Lshift: */									/* begin largeIntOrInt:growTo: */									if ((typeof div1 === "number")) {										/* begin cDigitLengthOfCSI: */										csi7 = div1;										len3 = ((csi7 >= 0) ? ((csi7 < 256) ? 1 : ((csi7 < 65536) ? 2 : ((csi7 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi7 < 4294967296) ? 4 : ((csi7 < 1099511627776) ? 5 : ((csi7 < 281474976710656) ? 6 : ((csi7 < 72057594037927936) ? 7 : 8)))))))) : ((csi7 > -256) ? 1 : ((csi7 > -65536) ? 2 : ((csi7 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi7 > -4294967296) ? 4 : ((csi7 > -1099511627776) ? 5 : ((csi7 > -281474976710656) ? 6 : ((csi7 > -72057594037927936) ? 7 : 8))))))))) + 1;										/* end cDigitLengthOfCSI: */									} else {										len3 = SIZEOF(div1) + 1;									}									if ((typeof div1 === "number")) {										val3 = div1;										class3 = (val3 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;										newBytes21 = (function(__size) {const __result = class3.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len3);										/* begin cCopyIntVal:toBytes: */										pByte3 = BYTESOF(newBytes21);										const ixLimiT = (val3 >= 0) ? ((val3 < 256) ? 1 : ((val3 < 65536) ? 2 : ((val3 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val3 < 4294967296) ? 4 : ((val3 < 1099511627776) ? 5 : ((val3 < 281474976710656) ? 6 : ((val3 < 72057594037927936) ? 7 : 8)))))))) : ((val3 > -256) ? 1 : ((val3 > -65536) ? 2 : ((val3 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val3 > -4294967296) ? 4 : ((val3 > -1099511627776) ? 5 : ((val3 > -281474976710656) ? 6 : ((val3 > -72057594037927936) ? 7 : 8))))))));										for (ix5 = 1; ix5 <= ixLimiT; ix5++) {											pByte3[ix5 - 1] = (UBANDS((SHR(((val3 < 0) ? (0 - val3) : val3), ((ix5 - 1) * 8))), 255));										}										/* end cCopyIntVal:toBytes: */									} else {										/* begin largeInt:growTo: */																			newBytes111 = (function(__size) {const __result = div1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len3);										oldLen21 = SIZEOF(div1);										copyLen2 = (oldLen21 < len3) ? oldLen21 : len3;										LargeIntegers.cDigitCopyFromtolen(BYTESOF(div1), BYTESOF(newBytes111), copyLen2);										newBytes21 = newBytes111;										/* end largeInt:growTo: */									}									div1 = newBytes21;									/* end largeIntOrInt:growTo: */																			/* begin digit:Lshift: */									oldLen11 = SIZEOF(firstAsLargeInteger);									if (((highBit11 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen11))) === 0) {										rem1 = 0;									} else {										newLen11 = ((highBit11 + d1) + 7) >> 3;																			newBytes13 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen11);										/* begin cDigitLshift:from:len:to:len: */										pFrom11 = BYTESOF(firstAsLargeInteger);										pTo11 = BYTESOF(newBytes13);										digitShift11 = d1 >> 3;										bitShift11 = MOD(d1, 8);										limit11 = digitShift11 - 1;										for (i31 = 0; i31 <= limit11; i31++) {											pTo11[i31] = 0;										}										if (bitShift11 === 0) {											{											// inlining self cDigitCopyFrom: pFrom11 + 0 to: pTo11 + digitShift11 len: newLen11 - 1 - digitShift11 + 1											const len = newLen11 - digitShift11											for (let i = 0; i < len; i++) 												pTo11[i + digitShift11] = pFrom11[i];											}										} else {											rshift11 = 8 - bitShift11;											carry11 = 0;											limit11 = oldLen11 - 1;											for (i121 = 0; i121 <= limit11; i121++) {												digit11 = pFrom11[i121];												pTo11[i121 + digitShift11] = (UBANDS((UBOR(carry11, (SHL(digit11, bitShift11)))), 255));												carry11 = SHR(digit11, rshift11);											}											if (carry11 !== 0) {												pTo11[newLen11 - 1] = carry11;											}										}										/* end cDigitLshift:from:len:to:len: */										rem1 = newBytes13;									}									/* end digit:Lshift: */									let rec1;if ((typeof rem1 === "number")) {										/* begin cDigitLengthOfCSI: */										csi12 = rem1;										rec1 = ((csi12 >= 0) ? ((csi12 < 256) ? 1 : ((csi12 < 65536) ? 2 : ((csi12 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi12 < 4294967296) ? 4 : ((csi12 < 1099511627776) ? 5 : ((csi12 < 281474976710656) ? 6 : ((csi12 < 72057594037927936) ? 7 : 8)))))))) : ((csi12 > -256) ? 1 : ((csi12 > -65536) ? 2 : ((csi12 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi12 > -4294967296) ? 4 : ((csi12 > -1099511627776) ? 5 : ((csi12 > -281474976710656) ? 6 : ((csi12 > -72057594037927936) ? 7 : 8))))))))) === firstLen1;										/* end cDigitLengthOfCSI: */									} else {										rec1 = SIZEOF(rem1) === firstLen1;									};if (rec1) {										/* begin largeIntOrInt:growTo: */										len12 = firstLen1 + 1;										if ((typeof rem1 === "number")) {											val12 = rem1;											class12 = (val12 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;											newBytes31 = (function(__size) {const __result = class12.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len12);											/* begin cCopyIntVal:toBytes: */											pByte12 = BYTESOF(newBytes31);											const ixLimiT = (val12 >= 0) ? ((val12 < 256) ? 1 : ((val12 < 65536) ? 2 : ((val12 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val12 < 4294967296) ? 4 : ((val12 < 1099511627776) ? 5 : ((val12 < 281474976710656) ? 6 : ((val12 < 72057594037927936) ? 7 : 8)))))))) : ((val12 > -256) ? 1 : ((val12 > -65536) ? 2 : ((val12 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val12 > -4294967296) ? 4 : ((val12 > -1099511627776) ? 5 : ((val12 > -281474976710656) ? 6 : ((val12 > -72057594037927936) ? 7 : 8))))))));											for (ix12 = 1; ix12 <= ixLimiT; ix12++) {												pByte12[ix12 - 1] = (UBANDS((SHR(((val12 < 0) ? (0 - val12) : val12), ((ix12 - 1) * 8))), 255));											}											/* end cCopyIntVal:toBytes: */										} else {											/* begin largeInt:growTo: */																					newBytes121 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len12);											oldLen31 = SIZEOF(rem1);											copyLen11 = (oldLen31 < len12) ? oldLen31 : len12;											LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem1), BYTESOF(newBytes121), copyLen11);											newBytes31 = newBytes121;											/* end largeInt:growTo: */										}										rem1 = newBytes31;										/* end largeIntOrInt:growTo: */									}																			quo1 = (function(__size) {const __result = resultClass1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l2);										/* begin cDigitDiv:len:rem:len:quo:len: */										pDiv1 = BYTESOF(div1);										if ((typeof div1 === "number")) {											/* begin cDigitLengthOfCSI: */											csi21 = div1;											divLen1 = (csi21 >= 0) ? ((csi21 < 256) ? 1 : ((csi21 < 65536) ? 2 : ((csi21 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi21 < 4294967296) ? 4 : ((csi21 < 1099511627776) ? 5 : ((csi21 < 281474976710656) ? 6 : ((csi21 < 72057594037927936) ? 7 : 8)))))))) : ((csi21 > -256) ? 1 : ((csi21 > -65536) ? 2 : ((csi21 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi21 > -4294967296) ? 4 : ((csi21 > -1099511627776) ? 5 : ((csi21 > -281474976710656) ? 6 : ((csi21 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											divLen1 = SIZEOF(div1);										}										pRem1 = BYTESOF(rem1);										if ((typeof rem1 === "number")) {											/* begin cDigitLengthOfCSI: */											csi31 = rem1;											remLen1 = (csi31 >= 0) ? ((csi31 < 256) ? 1 : ((csi31 < 65536) ? 2 : ((csi31 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi31 < 4294967296) ? 4 : ((csi31 < 1099511627776) ? 5 : ((csi31 < 281474976710656) ? 6 : ((csi31 < 72057594037927936) ? 7 : 8)))))))) : ((csi31 > -256) ? 1 : ((csi31 > -65536) ? 2 : ((csi31 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi31 > -4294967296) ? 4 : ((csi31 > -1099511627776) ? 5 : ((csi31 > -281474976710656) ? 6 : ((csi31 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											remLen1 = SIZEOF(rem1);										}										if ((typeof quo1 === "number")) {											/* begin cDigitLengthOfCSI: */											csi41 = quo1;											quoLen1 = (csi41 >= 0) ? ((csi41 < 256) ? 1 : ((csi41 < 65536) ? 2 : ((csi41 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi41 < 4294967296) ? 4 : ((csi41 < 1099511627776) ? 5 : ((csi41 < 281474976710656) ? 6 : ((csi41 < 72057594037927936) ? 7 : 8)))))))) : ((csi41 > -256) ? 1 : ((csi41 > -65536) ? 2 : ((csi41 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi41 > -4294967296) ? 4 : ((csi41 > -1099511627776) ? 5 : ((csi41 > -281474976710656) ? 6 : ((csi41 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											quoLen1 = SIZEOF(quo1);										}										dl1 = divLen1 - 1;										ql1 = quoLen1;										dh1 = pDiv1[dl1 - 1];										dnh1 = (dl1 === 1) ? 0 : pDiv1[dl1 - 2];										for (k1 = 1; k1 <= ql1; k1++) {											j2 = remLen1 + 1 - k1;											if (pRem1[j2 - 1] === dh1) {												q1 = 255;											} else {												r1r21 = pRem1[j2 - 1];												r1r21 = (r1r21 << 8 >>> 0) + pRem1[j2 - 2];												t1 = MOD(r1r21, dh1);												q1 = Math.trunc(r1r21 / dh1);												mul1 = q1 * dnh1;												hi1 = mul1 >>> 8;												lo1 = UBANDS(mul1, 255);												r31 = (j2 < 3) ? 0 : pRem1[j2 - 3];												while (true) {													if ((t1 < hi1) || ((t1 === hi1) && (r31 < lo1))) {														--q1;														if (hi1 === 0) {															cond1 = false;														} else {															if (lo1 < dnh1) {																--hi1;																lo1 = lo1 + 256 - dnh1;															} else {																lo1 -= dnh1;															}															cond1 = hi1 >= dh1;														}													} else {														cond1 = false;													}																										if (!(cond1)) break;													hi1 -= dh1;												}											}											l11 = j2 - dl1;											a2 = 0;											for (i4 = 1; i4 <= divLen1; i4++) {												hi1 = pDiv1[i4 - 1] * (q1 >>> 8);												lo1 = pDiv1[i4 - 1] * (UBANDS(q1, 255));												b1 = (pRem1[l11 - 1] - a2) - (UBANDS(lo1, 255));												pRem1[l11 - 1] = (UBANDS(b1, 255));												b1 = b1 >> 8;												a2 = (hi1 + (lo1 >>> 8)) - b1;												++l11;											}											if (a2 > 0) {												--q1;												l11 = j2 - dl1;												a2 = 0;												for (i13 = 1; i13 <= divLen1; i13++) {													a2 = ((a2 >>> 8) + pRem1[l11 - 1]) + pDiv1[i13 - 1];													pRem1[l11 - 1] = (UBANDS(a2, 255));													++l11;												}											}											BYTESOF(quo1)[quoLen1 - k1] = q1;										}										/* end cDigitDiv:len:rem:len:quo:len: */																			/* begin digit:Rshift:lookfirst: */									if ((typeof div1 === "number")) {										/* begin cDigitLengthOfCSI: */										csi51 = div1;										a11 = ((csi51 >= 0) ? ((csi51 < 256) ? 1 : ((csi51 < 65536) ? 2 : ((csi51 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi51 < 4294967296) ? 4 : ((csi51 < 1099511627776) ? 5 : ((csi51 < 281474976710656) ? 6 : ((csi51 < 72057594037927936) ? 7 : 8)))))))) : ((csi51 > -256) ? 1 : ((csi51 > -65536) ? 2 : ((csi51 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi51 > -4294967296) ? 4 : ((csi51 > -1099511627776) ? 5 : ((csi51 > -281474976710656) ? 6 : ((csi51 > -72057594037927936) ? 7 : 8))))))))) - 1;										/* end cDigitLengthOfCSI: */									} else {										a11 = SIZEOF(div1) - 1;									}									/* begin cDigitHighBit:len: */									realLength1 = a11;									brokenFromLoop_cDigitHighBitlen_12201 = false;									while (((lastDigit1 = BYTESOF(rem1)[realLength1 - 1])) === 0) {										if (((--realLength1)) === 0) {											oldBitLen1 = 0;											brokenFromLoop_cDigitHighBitlen_12201 = true;											break;										}									}									if (!brokenFromLoop_cDigitHighBitlen_12201) {										/* begin cHighBit: */										shifted11 = lastDigit1;										bitNo11 = 0;										if (shifted11 >= (65536)) {											shifted11 = shifted11 >>> 16;											bitNo11 += 16;										}										if (shifted11 >= (256)) {											shifted11 = shifted11 >>> 8;											bitNo11 += 8;										}										if (shifted11 >= (16)) {											shifted11 = shifted11 >>> 4;											bitNo11 += 4;										}										if (shifted11 >= (4)) {											shifted11 = shifted11 >>> 2;											bitNo11 += 2;										}										if (shifted11 >= (2)) {											shifted11 = shifted11 >>> 1;											++bitNo11;										}										oldBitLen1 = (bitNo11 + shifted11) + (8 * (realLength1 - 1));										/* end cHighBit: */									}									/* end cDigitHighBit:len: */									oldDigitLen1 = (oldBitLen1 + 7) >> 3;									newBitLen1 = oldBitLen1 - d1;									if (newBitLen1 <= 0) {										rem1 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);									} else {										newByteLen1 = (newBitLen1 + 7) >> 3;																			newOop1 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen1);										/* begin cDigitRshift:from:len:to:len: */										pFrom21 = BYTESOF(rem1);										pTo21 = BYTESOF(newOop1);										digitShift21 = d1 >> 3;										bitShift21 = MOD(d1, 8);										if (bitShift21 === 0) {											{											// inlining self cDigitCopyFrom: pFrom21 + digitShift21 to: pTo21 + 0 len: newByteLen1 - 1 - 0 + 1											for (let i = 0; i < newByteLen1; i++) 												pTo21[i] = pFrom21[i + digitShift21];											}										} else {											leftShift1 = 8 - bitShift21;											carry21 = SHR(pFrom21[digitShift21], bitShift21);											start1 = digitShift21 + 1;											limit21 = oldDigitLen1 - 1;											for (j11 = start1; j11 <= limit21; j11++) {												digit21 = pFrom21[j11];												pTo21[j11 - start1] = (UBANDS((UBOR(carry21, (SHL(digit21, leftShift1)))), 255));												carry21 = SHR(digit21, bitShift21);											}											if (carry21 !== 0) {												pTo21[newByteLen1 - 1] = carry21;											}										}										/* end cDigitRshift:from:len:to:len: */										rem1 = newOop1;									}									/* end digit:Rshift:lookfirst: */																			result1 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);										result1[1] = quo1;										result1[2] = rem1;										arg12 = result1;									}									/* end digitDivLarge:with:negative: */									throw Object.create(PrimitiveReturn).setPayload(arg12);								} else {									throw Object.create(PrimitiveFailed).setPayload(1);								}							} else {								minVal = -1073741824;								if (BYTESOF(secondInteger)[sLen - 1] >= (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255))) {									brokenFromLoop_isNormalized_3707 = false;									for (ix2 = 1; ix2 <= sLen; ix2++) {										if (BYTESOF(secondInteger)[ix2 - 1] !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((ix2 - 1) * 8))), 255))) {											returnValueFromLoop_isNormalized_3707 = true;											brokenFromLoop_isNormalized_3707 = true;											break;										}									}								}								throw Object.create(PrimitiveFailed).setPayload(1);							}						}					}				}			}		}		/* end isNormalized: */	} else {		if ((typeof firstInteger === "number")) {			/* begin cDigitLengthOfCSI: */			csi1 = firstInteger;			len1 = (csi1 >= 0) ? ((csi1 < 256) ? 1 : ((csi1 < 65536) ? 2 : ((csi1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi1 < 4294967296) ? 4 : ((csi1 < 1099511627776) ? 5 : ((csi1 < 281474976710656) ? 6 : ((csi1 < 72057594037927936) ? 7 : 8)))))))) : ((csi1 > -256) ? 1 : ((csi1 > -65536) ? 2 : ((csi1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi1 > -4294967296) ? 4 : ((csi1 > -1099511627776) ? 5 : ((csi1 > -281474976710656) ? 6 : ((csi1 > -72057594037927936) ? 7 : 8))))))));			/* end cDigitLengthOfCSI: */		} else {			len1 = SIZEOF(firstInteger);		}		if (len1 === 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		} else {			if (BYTESOF(firstInteger)[len1 - 1] === 0) {				throw Object.create(PrimitiveFailed).setPayload(1);			} else {				sLen1 = 4;				if (len1 > sLen1) {					/* begin isNormalized: */					if ((typeof secondInteger === "number")) {						if ((typeof firstInteger === "number")) {							/* convert to LargeInteger */													/* begin createLargeFromSmallInteger: */						val = firstInteger;						sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;						size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));						res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);						pByte = BYTESOF(res);						for (ix = 1; ix <= size; ix++) {							byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);							pByte[ix - 1] = byte;						}						firstAsLargeInteger = res;						/* end createLargeFromSmallInteger: */						} else {							firstAsLargeInteger = firstInteger;						}						if ((typeof secondInteger === "number")) {							/* check for zerodivide and convert to LargeInteger */							if (secondInteger === 0) {								throw Object.create(PrimitiveFailed).setPayload(1);							}													/* begin createLargeFromSmallInteger: */						val1 = secondInteger;						class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;						size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));						res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);						pByte1 = BYTESOF(res1);						for (ix1 = 1; ix1 <= size1; ix1++) {							byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);							pByte1[ix1 - 1] = byte1;						}						secondAsLargeInteger = res1;						/* end createLargeFromSmallInteger: */						} else {							secondAsLargeInteger = secondInteger;						}						/* begin digitDivLarge:with:negative: */						firstLen = SIZEOF(firstAsLargeInteger);						secondLen = SIZEOF(secondAsLargeInteger);						resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;						l = (firstLen - secondLen) + 1;						if (l <= 0) {													result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);							result[1] = 0;							result[2] = firstAsLargeInteger;							arg11 = result;						} else {							/* begin cHighBit: */							shifted = BYTESOF(secondAsLargeInteger)[secondLen - 1];							bitNo = 0;							if (shifted >= (65536)) {								shifted = shifted >>> 16;								bitNo += 16;							}							if (shifted >= (256)) {								shifted = shifted >>> 8;								bitNo += 8;							}							if (shifted >= (16)) {								shifted = shifted >>> 4;								bitNo += 4;							}							if (shifted >= (4)) {								shifted = shifted >>> 2;								bitNo += 2;							}							if (shifted >= (2)) {								shifted = shifted >>> 1;								++bitNo;							}							arg111 = bitNo + shifted;							/* end cHighBit: */							d = 8 - arg111;													/* begin digit:Lshift: */						oldLen = SIZEOF(secondAsLargeInteger);						if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen))) === 0) {							div = 0;						} else {							newLen = ((highBit + d) + 7) >> 3;													newBytes = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);							/* begin cDigitLshift:from:len:to:len: */							pFrom = BYTESOF(secondAsLargeInteger);							pTo = BYTESOF(newBytes);							digitShift = d >> 3;							bitShift = MOD(d, 8);							limit = digitShift - 1;							for (i2 = 0; i2 <= limit; i2++) {								pTo[i2] = 0;							}							if (bitShift === 0) {								{								// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1								const len = newLen - digitShift								for (let i = 0; i < len; i++) 									pTo[i + digitShift] = pFrom[i];								}							} else {								rshift = 8 - bitShift;								carry = 0;								limit = oldLen - 1;								for (i11 = 0; i11 <= limit; i11++) {									digit = pFrom[i11];									pTo[i11 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));									carry = SHR(digit, rshift);								}								if (carry !== 0) {									pTo[newLen - 1] = carry;								}							}							/* end cDigitLshift:from:len:to:len: */							div = newBytes;						}						/* end digit:Lshift: */						/* begin largeIntOrInt:growTo: */						if ((typeof div === "number")) {							/* begin cDigitLengthOfCSI: */							csi6 = div;							len2 = ((len2 = ((csi6 >= 0) ? ((csi6 < 256) ? 1 : ((csi6 < 65536) ? 2 : ((csi6 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi6 < 4294967296) ? 4 : ((csi6 < 1099511627776) ? 5 : ((csi6 < 281474976710656) ? 6 : ((csi6 < 72057594037927936) ? 7 : 8)))))))) : ((csi6 > -256) ? 1 : ((csi6 > -65536) ? 2 : ((csi6 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi6 > -4294967296) ? 4 : ((csi6 > -1099511627776) ? 5 : ((csi6 > -281474976710656) ? 6 : ((csi6 > -72057594037927936) ? 7 : 8))))))))) + 1)) + 1;							/* end cDigitLengthOfCSI: */						} else {							len2 = ((len2 = SIZEOF(div) + 1)) + 1;						}						if ((typeof div === "number")) {							val2 = div;							class2 = (val2 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;							newBytes2 = (function(__size) {const __result = class2.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len2);							/* begin cCopyIntVal:toBytes: */							pByte2 = BYTESOF(newBytes2);							const ixLimiT = (val2 >= 0) ? ((val2 < 256) ? 1 : ((val2 < 65536) ? 2 : ((val2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val2 < 4294967296) ? 4 : ((val2 < 1099511627776) ? 5 : ((val2 < 281474976710656) ? 6 : ((val2 < 72057594037927936) ? 7 : 8)))))))) : ((val2 > -256) ? 1 : ((val2 > -65536) ? 2 : ((val2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val2 > -4294967296) ? 4 : ((val2 > -1099511627776) ? 5 : ((val2 > -281474976710656) ? 6 : ((val2 > -72057594037927936) ? 7 : 8))))))));							for (ix4 = 1; ix4 <= ixLimiT; ix4++) {								pByte2[ix4 - 1] = (UBANDS((SHR(((val2 < 0) ? (0 - val2) : val2), ((ix4 - 1) * 8))), 255));							}							/* end cCopyIntVal:toBytes: */						} else {							/* begin largeInt:growTo: */													newBytes11 = (function(__size) {const __result = div._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len2);							oldLen2 = SIZEOF(div);							copyLen = (oldLen2 < len2) ? oldLen2 : len2;							LargeIntegers.cDigitCopyFromtolen(BYTESOF(div), BYTESOF(newBytes11), copyLen);							newBytes2 = newBytes11;							/* end largeInt:growTo: */						}						div = newBytes2;						/* end largeIntOrInt:growTo: */													/* begin digit:Lshift: */						oldLen1 = SIZEOF(firstAsLargeInteger);						if (((highBit1 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen1))) === 0) {							rem = 0;						} else {							newLen1 = ((highBit1 + d) + 7) >> 3;													newBytes1 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen1);							/* begin cDigitLshift:from:len:to:len: */							pFrom1 = BYTESOF(firstAsLargeInteger);							pTo1 = BYTESOF(newBytes1);							digitShift1 = d >> 3;							bitShift1 = MOD(d, 8);							limit1 = digitShift1 - 1;							for (i3 = 0; i3 <= limit1; i3++) {								pTo1[i3] = 0;							}							if (bitShift1 === 0) {								{								// inlining self cDigitCopyFrom: pFrom1 + 0 to: pTo1 + digitShift1 len: newLen1 - 1 - digitShift1 + 1								const len = newLen1 - digitShift1								for (let i = 0; i < len; i++) 									pTo1[i + digitShift1] = pFrom1[i];								}							} else {								rshift1 = 8 - bitShift1;								carry1 = 0;								limit1 = oldLen1 - 1;								for (i12 = 0; i12 <= limit1; i12++) {									digit1 = pFrom1[i12];									pTo1[i12 + digitShift1] = (UBANDS((UBOR(carry1, (SHL(digit1, bitShift1)))), 255));									carry1 = SHR(digit1, rshift1);								}								if (carry1 !== 0) {									pTo1[newLen1 - 1] = carry1;								}							}							/* end cDigitLshift:from:len:to:len: */							rem = newBytes1;						}						/* end digit:Lshift: */						let rec1;if ((typeof rem === "number")) {							/* begin cDigitLengthOfCSI: */							csi11 = rem;							rec1 = ((rec1 = ((csi11 >= 0) ? ((csi11 < 256) ? 1 : ((csi11 < 65536) ? 2 : ((csi11 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi11 < 4294967296) ? 4 : ((csi11 < 1099511627776) ? 5 : ((csi11 < 281474976710656) ? 6 : ((csi11 < 72057594037927936) ? 7 : 8)))))))) : ((csi11 > -256) ? 1 : ((csi11 > -65536) ? 2 : ((csi11 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi11 > -4294967296) ? 4 : ((csi11 > -1099511627776) ? 5 : ((csi11 > -281474976710656) ? 6 : ((csi11 > -72057594037927936) ? 7 : 8))))))))) === firstLen)) === firstLen;							/* end cDigitLengthOfCSI: */						} else {							rec1 = ((rec1 = SIZEOF(rem) === firstLen)) === firstLen;						};if (rec1) {							/* begin largeIntOrInt:growTo: */							len11 = firstLen + 1;							if ((typeof rem === "number")) {								val11 = rem;								class11 = (val11 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;								newBytes3 = (function(__size) {const __result = class11.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len11);								/* begin cCopyIntVal:toBytes: */								pByte11 = BYTESOF(newBytes3);								const ixLimiT = (val11 >= 0) ? ((val11 < 256) ? 1 : ((val11 < 65536) ? 2 : ((val11 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val11 < 4294967296) ? 4 : ((val11 < 1099511627776) ? 5 : ((val11 < 281474976710656) ? 6 : ((val11 < 72057594037927936) ? 7 : 8)))))))) : ((val11 > -256) ? 1 : ((val11 > -65536) ? 2 : ((val11 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val11 > -4294967296) ? 4 : ((val11 > -1099511627776) ? 5 : ((val11 > -281474976710656) ? 6 : ((val11 > -72057594037927936) ? 7 : 8))))))));								for (ix11 = 1; ix11 <= ixLimiT; ix11++) {									pByte11[ix11 - 1] = (UBANDS((SHR(((val11 < 0) ? (0 - val11) : val11), ((ix11 - 1) * 8))), 255));								}								/* end cCopyIntVal:toBytes: */							} else {								/* begin largeInt:growTo: */															newBytes12 = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len11);								oldLen3 = SIZEOF(rem);								copyLen1 = (oldLen3 < len11) ? oldLen3 : len11;								LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem), BYTESOF(newBytes12), copyLen1);								newBytes3 = newBytes12;								/* end largeInt:growTo: */							}							rem = newBytes3;							/* end largeIntOrInt:growTo: */						}													quo = (function(__size) {const __result = resultClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l);							/* begin cDigitDiv:len:rem:len:quo:len: */							pDiv = BYTESOF(div);							if ((typeof div === "number")) {								/* begin cDigitLengthOfCSI: */								csi2 = div;								divLen = (csi2 >= 0) ? ((csi2 < 256) ? 1 : ((csi2 < 65536) ? 2 : ((csi2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 < 4294967296) ? 4 : ((csi2 < 1099511627776) ? 5 : ((csi2 < 281474976710656) ? 6 : ((csi2 < 72057594037927936) ? 7 : 8)))))))) : ((csi2 > -256) ? 1 : ((csi2 > -65536) ? 2 : ((csi2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 > -4294967296) ? 4 : ((csi2 > -1099511627776) ? 5 : ((csi2 > -281474976710656) ? 6 : ((csi2 > -72057594037927936) ? 7 : 8))))))));								/* end cDigitLengthOfCSI: */							} else {								divLen = SIZEOF(div);							}							pRem = BYTESOF(rem);							if ((typeof rem === "number")) {								/* begin cDigitLengthOfCSI: */								csi3 = rem;								remLen = (csi3 >= 0) ? ((csi3 < 256) ? 1 : ((csi3 < 65536) ? 2 : ((csi3 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 < 4294967296) ? 4 : ((csi3 < 1099511627776) ? 5 : ((csi3 < 281474976710656) ? 6 : ((csi3 < 72057594037927936) ? 7 : 8)))))))) : ((csi3 > -256) ? 1 : ((csi3 > -65536) ? 2 : ((csi3 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 > -4294967296) ? 4 : ((csi3 > -1099511627776) ? 5 : ((csi3 > -281474976710656) ? 6 : ((csi3 > -72057594037927936) ? 7 : 8))))))));								/* end cDigitLengthOfCSI: */							} else {								remLen = SIZEOF(rem);							}							if ((typeof quo === "number")) {								/* begin cDigitLengthOfCSI: */								csi4 = quo;								quoLen = (csi4 >= 0) ? ((csi4 < 256) ? 1 : ((csi4 < 65536) ? 2 : ((csi4 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 < 4294967296) ? 4 : ((csi4 < 1099511627776) ? 5 : ((csi4 < 281474976710656) ? 6 : ((csi4 < 72057594037927936) ? 7 : 8)))))))) : ((csi4 > -256) ? 1 : ((csi4 > -65536) ? 2 : ((csi4 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 > -4294967296) ? 4 : ((csi4 > -1099511627776) ? 5 : ((csi4 > -281474976710656) ? 6 : ((csi4 > -72057594037927936) ? 7 : 8))))))));								/* end cDigitLengthOfCSI: */							} else {								quoLen = SIZEOF(quo);							}							dl = divLen - 1;							ql = quoLen;							dh = pDiv[dl - 1];							dnh = (dl === 1) ? 0 : pDiv[dl - 2];							for (k = 1; k <= ql; k++) {								j = remLen + 1 - k;								if (pRem[j - 1] === dh) {									q = 255;								} else {									r1r2 = pRem[j - 1];									r1r2 = (r1r2 << 8 >>> 0) + pRem[j - 2];									t = MOD(r1r2, dh);									q = Math.trunc(r1r2 / dh);									mul = q * dnh;									hi = mul >>> 8;									lo = UBANDS(mul, 255);									r3 = (j < 3) ? 0 : pRem[j - 3];									while (true) {										let ret1;										if ((t < hi) || ((t === hi) && (r3 < lo))) {											--q;											if (hi === 0) {												cond = ret1 = false;											} else {												if (lo < dnh) {													--hi;													lo = lo + 256 - dnh;												} else {													lo -= dnh;												}												cond = ret1 = hi >= dh;											}										} else {											cond = ret1 = false;										};										if (!(ret1)) break;										hi -= dh;									}								}								l1 = j - dl;								a = 0;								for (i = 1; i <= divLen; i++) {									hi = pDiv[i - 1] * (q >>> 8);									lo = pDiv[i - 1] * (UBANDS(q, 255));									b = (pRem[l1 - 1] - a) - (UBANDS(lo, 255));									pRem[l1 - 1] = (UBANDS(b, 255));									b = b >> 8;									a = (hi + (lo >>> 8)) - b;									++l1;								}								if (a > 0) {									--q;									l1 = j - dl;									a = 0;									for (i1 = 1; i1 <= divLen; i1++) {										a = ((a >>> 8) + pRem[l1 - 1]) + pDiv[i1 - 1];										pRem[l1 - 1] = (UBANDS(a, 255));										++l1;									}								}								BYTESOF(quo)[quoLen - k] = q;							}							/* end cDigitDiv:len:rem:len:quo:len: */													/* begin digit:Rshift:lookfirst: */						if ((typeof div === "number")) {							/* begin cDigitLengthOfCSI: */							csi5 = div;							a1 = ((a1 = ((csi5 >= 0) ? ((csi5 < 256) ? 1 : ((csi5 < 65536) ? 2 : ((csi5 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 < 4294967296) ? 4 : ((csi5 < 1099511627776) ? 5 : ((csi5 < 281474976710656) ? 6 : ((csi5 < 72057594037927936) ? 7 : 8)))))))) : ((csi5 > -256) ? 1 : ((csi5 > -65536) ? 2 : ((csi5 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 > -4294967296) ? 4 : ((csi5 > -1099511627776) ? 5 : ((csi5 > -281474976710656) ? 6 : ((csi5 > -72057594037927936) ? 7 : 8))))))))) - 1)) - 1;							/* end cDigitLengthOfCSI: */						} else {							a1 = ((a1 = SIZEOF(div) - 1)) - 1;						}						/* begin cDigitHighBit:len: */						realLength = a1;						brokenFromLoop_cDigitHighBitlen_1220 = false;						while (((lastDigit = BYTESOF(rem)[realLength - 1])) === 0) {							if (((--realLength)) === 0) {								oldBitLen = 0;								brokenFromLoop_cDigitHighBitlen_1220 = true;								break;							}						}						if (!brokenFromLoop_cDigitHighBitlen_1220) {							/* begin cHighBit: */							shifted1 = lastDigit;							bitNo1 = 0;							if (shifted1 >= (65536)) {								shifted1 = shifted1 >>> 16;								bitNo1 += 16;							}							if (shifted1 >= (256)) {								shifted1 = shifted1 >>> 8;								bitNo1 += 8;							}							if (shifted1 >= (16)) {								shifted1 = shifted1 >>> 4;								bitNo1 += 4;							}							if (shifted1 >= (4)) {								shifted1 = shifted1 >>> 2;								bitNo1 += 2;							}							if (shifted1 >= (2)) {								shifted1 = shifted1 >>> 1;								++bitNo1;							}							oldBitLen = (bitNo1 + shifted1) + (8 * (realLength - 1));							/* end cHighBit: */						}						/* end cDigitHighBit:len: */						oldDigitLen = (oldBitLen + 7) >> 3;						newBitLen = oldBitLen - d;						if (newBitLen <= 0) {							rem = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);						} else {							newByteLen = (newBitLen + 7) >> 3;													newOop = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);							/* begin cDigitRshift:from:len:to:len: */							pFrom2 = BYTESOF(rem);							pTo2 = BYTESOF(newOop);							digitShift2 = d >> 3;							bitShift2 = MOD(d, 8);							if (bitShift2 === 0) {								{								// inlining self cDigitCopyFrom: pFrom2 + digitShift2 to: pTo2 + 0 len: newByteLen - 1 - 0 + 1								for (let i = 0; i < newByteLen; i++) 									pTo2[i] = pFrom2[i + digitShift2];								}							} else {								leftShift = 8 - bitShift2;								carry2 = SHR(pFrom2[digitShift2], bitShift2);								start = digitShift2 + 1;								limit2 = oldDigitLen - 1;								for (j1 = start; j1 <= limit2; j1++) {									digit2 = pFrom2[j1];									pTo2[j1 - start] = (UBANDS((UBOR(carry2, (SHL(digit2, leftShift)))), 255));									carry2 = SHR(digit2, bitShift2);								}								if (carry2 !== 0) {									pTo2[newByteLen - 1] = carry2;								}							}							/* end cDigitRshift:from:len:to:len: */							rem = newOop;						}						/* end digit:Rshift:lookfirst: */													result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);							result[1] = quo;							result[2] = rem;							arg11 = result;						}						/* end digitDivLarge:with:negative: */						throw Object.create(PrimitiveReturn).setPayload(arg11);					} else {						if ((typeof secondInteger === "number")) {							/* begin cDigitLengthOfCSI: */							csi = secondInteger;							len = (csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))));							/* end cDigitLengthOfCSI: */						} else {							len = SIZEOF(secondInteger);						}						if (len === 0) {							throw Object.create(PrimitiveFailed).setPayload(1);						} else {							if (BYTESOF(secondInteger)[len - 1] === 0) {								throw Object.create(PrimitiveFailed).setPayload(1);							} else {								sLen = 4;								if (len > sLen) {									if ((typeof firstInteger === "number")) {										/* convert to LargeInteger */																			/* begin createLargeFromSmallInteger: */									val = firstInteger;									sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));									res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);									pByte = BYTESOF(res);									for (ix = 1; ix <= size; ix++) {										byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);										pByte[ix - 1] = byte;									}									firstAsLargeInteger = res;									/* end createLargeFromSmallInteger: */									} else {										firstAsLargeInteger = firstInteger;									}									if ((typeof secondInteger === "number")) {										/* check for zerodivide and convert to LargeInteger */										if (secondInteger === 0) {											throw Object.create(PrimitiveFailed).setPayload(1);										}																			/* begin createLargeFromSmallInteger: */									val1 = secondInteger;									class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));									res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);									pByte1 = BYTESOF(res1);									for (ix1 = 1; ix1 <= size1; ix1++) {										byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);										pByte1[ix1 - 1] = byte1;									}									secondAsLargeInteger = res1;									/* end createLargeFromSmallInteger: */									} else {										secondAsLargeInteger = secondInteger;									}									throw Object.create(PrimitiveReturn).setPayload(arg11);								} else {									if (len < sLen) {										throw Object.create(PrimitiveFailed).setPayload(1);									} else {										if (secondInteger._class() === SmalltalkGlobals._LargePositiveInteger) {											maxVal = 1073741823;											if (BYTESOF(secondInteger)[sLen - 1] > (UBANDS((SHR(((maxVal < 0) ? (0 - maxVal) : maxVal), ((sLen - 1) * 8))), 255))) {												if ((typeof firstInteger === "number")) {																									/* begin createLargeFromSmallInteger: */												val = firstInteger;												sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));												res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);												pByte = BYTESOF(res);												for (ix = 1; ix <= size; ix++) {													byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);													pByte[ix - 1] = byte;												}												firstAsLargeInteger = res;												/* end createLargeFromSmallInteger: */												} else {													firstAsLargeInteger = firstInteger;												}												if ((typeof secondInteger === "number")) {													if (secondInteger === 0) {														throw Object.create(PrimitiveFailed).setPayload(1);													}																									/* begin createLargeFromSmallInteger: */												val1 = secondInteger;												class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));												res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);												pByte1 = BYTESOF(res1);												for (ix1 = 1; ix1 <= size1; ix1++) {													byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);													pByte1[ix1 - 1] = byte1;												}												secondAsLargeInteger = res1;												/* end createLargeFromSmallInteger: */												} else {													secondAsLargeInteger = secondInteger;												}												/* begin digitDivLarge:with:negative: */												firstLen1 = SIZEOF(firstAsLargeInteger);												secondLen1 = SIZEOF(secondAsLargeInteger);												resultClass1 = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												l2 = (firstLen1 - secondLen1) + 1;												if (l2 <= 0) {																									result1 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);													result1[1] = 0;													result1[2] = firstAsLargeInteger;													arg12 = result1;												} else {													/* begin cHighBit: */													shifted2 = BYTESOF(secondAsLargeInteger)[secondLen1 - 1];													bitNo2 = 0;													if (shifted2 >= (65536)) {														shifted2 = shifted2 >>> 16;														bitNo2 += 16;													}													if (shifted2 >= (256)) {														shifted2 = shifted2 >>> 8;														bitNo2 += 8;													}													if (shifted2 >= (16)) {														shifted2 = shifted2 >>> 4;														bitNo2 += 4;													}													if (shifted2 >= (4)) {														shifted2 = shifted2 >>> 2;														bitNo2 += 2;													}													if (shifted2 >= (2)) {														shifted2 = shifted2 >>> 1;														++bitNo2;													}													arg112 = bitNo2 + shifted2;													/* end cHighBit: */													d1 = 8 - arg112;																									/* begin digit:Lshift: */												oldLen4 = SIZEOF(secondAsLargeInteger);												if (((highBit2 = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen4))) === 0) {													div1 = 0;												} else {													newLen2 = ((highBit2 + d1) + 7) >> 3;																									newBytes4 = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen2);													/* begin cDigitLshift:from:len:to:len: */													pFrom3 = BYTESOF(secondAsLargeInteger);													pTo3 = BYTESOF(newBytes4);													digitShift3 = d1 >> 3;													bitShift3 = MOD(d1, 8);													limit3 = digitShift3 - 1;													for (i21 = 0; i21 <= limit3; i21++) {														pTo3[i21] = 0;													}													if (bitShift3 === 0) {														{														// inlining self cDigitCopyFrom: pFrom3 + 0 to: pTo3 + digitShift3 len: newLen2 - 1 - digitShift3 + 1														const len = newLen2 - digitShift3														for (let i = 0; i < len; i++) 															pTo3[i + digitShift3] = pFrom3[i];														}													} else {														rshift2 = 8 - bitShift3;														carry3 = 0;														limit3 = oldLen4 - 1;														for (i111 = 0; i111 <= limit3; i111++) {															digit3 = pFrom3[i111];															pTo3[i111 + digitShift3] = (UBANDS((UBOR(carry3, (SHL(digit3, bitShift3)))), 255));															carry3 = SHR(digit3, rshift2);														}														if (carry3 !== 0) {															pTo3[newLen2 - 1] = carry3;														}													}													/* end cDigitLshift:from:len:to:len: */													div1 = newBytes4;												}												/* end digit:Lshift: */												/* begin largeIntOrInt:growTo: */												if ((typeof div1 === "number")) {													/* begin cDigitLengthOfCSI: */													csi7 = div1;													len3 = ((len3 = ((csi7 >= 0) ? ((csi7 < 256) ? 1 : ((csi7 < 65536) ? 2 : ((csi7 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi7 < 4294967296) ? 4 : ((csi7 < 1099511627776) ? 5 : ((csi7 < 281474976710656) ? 6 : ((csi7 < 72057594037927936) ? 7 : 8)))))))) : ((csi7 > -256) ? 1 : ((csi7 > -65536) ? 2 : ((csi7 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi7 > -4294967296) ? 4 : ((csi7 > -1099511627776) ? 5 : ((csi7 > -281474976710656) ? 6 : ((csi7 > -72057594037927936) ? 7 : 8))))))))) + 1)) + 1;													/* end cDigitLengthOfCSI: */												} else {													len3 = ((len3 = SIZEOF(div1) + 1)) + 1;												}												if ((typeof div1 === "number")) {													val3 = div1;													class3 = (val3 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;													newBytes21 = (function(__size) {const __result = class3.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len3);													/* begin cCopyIntVal:toBytes: */													pByte3 = BYTESOF(newBytes21);													const ixLimiT = (val3 >= 0) ? ((val3 < 256) ? 1 : ((val3 < 65536) ? 2 : ((val3 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val3 < 4294967296) ? 4 : ((val3 < 1099511627776) ? 5 : ((val3 < 281474976710656) ? 6 : ((val3 < 72057594037927936) ? 7 : 8)))))))) : ((val3 > -256) ? 1 : ((val3 > -65536) ? 2 : ((val3 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val3 > -4294967296) ? 4 : ((val3 > -1099511627776) ? 5 : ((val3 > -281474976710656) ? 6 : ((val3 > -72057594037927936) ? 7 : 8))))))));													for (ix5 = 1; ix5 <= ixLimiT; ix5++) {														pByte3[ix5 - 1] = (UBANDS((SHR(((val3 < 0) ? (0 - val3) : val3), ((ix5 - 1) * 8))), 255));													}													/* end cCopyIntVal:toBytes: */												} else {													/* begin largeInt:growTo: */																									newBytes111 = (function(__size) {const __result = div1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len3);													oldLen21 = SIZEOF(div1);													copyLen2 = (oldLen21 < len3) ? oldLen21 : len3;													LargeIntegers.cDigitCopyFromtolen(BYTESOF(div1), BYTESOF(newBytes111), copyLen2);													newBytes21 = newBytes111;													/* end largeInt:growTo: */												}												div1 = newBytes21;												/* end largeIntOrInt:growTo: */																									/* begin digit:Lshift: */												oldLen11 = SIZEOF(firstAsLargeInteger);												if (((highBit11 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen11))) === 0) {													rem1 = 0;												} else {													newLen11 = ((highBit11 + d1) + 7) >> 3;																									newBytes13 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen11);													/* begin cDigitLshift:from:len:to:len: */													pFrom11 = BYTESOF(firstAsLargeInteger);													pTo11 = BYTESOF(newBytes13);													digitShift11 = d1 >> 3;													bitShift11 = MOD(d1, 8);													limit11 = digitShift11 - 1;													for (i31 = 0; i31 <= limit11; i31++) {														pTo11[i31] = 0;													}													if (bitShift11 === 0) {														{														// inlining self cDigitCopyFrom: pFrom11 + 0 to: pTo11 + digitShift11 len: newLen11 - 1 - digitShift11 + 1														const len = newLen11 - digitShift11														for (let i = 0; i < len; i++) 															pTo11[i + digitShift11] = pFrom11[i];														}													} else {														rshift11 = 8 - bitShift11;														carry11 = 0;														limit11 = oldLen11 - 1;														for (i121 = 0; i121 <= limit11; i121++) {															digit11 = pFrom11[i121];															pTo11[i121 + digitShift11] = (UBANDS((UBOR(carry11, (SHL(digit11, bitShift11)))), 255));															carry11 = SHR(digit11, rshift11);														}														if (carry11 !== 0) {															pTo11[newLen11 - 1] = carry11;														}													}													/* end cDigitLshift:from:len:to:len: */													rem1 = newBytes13;												}												/* end digit:Lshift: */												let rec1;if ((typeof rem1 === "number")) {													/* begin cDigitLengthOfCSI: */													csi12 = rem1;													rec1 = ((rec1 = ((csi12 >= 0) ? ((csi12 < 256) ? 1 : ((csi12 < 65536) ? 2 : ((csi12 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi12 < 4294967296) ? 4 : ((csi12 < 1099511627776) ? 5 : ((csi12 < 281474976710656) ? 6 : ((csi12 < 72057594037927936) ? 7 : 8)))))))) : ((csi12 > -256) ? 1 : ((csi12 > -65536) ? 2 : ((csi12 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi12 > -4294967296) ? 4 : ((csi12 > -1099511627776) ? 5 : ((csi12 > -281474976710656) ? 6 : ((csi12 > -72057594037927936) ? 7 : 8))))))))) === firstLen1)) === firstLen1;													/* end cDigitLengthOfCSI: */												} else {													rec1 = ((rec1 = SIZEOF(rem1) === firstLen1)) === firstLen1;												};if (rec1) {													/* begin largeIntOrInt:growTo: */													len12 = firstLen1 + 1;													if ((typeof rem1 === "number")) {														val12 = rem1;														class12 = (val12 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;														newBytes31 = (function(__size) {const __result = class12.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len12);														/* begin cCopyIntVal:toBytes: */														pByte12 = BYTESOF(newBytes31);														const ixLimiT = (val12 >= 0) ? ((val12 < 256) ? 1 : ((val12 < 65536) ? 2 : ((val12 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val12 < 4294967296) ? 4 : ((val12 < 1099511627776) ? 5 : ((val12 < 281474976710656) ? 6 : ((val12 < 72057594037927936) ? 7 : 8)))))))) : ((val12 > -256) ? 1 : ((val12 > -65536) ? 2 : ((val12 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val12 > -4294967296) ? 4 : ((val12 > -1099511627776) ? 5 : ((val12 > -281474976710656) ? 6 : ((val12 > -72057594037927936) ? 7 : 8))))))));														for (ix12 = 1; ix12 <= ixLimiT; ix12++) {															pByte12[ix12 - 1] = (UBANDS((SHR(((val12 < 0) ? (0 - val12) : val12), ((ix12 - 1) * 8))), 255));														}														/* end cCopyIntVal:toBytes: */													} else {														/* begin largeInt:growTo: */																											newBytes121 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len12);														oldLen31 = SIZEOF(rem1);														copyLen11 = (oldLen31 < len12) ? oldLen31 : len12;														LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem1), BYTESOF(newBytes121), copyLen11);														newBytes31 = newBytes121;														/* end largeInt:growTo: */													}													rem1 = newBytes31;													/* end largeIntOrInt:growTo: */												}																									quo1 = (function(__size) {const __result = resultClass1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l2);													/* begin cDigitDiv:len:rem:len:quo:len: */													pDiv1 = BYTESOF(div1);													if ((typeof div1 === "number")) {														/* begin cDigitLengthOfCSI: */														csi21 = div1;														divLen1 = (csi21 >= 0) ? ((csi21 < 256) ? 1 : ((csi21 < 65536) ? 2 : ((csi21 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi21 < 4294967296) ? 4 : ((csi21 < 1099511627776) ? 5 : ((csi21 < 281474976710656) ? 6 : ((csi21 < 72057594037927936) ? 7 : 8)))))))) : ((csi21 > -256) ? 1 : ((csi21 > -65536) ? 2 : ((csi21 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi21 > -4294967296) ? 4 : ((csi21 > -1099511627776) ? 5 : ((csi21 > -281474976710656) ? 6 : ((csi21 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														divLen1 = SIZEOF(div1);													}													pRem1 = BYTESOF(rem1);													if ((typeof rem1 === "number")) {														/* begin cDigitLengthOfCSI: */														csi31 = rem1;														remLen1 = (csi31 >= 0) ? ((csi31 < 256) ? 1 : ((csi31 < 65536) ? 2 : ((csi31 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi31 < 4294967296) ? 4 : ((csi31 < 1099511627776) ? 5 : ((csi31 < 281474976710656) ? 6 : ((csi31 < 72057594037927936) ? 7 : 8)))))))) : ((csi31 > -256) ? 1 : ((csi31 > -65536) ? 2 : ((csi31 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi31 > -4294967296) ? 4 : ((csi31 > -1099511627776) ? 5 : ((csi31 > -281474976710656) ? 6 : ((csi31 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														remLen1 = SIZEOF(rem1);													}													if ((typeof quo1 === "number")) {														/* begin cDigitLengthOfCSI: */														csi41 = quo1;														quoLen1 = (csi41 >= 0) ? ((csi41 < 256) ? 1 : ((csi41 < 65536) ? 2 : ((csi41 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi41 < 4294967296) ? 4 : ((csi41 < 1099511627776) ? 5 : ((csi41 < 281474976710656) ? 6 : ((csi41 < 72057594037927936) ? 7 : 8)))))))) : ((csi41 > -256) ? 1 : ((csi41 > -65536) ? 2 : ((csi41 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi41 > -4294967296) ? 4 : ((csi41 > -1099511627776) ? 5 : ((csi41 > -281474976710656) ? 6 : ((csi41 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														quoLen1 = SIZEOF(quo1);													}													dl1 = divLen1 - 1;													ql1 = quoLen1;													dh1 = pDiv1[dl1 - 1];													dnh1 = (dl1 === 1) ? 0 : pDiv1[dl1 - 2];													for (k1 = 1; k1 <= ql1; k1++) {														j2 = remLen1 + 1 - k1;														if (pRem1[j2 - 1] === dh1) {															q1 = 255;														} else {															r1r21 = pRem1[j2 - 1];															r1r21 = (r1r21 << 8 >>> 0) + pRem1[j2 - 2];															t1 = MOD(r1r21, dh1);															q1 = Math.trunc(r1r21 / dh1);															mul1 = q1 * dnh1;															hi1 = mul1 >>> 8;															lo1 = UBANDS(mul1, 255);															r31 = (j2 < 3) ? 0 : pRem1[j2 - 3];															while (true) {																let ret1;																if ((t1 < hi1) || ((t1 === hi1) && (r31 < lo1))) {																	--q1;																	if (hi1 === 0) {																		cond1 = ret1 = false;																	} else {																		if (lo1 < dnh1) {																			--hi1;																			lo1 = lo1 + 256 - dnh1;																		} else {																			lo1 -= dnh1;																		}																		cond1 = ret1 = hi1 >= dh1;																	}																} else {																	cond1 = ret1 = false;																};																if (!(ret1)) break;																hi1 -= dh1;															}														}														l11 = j2 - dl1;														a2 = 0;														for (i4 = 1; i4 <= divLen1; i4++) {															hi1 = pDiv1[i4 - 1] * (q1 >>> 8);															lo1 = pDiv1[i4 - 1] * (UBANDS(q1, 255));															b1 = (pRem1[l11 - 1] - a2) - (UBANDS(lo1, 255));															pRem1[l11 - 1] = (UBANDS(b1, 255));															b1 = b1 >> 8;															a2 = (hi1 + (lo1 >>> 8)) - b1;															++l11;														}														if (a2 > 0) {															--q1;															l11 = j2 - dl1;															a2 = 0;															for (i13 = 1; i13 <= divLen1; i13++) {																a2 = ((a2 >>> 8) + pRem1[l11 - 1]) + pDiv1[i13 - 1];																pRem1[l11 - 1] = (UBANDS(a2, 255));																++l11;															}														}														BYTESOF(quo1)[quoLen1 - k1] = q1;													}													/* end cDigitDiv:len:rem:len:quo:len: */																									/* begin digit:Rshift:lookfirst: */												if ((typeof div1 === "number")) {													/* begin cDigitLengthOfCSI: */													csi51 = div1;													a11 = ((a11 = ((csi51 >= 0) ? ((csi51 < 256) ? 1 : ((csi51 < 65536) ? 2 : ((csi51 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi51 < 4294967296) ? 4 : ((csi51 < 1099511627776) ? 5 : ((csi51 < 281474976710656) ? 6 : ((csi51 < 72057594037927936) ? 7 : 8)))))))) : ((csi51 > -256) ? 1 : ((csi51 > -65536) ? 2 : ((csi51 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi51 > -4294967296) ? 4 : ((csi51 > -1099511627776) ? 5 : ((csi51 > -281474976710656) ? 6 : ((csi51 > -72057594037927936) ? 7 : 8))))))))) - 1)) - 1;													/* end cDigitLengthOfCSI: */												} else {													a11 = ((a11 = SIZEOF(div1) - 1)) - 1;												}												/* begin cDigitHighBit:len: */												realLength1 = a11;												brokenFromLoop_cDigitHighBitlen_12201 = false;												while (((lastDigit1 = BYTESOF(rem1)[realLength1 - 1])) === 0) {													if (((--realLength1)) === 0) {														oldBitLen1 = 0;														brokenFromLoop_cDigitHighBitlen_12201 = true;														break;													}												}												if (!brokenFromLoop_cDigitHighBitlen_12201) {													/* begin cHighBit: */													shifted11 = lastDigit1;													bitNo11 = 0;													if (shifted11 >= (65536)) {														shifted11 = shifted11 >>> 16;														bitNo11 += 16;													}													if (shifted11 >= (256)) {														shifted11 = shifted11 >>> 8;														bitNo11 += 8;													}													if (shifted11 >= (16)) {														shifted11 = shifted11 >>> 4;														bitNo11 += 4;													}													if (shifted11 >= (4)) {														shifted11 = shifted11 >>> 2;														bitNo11 += 2;													}													if (shifted11 >= (2)) {														shifted11 = shifted11 >>> 1;														++bitNo11;													}													oldBitLen1 = (bitNo11 + shifted11) + (8 * (realLength1 - 1));													/* end cHighBit: */												}												/* end cDigitHighBit:len: */												oldDigitLen1 = (oldBitLen1 + 7) >> 3;												newBitLen1 = oldBitLen1 - d1;												if (newBitLen1 <= 0) {													rem1 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);												} else {													newByteLen1 = (newBitLen1 + 7) >> 3;																									newOop1 = (function(__size) {const __result = rem1._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen1);													/* begin cDigitRshift:from:len:to:len: */													pFrom21 = BYTESOF(rem1);													pTo21 = BYTESOF(newOop1);													digitShift21 = d1 >> 3;													bitShift21 = MOD(d1, 8);													if (bitShift21 === 0) {														{														// inlining self cDigitCopyFrom: pFrom21 + digitShift21 to: pTo21 + 0 len: newByteLen1 - 1 - 0 + 1														for (let i = 0; i < newByteLen1; i++) 															pTo21[i] = pFrom21[i + digitShift21];														}													} else {														leftShift1 = 8 - bitShift21;														carry21 = SHR(pFrom21[digitShift21], bitShift21);														start1 = digitShift21 + 1;														limit21 = oldDigitLen1 - 1;														for (j11 = start1; j11 <= limit21; j11++) {															digit21 = pFrom21[j11];															pTo21[j11 - start1] = (UBANDS((UBOR(carry21, (SHL(digit21, leftShift1)))), 255));															carry21 = SHR(digit21, bitShift21);														}														if (carry21 !== 0) {															pTo21[newByteLen1 - 1] = carry21;														}													}													/* end cDigitRshift:from:len:to:len: */													rem1 = newOop1;												}												/* end digit:Rshift:lookfirst: */																									result1 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);													result1[1] = quo1;													result1[2] = rem1;													arg12 = result1;												}												/* end digitDivLarge:with:negative: */												throw Object.create(PrimitiveReturn).setPayload(arg12);											} else {												throw Object.create(PrimitiveFailed).setPayload(1);											}										} else {											minVal = -1073741824;											if (BYTESOF(secondInteger)[sLen - 1] >= (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255))) {												brokenFromLoop_isNormalized_3707 = false;												for (ix2 = 1; ix2 <= sLen; ix2++) {													if (BYTESOF(secondInteger)[ix2 - 1] !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((ix2 - 1) * 8))), 255))) {														returnValueFromLoop_isNormalized_3707 = true;														brokenFromLoop_isNormalized_3707 = true;														break;													}												}											}											throw Object.create(PrimitiveFailed).setPayload(1);										}									}								}							}						}					}					/* end isNormalized: */				} else {					if (len1 < sLen1) {						throw Object.create(PrimitiveFailed).setPayload(1);					} else {						if (firstInteger._class() === SmalltalkGlobals._LargePositiveInteger) {							maxVal1 = 1073741823;							if (BYTESOF(firstInteger)[sLen1 - 1] > (UBANDS((SHR(((maxVal1 < 0) ? (0 - maxVal1) : maxVal1), ((sLen1 - 1) * 8))), 255))) {								/* begin isNormalized: */								if ((typeof secondInteger === "number")) {									if ((typeof firstInteger === "number")) {																			/* begin createLargeFromSmallInteger: */									val = firstInteger;									sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));									res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);									pByte = BYTESOF(res);									for (ix = 1; ix <= size; ix++) {										byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);										pByte[ix - 1] = byte;									}									firstAsLargeInteger = res;									/* end createLargeFromSmallInteger: */									} else {										firstAsLargeInteger = firstInteger;									}									if ((typeof secondInteger === "number")) {										if (secondInteger === 0) {											throw Object.create(PrimitiveFailed).setPayload(1);										}																			/* begin createLargeFromSmallInteger: */									val1 = secondInteger;									class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));									res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);									pByte1 = BYTESOF(res1);									for (ix1 = 1; ix1 <= size1; ix1++) {										byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);										pByte1[ix1 - 1] = byte1;									}									secondAsLargeInteger = res1;									/* end createLargeFromSmallInteger: */									} else {										secondAsLargeInteger = secondInteger;									}									/* begin digitDivLarge:with:negative: */									firstLen2 = SIZEOF(firstAsLargeInteger);									secondLen2 = SIZEOF(secondAsLargeInteger);									resultClass2 = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;									l3 = (firstLen2 - secondLen2) + 1;									if (l3 <= 0) {																			result2 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);										result2[1] = 0;										result2[2] = firstAsLargeInteger;										arg13 = result2;									} else {										/* begin cHighBit: */										shifted3 = BYTESOF(secondAsLargeInteger)[secondLen2 - 1];										bitNo3 = 0;										if (shifted3 >= (65536)) {											shifted3 = shifted3 >>> 16;											bitNo3 += 16;										}										if (shifted3 >= (256)) {											shifted3 = shifted3 >>> 8;											bitNo3 += 8;										}										if (shifted3 >= (16)) {											shifted3 = shifted3 >>> 4;											bitNo3 += 4;										}										if (shifted3 >= (4)) {											shifted3 = shifted3 >>> 2;											bitNo3 += 2;										}										if (shifted3 >= (2)) {											shifted3 = shifted3 >>> 1;											++bitNo3;										}										arg113 = bitNo3 + shifted3;										/* end cHighBit: */										d2 = 8 - arg113;																			/* begin digit:Lshift: */									oldLen5 = SIZEOF(secondAsLargeInteger);									if (((highBit3 = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen5))) === 0) {										div2 = 0;									} else {										newLen3 = ((highBit3 + d2) + 7) >> 3;																			newBytes5 = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen3);										/* begin cDigitLshift:from:len:to:len: */										pFrom4 = BYTESOF(secondAsLargeInteger);										pTo4 = BYTESOF(newBytes5);										digitShift4 = d2 >> 3;										bitShift4 = MOD(d2, 8);										limit4 = digitShift4 - 1;										for (i22 = 0; i22 <= limit4; i22++) {											pTo4[i22] = 0;										}										if (bitShift4 === 0) {											{											// inlining self cDigitCopyFrom: pFrom4 + 0 to: pTo4 + digitShift4 len: newLen3 - 1 - digitShift4 + 1											const len = newLen3 - digitShift4											for (let i = 0; i < len; i++) 												pTo4[i + digitShift4] = pFrom4[i];											}										} else {											rshift3 = 8 - bitShift4;											carry4 = 0;											limit4 = oldLen5 - 1;											for (i112 = 0; i112 <= limit4; i112++) {												digit4 = pFrom4[i112];												pTo4[i112 + digitShift4] = (UBANDS((UBOR(carry4, (SHL(digit4, bitShift4)))), 255));												carry4 = SHR(digit4, rshift3);											}											if (carry4 !== 0) {												pTo4[newLen3 - 1] = carry4;											}										}										/* end cDigitLshift:from:len:to:len: */										div2 = newBytes5;									}									/* end digit:Lshift: */									/* begin largeIntOrInt:growTo: */									if ((typeof div2 === "number")) {										/* begin cDigitLengthOfCSI: */										csi8 = div2;										len4 = ((csi8 >= 0) ? ((csi8 < 256) ? 1 : ((csi8 < 65536) ? 2 : ((csi8 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi8 < 4294967296) ? 4 : ((csi8 < 1099511627776) ? 5 : ((csi8 < 281474976710656) ? 6 : ((csi8 < 72057594037927936) ? 7 : 8)))))))) : ((csi8 > -256) ? 1 : ((csi8 > -65536) ? 2 : ((csi8 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi8 > -4294967296) ? 4 : ((csi8 > -1099511627776) ? 5 : ((csi8 > -281474976710656) ? 6 : ((csi8 > -72057594037927936) ? 7 : 8))))))))) + 1;										/* end cDigitLengthOfCSI: */									} else {										len4 = SIZEOF(div2) + 1;									}									if ((typeof div2 === "number")) {										val4 = div2;										class4 = (val4 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;										newBytes22 = (function(__size) {const __result = class4.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len4);										/* begin cCopyIntVal:toBytes: */										pByte4 = BYTESOF(newBytes22);										const ixLimiT = (val4 >= 0) ? ((val4 < 256) ? 1 : ((val4 < 65536) ? 2 : ((val4 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val4 < 4294967296) ? 4 : ((val4 < 1099511627776) ? 5 : ((val4 < 281474976710656) ? 6 : ((val4 < 72057594037927936) ? 7 : 8)))))))) : ((val4 > -256) ? 1 : ((val4 > -65536) ? 2 : ((val4 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val4 > -4294967296) ? 4 : ((val4 > -1099511627776) ? 5 : ((val4 > -281474976710656) ? 6 : ((val4 > -72057594037927936) ? 7 : 8))))))));										for (ix6 = 1; ix6 <= ixLimiT; ix6++) {											pByte4[ix6 - 1] = (UBANDS((SHR(((val4 < 0) ? (0 - val4) : val4), ((ix6 - 1) * 8))), 255));										}										/* end cCopyIntVal:toBytes: */									} else {										/* begin largeInt:growTo: */																			newBytes112 = (function(__size) {const __result = div2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len4);										oldLen22 = SIZEOF(div2);										copyLen3 = (oldLen22 < len4) ? oldLen22 : len4;										LargeIntegers.cDigitCopyFromtolen(BYTESOF(div2), BYTESOF(newBytes112), copyLen3);										newBytes22 = newBytes112;										/* end largeInt:growTo: */									}									div2 = newBytes22;									/* end largeIntOrInt:growTo: */																			/* begin digit:Lshift: */									oldLen12 = SIZEOF(firstAsLargeInteger);									if (((highBit12 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen12))) === 0) {										rem2 = 0;									} else {										newLen12 = ((highBit12 + d2) + 7) >> 3;																			newBytes14 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen12);										/* begin cDigitLshift:from:len:to:len: */										pFrom12 = BYTESOF(firstAsLargeInteger);										pTo12 = BYTESOF(newBytes14);										digitShift12 = d2 >> 3;										bitShift12 = MOD(d2, 8);										limit12 = digitShift12 - 1;										for (i32 = 0; i32 <= limit12; i32++) {											pTo12[i32] = 0;										}										if (bitShift12 === 0) {											{											// inlining self cDigitCopyFrom: pFrom12 + 0 to: pTo12 + digitShift12 len: newLen12 - 1 - digitShift12 + 1											const len = newLen12 - digitShift12											for (let i = 0; i < len; i++) 												pTo12[i + digitShift12] = pFrom12[i];											}										} else {											rshift12 = 8 - bitShift12;											carry12 = 0;											limit12 = oldLen12 - 1;											for (i122 = 0; i122 <= limit12; i122++) {												digit12 = pFrom12[i122];												pTo12[i122 + digitShift12] = (UBANDS((UBOR(carry12, (SHL(digit12, bitShift12)))), 255));												carry12 = SHR(digit12, rshift12);											}											if (carry12 !== 0) {												pTo12[newLen12 - 1] = carry12;											}										}										/* end cDigitLshift:from:len:to:len: */										rem2 = newBytes14;									}									/* end digit:Lshift: */									let rec1;if ((typeof rem2 === "number")) {										/* begin cDigitLengthOfCSI: */										csi13 = rem2;										rec1 = ((csi13 >= 0) ? ((csi13 < 256) ? 1 : ((csi13 < 65536) ? 2 : ((csi13 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi13 < 4294967296) ? 4 : ((csi13 < 1099511627776) ? 5 : ((csi13 < 281474976710656) ? 6 : ((csi13 < 72057594037927936) ? 7 : 8)))))))) : ((csi13 > -256) ? 1 : ((csi13 > -65536) ? 2 : ((csi13 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi13 > -4294967296) ? 4 : ((csi13 > -1099511627776) ? 5 : ((csi13 > -281474976710656) ? 6 : ((csi13 > -72057594037927936) ? 7 : 8))))))))) === firstLen2;										/* end cDigitLengthOfCSI: */									} else {										rec1 = SIZEOF(rem2) === firstLen2;									};if (rec1) {										/* begin largeIntOrInt:growTo: */										len13 = firstLen2 + 1;										if ((typeof rem2 === "number")) {											val13 = rem2;											class13 = (val13 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;											newBytes32 = (function(__size) {const __result = class13.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len13);											/* begin cCopyIntVal:toBytes: */											pByte13 = BYTESOF(newBytes32);											const ixLimiT = (val13 >= 0) ? ((val13 < 256) ? 1 : ((val13 < 65536) ? 2 : ((val13 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val13 < 4294967296) ? 4 : ((val13 < 1099511627776) ? 5 : ((val13 < 281474976710656) ? 6 : ((val13 < 72057594037927936) ? 7 : 8)))))))) : ((val13 > -256) ? 1 : ((val13 > -65536) ? 2 : ((val13 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val13 > -4294967296) ? 4 : ((val13 > -1099511627776) ? 5 : ((val13 > -281474976710656) ? 6 : ((val13 > -72057594037927936) ? 7 : 8))))))));											for (ix13 = 1; ix13 <= ixLimiT; ix13++) {												pByte13[ix13 - 1] = (UBANDS((SHR(((val13 < 0) ? (0 - val13) : val13), ((ix13 - 1) * 8))), 255));											}											/* end cCopyIntVal:toBytes: */										} else {											/* begin largeInt:growTo: */																					newBytes122 = (function(__size) {const __result = rem2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len13);											oldLen32 = SIZEOF(rem2);											copyLen12 = (oldLen32 < len13) ? oldLen32 : len13;											LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem2), BYTESOF(newBytes122), copyLen12);											newBytes32 = newBytes122;											/* end largeInt:growTo: */										}										rem2 = newBytes32;										/* end largeIntOrInt:growTo: */									}																			quo2 = (function(__size) {const __result = resultClass2.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l3);										/* begin cDigitDiv:len:rem:len:quo:len: */										pDiv2 = BYTESOF(div2);										if ((typeof div2 === "number")) {											/* begin cDigitLengthOfCSI: */											csi22 = div2;											divLen2 = (csi22 >= 0) ? ((csi22 < 256) ? 1 : ((csi22 < 65536) ? 2 : ((csi22 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi22 < 4294967296) ? 4 : ((csi22 < 1099511627776) ? 5 : ((csi22 < 281474976710656) ? 6 : ((csi22 < 72057594037927936) ? 7 : 8)))))))) : ((csi22 > -256) ? 1 : ((csi22 > -65536) ? 2 : ((csi22 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi22 > -4294967296) ? 4 : ((csi22 > -1099511627776) ? 5 : ((csi22 > -281474976710656) ? 6 : ((csi22 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											divLen2 = SIZEOF(div2);										}										pRem2 = BYTESOF(rem2);										if ((typeof rem2 === "number")) {											/* begin cDigitLengthOfCSI: */											csi32 = rem2;											remLen2 = (csi32 >= 0) ? ((csi32 < 256) ? 1 : ((csi32 < 65536) ? 2 : ((csi32 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi32 < 4294967296) ? 4 : ((csi32 < 1099511627776) ? 5 : ((csi32 < 281474976710656) ? 6 : ((csi32 < 72057594037927936) ? 7 : 8)))))))) : ((csi32 > -256) ? 1 : ((csi32 > -65536) ? 2 : ((csi32 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi32 > -4294967296) ? 4 : ((csi32 > -1099511627776) ? 5 : ((csi32 > -281474976710656) ? 6 : ((csi32 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											remLen2 = SIZEOF(rem2);										}										if ((typeof quo2 === "number")) {											/* begin cDigitLengthOfCSI: */											csi42 = quo2;											quoLen2 = (csi42 >= 0) ? ((csi42 < 256) ? 1 : ((csi42 < 65536) ? 2 : ((csi42 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi42 < 4294967296) ? 4 : ((csi42 < 1099511627776) ? 5 : ((csi42 < 281474976710656) ? 6 : ((csi42 < 72057594037927936) ? 7 : 8)))))))) : ((csi42 > -256) ? 1 : ((csi42 > -65536) ? 2 : ((csi42 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi42 > -4294967296) ? 4 : ((csi42 > -1099511627776) ? 5 : ((csi42 > -281474976710656) ? 6 : ((csi42 > -72057594037927936) ? 7 : 8))))))));											/* end cDigitLengthOfCSI: */										} else {											quoLen2 = SIZEOF(quo2);										}										dl2 = divLen2 - 1;										ql2 = quoLen2;										dh2 = pDiv2[dl2 - 1];										dnh2 = (dl2 === 1) ? 0 : pDiv2[dl2 - 2];										for (k2 = 1; k2 <= ql2; k2++) {											j3 = remLen2 + 1 - k2;											if (pRem2[j3 - 1] === dh2) {												q2 = 255;											} else {												r1r22 = pRem2[j3 - 1];												r1r22 = (r1r22 << 8 >>> 0) + pRem2[j3 - 2];												t2 = MOD(r1r22, dh2);												q2 = Math.trunc(r1r22 / dh2);												mul2 = q2 * dnh2;												hi2 = mul2 >>> 8;												lo2 = UBANDS(mul2, 255);												r32 = (j3 < 3) ? 0 : pRem2[j3 - 3];												while (true) {													if ((t2 < hi2) || ((t2 === hi2) && (r32 < lo2))) {														--q2;														if (hi2 === 0) {															cond2 = false;														} else {															if (lo2 < dnh2) {																--hi2;																lo2 = lo2 + 256 - dnh2;															} else {																lo2 -= dnh2;															}															cond2 = hi2 >= dh2;														}													} else {														cond2 = false;													}																										if (!(cond2)) break;													hi2 -= dh2;												}											}											l12 = j3 - dl2;											a3 = 0;											for (i5 = 1; i5 <= divLen2; i5++) {												hi2 = pDiv2[i5 - 1] * (q2 >>> 8);												lo2 = pDiv2[i5 - 1] * (UBANDS(q2, 255));												b2 = (pRem2[l12 - 1] - a3) - (UBANDS(lo2, 255));												pRem2[l12 - 1] = (UBANDS(b2, 255));												b2 = b2 >> 8;												a3 = (hi2 + (lo2 >>> 8)) - b2;												++l12;											}											if (a3 > 0) {												--q2;												l12 = j3 - dl2;												a3 = 0;												for (i14 = 1; i14 <= divLen2; i14++) {													a3 = ((a3 >>> 8) + pRem2[l12 - 1]) + pDiv2[i14 - 1];													pRem2[l12 - 1] = (UBANDS(a3, 255));													++l12;												}											}											BYTESOF(quo2)[quoLen2 - k2] = q2;										}										/* end cDigitDiv:len:rem:len:quo:len: */																			/* begin digit:Rshift:lookfirst: */									if ((typeof div2 === "number")) {										/* begin cDigitLengthOfCSI: */										csi52 = div2;										a12 = ((csi52 >= 0) ? ((csi52 < 256) ? 1 : ((csi52 < 65536) ? 2 : ((csi52 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi52 < 4294967296) ? 4 : ((csi52 < 1099511627776) ? 5 : ((csi52 < 281474976710656) ? 6 : ((csi52 < 72057594037927936) ? 7 : 8)))))))) : ((csi52 > -256) ? 1 : ((csi52 > -65536) ? 2 : ((csi52 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi52 > -4294967296) ? 4 : ((csi52 > -1099511627776) ? 5 : ((csi52 > -281474976710656) ? 6 : ((csi52 > -72057594037927936) ? 7 : 8))))))))) - 1;										/* end cDigitLengthOfCSI: */									} else {										a12 = SIZEOF(div2) - 1;									}									/* begin cDigitHighBit:len: */									realLength2 = a12;									brokenFromLoop_cDigitHighBitlen_12202 = false;									while (((lastDigit2 = BYTESOF(rem2)[realLength2 - 1])) === 0) {										if (((--realLength2)) === 0) {											oldBitLen2 = 0;											brokenFromLoop_cDigitHighBitlen_12202 = true;											break;										}									}									if (!brokenFromLoop_cDigitHighBitlen_12202) {										/* begin cHighBit: */										shifted12 = lastDigit2;										bitNo12 = 0;										if (shifted12 >= (65536)) {											shifted12 = shifted12 >>> 16;											bitNo12 += 16;										}										if (shifted12 >= (256)) {											shifted12 = shifted12 >>> 8;											bitNo12 += 8;										}										if (shifted12 >= (16)) {											shifted12 = shifted12 >>> 4;											bitNo12 += 4;										}										if (shifted12 >= (4)) {											shifted12 = shifted12 >>> 2;											bitNo12 += 2;										}										if (shifted12 >= (2)) {											shifted12 = shifted12 >>> 1;											++bitNo12;										}										oldBitLen2 = (bitNo12 + shifted12) + (8 * (realLength2 - 1));										/* end cHighBit: */									}									/* end cDigitHighBit:len: */									oldDigitLen2 = (oldBitLen2 + 7) >> 3;									newBitLen2 = oldBitLen2 - d2;									if (newBitLen2 <= 0) {										rem2 = (function(__size) {const __result = rem2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);									} else {										newByteLen2 = (newBitLen2 + 7) >> 3;																			newOop2 = (function(__size) {const __result = rem2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen2);										/* begin cDigitRshift:from:len:to:len: */										pFrom22 = BYTESOF(rem2);										pTo22 = BYTESOF(newOop2);										digitShift22 = d2 >> 3;										bitShift22 = MOD(d2, 8);										if (bitShift22 === 0) {											{											// inlining self cDigitCopyFrom: pFrom22 + digitShift22 to: pTo22 + 0 len: newByteLen2 - 1 - 0 + 1											for (let i = 0; i < newByteLen2; i++) 												pTo22[i] = pFrom22[i + digitShift22];											}										} else {											leftShift2 = 8 - bitShift22;											carry22 = SHR(pFrom22[digitShift22], bitShift22);											start2 = digitShift22 + 1;											limit22 = oldDigitLen2 - 1;											for (j12 = start2; j12 <= limit22; j12++) {												digit22 = pFrom22[j12];												pTo22[j12 - start2] = (UBANDS((UBOR(carry22, (SHL(digit22, leftShift2)))), 255));												carry22 = SHR(digit22, bitShift22);											}											if (carry22 !== 0) {												pTo22[newByteLen2 - 1] = carry22;											}										}										/* end cDigitRshift:from:len:to:len: */										rem2 = newOop2;									}									/* end digit:Rshift:lookfirst: */																			result2 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);										result2[1] = quo2;										result2[2] = rem2;										arg13 = result2;									}									/* end digitDivLarge:with:negative: */									throw Object.create(PrimitiveReturn).setPayload(arg13);								} else {									if ((typeof secondInteger === "number")) {										/* begin cDigitLengthOfCSI: */										csi = secondInteger;										len = (csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))));										/* end cDigitLengthOfCSI: */									} else {										len = SIZEOF(secondInteger);									}									if (len === 0) {										throw Object.create(PrimitiveFailed).setPayload(1);									} else {										if (BYTESOF(secondInteger)[len - 1] === 0) {											throw Object.create(PrimitiveFailed).setPayload(1);										} else {											sLen = 4;											if (len > sLen) {												if ((typeof firstInteger === "number")) {																									/* begin createLargeFromSmallInteger: */												val = firstInteger;												sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));												res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);												pByte = BYTESOF(res);												for (ix = 1; ix <= size; ix++) {													byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);													pByte[ix - 1] = byte;												}												firstAsLargeInteger = res;												/* end createLargeFromSmallInteger: */												} else {													firstAsLargeInteger = firstInteger;												}												if ((typeof secondInteger === "number")) {													if (secondInteger === 0) {														throw Object.create(PrimitiveFailed).setPayload(1);													}																									/* begin createLargeFromSmallInteger: */												val1 = secondInteger;												class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));												res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);												pByte1 = BYTESOF(res1);												for (ix1 = 1; ix1 <= size1; ix1++) {													byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);													pByte1[ix1 - 1] = byte1;												}												secondAsLargeInteger = res1;												/* end createLargeFromSmallInteger: */												} else {													secondAsLargeInteger = secondInteger;												}												/* begin digitDivLarge:with:negative: */												firstLen3 = SIZEOF(firstAsLargeInteger);												secondLen3 = SIZEOF(secondAsLargeInteger);												resultClass3 = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;												l4 = (firstLen3 - secondLen3) + 1;												if (l4 <= 0) {																									result3 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);													result3[1] = 0;													result3[2] = firstAsLargeInteger;													arg14 = result3;												} else {													/* begin cHighBit: */													shifted4 = BYTESOF(secondAsLargeInteger)[secondLen3 - 1];													bitNo4 = 0;													if (shifted4 >= (65536)) {														shifted4 = shifted4 >>> 16;														bitNo4 += 16;													}													if (shifted4 >= (256)) {														shifted4 = shifted4 >>> 8;														bitNo4 += 8;													}													if (shifted4 >= (16)) {														shifted4 = shifted4 >>> 4;														bitNo4 += 4;													}													if (shifted4 >= (4)) {														shifted4 = shifted4 >>> 2;														bitNo4 += 2;													}													if (shifted4 >= (2)) {														shifted4 = shifted4 >>> 1;														++bitNo4;													}													arg114 = bitNo4 + shifted4;													/* end cHighBit: */													d3 = 8 - arg114;																									/* begin digit:Lshift: */												oldLen6 = SIZEOF(secondAsLargeInteger);												if (((highBit4 = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen6))) === 0) {													div3 = 0;												} else {													newLen4 = ((highBit4 + d3) + 7) >> 3;																									newBytes6 = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen4);													/* begin cDigitLshift:from:len:to:len: */													pFrom5 = BYTESOF(secondAsLargeInteger);													pTo5 = BYTESOF(newBytes6);													digitShift5 = d3 >> 3;													bitShift5 = MOD(d3, 8);													limit5 = digitShift5 - 1;													for (i23 = 0; i23 <= limit5; i23++) {														pTo5[i23] = 0;													}													if (bitShift5 === 0) {														{														// inlining self cDigitCopyFrom: pFrom5 + 0 to: pTo5 + digitShift5 len: newLen4 - 1 - digitShift5 + 1														const len = newLen4 - digitShift5														for (let i = 0; i < len; i++) 															pTo5[i + digitShift5] = pFrom5[i];														}													} else {														rshift4 = 8 - bitShift5;														carry5 = 0;														limit5 = oldLen6 - 1;														for (i113 = 0; i113 <= limit5; i113++) {															digit5 = pFrom5[i113];															pTo5[i113 + digitShift5] = (UBANDS((UBOR(carry5, (SHL(digit5, bitShift5)))), 255));															carry5 = SHR(digit5, rshift4);														}														if (carry5 !== 0) {															pTo5[newLen4 - 1] = carry5;														}													}													/* end cDigitLshift:from:len:to:len: */													div3 = newBytes6;												}												/* end digit:Lshift: */												/* begin largeIntOrInt:growTo: */												if ((typeof div3 === "number")) {													/* begin cDigitLengthOfCSI: */													csi9 = div3;													len5 = ((csi9 >= 0) ? ((csi9 < 256) ? 1 : ((csi9 < 65536) ? 2 : ((csi9 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi9 < 4294967296) ? 4 : ((csi9 < 1099511627776) ? 5 : ((csi9 < 281474976710656) ? 6 : ((csi9 < 72057594037927936) ? 7 : 8)))))))) : ((csi9 > -256) ? 1 : ((csi9 > -65536) ? 2 : ((csi9 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi9 > -4294967296) ? 4 : ((csi9 > -1099511627776) ? 5 : ((csi9 > -281474976710656) ? 6 : ((csi9 > -72057594037927936) ? 7 : 8))))))))) + 1;													/* end cDigitLengthOfCSI: */												} else {													len5 = SIZEOF(div3) + 1;												}												if ((typeof div3 === "number")) {													val5 = div3;													class5 = (val5 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;													newBytes23 = (function(__size) {const __result = class5.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len5);													/* begin cCopyIntVal:toBytes: */													pByte5 = BYTESOF(newBytes23);													const ixLimiT = (val5 >= 0) ? ((val5 < 256) ? 1 : ((val5 < 65536) ? 2 : ((val5 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val5 < 4294967296) ? 4 : ((val5 < 1099511627776) ? 5 : ((val5 < 281474976710656) ? 6 : ((val5 < 72057594037927936) ? 7 : 8)))))))) : ((val5 > -256) ? 1 : ((val5 > -65536) ? 2 : ((val5 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val5 > -4294967296) ? 4 : ((val5 > -1099511627776) ? 5 : ((val5 > -281474976710656) ? 6 : ((val5 > -72057594037927936) ? 7 : 8))))))));													for (ix7 = 1; ix7 <= ixLimiT; ix7++) {														pByte5[ix7 - 1] = (UBANDS((SHR(((val5 < 0) ? (0 - val5) : val5), ((ix7 - 1) * 8))), 255));													}													/* end cCopyIntVal:toBytes: */												} else {													/* begin largeInt:growTo: */																									newBytes113 = (function(__size) {const __result = div3._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len5);													oldLen23 = SIZEOF(div3);													copyLen4 = (oldLen23 < len5) ? oldLen23 : len5;													LargeIntegers.cDigitCopyFromtolen(BYTESOF(div3), BYTESOF(newBytes113), copyLen4);													newBytes23 = newBytes113;													/* end largeInt:growTo: */												}												div3 = newBytes23;												/* end largeIntOrInt:growTo: */																									/* begin digit:Lshift: */												oldLen13 = SIZEOF(firstAsLargeInteger);												if (((highBit13 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen13))) === 0) {													rem3 = 0;												} else {													newLen13 = ((highBit13 + d3) + 7) >> 3;																									newBytes15 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen13);													/* begin cDigitLshift:from:len:to:len: */													pFrom13 = BYTESOF(firstAsLargeInteger);													pTo13 = BYTESOF(newBytes15);													digitShift13 = d3 >> 3;													bitShift13 = MOD(d3, 8);													limit13 = digitShift13 - 1;													for (i33 = 0; i33 <= limit13; i33++) {														pTo13[i33] = 0;													}													if (bitShift13 === 0) {														{														// inlining self cDigitCopyFrom: pFrom13 + 0 to: pTo13 + digitShift13 len: newLen13 - 1 - digitShift13 + 1														const len = newLen13 - digitShift13														for (let i = 0; i < len; i++) 															pTo13[i + digitShift13] = pFrom13[i];														}													} else {														rshift13 = 8 - bitShift13;														carry13 = 0;														limit13 = oldLen13 - 1;														for (i123 = 0; i123 <= limit13; i123++) {															digit13 = pFrom13[i123];															pTo13[i123 + digitShift13] = (UBANDS((UBOR(carry13, (SHL(digit13, bitShift13)))), 255));															carry13 = SHR(digit13, rshift13);														}														if (carry13 !== 0) {															pTo13[newLen13 - 1] = carry13;														}													}													/* end cDigitLshift:from:len:to:len: */													rem3 = newBytes15;												}												/* end digit:Lshift: */												let rec1;if ((typeof rem3 === "number")) {													/* begin cDigitLengthOfCSI: */													csi14 = rem3;													rec1 = ((csi14 >= 0) ? ((csi14 < 256) ? 1 : ((csi14 < 65536) ? 2 : ((csi14 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi14 < 4294967296) ? 4 : ((csi14 < 1099511627776) ? 5 : ((csi14 < 281474976710656) ? 6 : ((csi14 < 72057594037927936) ? 7 : 8)))))))) : ((csi14 > -256) ? 1 : ((csi14 > -65536) ? 2 : ((csi14 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi14 > -4294967296) ? 4 : ((csi14 > -1099511627776) ? 5 : ((csi14 > -281474976710656) ? 6 : ((csi14 > -72057594037927936) ? 7 : 8))))))))) === firstLen3;													/* end cDigitLengthOfCSI: */												} else {													rec1 = SIZEOF(rem3) === firstLen3;												};if (rec1) {													/* begin largeIntOrInt:growTo: */													len14 = firstLen3 + 1;													if ((typeof rem3 === "number")) {														val14 = rem3;														class14 = (val14 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;														newBytes33 = (function(__size) {const __result = class14.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len14);														/* begin cCopyIntVal:toBytes: */														pByte14 = BYTESOF(newBytes33);														const ixLimiT = (val14 >= 0) ? ((val14 < 256) ? 1 : ((val14 < 65536) ? 2 : ((val14 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val14 < 4294967296) ? 4 : ((val14 < 1099511627776) ? 5 : ((val14 < 281474976710656) ? 6 : ((val14 < 72057594037927936) ? 7 : 8)))))))) : ((val14 > -256) ? 1 : ((val14 > -65536) ? 2 : ((val14 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val14 > -4294967296) ? 4 : ((val14 > -1099511627776) ? 5 : ((val14 > -281474976710656) ? 6 : ((val14 > -72057594037927936) ? 7 : 8))))))));														for (ix14 = 1; ix14 <= ixLimiT; ix14++) {															pByte14[ix14 - 1] = (UBANDS((SHR(((val14 < 0) ? (0 - val14) : val14), ((ix14 - 1) * 8))), 255));														}														/* end cCopyIntVal:toBytes: */													} else {														/* begin largeInt:growTo: */																											newBytes123 = (function(__size) {const __result = rem3._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len14);														oldLen33 = SIZEOF(rem3);														copyLen13 = (oldLen33 < len14) ? oldLen33 : len14;														LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem3), BYTESOF(newBytes123), copyLen13);														newBytes33 = newBytes123;														/* end largeInt:growTo: */													}													rem3 = newBytes33;													/* end largeIntOrInt:growTo: */												}																									quo3 = (function(__size) {const __result = resultClass3.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l4);													/* begin cDigitDiv:len:rem:len:quo:len: */													pDiv3 = BYTESOF(div3);													if ((typeof div3 === "number")) {														/* begin cDigitLengthOfCSI: */														csi23 = div3;														divLen3 = (csi23 >= 0) ? ((csi23 < 256) ? 1 : ((csi23 < 65536) ? 2 : ((csi23 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi23 < 4294967296) ? 4 : ((csi23 < 1099511627776) ? 5 : ((csi23 < 281474976710656) ? 6 : ((csi23 < 72057594037927936) ? 7 : 8)))))))) : ((csi23 > -256) ? 1 : ((csi23 > -65536) ? 2 : ((csi23 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi23 > -4294967296) ? 4 : ((csi23 > -1099511627776) ? 5 : ((csi23 > -281474976710656) ? 6 : ((csi23 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														divLen3 = SIZEOF(div3);													}													pRem3 = BYTESOF(rem3);													if ((typeof rem3 === "number")) {														/* begin cDigitLengthOfCSI: */														csi33 = rem3;														remLen3 = (csi33 >= 0) ? ((csi33 < 256) ? 1 : ((csi33 < 65536) ? 2 : ((csi33 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi33 < 4294967296) ? 4 : ((csi33 < 1099511627776) ? 5 : ((csi33 < 281474976710656) ? 6 : ((csi33 < 72057594037927936) ? 7 : 8)))))))) : ((csi33 > -256) ? 1 : ((csi33 > -65536) ? 2 : ((csi33 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi33 > -4294967296) ? 4 : ((csi33 > -1099511627776) ? 5 : ((csi33 > -281474976710656) ? 6 : ((csi33 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														remLen3 = SIZEOF(rem3);													}													if ((typeof quo3 === "number")) {														/* begin cDigitLengthOfCSI: */														csi43 = quo3;														quoLen3 = (csi43 >= 0) ? ((csi43 < 256) ? 1 : ((csi43 < 65536) ? 2 : ((csi43 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi43 < 4294967296) ? 4 : ((csi43 < 1099511627776) ? 5 : ((csi43 < 281474976710656) ? 6 : ((csi43 < 72057594037927936) ? 7 : 8)))))))) : ((csi43 > -256) ? 1 : ((csi43 > -65536) ? 2 : ((csi43 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi43 > -4294967296) ? 4 : ((csi43 > -1099511627776) ? 5 : ((csi43 > -281474976710656) ? 6 : ((csi43 > -72057594037927936) ? 7 : 8))))))));														/* end cDigitLengthOfCSI: */													} else {														quoLen3 = SIZEOF(quo3);													}													dl3 = divLen3 - 1;													ql3 = quoLen3;													dh3 = pDiv3[dl3 - 1];													dnh3 = (dl3 === 1) ? 0 : pDiv3[dl3 - 2];													for (k3 = 1; k3 <= ql3; k3++) {														j4 = remLen3 + 1 - k3;														if (pRem3[j4 - 1] === dh3) {															q3 = 255;														} else {															r1r23 = pRem3[j4 - 1];															r1r23 = (r1r23 << 8 >>> 0) + pRem3[j4 - 2];															t3 = MOD(r1r23, dh3);															q3 = Math.trunc(r1r23 / dh3);															mul3 = q3 * dnh3;															hi3 = mul3 >>> 8;															lo3 = UBANDS(mul3, 255);															r33 = (j4 < 3) ? 0 : pRem3[j4 - 3];															while (true) {																if ((t3 < hi3) || ((t3 === hi3) && (r33 < lo3))) {																	--q3;																	if (hi3 === 0) {																		cond3 = false;																	} else {																		if (lo3 < dnh3) {																			--hi3;																			lo3 = lo3 + 256 - dnh3;																		} else {																			lo3 -= dnh3;																		}																		cond3 = hi3 >= dh3;																	}																} else {																	cond3 = false;																}																																if (!(cond3)) break;																hi3 -= dh3;															}														}														l13 = j4 - dl3;														a4 = 0;														for (i6 = 1; i6 <= divLen3; i6++) {															hi3 = pDiv3[i6 - 1] * (q3 >>> 8);															lo3 = pDiv3[i6 - 1] * (UBANDS(q3, 255));															b3 = (pRem3[l13 - 1] - a4) - (UBANDS(lo3, 255));															pRem3[l13 - 1] = (UBANDS(b3, 255));															b3 = b3 >> 8;															a4 = (hi3 + (lo3 >>> 8)) - b3;															++l13;														}														if (a4 > 0) {															--q3;															l13 = j4 - dl3;															a4 = 0;															for (i15 = 1; i15 <= divLen3; i15++) {																a4 = ((a4 >>> 8) + pRem3[l13 - 1]) + pDiv3[i15 - 1];																pRem3[l13 - 1] = (UBANDS(a4, 255));																++l13;															}														}														BYTESOF(quo3)[quoLen3 - k3] = q3;													}													/* end cDigitDiv:len:rem:len:quo:len: */																									/* begin digit:Rshift:lookfirst: */												if ((typeof div3 === "number")) {													/* begin cDigitLengthOfCSI: */													csi53 = div3;													a13 = ((csi53 >= 0) ? ((csi53 < 256) ? 1 : ((csi53 < 65536) ? 2 : ((csi53 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi53 < 4294967296) ? 4 : ((csi53 < 1099511627776) ? 5 : ((csi53 < 281474976710656) ? 6 : ((csi53 < 72057594037927936) ? 7 : 8)))))))) : ((csi53 > -256) ? 1 : ((csi53 > -65536) ? 2 : ((csi53 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi53 > -4294967296) ? 4 : ((csi53 > -1099511627776) ? 5 : ((csi53 > -281474976710656) ? 6 : ((csi53 > -72057594037927936) ? 7 : 8))))))))) - 1;													/* end cDigitLengthOfCSI: */												} else {													a13 = SIZEOF(div3) - 1;												}												/* begin cDigitHighBit:len: */												realLength3 = a13;												brokenFromLoop_cDigitHighBitlen_12203 = false;												while (((lastDigit3 = BYTESOF(rem3)[realLength3 - 1])) === 0) {													if (((--realLength3)) === 0) {														oldBitLen3 = 0;														brokenFromLoop_cDigitHighBitlen_12203 = true;														break;													}												}												if (!brokenFromLoop_cDigitHighBitlen_12203) {													/* begin cHighBit: */													shifted13 = lastDigit3;													bitNo13 = 0;													if (shifted13 >= (65536)) {														shifted13 = shifted13 >>> 16;														bitNo13 += 16;													}													if (shifted13 >= (256)) {														shifted13 = shifted13 >>> 8;														bitNo13 += 8;													}													if (shifted13 >= (16)) {														shifted13 = shifted13 >>> 4;														bitNo13 += 4;													}													if (shifted13 >= (4)) {														shifted13 = shifted13 >>> 2;														bitNo13 += 2;													}													if (shifted13 >= (2)) {														shifted13 = shifted13 >>> 1;														++bitNo13;													}													oldBitLen3 = (bitNo13 + shifted13) + (8 * (realLength3 - 1));													/* end cHighBit: */												}												/* end cDigitHighBit:len: */												oldDigitLen3 = (oldBitLen3 + 7) >> 3;												newBitLen3 = oldBitLen3 - d3;												if (newBitLen3 <= 0) {													rem3 = (function(__size) {const __result = rem3._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);												} else {													newByteLen3 = (newBitLen3 + 7) >> 3;																									newOop3 = (function(__size) {const __result = rem3._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen3);													/* begin cDigitRshift:from:len:to:len: */													pFrom23 = BYTESOF(rem3);													pTo23 = BYTESOF(newOop3);													digitShift23 = d3 >> 3;													bitShift23 = MOD(d3, 8);													if (bitShift23 === 0) {														{														// inlining self cDigitCopyFrom: pFrom23 + digitShift23 to: pTo23 + 0 len: newByteLen3 - 1 - 0 + 1														for (let i = 0; i < newByteLen3; i++) 															pTo23[i] = pFrom23[i + digitShift23];														}													} else {														leftShift3 = 8 - bitShift23;														carry23 = SHR(pFrom23[digitShift23], bitShift23);														start3 = digitShift23 + 1;														limit23 = oldDigitLen3 - 1;														for (j13 = start3; j13 <= limit23; j13++) {															digit23 = pFrom23[j13];															pTo23[j13 - start3] = (UBANDS((UBOR(carry23, (SHL(digit23, leftShift3)))), 255));															carry23 = SHR(digit23, bitShift23);														}														if (carry23 !== 0) {															pTo23[newByteLen3 - 1] = carry23;														}													}													/* end cDigitRshift:from:len:to:len: */													rem3 = newOop3;												}												/* end digit:Rshift:lookfirst: */																									result3 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);													result3[1] = quo3;													result3[2] = rem3;													arg14 = result3;												}												/* end digitDivLarge:with:negative: */												throw Object.create(PrimitiveReturn).setPayload(arg14);											} else {												if (len < sLen) {													throw Object.create(PrimitiveFailed).setPayload(1);												} else {													if (secondInteger._class() === SmalltalkGlobals._LargePositiveInteger) {														maxVal = 1073741823;														if (BYTESOF(secondInteger)[sLen - 1] > (UBANDS((SHR(((maxVal < 0) ? (0 - maxVal) : maxVal), ((sLen - 1) * 8))), 255))) {															if ((typeof firstInteger === "number")) {																															/* begin createLargeFromSmallInteger: */															val = firstInteger;															sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;															size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));															res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);															pByte = BYTESOF(res);															for (ix = 1; ix <= size; ix++) {																byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);																pByte[ix - 1] = byte;															}															firstAsLargeInteger = res;															/* end createLargeFromSmallInteger: */															} else {																firstAsLargeInteger = firstInteger;															}															if ((typeof secondInteger === "number")) {																if (secondInteger === 0) {																	throw Object.create(PrimitiveFailed).setPayload(1);																}																															/* begin createLargeFromSmallInteger: */															val1 = secondInteger;															class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;															size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));															res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);															pByte1 = BYTESOF(res1);															for (ix1 = 1; ix1 <= size1; ix1++) {																byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);																pByte1[ix1 - 1] = byte1;															}															secondAsLargeInteger = res1;															/* end createLargeFromSmallInteger: */															} else {																secondAsLargeInteger = secondInteger;															}															/* begin digitDivLarge:with:negative: */															firstLen4 = SIZEOF(firstAsLargeInteger);															secondLen4 = SIZEOF(secondAsLargeInteger);															resultClass4 = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;															l5 = (firstLen4 - secondLen4) + 1;															if (l5 <= 0) {																															result4 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);																result4[1] = 0;																result4[2] = firstAsLargeInteger;																arg15 = result4;															} else {																/* begin cHighBit: */																shifted5 = BYTESOF(secondAsLargeInteger)[secondLen4 - 1];																bitNo5 = 0;																if (shifted5 >= (65536)) {																	shifted5 = shifted5 >>> 16;																	bitNo5 += 16;																}																if (shifted5 >= (256)) {																	shifted5 = shifted5 >>> 8;																	bitNo5 += 8;																}																if (shifted5 >= (16)) {																	shifted5 = shifted5 >>> 4;																	bitNo5 += 4;																}																if (shifted5 >= (4)) {																	shifted5 = shifted5 >>> 2;																	bitNo5 += 2;																}																if (shifted5 >= (2)) {																	shifted5 = shifted5 >>> 1;																	++bitNo5;																}																arg115 = bitNo5 + shifted5;																/* end cHighBit: */																d4 = 8 - arg115;																															/* begin digit:Lshift: */															oldLen7 = SIZEOF(secondAsLargeInteger);															if (((highBit5 = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen7))) === 0) {																div4 = 0;															} else {																newLen5 = ((highBit5 + d4) + 7) >> 3;																															newBytes7 = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen5);																/* begin cDigitLshift:from:len:to:len: */																pFrom6 = BYTESOF(secondAsLargeInteger);																pTo6 = BYTESOF(newBytes7);																digitShift6 = d4 >> 3;																bitShift6 = MOD(d4, 8);																limit6 = digitShift6 - 1;																for (i24 = 0; i24 <= limit6; i24++) {																	pTo6[i24] = 0;																}																if (bitShift6 === 0) {																	{																	// inlining self cDigitCopyFrom: pFrom6 + 0 to: pTo6 + digitShift6 len: newLen5 - 1 - digitShift6 + 1																	const len = newLen5 - digitShift6																	for (let i = 0; i < len; i++) 																		pTo6[i + digitShift6] = pFrom6[i];																	}																} else {																	rshift5 = 8 - bitShift6;																	carry6 = 0;																	limit6 = oldLen7 - 1;																	for (i114 = 0; i114 <= limit6; i114++) {																		digit6 = pFrom6[i114];																		pTo6[i114 + digitShift6] = (UBANDS((UBOR(carry6, (SHL(digit6, bitShift6)))), 255));																		carry6 = SHR(digit6, rshift5);																	}																	if (carry6 !== 0) {																		pTo6[newLen5 - 1] = carry6;																	}																}																/* end cDigitLshift:from:len:to:len: */																div4 = newBytes7;															}															/* end digit:Lshift: */															/* begin largeIntOrInt:growTo: */															if ((typeof div4 === "number")) {																/* begin cDigitLengthOfCSI: */																csi10 = div4;																len6 = ((csi10 >= 0) ? ((csi10 < 256) ? 1 : ((csi10 < 65536) ? 2 : ((csi10 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi10 < 4294967296) ? 4 : ((csi10 < 1099511627776) ? 5 : ((csi10 < 281474976710656) ? 6 : ((csi10 < 72057594037927936) ? 7 : 8)))))))) : ((csi10 > -256) ? 1 : ((csi10 > -65536) ? 2 : ((csi10 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi10 > -4294967296) ? 4 : ((csi10 > -1099511627776) ? 5 : ((csi10 > -281474976710656) ? 6 : ((csi10 > -72057594037927936) ? 7 : 8))))))))) + 1;																/* end cDigitLengthOfCSI: */															} else {																len6 = SIZEOF(div4) + 1;															}															if ((typeof div4 === "number")) {																val6 = div4;																class6 = (val6 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;																newBytes24 = (function(__size) {const __result = class6.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len6);																/* begin cCopyIntVal:toBytes: */																pByte6 = BYTESOF(newBytes24);																const ixLimiT = (val6 >= 0) ? ((val6 < 256) ? 1 : ((val6 < 65536) ? 2 : ((val6 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val6 < 4294967296) ? 4 : ((val6 < 1099511627776) ? 5 : ((val6 < 281474976710656) ? 6 : ((val6 < 72057594037927936) ? 7 : 8)))))))) : ((val6 > -256) ? 1 : ((val6 > -65536) ? 2 : ((val6 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val6 > -4294967296) ? 4 : ((val6 > -1099511627776) ? 5 : ((val6 > -281474976710656) ? 6 : ((val6 > -72057594037927936) ? 7 : 8))))))));																for (ix8 = 1; ix8 <= ixLimiT; ix8++) {																	pByte6[ix8 - 1] = (UBANDS((SHR(((val6 < 0) ? (0 - val6) : val6), ((ix8 - 1) * 8))), 255));																}																/* end cCopyIntVal:toBytes: */															} else {																/* begin largeInt:growTo: */																															newBytes114 = (function(__size) {const __result = div4._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len6);																oldLen24 = SIZEOF(div4);																copyLen5 = (oldLen24 < len6) ? oldLen24 : len6;																LargeIntegers.cDigitCopyFromtolen(BYTESOF(div4), BYTESOF(newBytes114), copyLen5);																newBytes24 = newBytes114;																/* end largeInt:growTo: */															}															div4 = newBytes24;															/* end largeIntOrInt:growTo: */																															/* begin digit:Lshift: */															oldLen14 = SIZEOF(firstAsLargeInteger);															if (((highBit14 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen14))) === 0) {																rem4 = 0;															} else {																newLen14 = ((highBit14 + d4) + 7) >> 3;																															newBytes16 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen14);																/* begin cDigitLshift:from:len:to:len: */																pFrom14 = BYTESOF(firstAsLargeInteger);																pTo14 = BYTESOF(newBytes16);																digitShift14 = d4 >> 3;																bitShift14 = MOD(d4, 8);																limit14 = digitShift14 - 1;																for (i34 = 0; i34 <= limit14; i34++) {																	pTo14[i34] = 0;																}																if (bitShift14 === 0) {																	{																	// inlining self cDigitCopyFrom: pFrom14 + 0 to: pTo14 + digitShift14 len: newLen14 - 1 - digitShift14 + 1																	const len = newLen14 - digitShift14																	for (let i = 0; i < len; i++) 																		pTo14[i + digitShift14] = pFrom14[i];																	}																} else {																	rshift14 = 8 - bitShift14;																	carry14 = 0;																	limit14 = oldLen14 - 1;																	for (i124 = 0; i124 <= limit14; i124++) {																		digit14 = pFrom14[i124];																		pTo14[i124 + digitShift14] = (UBANDS((UBOR(carry14, (SHL(digit14, bitShift14)))), 255));																		carry14 = SHR(digit14, rshift14);																	}																	if (carry14 !== 0) {																		pTo14[newLen14 - 1] = carry14;																	}																}																/* end cDigitLshift:from:len:to:len: */																rem4 = newBytes16;															}															/* end digit:Lshift: */															let rec1;if ((typeof rem4 === "number")) {																/* begin cDigitLengthOfCSI: */																csi15 = rem4;																rec1 = ((csi15 >= 0) ? ((csi15 < 256) ? 1 : ((csi15 < 65536) ? 2 : ((csi15 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi15 < 4294967296) ? 4 : ((csi15 < 1099511627776) ? 5 : ((csi15 < 281474976710656) ? 6 : ((csi15 < 72057594037927936) ? 7 : 8)))))))) : ((csi15 > -256) ? 1 : ((csi15 > -65536) ? 2 : ((csi15 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi15 > -4294967296) ? 4 : ((csi15 > -1099511627776) ? 5 : ((csi15 > -281474976710656) ? 6 : ((csi15 > -72057594037927936) ? 7 : 8))))))))) === firstLen4;																/* end cDigitLengthOfCSI: */															} else {																rec1 = SIZEOF(rem4) === firstLen4;															};if (rec1) {																/* begin largeIntOrInt:growTo: */																len15 = firstLen4 + 1;																if ((typeof rem4 === "number")) {																	val15 = rem4;																	class15 = (val15 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;																	newBytes34 = (function(__size) {const __result = class15.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len15);																	/* begin cCopyIntVal:toBytes: */																	pByte15 = BYTESOF(newBytes34);																	const ixLimiT = (val15 >= 0) ? ((val15 < 256) ? 1 : ((val15 < 65536) ? 2 : ((val15 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val15 < 4294967296) ? 4 : ((val15 < 1099511627776) ? 5 : ((val15 < 281474976710656) ? 6 : ((val15 < 72057594037927936) ? 7 : 8)))))))) : ((val15 > -256) ? 1 : ((val15 > -65536) ? 2 : ((val15 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val15 > -4294967296) ? 4 : ((val15 > -1099511627776) ? 5 : ((val15 > -281474976710656) ? 6 : ((val15 > -72057594037927936) ? 7 : 8))))))));																	for (ix15 = 1; ix15 <= ixLimiT; ix15++) {																		pByte15[ix15 - 1] = (UBANDS((SHR(((val15 < 0) ? (0 - val15) : val15), ((ix15 - 1) * 8))), 255));																	}																	/* end cCopyIntVal:toBytes: */																} else {																	/* begin largeInt:growTo: */																																	newBytes124 = (function(__size) {const __result = rem4._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len15);																	oldLen34 = SIZEOF(rem4);																	copyLen14 = (oldLen34 < len15) ? oldLen34 : len15;																	LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem4), BYTESOF(newBytes124), copyLen14);																	newBytes34 = newBytes124;																	/* end largeInt:growTo: */																}																rem4 = newBytes34;																/* end largeIntOrInt:growTo: */															}																															quo4 = (function(__size) {const __result = resultClass4.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l5);																/* begin cDigitDiv:len:rem:len:quo:len: */																pDiv4 = BYTESOF(div4);																if ((typeof div4 === "number")) {																	/* begin cDigitLengthOfCSI: */																	csi24 = div4;																	divLen4 = (csi24 >= 0) ? ((csi24 < 256) ? 1 : ((csi24 < 65536) ? 2 : ((csi24 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi24 < 4294967296) ? 4 : ((csi24 < 1099511627776) ? 5 : ((csi24 < 281474976710656) ? 6 : ((csi24 < 72057594037927936) ? 7 : 8)))))))) : ((csi24 > -256) ? 1 : ((csi24 > -65536) ? 2 : ((csi24 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi24 > -4294967296) ? 4 : ((csi24 > -1099511627776) ? 5 : ((csi24 > -281474976710656) ? 6 : ((csi24 > -72057594037927936) ? 7 : 8))))))));																	/* end cDigitLengthOfCSI: */																} else {																	divLen4 = SIZEOF(div4);																}																pRem4 = BYTESOF(rem4);																if ((typeof rem4 === "number")) {																	/* begin cDigitLengthOfCSI: */																	csi34 = rem4;																	remLen4 = (csi34 >= 0) ? ((csi34 < 256) ? 1 : ((csi34 < 65536) ? 2 : ((csi34 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi34 < 4294967296) ? 4 : ((csi34 < 1099511627776) ? 5 : ((csi34 < 281474976710656) ? 6 : ((csi34 < 72057594037927936) ? 7 : 8)))))))) : ((csi34 > -256) ? 1 : ((csi34 > -65536) ? 2 : ((csi34 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi34 > -4294967296) ? 4 : ((csi34 > -1099511627776) ? 5 : ((csi34 > -281474976710656) ? 6 : ((csi34 > -72057594037927936) ? 7 : 8))))))));																	/* end cDigitLengthOfCSI: */																} else {																	remLen4 = SIZEOF(rem4);																}																if ((typeof quo4 === "number")) {																	/* begin cDigitLengthOfCSI: */																	csi44 = quo4;																	quoLen4 = (csi44 >= 0) ? ((csi44 < 256) ? 1 : ((csi44 < 65536) ? 2 : ((csi44 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi44 < 4294967296) ? 4 : ((csi44 < 1099511627776) ? 5 : ((csi44 < 281474976710656) ? 6 : ((csi44 < 72057594037927936) ? 7 : 8)))))))) : ((csi44 > -256) ? 1 : ((csi44 > -65536) ? 2 : ((csi44 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi44 > -4294967296) ? 4 : ((csi44 > -1099511627776) ? 5 : ((csi44 > -281474976710656) ? 6 : ((csi44 > -72057594037927936) ? 7 : 8))))))));																	/* end cDigitLengthOfCSI: */																} else {																	quoLen4 = SIZEOF(quo4);																}																dl4 = divLen4 - 1;																ql4 = quoLen4;																dh4 = pDiv4[dl4 - 1];																dnh4 = (dl4 === 1) ? 0 : pDiv4[dl4 - 2];																for (k4 = 1; k4 <= ql4; k4++) {																	j5 = remLen4 + 1 - k4;																	if (pRem4[j5 - 1] === dh4) {																		q4 = 255;																	} else {																		r1r24 = pRem4[j5 - 1];																		r1r24 = (r1r24 << 8 >>> 0) + pRem4[j5 - 2];																		t4 = MOD(r1r24, dh4);																		q4 = Math.trunc(r1r24 / dh4);																		mul4 = q4 * dnh4;																		hi4 = mul4 >>> 8;																		lo4 = UBANDS(mul4, 255);																		r34 = (j5 < 3) ? 0 : pRem4[j5 - 3];																		while (true) {																			if ((t4 < hi4) || ((t4 === hi4) && (r34 < lo4))) {																				--q4;																				if (hi4 === 0) {																					cond4 = false;																				} else {																					if (lo4 < dnh4) {																						--hi4;																						lo4 = lo4 + 256 - dnh4;																					} else {																						lo4 -= dnh4;																					}																					cond4 = hi4 >= dh4;																				}																			} else {																				cond4 = false;																			}																																						if (!(cond4)) break;																			hi4 -= dh4;																		}																	}																	l14 = j5 - dl4;																	a5 = 0;																	for (i7 = 1; i7 <= divLen4; i7++) {																		hi4 = pDiv4[i7 - 1] * (q4 >>> 8);																		lo4 = pDiv4[i7 - 1] * (UBANDS(q4, 255));																		b4 = (pRem4[l14 - 1] - a5) - (UBANDS(lo4, 255));																		pRem4[l14 - 1] = (UBANDS(b4, 255));																		b4 = b4 >> 8;																		a5 = (hi4 + (lo4 >>> 8)) - b4;																		++l14;																	}																	if (a5 > 0) {																		--q4;																		l14 = j5 - dl4;																		a5 = 0;																		for (i16 = 1; i16 <= divLen4; i16++) {																			a5 = ((a5 >>> 8) + pRem4[l14 - 1]) + pDiv4[i16 - 1];																			pRem4[l14 - 1] = (UBANDS(a5, 255));																			++l14;																		}																	}																	BYTESOF(quo4)[quoLen4 - k4] = q4;																}																/* end cDigitDiv:len:rem:len:quo:len: */																															/* begin digit:Rshift:lookfirst: */															if ((typeof div4 === "number")) {																/* begin cDigitLengthOfCSI: */																csi54 = div4;																a14 = ((csi54 >= 0) ? ((csi54 < 256) ? 1 : ((csi54 < 65536) ? 2 : ((csi54 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi54 < 4294967296) ? 4 : ((csi54 < 1099511627776) ? 5 : ((csi54 < 281474976710656) ? 6 : ((csi54 < 72057594037927936) ? 7 : 8)))))))) : ((csi54 > -256) ? 1 : ((csi54 > -65536) ? 2 : ((csi54 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi54 > -4294967296) ? 4 : ((csi54 > -1099511627776) ? 5 : ((csi54 > -281474976710656) ? 6 : ((csi54 > -72057594037927936) ? 7 : 8))))))))) - 1;																/* end cDigitLengthOfCSI: */															} else {																a14 = SIZEOF(div4) - 1;															}															/* begin cDigitHighBit:len: */															realLength4 = a14;															brokenFromLoop_cDigitHighBitlen_12204 = false;															while (((lastDigit4 = BYTESOF(rem4)[realLength4 - 1])) === 0) {																if (((--realLength4)) === 0) {																	oldBitLen4 = 0;																	brokenFromLoop_cDigitHighBitlen_12204 = true;																	break;																}															}															if (!brokenFromLoop_cDigitHighBitlen_12204) {																/* begin cHighBit: */																shifted14 = lastDigit4;																bitNo14 = 0;																if (shifted14 >= (65536)) {																	shifted14 = shifted14 >>> 16;																	bitNo14 += 16;																}																if (shifted14 >= (256)) {																	shifted14 = shifted14 >>> 8;																	bitNo14 += 8;																}																if (shifted14 >= (16)) {																	shifted14 = shifted14 >>> 4;																	bitNo14 += 4;																}																if (shifted14 >= (4)) {																	shifted14 = shifted14 >>> 2;																	bitNo14 += 2;																}																if (shifted14 >= (2)) {																	shifted14 = shifted14 >>> 1;																	++bitNo14;																}																oldBitLen4 = (bitNo14 + shifted14) + (8 * (realLength4 - 1));																/* end cHighBit: */															}															/* end cDigitHighBit:len: */															oldDigitLen4 = (oldBitLen4 + 7) >> 3;															newBitLen4 = oldBitLen4 - d4;															if (newBitLen4 <= 0) {																rem4 = (function(__size) {const __result = rem4._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);															} else {																newByteLen4 = (newBitLen4 + 7) >> 3;																															newOop4 = (function(__size) {const __result = rem4._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen4);																/* begin cDigitRshift:from:len:to:len: */																pFrom24 = BYTESOF(rem4);																pTo24 = BYTESOF(newOop4);																digitShift24 = d4 >> 3;																bitShift24 = MOD(d4, 8);																if (bitShift24 === 0) {																	{																	// inlining self cDigitCopyFrom: pFrom24 + digitShift24 to: pTo24 + 0 len: newByteLen4 - 1 - 0 + 1																	for (let i = 0; i < newByteLen4; i++) 																		pTo24[i] = pFrom24[i + digitShift24];																	}																} else {																	leftShift4 = 8 - bitShift24;																	carry24 = SHR(pFrom24[digitShift24], bitShift24);																	start4 = digitShift24 + 1;																	limit24 = oldDigitLen4 - 1;																	for (j14 = start4; j14 <= limit24; j14++) {																		digit24 = pFrom24[j14];																		pTo24[j14 - start4] = (UBANDS((UBOR(carry24, (SHL(digit24, leftShift4)))), 255));																		carry24 = SHR(digit24, bitShift24);																	}																	if (carry24 !== 0) {																		pTo24[newByteLen4 - 1] = carry24;																	}																}																/* end cDigitRshift:from:len:to:len: */																rem4 = newOop4;															}															/* end digit:Rshift:lookfirst: */																															result4 = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);																result4[1] = quo4;																result4[2] = rem4;																arg15 = result4;															}															/* end digitDivLarge:with:negative: */															throw Object.create(PrimitiveReturn).setPayload(arg15);														} else {															throw Object.create(PrimitiveFailed).setPayload(1);														}													} else {														minVal = -1073741824;														if (BYTESOF(secondInteger)[sLen - 1] >= (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255))) {															brokenFromLoop_isNormalized_3707 = false;															for (ix2 = 1; ix2 <= sLen; ix2++) {																if (BYTESOF(secondInteger)[ix2 - 1] !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((ix2 - 1) * 8))), 255))) {																	returnValueFromLoop_isNormalized_3707 = true;																	brokenFromLoop_isNormalized_3707 = true;																	break;																}															}														}														throw Object.create(PrimitiveFailed).setPayload(1);													}												}											}										}									}								}								/* end isNormalized: */							} else {								throw Object.create(PrimitiveFailed).setPayload(1);							}						} else {							minVal1 = -1073741824;							if (BYTESOF(firstInteger)[sLen1 - 1] >= (UBANDS((SHR(((minVal1 < 0) ? (0 - minVal1) : minVal1), ((sLen1 - 1) * 8))), 255))) {								brokenFromLoop_isNormalized_3298 = false;								for (ix3 = 1; ix3 <= sLen1; ix3++) {									if (BYTESOF(firstInteger)[ix3 - 1] !== (UBANDS((SHR(((minVal1 < 0) ? (0 - minVal1) : minVal1), ((ix3 - 1) * 8))), 255))) {										returnValueFromLoop_isNormalized_3298 = true;										brokenFromLoop_isNormalized_3298 = true;										break;									}								}							}							throw Object.create(PrimitiveFailed).setPayload(1);						}					}				}			}		}	}	/* end isNormalized: */}, /*	Answer the result of dividing firstInteger by secondInteger.	Fail if parameters are not integers or secondInteger is zero. */primDigitDivWithNegative(firstInteger, secondInteger, neg) {	let firstAsLargeInteger;	let secondAsLargeInteger;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let resultClass;	let result;	let rem;	let div;	let quo;	let d;	let l;	let secondLen;	let firstLen;	let csi;	let csi1;	let csi2;	let csi3;	let csi4;	let csi5;	let arg111;	let shifted;	let bitNo;	let pDiv;	let divLen;	let pRem;	let remLen;	let quoLen;	let b;	let q;	let a;	let dnh;	let lo;	let hi;	let r3;	let mul;	let cond;	let l1;	let k;	let j;	let i;	let dl;	let ql;	let i1;	let r1r2;	let dh;	let t;	let highBit;	let newBytes;	let oldLen;	let newLen;	let pFrom;	let pTo;	let digitShift;	let carry;	let digit;	let i2;	let i11;	let bitShift;	let rshift;	let limit;	let highBit1;	let newBytes1;	let oldLen1;	let newLen1;	let pFrom1;	let pTo1;	let digitShift1;	let carry1;	let digit1;	let i3;	let i12;	let bitShift1;	let rshift1;	let limit1;	let len;	let class2;	let val2;	let newBytes2;	let pByte2;	let ix2;	let oldLen2;	let newBytes11;	let copyLen;	let len1;	let class11;	let val11;	let newBytes3;	let pByte11;	let ix11;	let oldLen3;	let newBytes12;	let copyLen1;	let a1;	let newOop;	let oldDigitLen;	let newByteLen;	let newBitLen;	let oldBitLen;	let pFrom2;	let pTo2;	let j1;	let digitShift2;	let carry2;	let digit2;	let bitShift2;	let leftShift;	let limit2;	let start;	let lastDigit;	let realLength;	let shifted1;	let bitNo1;	let brokenFromLoop_cDigitHighBitlen_1220;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof neg.valueOf() !== "boolean") throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof firstInteger === "number")) {		/* convert to LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstAsLargeInteger = res;	/* end createLargeFromSmallInteger: */	} else {		firstAsLargeInteger = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* check for zerodivide and convert to LargeInteger */		if (secondInteger === 0) {			throw Object.create(PrimitiveFailed).setPayload(1);		}			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondAsLargeInteger = res1;	/* end createLargeFromSmallInteger: */	} else {		secondAsLargeInteger = secondInteger;	}	/* begin digitDivLarge:with:negative: */	firstLen = SIZEOF(firstAsLargeInteger);	secondLen = SIZEOF(secondAsLargeInteger);	resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	l = (firstLen - secondLen) + 1;	if (l <= 0) {			result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);		result[1] = 0;		result[2] = firstAsLargeInteger;		arg11 = result;	} else {		/* begin cHighBit: */		shifted = BYTESOF(secondAsLargeInteger)[secondLen - 1];		bitNo = 0;		if (shifted >= (65536)) {			shifted = shifted >>> 16;			bitNo += 16;		}		if (shifted >= (256)) {			shifted = shifted >>> 8;			bitNo += 8;		}		if (shifted >= (16)) {			shifted = shifted >>> 4;			bitNo += 4;		}		if (shifted >= (4)) {			shifted = shifted >>> 2;			bitNo += 2;		}		if (shifted >= (2)) {			shifted = shifted >>> 1;			++bitNo;		}		arg111 = bitNo + shifted;		/* end cHighBit: */		d = 8 - arg111;			/* begin digit:Lshift: */	oldLen = SIZEOF(secondAsLargeInteger);	if (((highBit = LargeIntegers.cDigitHighBitlen(BYTESOF(secondAsLargeInteger), oldLen))) === 0) {		div = 0;	} else {		newLen = ((highBit + d) + 7) >> 3;			newBytes = (function(__size) {const __result = secondAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen);		/* begin cDigitLshift:from:len:to:len: */		pFrom = BYTESOF(secondAsLargeInteger);		pTo = BYTESOF(newBytes);		digitShift = d >> 3;		bitShift = MOD(d, 8);		limit = digitShift - 1;		for (i2 = 0; i2 <= limit; i2++) {			pTo[i2] = 0;		}		if (bitShift === 0) {			{			// inlining self cDigitCopyFrom: pFrom + 0 to: pTo + digitShift len: newLen - 1 - digitShift + 1			const len = newLen - digitShift			for (let i = 0; i < len; i++) 				pTo[i + digitShift] = pFrom[i];			}		} else {			rshift = 8 - bitShift;			carry = 0;			limit = oldLen - 1;			for (i11 = 0; i11 <= limit; i11++) {				digit = pFrom[i11];				pTo[i11 + digitShift] = (UBANDS((UBOR(carry, (SHL(digit, bitShift)))), 255));				carry = SHR(digit, rshift);			}			if (carry !== 0) {				pTo[newLen - 1] = carry;			}		}		/* end cDigitLshift:from:len:to:len: */		div = newBytes;	}	/* end digit:Lshift: */	/* begin largeIntOrInt:growTo: */	if ((typeof div === "number")) {		/* begin cDigitLengthOfCSI: */		csi = div;		len = ((csi >= 0) ? ((csi < 256) ? 1 : ((csi < 65536) ? 2 : ((csi < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi < 4294967296) ? 4 : ((csi < 1099511627776) ? 5 : ((csi < 281474976710656) ? 6 : ((csi < 72057594037927936) ? 7 : 8)))))))) : ((csi > -256) ? 1 : ((csi > -65536) ? 2 : ((csi > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi > -4294967296) ? 4 : ((csi > -1099511627776) ? 5 : ((csi > -281474976710656) ? 6 : ((csi > -72057594037927936) ? 7 : 8))))))))) + 1;		/* end cDigitLengthOfCSI: */	} else {		len = SIZEOF(div) + 1;	}	if ((typeof div === "number")) {		val2 = div;		class2 = (val2 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;		newBytes2 = (function(__size) {const __result = class2.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);		/* begin cCopyIntVal:toBytes: */		pByte2 = BYTESOF(newBytes2);		const ixLimiT = (val2 >= 0) ? ((val2 < 256) ? 1 : ((val2 < 65536) ? 2 : ((val2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val2 < 4294967296) ? 4 : ((val2 < 1099511627776) ? 5 : ((val2 < 281474976710656) ? 6 : ((val2 < 72057594037927936) ? 7 : 8)))))))) : ((val2 > -256) ? 1 : ((val2 > -65536) ? 2 : ((val2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val2 > -4294967296) ? 4 : ((val2 > -1099511627776) ? 5 : ((val2 > -281474976710656) ? 6 : ((val2 > -72057594037927936) ? 7 : 8))))))));		for (ix2 = 1; ix2 <= ixLimiT; ix2++) {			pByte2[ix2 - 1] = (UBANDS((SHR(((val2 < 0) ? (0 - val2) : val2), ((ix2 - 1) * 8))), 255));		}		/* end cCopyIntVal:toBytes: */	} else {		/* begin largeInt:growTo: */			newBytes11 = (function(__size) {const __result = div._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);		oldLen2 = SIZEOF(div);		copyLen = (oldLen2 < len) ? oldLen2 : len;		LargeIntegers.cDigitCopyFromtolen(BYTESOF(div), BYTESOF(newBytes11), copyLen);		newBytes2 = newBytes11;		/* end largeInt:growTo: */	}	div = newBytes2;	/* end largeIntOrInt:growTo: */			/* begin digit:Lshift: */	oldLen1 = SIZEOF(firstAsLargeInteger);	if (((highBit1 = LargeIntegers.cDigitHighBitlen(BYTESOF(firstAsLargeInteger), oldLen1))) === 0) {		rem = 0;	} else {		newLen1 = ((highBit1 + d) + 7) >> 3;			newBytes1 = (function(__size) {const __result = firstAsLargeInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newLen1);		/* begin cDigitLshift:from:len:to:len: */		pFrom1 = BYTESOF(firstAsLargeInteger);		pTo1 = BYTESOF(newBytes1);		digitShift1 = d >> 3;		bitShift1 = MOD(d, 8);		limit1 = digitShift1 - 1;		for (i3 = 0; i3 <= limit1; i3++) {			pTo1[i3] = 0;		}		if (bitShift1 === 0) {			{			// inlining self cDigitCopyFrom: pFrom1 + 0 to: pTo1 + digitShift1 len: newLen1 - 1 - digitShift1 + 1			const len = newLen1 - digitShift1			for (let i = 0; i < len; i++) 				pTo1[i + digitShift1] = pFrom1[i];			}		} else {			rshift1 = 8 - bitShift1;			carry1 = 0;			limit1 = oldLen1 - 1;			for (i12 = 0; i12 <= limit1; i12++) {				digit1 = pFrom1[i12];				pTo1[i12 + digitShift1] = (UBANDS((UBOR(carry1, (SHL(digit1, bitShift1)))), 255));				carry1 = SHR(digit1, rshift1);			}			if (carry1 !== 0) {				pTo1[newLen1 - 1] = carry1;			}		}		/* end cDigitLshift:from:len:to:len: */		rem = newBytes1;	}	/* end digit:Lshift: */	let rec1;if ((typeof rem === "number")) {		/* begin cDigitLengthOfCSI: */		csi1 = rem;		rec1 = ((csi1 >= 0) ? ((csi1 < 256) ? 1 : ((csi1 < 65536) ? 2 : ((csi1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi1 < 4294967296) ? 4 : ((csi1 < 1099511627776) ? 5 : ((csi1 < 281474976710656) ? 6 : ((csi1 < 72057594037927936) ? 7 : 8)))))))) : ((csi1 > -256) ? 1 : ((csi1 > -65536) ? 2 : ((csi1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi1 > -4294967296) ? 4 : ((csi1 > -1099511627776) ? 5 : ((csi1 > -281474976710656) ? 6 : ((csi1 > -72057594037927936) ? 7 : 8))))))))) === firstLen;		/* end cDigitLengthOfCSI: */	} else {		rec1 = SIZEOF(rem) === firstLen;	};if (rec1) {		/* begin largeIntOrInt:growTo: */		len1 = firstLen + 1;		if ((typeof rem === "number")) {			val11 = rem;			class11 = (val11 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;			newBytes3 = (function(__size) {const __result = class11.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);			/* begin cCopyIntVal:toBytes: */			pByte11 = BYTESOF(newBytes3);			const ixLimiT = (val11 >= 0) ? ((val11 < 256) ? 1 : ((val11 < 65536) ? 2 : ((val11 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val11 < 4294967296) ? 4 : ((val11 < 1099511627776) ? 5 : ((val11 < 281474976710656) ? 6 : ((val11 < 72057594037927936) ? 7 : 8)))))))) : ((val11 > -256) ? 1 : ((val11 > -65536) ? 2 : ((val11 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val11 > -4294967296) ? 4 : ((val11 > -1099511627776) ? 5 : ((val11 > -281474976710656) ? 6 : ((val11 > -72057594037927936) ? 7 : 8))))))));			for (ix11 = 1; ix11 <= ixLimiT; ix11++) {				pByte11[ix11 - 1] = (UBANDS((SHR(((val11 < 0) ? (0 - val11) : val11), ((ix11 - 1) * 8))), 255));			}			/* end cCopyIntVal:toBytes: */		} else {			/* begin largeInt:growTo: */					newBytes12 = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);			oldLen3 = SIZEOF(rem);			copyLen1 = (oldLen3 < len1) ? oldLen3 : len1;			LargeIntegers.cDigitCopyFromtolen(BYTESOF(rem), BYTESOF(newBytes12), copyLen1);			newBytes3 = newBytes12;			/* end largeInt:growTo: */		}		rem = newBytes3;		/* end largeIntOrInt:growTo: */	}			quo = (function(__size) {const __result = resultClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(l);		/* begin cDigitDiv:len:rem:len:quo:len: */		pDiv = BYTESOF(div);		if ((typeof div === "number")) {			/* begin cDigitLengthOfCSI: */			csi2 = div;			divLen = (csi2 >= 0) ? ((csi2 < 256) ? 1 : ((csi2 < 65536) ? 2 : ((csi2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 < 4294967296) ? 4 : ((csi2 < 1099511627776) ? 5 : ((csi2 < 281474976710656) ? 6 : ((csi2 < 72057594037927936) ? 7 : 8)))))))) : ((csi2 > -256) ? 1 : ((csi2 > -65536) ? 2 : ((csi2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi2 > -4294967296) ? 4 : ((csi2 > -1099511627776) ? 5 : ((csi2 > -281474976710656) ? 6 : ((csi2 > -72057594037927936) ? 7 : 8))))))));			/* end cDigitLengthOfCSI: */		} else {			divLen = SIZEOF(div);		}		pRem = BYTESOF(rem);		if ((typeof rem === "number")) {			/* begin cDigitLengthOfCSI: */			csi3 = rem;			remLen = (csi3 >= 0) ? ((csi3 < 256) ? 1 : ((csi3 < 65536) ? 2 : ((csi3 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 < 4294967296) ? 4 : ((csi3 < 1099511627776) ? 5 : ((csi3 < 281474976710656) ? 6 : ((csi3 < 72057594037927936) ? 7 : 8)))))))) : ((csi3 > -256) ? 1 : ((csi3 > -65536) ? 2 : ((csi3 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi3 > -4294967296) ? 4 : ((csi3 > -1099511627776) ? 5 : ((csi3 > -281474976710656) ? 6 : ((csi3 > -72057594037927936) ? 7 : 8))))))));			/* end cDigitLengthOfCSI: */		} else {			remLen = SIZEOF(rem);		}		if ((typeof quo === "number")) {			/* begin cDigitLengthOfCSI: */			csi4 = quo;			quoLen = (csi4 >= 0) ? ((csi4 < 256) ? 1 : ((csi4 < 65536) ? 2 : ((csi4 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 < 4294967296) ? 4 : ((csi4 < 1099511627776) ? 5 : ((csi4 < 281474976710656) ? 6 : ((csi4 < 72057594037927936) ? 7 : 8)))))))) : ((csi4 > -256) ? 1 : ((csi4 > -65536) ? 2 : ((csi4 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi4 > -4294967296) ? 4 : ((csi4 > -1099511627776) ? 5 : ((csi4 > -281474976710656) ? 6 : ((csi4 > -72057594037927936) ? 7 : 8))))))));			/* end cDigitLengthOfCSI: */		} else {			quoLen = SIZEOF(quo);		}		dl = divLen - 1;		ql = quoLen;		dh = pDiv[dl - 1];		dnh = (dl === 1) ? 0 : pDiv[dl - 2];		for (k = 1; k <= ql; k++) {			j = remLen + 1 - k;			if (pRem[j - 1] === dh) {				q = 255;			} else {				r1r2 = pRem[j - 1];				r1r2 = (r1r2 << 8 >>> 0) + pRem[j - 2];				t = MOD(r1r2, dh);				q = Math.trunc(r1r2 / dh);				mul = q * dnh;				hi = mul >>> 8;				lo = UBANDS(mul, 255);				r3 = (j < 3) ? 0 : pRem[j - 3];				while (true) {					if ((t < hi) || ((t === hi) && (r3 < lo))) {						--q;						if (hi === 0) {							cond = false;						} else {							if (lo < dnh) {								--hi;								lo = lo + 256 - dnh;							} else {								lo -= dnh;							}							cond = hi >= dh;						}					} else {						cond = false;					}										if (!(cond)) break;					hi -= dh;				}			}			l1 = j - dl;			a = 0;			for (i = 1; i <= divLen; i++) {				hi = pDiv[i - 1] * (q >>> 8);				lo = pDiv[i - 1] * (UBANDS(q, 255));				b = (pRem[l1 - 1] - a) - (UBANDS(lo, 255));				pRem[l1 - 1] = (UBANDS(b, 255));				b = b >> 8;				a = (hi + (lo >>> 8)) - b;				++l1;			}			if (a > 0) {				--q;				l1 = j - dl;				a = 0;				for (i1 = 1; i1 <= divLen; i1++) {					a = ((a >>> 8) + pRem[l1 - 1]) + pDiv[i1 - 1];					pRem[l1 - 1] = (UBANDS(a, 255));					++l1;				}			}			BYTESOF(quo)[quoLen - k] = q;		}		/* end cDigitDiv:len:rem:len:quo:len: */			/* begin digit:Rshift:lookfirst: */	if ((typeof div === "number")) {		/* begin cDigitLengthOfCSI: */		csi5 = div;		a1 = ((csi5 >= 0) ? ((csi5 < 256) ? 1 : ((csi5 < 65536) ? 2 : ((csi5 < 16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 < 4294967296) ? 4 : ((csi5 < 1099511627776) ? 5 : ((csi5 < 281474976710656) ? 6 : ((csi5 < 72057594037927936) ? 7 : 8)))))))) : ((csi5 > -256) ? 1 : ((csi5 > -65536) ? 2 : ((csi5 > -16777216) ? 3 : ((8 === 4) ? 4 : ((csi5 > -4294967296) ? 4 : ((csi5 > -1099511627776) ? 5 : ((csi5 > -281474976710656) ? 6 : ((csi5 > -72057594037927936) ? 7 : 8))))))))) - 1;		/* end cDigitLengthOfCSI: */	} else {		a1 = SIZEOF(div) - 1;	}	/* begin cDigitHighBit:len: */	realLength = a1;	brokenFromLoop_cDigitHighBitlen_1220 = false;	while (((lastDigit = BYTESOF(rem)[realLength - 1])) === 0) {		if (((--realLength)) === 0) {			oldBitLen = 0;			brokenFromLoop_cDigitHighBitlen_1220 = true;			break;		}	}	if (!brokenFromLoop_cDigitHighBitlen_1220) {		/* begin cHighBit: */		shifted1 = lastDigit;		bitNo1 = 0;		if (shifted1 >= (65536)) {			shifted1 = shifted1 >>> 16;			bitNo1 += 16;		}		if (shifted1 >= (256)) {			shifted1 = shifted1 >>> 8;			bitNo1 += 8;		}		if (shifted1 >= (16)) {			shifted1 = shifted1 >>> 4;			bitNo1 += 4;		}		if (shifted1 >= (4)) {			shifted1 = shifted1 >>> 2;			bitNo1 += 2;		}		if (shifted1 >= (2)) {			shifted1 = shifted1 >>> 1;			++bitNo1;		}		oldBitLen = (bitNo1 + shifted1) + (8 * (realLength - 1));		/* end cHighBit: */	}	/* end cDigitHighBit:len: */	oldDigitLen = (oldBitLen + 7) >> 3;	newBitLen = oldBitLen - d;	if (newBitLen <= 0) {		rem = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(0);	} else {		newByteLen = (newBitLen + 7) >> 3;			newOop = (function(__size) {const __result = rem._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(newByteLen);		/* begin cDigitRshift:from:len:to:len: */		pFrom2 = BYTESOF(rem);		pTo2 = BYTESOF(newOop);		digitShift2 = d >> 3;		bitShift2 = MOD(d, 8);		if (bitShift2 === 0) {			{			// inlining self cDigitCopyFrom: pFrom2 + digitShift2 to: pTo2 + 0 len: newByteLen - 1 - 0 + 1			for (let i = 0; i < newByteLen; i++) 				pTo2[i] = pFrom2[i + digitShift2];			}		} else {			leftShift = 8 - bitShift2;			carry2 = SHR(pFrom2[digitShift2], bitShift2);			start = digitShift2 + 1;			limit2 = oldDigitLen - 1;			for (j1 = start; j1 <= limit2; j1++) {				digit2 = pFrom2[j1];				pTo2[j1 - start] = (UBANDS((UBOR(carry2, (SHL(digit2, leftShift)))), 255));				carry2 = SHR(digit2, bitShift2);			}			if (carry2 !== 0) {				pTo2[newByteLen - 1] = carry2;			}		}		/* end cDigitRshift:from:len:to:len: */		rem = newOop;	}	/* end digit:Rshift:lookfirst: */			result = (function(__size) {const __result = SmalltalkGlobals._Array.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(2);		result[1] = quo;		result[2] = rem;		arg11 = result;	}	/* end digitDivLarge:with:negative: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitMultiplyNegative(secondInteger, neg) {	let firstLarge;	let firstInteger;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let longInt;	let resultClass;	let shortLen;	let shortInt;	let longLen;	let prod;	let secondLen;	let firstLen;	let pByteShort;	let pByteLong;	let pByteRes;	let ab;	let j;	let digit;	let carry;	let i;	let limitLong;	let k;	let limitShort;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	let len1;	let i2;	let i1;	let sLen1;	let minVal;	let oldLen3;	let val11;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof neg.valueOf() !== "boolean") throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitMultiplyLarge:with:negative: */	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen <= secondLen) {		shortInt = firstLarge;		shortLen = firstLen;		longInt = secondLarge;		longLen = secondLen;	} else {		shortInt = secondLarge;		shortLen = secondLen;		longInt = firstLarge;		longLen = firstLen;	}	resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	prod = (function(__size) {const __result = resultClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})((longLen + shortLen));	/* begin cDigitMultiply:len:with:len:into: */	pByteShort = BYTESOF(shortInt);	pByteLong = BYTESOF(longInt);	pByteRes = BYTESOF(prod);	if (!((shortLen === 1) && (pByteShort[0] === 0))) {		if (!((longLen === 1) && (pByteLong[0] === 0))) {			limitShort = shortLen - 1;			limitLong = longLen - 1;			for (i = 0; i <= limitShort; i++) {				if (((digit = pByteShort[i])) !== 0) {					k = i;					carry = 0;					for (j = 0; j <= limitLong; j++) {						ab = pByteLong[j];						ab = ((ab * digit) + carry) + pByteRes[k];						carry = ab >>> 8;						pByteRes[k] = (UBANDS(ab, 255));						++k;					}					pByteRes[k] = carry;				}			}		}	}	/* end cDigitMultiply:len:with:len:into: */	/* begin normalize: */	if (prod._class() === SmalltalkGlobals._LargePositiveInteger) {		/* begin normalizePositive: */		len = (typeof prod === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(prod))) : ((oldLen = SIZEOF(prod)));		while ((len !== 0) && (BYTESOF(prod)[len - 1] === 0)) {			--len;		}		if (len === 0) {			arg11 = 0;		} else {			sLen = 4;			if ((len <= sLen) && (((sLen > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {				val2 = 0;				for (i3 = len; i3 >= 1; i3--) {					val2 = (val2 * 256) + BYTESOF(prod)[i3 - 1];				}				arg11 = val2;			} else {				if (len < oldLen) {					/* begin bytes:growTo: */									newBytes = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);					oldLen1 = BYTESIZEOF(prod);					copyLen = (oldLen1 < len) ? oldLen1 : len;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes), copyLen);					arg11 = newBytes;					/* end bytes:growTo: */				} else {					arg11 = prod;				}			}		}		/* end normalizePositive: */	} else {		/* begin normalizeNegative: */		len1 = (typeof prod === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(prod))) : ((oldLen3 = SIZEOF(prod)));		while ((len1 !== 0) && (BYTESOF(prod)[len1 - 1] === 0)) {			--len1;		}		if (len1 === 0) {			arg11 = 0;		} else {			sLen1 = 4;			if (len1 <= sLen1) {				minVal = -1073741824;				if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {					val11 = 0;					for (i2 = len1; i2 >= 1; i2--) {						val11 = (val11 * 256) - BYTESOF(prod)[i2 - 1];					}					arg11 = val11;				} else {					brokenFromLoop_normalizeNegative_2202 = false;					for (i1 = 1; i1 <= sLen1; i1++) {						if (((i1 > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[i1 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i1 - 1) * 8))), 255))) {							if (len1 < oldLen3) {								/* begin bytes:growTo: */															newBytes2 = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);								oldLen11 = BYTESIZEOF(prod);								copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;								LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes2), copyLen2);								returnValueFromLoop_normalizeNegative_2202 = newBytes2;								/* end bytes:growTo: */							} else {								returnValueFromLoop_normalizeNegative_2202 = prod;							}							brokenFromLoop_normalizeNegative_2202 = true;							break;						}					}					arg11 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;				}			} else {				if (len1 < oldLen3) {					/* begin bytes:growTo: */									newBytes1 = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);					oldLen2 = BYTESIZEOF(prod);					copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes1), copyLen1);					arg11 = newBytes1;					/* end bytes:growTo: */				} else {					arg11 = prod;				}			}		}		/* end normalizeNegative: */	}	/* end normalize: */	/* end digitMultiplyLarge:with:negative: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitMultiplyWithNegative(firstInteger, secondInteger, neg) {	let firstLarge;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let longInt;	let resultClass;	let shortLen;	let shortInt;	let longLen;	let prod;	let secondLen;	let firstLen;	let pByteShort;	let pByteLong;	let pByteRes;	let ab;	let j;	let digit;	let carry;	let i;	let limitLong;	let k;	let limitShort;	let i3;	let len;	let sLen;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	let len1;	let i2;	let i1;	let sLen1;	let minVal;	let oldLen3;	let val11;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (typeof neg.valueOf() !== "boolean") throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitMultiplyLarge:with:negative: */	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen <= secondLen) {		shortInt = firstLarge;		shortLen = firstLen;		longInt = secondLarge;		longLen = secondLen;	} else {		shortInt = secondLarge;		shortLen = secondLen;		longInt = firstLarge;		longLen = firstLen;	}	resultClass = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	prod = (function(__size) {const __result = resultClass.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})((longLen + shortLen));	/* begin cDigitMultiply:len:with:len:into: */	pByteShort = BYTESOF(shortInt);	pByteLong = BYTESOF(longInt);	pByteRes = BYTESOF(prod);	if (!((shortLen === 1) && (pByteShort[0] === 0))) {		if (!((longLen === 1) && (pByteLong[0] === 0))) {			limitShort = shortLen - 1;			limitLong = longLen - 1;			for (i = 0; i <= limitShort; i++) {				if (((digit = pByteShort[i])) !== 0) {					k = i;					carry = 0;					for (j = 0; j <= limitLong; j++) {						ab = pByteLong[j];						ab = ((ab * digit) + carry) + pByteRes[k];						carry = ab >>> 8;						pByteRes[k] = (UBANDS(ab, 255));						++k;					}					pByteRes[k] = carry;				}			}		}	}	/* end cDigitMultiply:len:with:len:into: */	/* begin normalize: */	if (prod._class() === SmalltalkGlobals._LargePositiveInteger) {		/* begin normalizePositive: */		len = (typeof prod === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(prod))) : ((oldLen = SIZEOF(prod)));		while ((len !== 0) && (BYTESOF(prod)[len - 1] === 0)) {			--len;		}		if (len === 0) {			arg11 = 0;		} else {			sLen = 4;			if ((len <= sLen) && (((sLen > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {				val2 = 0;				for (i3 = len; i3 >= 1; i3--) {					val2 = (val2 * 256) + BYTESOF(prod)[i3 - 1];				}				arg11 = val2;			} else {				if (len < oldLen) {					/* begin bytes:growTo: */									newBytes = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);					oldLen1 = BYTESIZEOF(prod);					copyLen = (oldLen1 < len) ? oldLen1 : len;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes), copyLen);					arg11 = newBytes;					/* end bytes:growTo: */				} else {					arg11 = prod;				}			}		}		/* end normalizePositive: */	} else {		/* begin normalizeNegative: */		len1 = (typeof prod === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(prod))) : ((oldLen3 = SIZEOF(prod)));		while ((len1 !== 0) && (BYTESOF(prod)[len1 - 1] === 0)) {			--len1;		}		if (len1 === 0) {			arg11 = 0;		} else {			sLen1 = 4;			if (len1 <= sLen1) {				minVal = -1073741824;				if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {					val11 = 0;					for (i2 = len1; i2 >= 1; i2--) {						val11 = (val11 * 256) - BYTESOF(prod)[i2 - 1];					}					arg11 = val11;				} else {					brokenFromLoop_normalizeNegative_2202 = false;					for (i1 = 1; i1 <= sLen1; i1++) {						if (((i1 > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[i1 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i1 - 1) * 8))), 255))) {							if (len1 < oldLen3) {								/* begin bytes:growTo: */															newBytes2 = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);								oldLen11 = BYTESIZEOF(prod);								copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;								LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes2), copyLen2);								returnValueFromLoop_normalizeNegative_2202 = newBytes2;								/* end bytes:growTo: */							} else {								returnValueFromLoop_normalizeNegative_2202 = prod;							}							brokenFromLoop_normalizeNegative_2202 = true;							break;						}					}					arg11 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;				}			} else {				if (len1 < oldLen3) {					/* begin bytes:growTo: */									newBytes1 = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);					oldLen2 = BYTESIZEOF(prod);					copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes1), copyLen1);					arg11 = newBytes1;					/* end bytes:growTo: */				} else {					arg11 = prod;				}			}		}		/* end normalizeNegative: */	}	/* end normalize: */	/* end digitMultiplyLarge:with:negative: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitSubtract(secondInteger) {	let firstLarge;	let firstInteger;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let smallerLen;	let larger;	let res2;	let zzzTemp;	let smaller;	let resLen;	let largerLen;	let firstNeg;	let firstLen;	let secondLen;	let neg;	let pByteLarge;	let pByteRes;	let z;	let i;	let i1;	let len;	let i2;	let i11;	let sLen;	let minVal;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_1558;	let brokenFromLoop_normalizeNegative_1558;	let i3;	let len1;	let sLen1;	let oldLen3;	let val11;	let oldLen11;	let newBytes2;	let copyLen2;	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitSubLarge:with: */	firstNeg = firstLarge._class() === SmalltalkGlobals._LargeNegativeInteger;	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen === secondLen) {		while ((firstLen > 1) && (((firstLen > SIZEOF(firstLarge)	? 0	: BYTESOF(firstLarge)[firstLen - 1])) === ((firstLen > SIZEOF(secondLarge)	? 0	: BYTESOF(secondLarge)[firstLen - 1])))) {			--firstLen;		}		secondLen = firstLen;	}	if ((firstLen < secondLen) || ((firstLen === secondLen) && (((firstLen > SIZEOF(firstLarge)	? 0	: BYTESOF(firstLarge)[firstLen - 1])) < ((firstLen > SIZEOF(secondLarge)	? 0	: BYTESOF(secondLarge)[firstLen - 1]))))) {		larger = secondLarge;		largerLen = secondLen;		smaller = firstLarge;		smallerLen = firstLen;		neg = firstNeg === false;	} else {		larger = firstLarge;		largerLen = firstLen;		smaller = secondLarge;		smallerLen = secondLen;		neg = firstNeg;	}	resLen = largerLen;	zzzTemp = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;res2 = (function(__size) {const __result = zzzTemp.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(resLen);	/* begin cDigitSub:len:with:len:into: */	pByteLarge = BYTESOF(larger);	pByteRes = BYTESOF(res2);	z = 0;	for (i = 0; i < smallerLen; i++) {		z = (z + pByteLarge[i]) - BYTESOF(smaller)[i];		pByteRes[i] = z;		z = z >> 8;	}	for (i1 = smallerLen; i1 < largerLen; i1++) {		z += pByteLarge[i1];		pByteRes[i1] = z;		z = z >> 8;	}	/* end cDigitSub:len:with:len:into: */	if (neg) {		/* begin normalizeNegative: */		len = (typeof res2 === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(res2))) : ((oldLen = SIZEOF(res2)));		while ((len !== 0) && (BYTESOF(res2)[len - 1] === 0)) {			--len;		}		if (len === 0) {			arg11 = 0;		} else {			sLen = 4;			if (len <= sLen) {				minVal = -1073741824;				if ((len < sLen) || (((sLen > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[sLen - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255)))) {					val2 = 0;					for (i2 = len; i2 >= 1; i2--) {						val2 = (val2 * 256) - BYTESOF(res2)[i2 - 1];					}					arg11 = val2;				} else {					brokenFromLoop_normalizeNegative_1558 = false;					for (i11 = 1; i11 <= sLen; i11++) {						if (((i11 > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[i11 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i11 - 1) * 8))), 255))) {							if (len < oldLen) {								/* begin bytes:growTo: */															newBytes = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);								oldLen1 = BYTESIZEOF(res2);								copyLen = (oldLen1 < len) ? oldLen1 : len;								LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes), copyLen);								returnValueFromLoop_normalizeNegative_1558 = newBytes;								/* end bytes:growTo: */							} else {								returnValueFromLoop_normalizeNegative_1558 = res2;							}							brokenFromLoop_normalizeNegative_1558 = true;							break;						}					}					arg11 = brokenFromLoop_normalizeNegative_1558 ? returnValueFromLoop_normalizeNegative_1558 : minVal;				}			} else {				if (len < oldLen) {					/* begin bytes:growTo: */									newBytes1 = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);					oldLen2 = BYTESIZEOF(res2);					copyLen1 = (oldLen2 < len) ? oldLen2 : len;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes1), copyLen1);					arg11 = newBytes1;					/* end bytes:growTo: */				} else {					arg11 = res2;				}			}		}		/* end normalizeNegative: */	} else {		/* begin normalizePositive: */		len1 = (typeof res2 === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(res2))) : ((oldLen3 = SIZEOF(res2)));		while ((len1 !== 0) && (BYTESOF(res2)[len1 - 1] === 0)) {			--len1;		}		if (len1 === 0) {			arg11 = 0;		} else {			sLen1 = 4;			if ((len1 <= sLen1) && (((sLen1 > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[sLen1 - 1])) <= (UBANDS((SHR((1073741823), ((sLen1 - 1) * 8))), 255)))) {				val11 = 0;				for (i3 = len1; i3 >= 1; i3--) {					val11 = (val11 * 256) + BYTESOF(res2)[i3 - 1];				}				arg11 = val11;			} else {				if (len1 < oldLen3) {					/* begin bytes:growTo: */									newBytes2 = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);					oldLen11 = BYTESIZEOF(res2);					copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes2), copyLen2);					arg11 = newBytes2;					/* end bytes:growTo: */				} else {					arg11 = res2;				}			}		}		/* end normalizePositive: */	}	/* end digitSubLarge:with: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primDigitSubtractWith(firstInteger, secondInteger) {	let firstLarge;	let secondLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let arg11;	let smallerLen;	let larger;	let res2;	let zzzTemp;	let smaller;	let resLen;	let largerLen;	let firstNeg;	let firstLen;	let secondLen;	let neg;	let pByteLarge;	let pByteRes;	let z;	let i;	let i1;	let len;	let i2;	let i11;	let sLen;	let minVal;	let oldLen;	let val2;	let oldLen1;	let newBytes;	let copyLen;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_1558;	let brokenFromLoop_normalizeNegative_1558;	let i3;	let len1;	let sLen1;	let oldLen3;	let val11;	let oldLen11;	let newBytes2;	let copyLen2;	if ((typeof firstInteger !== "number" && typeof firstInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof secondInteger !== "number" && typeof secondInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondInteger;	}	/* begin digitSubLarge:with: */	firstNeg = firstLarge._class() === SmalltalkGlobals._LargeNegativeInteger;	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	if (firstLen === secondLen) {		while ((firstLen > 1) && (((firstLen > SIZEOF(firstLarge)	? 0	: BYTESOF(firstLarge)[firstLen - 1])) === ((firstLen > SIZEOF(secondLarge)	? 0	: BYTESOF(secondLarge)[firstLen - 1])))) {			--firstLen;		}		secondLen = firstLen;	}	if ((firstLen < secondLen) || ((firstLen === secondLen) && (((firstLen > SIZEOF(firstLarge)	? 0	: BYTESOF(firstLarge)[firstLen - 1])) < ((firstLen > SIZEOF(secondLarge)	? 0	: BYTESOF(secondLarge)[firstLen - 1]))))) {		larger = secondLarge;		largerLen = secondLen;		smaller = firstLarge;		smallerLen = firstLen;		neg = firstNeg === false;	} else {		larger = firstLarge;		largerLen = firstLen;		smaller = secondLarge;		smallerLen = secondLen;		neg = firstNeg;	}	resLen = largerLen;	zzzTemp = neg ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;res2 = (function(__size) {const __result = zzzTemp.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(resLen);	/* begin cDigitSub:len:with:len:into: */	pByteLarge = BYTESOF(larger);	pByteRes = BYTESOF(res2);	z = 0;	for (i = 0; i < smallerLen; i++) {		z = (z + pByteLarge[i]) - BYTESOF(smaller)[i];		pByteRes[i] = z;		z = z >> 8;	}	for (i1 = smallerLen; i1 < largerLen; i1++) {		z += pByteLarge[i1];		pByteRes[i1] = z;		z = z >> 8;	}	/* end cDigitSub:len:with:len:into: */	if (neg) {		/* begin normalizeNegative: */		len = (typeof res2 === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(res2))) : ((oldLen = SIZEOF(res2)));		while ((len !== 0) && (BYTESOF(res2)[len - 1] === 0)) {			--len;		}		if (len === 0) {			arg11 = 0;		} else {			sLen = 4;			if (len <= sLen) {				minVal = -1073741824;				if ((len < sLen) || (((sLen > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[sLen - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255)))) {					val2 = 0;					for (i2 = len; i2 >= 1; i2--) {						val2 = (val2 * 256) - BYTESOF(res2)[i2 - 1];					}					arg11 = val2;				} else {					brokenFromLoop_normalizeNegative_1558 = false;					for (i11 = 1; i11 <= sLen; i11++) {						if (((i11 > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[i11 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i11 - 1) * 8))), 255))) {							if (len < oldLen) {								/* begin bytes:growTo: */															newBytes = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);								oldLen1 = BYTESIZEOF(res2);								copyLen = (oldLen1 < len) ? oldLen1 : len;								LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes), copyLen);								returnValueFromLoop_normalizeNegative_1558 = newBytes;								/* end bytes:growTo: */							} else {								returnValueFromLoop_normalizeNegative_1558 = res2;							}							brokenFromLoop_normalizeNegative_1558 = true;							break;						}					}					arg11 = brokenFromLoop_normalizeNegative_1558 ? returnValueFromLoop_normalizeNegative_1558 : minVal;				}			} else {				if (len < oldLen) {					/* begin bytes:growTo: */									newBytes1 = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);					oldLen2 = BYTESIZEOF(res2);					copyLen1 = (oldLen2 < len) ? oldLen2 : len;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes1), copyLen1);					arg11 = newBytes1;					/* end bytes:growTo: */				} else {					arg11 = res2;				}			}		}		/* end normalizeNegative: */	} else {		/* begin normalizePositive: */		len1 = (typeof res2 === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(res2))) : ((oldLen3 = SIZEOF(res2)));		while ((len1 !== 0) && (BYTESOF(res2)[len1 - 1] === 0)) {			--len1;		}		if (len1 === 0) {			arg11 = 0;		} else {			sLen1 = 4;			if ((len1 <= sLen1) && (((sLen1 > BYTESIZEOF(res2)	? 0	: BYTESOF(res2)[sLen1 - 1])) <= (UBANDS((SHR((1073741823), ((sLen1 - 1) * 8))), 255)))) {				val11 = 0;				for (i3 = len1; i3 >= 1; i3--) {					val11 = (val11 * 256) + BYTESOF(res2)[i3 - 1];				}				arg11 = val11;			} else {				if (len1 < oldLen3) {					/* begin bytes:growTo: */									newBytes2 = (function(__size) {const __result = res2._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);					oldLen11 = BYTESIZEOF(res2);					copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;					LargeIntegers.cDigitCopyFromtolen(BYTESOF(res2), BYTESOF(newBytes2), copyLen2);					arg11 = newBytes2;					/* end bytes:growTo: */				} else {					arg11 = res2;				}			}		}		/* end normalizePositive: */	}	/* end digitSubLarge:with: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, /*	If calling this primitive fails, then C module does not exist. */primGetModuleName() {	let strLen;	let i;	let strOop;	strLen = LargeIntegers.strlen(LargeIntegers.getModuleName.apply(this, arguments));	strOop = (function(__size) {const __result = SmalltalkGlobals._String.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(strLen);	for (i = 0; i < strLen; i++) {		SmalltalkVM.storeByteofObjectwithValue(i, strOop, LargeIntegers.getModuleName.apply(this, arguments)[i]);	}	throw Object.create(PrimitiveReturn).setPayload(strOop);}, primMontgomeryDigitLength() {	throw Object.create(PrimitiveReturn).setPayload(8);}, primMontgomeryTimesModulo(secondOperandInteger, thirdModuloInteger, smallInverseInteger) {	let firstLarge;	let secondLarge;	let firstInteger;	let thirdLarge;	let size;	let res;	let byte;	let pByte;	let ix;	let sq_class;	let val;	let size1;	let res1;	let byte1;	let pByte1;	let ix1;	let class1;	let val1;	let size2;	let res2;	let byte2;	let pByte2;	let ix2;	let class2;	let val2;	let arg11;	let prod;	let thirdLen;	let firstLen;	let secondLen;	let pBytesFirst;	let pBytesSecond;	let pBytesThird;	let pBytesRes;	let k;	let i2;	let k2;	let i;	let i1;	let lastByte;	let k1;	let limit3;	let limit2;	let limit1;	let u;	let accum;	let firstDigit;	let secondDigit;	let ix3;	let returnValueFromLoop_cDigitComparewithlen_3435;	let brokenFromLoop_cDigitComparewithlen_3435;	let i3;	let len;	let sLen;	let oldLen;	let val3;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof secondOperandInteger !== "number" && typeof secondOperandInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof thirdModuloInteger !== "number" && typeof thirdModuloInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if (!(typeof smallInverseInteger === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof this !== "number" && typeof this.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	firstInteger = this;	if ((typeof firstInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val = firstInteger;	sq_class = (val < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size = (val >= 0) ? ((val < 256) ? 1 : ((val < 65536) ? 2 : ((val < 16777216) ? 3 : ((8 === 4) ? 4 : ((val < 4294967296) ? 4 : ((val < 1099511627776) ? 5 : ((val < 281474976710656) ? 6 : ((val < 72057594037927936) ? 7 : 8)))))))) : ((val > -256) ? 1 : ((val > -65536) ? 2 : ((val > -16777216) ? 3 : ((8 === 4) ? 4 : ((val > -4294967296) ? 4 : ((val > -1099511627776) ? 5 : ((val > -281474976710656) ? 6 : ((val > -72057594037927936) ? 7 : 8))))))));	res = (function(__size) {const __result = sq_class.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size);	pByte = BYTESOF(res);	for (ix = 1; ix <= size; ix++) {		byte = UBANDS((SHR(((val < 0) ? (0 - val) : val), ((ix - 1) * 8))), 255);		pByte[ix - 1] = byte;	}	firstLarge = res;	/* end createLargeFromSmallInteger: */	} else {		firstLarge = firstInteger;	}	if ((typeof secondOperandInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val1 = secondOperandInteger;	class1 = (val1 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size1 = (val1 >= 0) ? ((val1 < 256) ? 1 : ((val1 < 65536) ? 2 : ((val1 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val1 < 4294967296) ? 4 : ((val1 < 1099511627776) ? 5 : ((val1 < 281474976710656) ? 6 : ((val1 < 72057594037927936) ? 7 : 8)))))))) : ((val1 > -256) ? 1 : ((val1 > -65536) ? 2 : ((val1 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val1 > -4294967296) ? 4 : ((val1 > -1099511627776) ? 5 : ((val1 > -281474976710656) ? 6 : ((val1 > -72057594037927936) ? 7 : 8))))))));	res1 = (function(__size) {const __result = class1.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size1);	pByte1 = BYTESOF(res1);	for (ix1 = 1; ix1 <= size1; ix1++) {		byte1 = UBANDS((SHR(((val1 < 0) ? (0 - val1) : val1), ((ix1 - 1) * 8))), 255);		pByte1[ix1 - 1] = byte1;	}	secondLarge = res1;	/* end createLargeFromSmallInteger: */	} else {		secondLarge = secondOperandInteger;	}	if ((typeof thirdModuloInteger === "number")) {		/* convert it to a not normalized LargeInteger */			/* begin createLargeFromSmallInteger: */	val2 = thirdModuloInteger;	class2 = (val2 < 0) ? SmalltalkGlobals._LargeNegativeInteger : SmalltalkGlobals._LargePositiveInteger;	size2 = (val2 >= 0) ? ((val2 < 256) ? 1 : ((val2 < 65536) ? 2 : ((val2 < 16777216) ? 3 : ((8 === 4) ? 4 : ((val2 < 4294967296) ? 4 : ((val2 < 1099511627776) ? 5 : ((val2 < 281474976710656) ? 6 : ((val2 < 72057594037927936) ? 7 : 8)))))))) : ((val2 > -256) ? 1 : ((val2 > -65536) ? 2 : ((val2 > -16777216) ? 3 : ((8 === 4) ? 4 : ((val2 > -4294967296) ? 4 : ((val2 > -1099511627776) ? 5 : ((val2 > -281474976710656) ? 6 : ((val2 > -72057594037927936) ? 7 : 8))))))));	res2 = (function(__size) {const __result = class2.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(size2);	pByte2 = BYTESOF(res2);	for (ix2 = 1; ix2 <= size2; ix2++) {		byte2 = UBANDS((SHR(((val2 < 0) ? (0 - val2) : val2), ((ix2 - 1) * 8))), 255);		pByte2[ix2 - 1] = byte2;	}	thirdLarge = res2;	/* end createLargeFromSmallInteger: */	} else {		thirdLarge = thirdModuloInteger;	}	/* begin digitMontgomery:times:modulo:mInvModB: */	firstLen = SIZEOF(firstLarge);	secondLen = SIZEOF(secondLarge);	thirdLen = SIZEOF(thirdLarge);	if (firstLen <= thirdLen) {		if (secondLen <= thirdLen) {			if ((smallInverseInteger >= 0) && (smallInverseInteger <= 255)) {							prod = (function(__size) {const __result = SmalltalkGlobals._LargePositiveInteger.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(thirdLen);				/* begin cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */				pBytesFirst = BYTESOF(firstLarge);				pBytesSecond = BYTESOF(secondLarge);				pBytesThird = BYTESOF(thirdLarge);				pBytesRes = BYTESOF(prod);				limit1 = firstLen - 1;				limit2 = secondLen - 1;				limit3 = thirdLen - 1;				lastByte = 0;				for (i = 0; i <= limit1; i++) {					accum = pBytesRes[0] + (pBytesFirst[i] * pBytesSecond[0]);					u = UBANDS((accum * smallInverseInteger), 255);					accum += u * pBytesThird[0];					for (k = 1; k <= limit2; k++) {						accum = (((accum >>> 8) + pBytesRes[k]) + (pBytesFirst[i] * pBytesSecond[k])) + (u * pBytesThird[k]);						pBytesRes[k - 1] = (UBANDS(accum, 255));					}					for (k1 = secondLen; k1 <= limit3; k1++) {						accum = ((accum >>> 8) + pBytesRes[k1]) + (u * pBytesThird[k1]);						pBytesRes[k1 - 1] = (UBANDS(accum, 255));					}					accum = (accum >>> 8) + lastByte;					pBytesRes[limit3] = (UBANDS(accum, 255));					lastByte = accum >>> 8;				}				for (i1 = firstLen; i1 <= limit3; i1++) {					accum = pBytesRes[0];					u = UBANDS((accum * smallInverseInteger), 255);					accum += u * pBytesThird[0];					for (k2 = 1; k2 <= limit3; k2++) {						accum = ((accum >>> 8) + pBytesRes[k2]) + (u * pBytesThird[k2]);						pBytesRes[k2 - 1] = (UBANDS(accum, 255));					}					accum = (accum >>> 8) + lastByte;					pBytesRes[limit3] = (UBANDS(accum, 255));					lastByte = accum >>> 8;				}				let rec1;if (lastByte === 0) {					/* begin cDigitCompare:with:len: */					ix3 = thirdLen - 1;					brokenFromLoop_cDigitComparewithlen_3435 = false;					while (ix3 >= 0) {						if (((secondDigit = pBytesRes[ix3])) !== ((firstDigit = pBytesThird[ix3]))) {							returnValueFromLoop_cDigitComparewithlen_3435 = (secondDigit < firstDigit) ? 1 : -1;							brokenFromLoop_cDigitComparewithlen_3435 = true;							break;						} else {							--ix3;						}					}					rec1 = ((brokenFromLoop_cDigitComparewithlen_3435	? returnValueFromLoop_cDigitComparewithlen_3435	: 0)) === 1;					/* end cDigitCompare:with:len: */				} else {					rec1 = false;				};if (!rec1) {					accum = 0;					for (i2 = 0; i2 <= limit3; i2++) {						accum = (accum + pBytesRes[i2]) - pBytesThird[i2];						pBytesRes[i2] = accum;						accum = accum >> 8;					}				}				/* end cDigitMontgomery:len:times:len:modulo:len:mInvModB:into: */				/* begin normalizePositive: */				len = (typeof prod === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(prod))) : ((oldLen = SIZEOF(prod)));				while ((len !== 0) && (BYTESOF(prod)[len - 1] === 0)) {					--len;				}				if (len === 0) {					arg11 = 0;				} else {					sLen = 4;					if ((len <= sLen) && (((sLen > BYTESIZEOF(prod)	? 0	: BYTESOF(prod)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {						val3 = 0;						for (i3 = len; i3 >= 1; i3--) {							val3 = (val3 * 256) + BYTESOF(prod)[i3 - 1];						}						arg11 = val3;					} else {						if (len < oldLen) {							/* begin bytes:growTo: */													newBytes = (function(__size) {const __result = prod._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);							oldLen1 = BYTESIZEOF(prod);							copyLen = (oldLen1 < len) ? oldLen1 : len;							LargeIntegers.cDigitCopyFromtolen(BYTESOF(prod), BYTESOF(newBytes), copyLen);							arg11 = newBytes;							/* end bytes:growTo: */						} else {							arg11 = prod;						}					}				}				/* end normalizePositive: */			} else {				throw Object.create(PrimitiveFailed).setPayload(1);			}		} else {			throw Object.create(PrimitiveFailed).setPayload(1);		}	} else {		throw Object.create(PrimitiveFailed).setPayload(1);	}	/* end digitMontgomery:times:modulo:mInvModB: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, /*	Parameter specification #(Integer) doesn't convert! */primNormalize(anInteger) {	let arg11;	let i;	let len;	let sLen;	let oldLen;	let val;	let oldLen1;	let newBytes;	let copyLen;	let len1;	let i2;	let i1;	let sLen1;	let minVal;	let oldLen3;	let val1;	let oldLen11;	let newBytes2;	let copyLen2;	let oldLen2;	let newBytes1;	let copyLen1;	let returnValueFromLoop_normalizeNegative_2202;	let brokenFromLoop_normalizeNegative_2202;	if ((typeof anInteger !== "number" && typeof anInteger.valueOf() !== "bigint")) throw Object.create(PrimitiveFailed).setPayload(1);	if ((typeof anInteger === "number")) {		throw Object.create(PrimitiveReturn).setPayload(anInteger);	} else {		/* begin normalize: */		if (anInteger._class() === SmalltalkGlobals._LargePositiveInteger) {			/* begin normalizePositive: */			len = (typeof anInteger === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(anInteger))) : ((oldLen = SIZEOF(anInteger)));			while ((len !== 0) && (BYTESOF(anInteger)[len - 1] === 0)) {				--len;			}			if (len === 0) {				arg11 = 0;			} else {				sLen = 4;				if ((len <= sLen) && (((sLen > BYTESIZEOF(anInteger)	? 0	: BYTESOF(anInteger)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {					val = 0;					for (i = len; i >= 1; i--) {						val = (val * 256) + BYTESOF(anInteger)[i - 1];					}					arg11 = val;				} else {					if (len < oldLen) {						/* begin bytes:growTo: */											newBytes = (function(__size) {const __result = anInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);						oldLen1 = BYTESIZEOF(anInteger);						copyLen = (oldLen1 < len) ? oldLen1 : len;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(anInteger), BYTESOF(newBytes), copyLen);						arg11 = newBytes;						/* end bytes:growTo: */					} else {						arg11 = anInteger;					}				}			}			/* end normalizePositive: */		} else {			/* begin normalizeNegative: */			len1 = (typeof anInteger === "number") ? ((oldLen3 = LargeIntegers.cDigitLengthOfCSI(anInteger))) : ((oldLen3 = SIZEOF(anInteger)));			while ((len1 !== 0) && (BYTESOF(anInteger)[len1 - 1] === 0)) {				--len1;			}			if (len1 === 0) {				arg11 = 0;			} else {				sLen1 = 4;				if (len1 <= sLen1) {					minVal = -1073741824;					if ((len1 < sLen1) || (((sLen1 > BYTESIZEOF(anInteger)	? 0	: BYTESOF(anInteger)[sLen1 - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen1 - 1) * 8))), 255)))) {						val1 = 0;						for (i2 = len1; i2 >= 1; i2--) {							val1 = (val1 * 256) - BYTESOF(anInteger)[i2 - 1];						}						arg11 = val1;					} else {						brokenFromLoop_normalizeNegative_2202 = false;						for (i1 = 1; i1 <= sLen1; i1++) {							if (((i1 > BYTESIZEOF(anInteger)	? 0	: BYTESOF(anInteger)[i1 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i1 - 1) * 8))), 255))) {								if (len1 < oldLen3) {									/* begin bytes:growTo: */																	newBytes2 = (function(__size) {const __result = anInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);									oldLen11 = BYTESIZEOF(anInteger);									copyLen2 = (oldLen11 < len1) ? oldLen11 : len1;									LargeIntegers.cDigitCopyFromtolen(BYTESOF(anInteger), BYTESOF(newBytes2), copyLen2);									returnValueFromLoop_normalizeNegative_2202 = newBytes2;									/* end bytes:growTo: */								} else {									returnValueFromLoop_normalizeNegative_2202 = anInteger;								}								brokenFromLoop_normalizeNegative_2202 = true;								break;							}						}						arg11 = brokenFromLoop_normalizeNegative_2202 ? returnValueFromLoop_normalizeNegative_2202 : minVal;					}				} else {					if (len1 < oldLen3) {						/* begin bytes:growTo: */											newBytes1 = (function(__size) {const __result = anInteger._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len1);						oldLen2 = BYTESIZEOF(anInteger);						copyLen1 = (oldLen2 < len1) ? oldLen2 : len1;						LargeIntegers.cDigitCopyFromtolen(BYTESOF(anInteger), BYTESOF(newBytes1), copyLen1);						arg11 = newBytes1;						/* end bytes:growTo: */					} else {						arg11 = anInteger;					}				}			}			/* end normalizeNegative: */		}		/* end normalize: */		throw Object.create(PrimitiveReturn).setPayload(arg11);	}}, primNormalizeNegative() {	let rcvr;	let arg11;	let len;	let i;	let i1;	let sLen;	let minVal;	let oldLen;	let val;	let oldLen1;	let newBytes;	let copyLen;	let oldLen2;	let newBytes1;	let copyLen1;	let brokenFromLoop_normalizeNegative_3550;	if ((typeof this.valueOf() !== "bigint" || this.valueOf() >= 0)) throw Object.create(PrimitiveFailed).setPayload(1);	rcvr = this;	/* begin normalizeNegative: */	len = (typeof rcvr === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(rcvr))) : ((oldLen = SIZEOF(rcvr)));	while ((len !== 0) && (BYTESOF(rcvr)[len - 1] === 0)) {		--len;	}	if (len === 0) {		arg11 = 0;	} else {		sLen = 4;		if (len <= sLen) {			minVal = -1073741824;			if ((len < sLen) || (((sLen > BYTESIZEOF(rcvr)	? 0	: BYTESOF(rcvr)[sLen - 1])) < (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((sLen - 1) * 8))), 255)))) {				val = 0;				for (i = len; i >= 1; i--) {					val = (val * 256) - BYTESOF(rcvr)[i - 1];				}				arg11 = val;			} else {				brokenFromLoop_normalizeNegative_3550 = false;				for (i1 = 1; i1 <= sLen; i1++) {					if (((i1 > BYTESIZEOF(rcvr)	? 0	: BYTESOF(rcvr)[i1 - 1])) !== (UBANDS((SHR(((minVal < 0) ? (0 - minVal) : minVal), ((i1 - 1) * 8))), 255))) {						if (len < oldLen) {							/* begin bytes:growTo: */													newBytes = (function(__size) {const __result = rcvr._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);							oldLen1 = BYTESIZEOF(rcvr);							copyLen = (oldLen1 < len) ? oldLen1 : len;							LargeIntegers.cDigitCopyFromtolen(BYTESOF(rcvr), BYTESOF(newBytes), copyLen);							arg11 = newBytes;							/* end bytes:growTo: */						} else {							arg11 = rcvr;						}						brokenFromLoop_normalizeNegative_3550 = true;						break;					}				}				arg11 = brokenFromLoop_normalizeNegative_3550 ? arg11 : minVal;			}		} else {			if (len < oldLen) {				/* begin bytes:growTo: */							newBytes1 = (function(__size) {const __result = rcvr._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);				oldLen2 = BYTESIZEOF(rcvr);				copyLen1 = (oldLen2 < len) ? oldLen2 : len;				LargeIntegers.cDigitCopyFromtolen(BYTESOF(rcvr), BYTESOF(newBytes1), copyLen1);				arg11 = newBytes1;				/* end bytes:growTo: */			} else {				arg11 = rcvr;			}		}	}	/* end normalizeNegative: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, primNormalizePositive() {	let rcvr;	let arg11;	let i;	let len;	let sLen;	let oldLen;	let val;	let oldLen1;	let newBytes;	let copyLen;	if ((typeof this.valueOf() !== "bigint" || this.valueOf() < 0)) throw Object.create(PrimitiveFailed).setPayload(1);	rcvr = this;	/* begin normalizePositive: */	len = (typeof rcvr === "number") ? ((oldLen = LargeIntegers.cDigitLengthOfCSI(rcvr))) : ((oldLen = SIZEOF(rcvr)));	while ((len !== 0) && (BYTESOF(rcvr)[len - 1] === 0)) {		--len;	}	if (len === 0) {		arg11 = 0;	} else {		sLen = 4;		if ((len <= sLen) && (((sLen > BYTESIZEOF(rcvr)	? 0	: BYTESOF(rcvr)[sLen - 1])) <= (UBANDS((SHR((1073741823), ((sLen - 1) * 8))), 255)))) {			val = 0;			for (i = len; i >= 1; i--) {				val = (val * 256) + BYTESOF(rcvr)[i - 1];			}			arg11 = val;		} else {			if (len < oldLen) {				/* begin bytes:growTo: */							newBytes = (function(__size) {const __result = rcvr._class().primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})(len);				oldLen1 = BYTESIZEOF(rcvr);				copyLen = (oldLen1 < len) ? oldLen1 : len;				LargeIntegers.cDigitCopyFromtolen(BYTESOF(rcvr), BYTESOF(newBytes), copyLen);				arg11 = newBytes;				/* end bytes:growTo: */			} else {				arg11 = rcvr;			}		}	}	/* end normalizePositive: */	throw Object.create(PrimitiveReturn).setPayload(arg11);}, }