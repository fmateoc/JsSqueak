/* Smalltalk from Squeak4.5 with VMMaker 4.18.1 translated as JavaScript source on 7 February 2022 11:04:23 pm *//* Automatically generated by	JSPluginCodeGenerator * VMMakerJS-dtl.18 uuid: 544d97d2-2811-46b7-a653-5c1776f146a4   from	ADPCMCodecPlugin * VMMaker-dtl.414 uuid: ba7b0d94-ec3e-4744-8fff-788c6b31790d */var VM_PROXY_MAJOR = 1var VM_PROXY_MINOR = 11/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a == 1 && b == 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function CPTR_CPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }function FPTR_FPTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }/* * define SQ_VI_BYTES_PER_WORD 8 for a 64-bit word size VM */const SQ_VI_BYTES_PER_WORD = 4const BYTES_PER_WORD = SQ_VI_BYTES_PER_WORDconst BASE_HEADER_SIZE = SQ_VI_BYTES_PER_WORDconst WORD_MASK = 0xffffffffconst SHIFT_FOR_WORD = 2const SMALL_CONTEXT_SIZE = 92const LARGE_CONTEXT_SIZE = 252const SIZE_MASK = 0xfcconst LONG_SIZE_MASK = 0xfffffffcconst SIZE_4_BIT = 0const MARK_BIT = 0x80000000const ROOT_BIT = 0x40000000const ALL_BUT_MARK_BIT = 0x7fffffffconst ALL_BUT_ROOT_BIT = 0xbfffffffconst ALL_BUT_TYPE_MASK = 0xfffffffcconst ALL_BUT_MARK_BIT_AND_TYPE_MASK = 0x7ffffffcconst ALL_BUT_HASH_BITS = 0xe001ffff/*** Variables ***/let interpreterProxy;let moduleName = "ADPCMCodecPlugin 7 February 2022 (e)";globalThis.ADPCMCodecPlugin = {/*	Note: This is hardcoded so it can be run from Squeak.	The module name is used for validating a module *after*	it is loaded to check if it does really contain the module	we're thinking it contains. This is important! */getModuleName() {	return moduleName;}, halt() {	;}, primitiveDecodeMono(count) {	let bit;	let delta;	let i;	let predictedDelta;	let step;	let remaining;	let result;	let shift;	let remaining1;	let result1;	let shift1;	let remaining2;	let result2;	let shift2;	let predicted;	let index;	let deltaSignMask;	let deltaValueMask;	let deltaValueHighBit;	let frameSizeMask;	let currentByte;	let bitPosition;	let byteIndex;	let encodedBytes;	let samples;	let sampleIndex;	let bitsPerSample;	let stepSizeTable;	let indexTable;	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	predicted = this.pointers[0];	if (!(typeof predicted === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	index = this.pointers[1];	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaSignMask = this.pointers[2];	if (!(typeof deltaSignMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaValueMask = this.pointers[3];	if (!(typeof deltaValueMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaValueHighBit = this.pointers[4];	if (!(typeof deltaValueHighBit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	frameSizeMask = this.pointers[5];	if (!(typeof frameSizeMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	currentByte = this.pointers[6];	if (!(typeof currentByte === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitPosition = this.pointers[7];	if (!(typeof bitPosition === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	byteIndex = this.pointers[8];	if (!(typeof byteIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	encodedBytes = this.pointers[9].storageType !== "bytes" ? (this.pointers[9].storageType !== "words" ? PrimitiveFailed.signal() : this.pointers[9].wordsAsUint8Array()) : BYTESOF(this.pointers[9]);	samples = this.pointers[10].storageType === "words" ? this.pointers[10].wordsAsInt16Array() : PrimitiveFailed.signal();	sampleIndex = this.pointers[12];	if (!(typeof sampleIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitsPerSample = this.pointers[13];	if (!(typeof bitsPerSample === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	stepSizeTable = this.pointers[14].storageType === "words" ? this.pointers[14].wordsAsInt16Array() : PrimitiveFailed.signal();	indexTable = this.pointers[15].storageType === "words" ? this.pointers[15].wordsAsInt16Array() : PrimitiveFailed.signal();	for (i = 1; i <= count; i++) {		if ((UBAND(i, frameSizeMask)) === 1) {			/* start of frame; read frame header */			/* begin nextBits: */			result = 0;			remaining = 16;			while(true) {				shift = remaining - bitPosition;				if (shift > 0) {					result += SHL(currentByte, shift);					remaining -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result += SHR(currentByte, (0 - shift));					bitPosition -= remaining;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					predicted = result;					break;				}			}			/* end nextBits: */			if (predicted > 32767) {				predicted -= 65536;			}			/* begin nextBits: */			result1 = 0;			remaining1 = 6;			while(true) {				shift1 = remaining1 - bitPosition;				if (shift1 > 0) {					result1 += SHL(currentByte, shift1);					remaining1 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result1 += SHR(currentByte, (0 - shift1));					bitPosition -= remaining1;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					index = result1;					break;				}			}			/* end nextBits: */		} else {			/* begin nextBits: */			result2 = 0;			remaining2 = bitsPerSample;			while(true) {				shift2 = remaining2 - bitPosition;				if (shift2 > 0) {					result2 += SHL(currentByte, shift2);					remaining2 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result2 += SHR(currentByte, (0 - shift2));					bitPosition -= remaining2;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					delta = result2;					break;				}			}			/* end nextBits: */			step = stepSizeTable[index];			predictedDelta = 0;			bit = deltaValueHighBit;			while (bit > 0) {				if ((UBAND(delta, bit)) > 0) {					predictedDelta += step;				}				step = step >>> 1;				bit = bit >>> 1;			}			predictedDelta += step;			predicted = ((UBAND(delta, deltaSignMask)) > 0) ? (predicted - predictedDelta) : (predicted + predictedDelta);			if (predicted > 32767) {				predicted = 32767;			} else {				if (predicted < -32768) {					predicted = -32768;				}			}			index += indexTable[UBAND(delta, deltaValueMask)];			if (index < 0) {				index = 0;			} else {				if (index > 88) {					index = 88;				}			}		}		samples[((++sampleIndex)) - 1] = predicted;	}	this.pointers[0] = predicted;	this.pointers[1] = index;	this.pointers[6] = currentByte;	this.pointers[7] = bitPosition;	this.pointers[8] = byteIndex;	this.pointers[12] = sampleIndex;}, primitiveDecodeStereo(count) {	let bit;	let deltaLeft;	let deltaRight;	let i;	let indexLeft;	let indexRight;	let predictedDeltaLeft;	let predictedDeltaRight;	let predictedLeft;	let predictedRight;	let stepLeft;	let stepRight;	let remaining;	let result;	let shift;	let remaining1;	let result1;	let shift1;	let remaining2;	let result2;	let shift2;	let remaining3;	let result3;	let shift3;	let remaining4;	let result4;	let shift4;	let remaining5;	let result5;	let shift5;	let predicted;	let index;	let deltaSignMask;	let deltaValueMask;	let deltaValueHighBit;	let frameSizeMask;	let currentByte;	let bitPosition;	let byteIndex;	let encodedBytes;	let samples;	let rightSamples;	let sampleIndex;	let bitsPerSample;	let stepSizeTable;	let indexTable;	/* make local copies of decoder state variables */	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	predicted = this.pointers[0].storageType === "words" ? this.pointers[0].wordsAsInt16Array() : PrimitiveFailed.signal();	index = this.pointers[1].storageType === "words" ? this.pointers[1].wordsAsInt16Array() : PrimitiveFailed.signal();	deltaSignMask = this.pointers[2];	if (!(typeof deltaSignMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaValueMask = this.pointers[3];	if (!(typeof deltaValueMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaValueHighBit = this.pointers[4];	if (!(typeof deltaValueHighBit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	frameSizeMask = this.pointers[5];	if (!(typeof frameSizeMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	currentByte = this.pointers[6];	if (!(typeof currentByte === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitPosition = this.pointers[7];	if (!(typeof bitPosition === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	byteIndex = this.pointers[8];	if (!(typeof byteIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	encodedBytes = this.pointers[9].storageType !== "bytes" ? (this.pointers[9].storageType !== "words" ? PrimitiveFailed.signal() : this.pointers[9].wordsAsUint8Array()) : BYTESOF(this.pointers[9]);	samples = this.pointers[10].storageType === "words" ? this.pointers[10].wordsAsInt16Array() : PrimitiveFailed.signal();	rightSamples = this.pointers[11].storageType === "words" ? this.pointers[11].wordsAsInt16Array() : PrimitiveFailed.signal();	sampleIndex = this.pointers[12];	if (!(typeof sampleIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitsPerSample = this.pointers[13];	if (!(typeof bitsPerSample === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	stepSizeTable = this.pointers[14].storageType === "words" ? this.pointers[14].wordsAsInt16Array() : PrimitiveFailed.signal();	indexTable = this.pointers[15].storageType === "words" ? this.pointers[15].wordsAsInt16Array() : PrimitiveFailed.signal();	predictedLeft = predicted[1 - 1];	predictedRight = predicted[2 - 1];	indexLeft = index[1 - 1];	indexRight = index[2 - 1];	for (i = 1; i <= count; i++) {		if ((UBAND(i, frameSizeMask)) === 1) {			/* start of frame; read frame header */			/* begin nextBits: */			result = 0;			remaining = 16;			while(true) {				shift = remaining - bitPosition;				if (shift > 0) {					result += SHL(currentByte, shift);					remaining -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result += SHR(currentByte, (0 - shift));					bitPosition -= remaining;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					predictedLeft = result;					break;				}			}			/* end nextBits: */			/* begin nextBits: */			result1 = 0;			remaining1 = 6;			while(true) {				shift1 = remaining1 - bitPosition;				if (shift1 > 0) {					result1 += SHL(currentByte, shift1);					remaining1 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result1 += SHR(currentByte, (0 - shift1));					bitPosition -= remaining1;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					indexLeft = result1;					break;				}			}			/* end nextBits: */			/* begin nextBits: */			result2 = 0;			remaining2 = 16;			while(true) {				shift2 = remaining2 - bitPosition;				if (shift2 > 0) {					result2 += SHL(currentByte, shift2);					remaining2 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result2 += SHR(currentByte, (0 - shift2));					bitPosition -= remaining2;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					predictedRight = result2;					break;				}			}			/* end nextBits: */			/* begin nextBits: */			result3 = 0;			remaining3 = 6;			while(true) {				shift3 = remaining3 - bitPosition;				if (shift3 > 0) {					result3 += SHL(currentByte, shift3);					remaining3 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result3 += SHR(currentByte, (0 - shift3));					bitPosition -= remaining3;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					indexRight = result3;					break;				}			}			/* end nextBits: */			if (predictedLeft > 32767) {				predictedLeft -= 65536;			}			if (predictedRight > 32767) {				predictedRight -= 65536;			}		} else {			/* begin nextBits: */			result4 = 0;			remaining4 = bitsPerSample;			while(true) {				shift4 = remaining4 - bitPosition;				if (shift4 > 0) {					result4 += SHL(currentByte, shift4);					remaining4 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result4 += SHR(currentByte, (0 - shift4));					bitPosition -= remaining4;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					deltaLeft = result4;					break;				}			}			/* end nextBits: */			/* begin nextBits: */			result5 = 0;			remaining5 = bitsPerSample;			while(true) {				shift5 = remaining5 - bitPosition;				if (shift5 > 0) {					result5 += SHL(currentByte, shift5);					remaining5 -= bitPosition;					currentByte = encodedBytes[((++byteIndex)) - 1];					bitPosition = 8;				} else {					result5 += SHR(currentByte, (0 - shift5));					bitPosition -= remaining5;					currentByte = UBAND(currentByte, (SHR(255, (8 - bitPosition))));					deltaRight = result5;					break;				}			}			/* end nextBits: */			stepLeft = stepSizeTable[indexLeft];			stepRight = stepSizeTable[indexRight];			predictedDeltaLeft = (predictedDeltaRight = 0);			bit = deltaValueHighBit;			while (bit > 0) {				if ((UBAND(deltaLeft, bit)) > 0) {					predictedDeltaLeft += stepLeft;				}				if ((UBAND(deltaRight, bit)) > 0) {					predictedDeltaRight += stepRight;				}				stepLeft = stepLeft >>> 1;				stepRight = stepRight >>> 1;				bit = bit >>> 1;			}			predictedDeltaLeft += stepLeft;			predictedDeltaRight += stepRight;			predictedLeft = ((UBAND(deltaLeft, deltaSignMask)) > 0) ? (predictedLeft - predictedDeltaLeft) : (predictedLeft + predictedDeltaLeft);			predictedRight = ((UBAND(deltaRight, deltaSignMask)) > 0) ? (predictedRight - predictedDeltaRight) : (predictedRight + predictedDeltaRight);			if (predictedLeft > 32767) {				predictedLeft = 32767;			} else {				if (predictedLeft < -32768) {					predictedLeft = -32768;				}			}			if (predictedRight > 32767) {				predictedRight = 32767;			} else {				if (predictedRight < -32768) {					predictedRight = -32768;				}			}			indexLeft += indexTable[UBAND(deltaLeft, deltaValueMask)];			if (indexLeft < 0) {				indexLeft = 0;			} else {				if (indexLeft > 88) {					indexLeft = 88;				}			}			indexRight += indexTable[UBAND(deltaRight, deltaValueMask)];			if (indexRight < 0) {				indexRight = 0;			} else {				if (indexRight > 88) {					indexRight = 88;				}			}		}		samples[((++sampleIndex)) - 1] = predictedLeft;		rightSamples[sampleIndex - 1] = predictedRight;	}	predicted[1 - 1] = predictedLeft;	predicted[2 - 1] = predictedRight;	index[1 - 1] = indexLeft;	index[2 - 1] = indexRight;	this.pointers[6] = currentByte;	this.pointers[7] = bitPosition;	this.pointers[8] = byteIndex;	this.pointers[12] = sampleIndex;}, primitiveEncodeMono(count) {	let bit;	let delta;	let diff;	let i;	let p;	let predictedDelta;	let sign;	let step;	let bestIndex;	let diff1;	let j;	let bitsAvailable;	let buf;	let bufBits;	let shift;	let bitsAvailable1;	let buf1;	let bufBits1;	let shift1;	let bitsAvailable2;	let buf2;	let bufBits2;	let shift2;	let predicted;	let index;	let deltaSignMask;	let deltaValueHighBit;	let frameSizeMask;	let currentByte;	let bitPosition;	let byteIndex;	let encodedBytes;	let samples;	let sampleIndex;	let bitsPerSample;	let stepSizeTable;	let indexTable;	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	predicted = this.pointers[0];	if (!(typeof predicted === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	index = this.pointers[1];	if (!(typeof index === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaSignMask = this.pointers[2];	if (!(typeof deltaSignMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	deltaValueHighBit = this.pointers[4];	if (!(typeof deltaValueHighBit === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	frameSizeMask = this.pointers[5];	if (!(typeof frameSizeMask === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	currentByte = this.pointers[6];	if (!(typeof currentByte === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitPosition = this.pointers[7];	if (!(typeof bitPosition === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	byteIndex = this.pointers[8];	if (!(typeof byteIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	encodedBytes = this.pointers[9].storageType !== "bytes" ? (this.pointers[9].storageType !== "words" ? PrimitiveFailed.signal() : this.pointers[9].wordsAsUint8Array()) : BYTESOF(this.pointers[9]);	samples = this.pointers[10].storageType === "words" ? this.pointers[10].wordsAsInt16Array() : PrimitiveFailed.signal();	sampleIndex = this.pointers[12];	if (!(typeof sampleIndex === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	bitsPerSample = this.pointers[13];	if (!(typeof bitsPerSample === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	stepSizeTable = this.pointers[14].storageType === "words" ? this.pointers[14].wordsAsInt16Array() : PrimitiveFailed.signal();	indexTable = this.pointers[15].storageType === "words" ? this.pointers[15].wordsAsInt16Array() : PrimitiveFailed.signal();	step = stepSizeTable[1 - 1];	for (i = 1; i <= count; i++) {		if ((UBAND(i, frameSizeMask)) === 1) {			predicted = samples[((++sampleIndex)) - 1];			if (((p = predicted)) < 0) {				p += 65536;			}			/* begin nextBits:put: */			buf = p;			bufBits = 16;			while(true) {				bitsAvailable = 8 - bitPosition;				shift = bitsAvailable - bufBits;				if (shift < 0) {					currentByte += SHR(buf, (0 - shift));					encodedBytes[((++byteIndex)) - 1] = currentByte;					bitPosition = 0;					currentByte = 0;					buf = UBAND(buf, ((SHL(1, (0 - shift))) - 1));					bufBits -= bitsAvailable;				} else {					currentByte += SHL(buf, shift);					bitPosition += bufBits;					break;				}			}			/* end nextBits:put: */			if (i < count) {				/* begin indexForDeltaFrom:to: */				diff1 = samples[sampleIndex] - predicted;				if (diff1 < 0) {					diff1 = 0 - diff1;				}				bestIndex = 63;				for (j = 1; j <= 62; j++) {					if (bestIndex === 63) {						if (stepSizeTable[j - 1] >= diff1) {							bestIndex = j;						}					}				}				index = bestIndex;				/* end indexForDeltaFrom:to: */			}			/* begin nextBits:put: */			buf1 = index;			bufBits1 = 6;			while(true) {				bitsAvailable1 = 8 - bitPosition;				shift1 = bitsAvailable1 - bufBits1;				if (shift1 < 0) {					currentByte += SHR(buf1, (0 - shift1));					encodedBytes[((++byteIndex)) - 1] = currentByte;					bitPosition = 0;					currentByte = 0;					buf1 = UBAND(buf1, ((SHL(1, (0 - shift1))) - 1));					bufBits1 -= bitsAvailable1;				} else {					currentByte += SHL(buf1, shift1);					bitPosition += bufBits1;					break;				}			}			/* end nextBits:put: */		} else {			/* compute sign and magnitude of difference from the predicted sample */			sign = 0;			diff = samples[((++sampleIndex)) - 1] - predicted;			if (diff < 0) {				sign = deltaSignMask;				diff = 0 - diff;			}			delta = 0;			predictedDelta = 0;			bit = deltaValueHighBit;			while (bit > 0) {				if (diff >= step) {					delta += bit;					predictedDelta += step;					diff -= step;				}				step = step >>> 1;				bit = bit >>> 1;			}			/* compute and clamp new prediction */			predictedDelta += step;			predicted = (sign > 0) ? (predicted - predictedDelta) : (predicted + predictedDelta);			if (predicted > 32767) {				predicted = 32767;			} else {				if (predicted < -32768) {					predicted = -32768;				}			}			index += indexTable[delta];			if (index < 0) {				index = 0;			} else {				if (index > 88) {					index = 88;				}			}			/* output encoded, signed delta */			step = stepSizeTable[index];			/* begin nextBits:put: */			buf2 = UBOR(sign, delta);			bufBits2 = bitsPerSample;			while(true) {				bitsAvailable2 = 8 - bitPosition;				shift2 = bitsAvailable2 - bufBits2;				if (shift2 < 0) {					currentByte += SHR(buf2, (0 - shift2));					encodedBytes[((++byteIndex)) - 1] = currentByte;					bitPosition = 0;					currentByte = 0;					buf2 = UBAND(buf2, ((SHL(1, (0 - shift2))) - 1));					bufBits2 -= bitsAvailable2;				} else {					currentByte += SHL(buf2, shift2);					bitPosition += bufBits2;					break;				}			}			/* end nextBits:put: */		}	}	if (bitPosition > 0) {		/* flush the last output byte, if necessary */		encodedBytes[((++byteIndex)) - 1] = currentByte;	}	this.pointers[0] = predicted;	this.pointers[1] = index;	this.pointers[6] = currentByte;	this.pointers[7] = bitPosition;	this.pointers[8] = byteIndex;	this.pointers[12] = sampleIndex;}, /*	not yet implemented */primitiveEncodeStereo(count) {	if (!(typeof count === "number")) throw Object.create(PrimitiveFailed).setPayload(1);	if (true) throw Object.create(PrimitiveFailed).setPayload(1);}, /*	Note: This is coded so that is can be run from Squeak. */setInterpreter(anInterpreter) {	let ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;	if (ok === false) {		return false;	} else {		ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;		return ok;	}}, }