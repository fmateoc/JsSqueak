'From Squeak4.5 of 10 April 2015 [latest update: #13712] on 25 July 2023 at 11:30:16 pm'!Object subclass: #JSCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations scopeStack methods macros preparedMethodList variablesSetCache headerFiles globalVariableUsage useSymbolicConstants generateDeadCode doNotRemoveMethodList asArgumentTranslationDict receiverDict vmClass currentMethod logger declareMethodsStatic permitMethodPruning pools abstractDeclarations uncheckedAbstractMethods cCodeTranslationDict oneBasedArrays exceptions omSimulator '	classVariableNames: 'IsActive UseRightShiftForDivide '	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!Object subclass: #JSMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export static sharedLabel sharedCase comment definingClass globalStructureBuildMethodHasFoo canAsmLabel mustAsmLabel properties cascadeVariableNumber extraVariableNumber oneBasedArrays loopsWithReturns writtenToGlobalVarsCache '	classVariableNames: 'CaseStatements '	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!TParseNode subclass: #TBreakNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!!BalloonEngineBase methodsFor: 'accessing state' stamp: 'fm 3/26/2021 14:02'!colorTransform	<inline: false>	 "There is a special hack for this method in JSMethod>>#emitJSSpecialOn:level:generator:"	<returnTypeC:'float *'>	^self cCoerce: workBuffer + GWColorTransform to:'float *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'fm 3/26/2021 14:02'!edgeTransform	<inline: false>	 "There is a special hack for this method in JSMethod>>#emitJSSpecialOn:level:generator:"	<returnTypeC:'float *'>	^self cCoerce: workBuffer + GWEdgeTransform to:'float *'! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:12'!copyBitsRule41Test	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		combinationRule = 41		ifTrue:["fetch the forecolor into componentAlphaModeColor."			interpreterProxy methodArgumentCount >= 4				ifTrue:[					self copyBitsRule41Test4				] ifFalse: [					gammaLookupTable := nil.					ungammaLookupTable := nil.					interpreterProxy methodArgumentCount < 2						ifTrue: [							componentAlphaModeAlpha := 255.							self copyBitsRule41Test1						] ifFalse:[							interpreterProxy methodArgumentCount > 1								ifTrue:[									self copyBitsRule41Test2								] ifFalse:[^ interpreterProxy primitiveFail]]]].	! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:09'!copyBitsRule41Test1	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		interpreterProxy methodArgumentCount = 1		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 0.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail]]! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:09'!copyBitsRule41Test2	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		interpreterProxy methodArgumentCount = 2		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 1.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			componentAlphaModeAlpha := interpreterProxy stackIntegerValue: 0.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail]].	! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 17:27'!copyBitsRule41Test4	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	| gammaLookupTableOop ungammaLookupTableOop |	<inline: false>		interpreterProxy methodArgumentCount = 4		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 3.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			componentAlphaModeAlpha := interpreterProxy stackIntegerValue: 2.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			gammaLookupTableOop := interpreterProxy stackObjectValue: 1.			(interpreterProxy isBytes: gammaLookupTableOop) 				ifTrue:[gammaLookupTable := interpreterProxy firstIndexableField: gammaLookupTableOop.].			ungammaLookupTableOop := interpreterProxy stackObjectValue: 0.			(interpreterProxy isBytes: ungammaLookupTableOop) 				ifTrue:[ungammaLookupTable := interpreterProxy firstIndexableField: ungammaLookupTableOop]].	! !!BitBltSimulation methodsFor: 'primitives' stamp: 'fm 12/6/2020 22:37'!primitivePixelValueAtX: xVal y: yVal	"returns the single pixel at x@y.	It does not handle LSB bitmaps right now.	If x or y are < 0, return 0 to indicate transparent (cf BitBlt>bitPeekerFromForm: usage).	Likewise if x>width or y>depth.	Fail if the rcvr doesn't seem to be a Form, or x|y seem wrong"	| rcvr bitmap depth ppW stride bitsSize word mask shift pixel |	rcvr := self primitive: 'primitivePixelValueAt' parameters: #(SmallInteger SmallInteger) receiver: #Oop.		"possible quick exit if x or y is -ve"	(xVal < 0 or: [ yVal < 0 ] ) ifTrue:[^interpreterProxy integerObjectOf: 0].	"check that rcvr is plausibly a Form or subclass"		((interpreterProxy isPointers: rcvr) and: [(interpreterProxy slotSizeOf: rcvr) >= 4])		ifFalse: [^interpreterProxy primitiveFail].	"get the bits oop and width/height/depth"	bitmap := interpreterProxy fetchPointer: FormBitsIndex ofObject: rcvr.	(interpreterProxy isWordsOrBytes: bitmap) ifFalse: [^interpreterProxy primitiveFail].	width := interpreterProxy fetchInteger: FormWidthIndex ofObject: rcvr.	height := interpreterProxy fetchInteger: FormHeightIndex ofObject: rcvr.	depth := interpreterProxy fetchInteger: FormDepthIndex ofObject: rcvr.	"if width/height/depth are not integer, fail"	interpreterProxy failed ifTrue:[^nil].	"possible quick exit if x or y is >= extent of form. This also catches cases where the width/height are < 0"	(xVal >= width or: [ yVal >= height ] ) ifTrue:[^interpreterProxy integerObjectOf: 0].	"we don't handle LSB Forms yet"	depth < 0 ifTrue:[^interpreterProxy primitiveFail].		"OK so now we know we have a plausible Form, the width/height/depth/x/y are all reasonable and it's time to plunder the bitmap"	ppW := 32//depth. "pixels in each word"	stride := (width + (ppW  -1)) // ppW. "how many words per row of pixels"	bitsSize := interpreterProxy byteSizeOf: bitmap.	bitsSize = (stride * height * 4 "bytes per word")		ifFalse: [^interpreterProxy primitiveFail].	word := interpreterProxy fetchLong32:(yVal * stride) + (xVal//ppW) ofObject: bitmap. "load the word that contains our target"	mask := 16rFFFFFFFF >> (32 - depth). "make a mask to isolate the pixel within that word"	shift := 32 - (((xVal bitAnd: ppW-1) + 1) * depth). "this is the tricky MSB part - we mask the xVal to find how far into the word we need, then add 1 for the pixel we're looking for, then * depth to get the bit shift"	pixel := (word >> shift) bitAnd: mask. "shift, mask and dim the lights"	^ pixel asPositiveIntegerObj "pop the incoming and push our answer"! !!CairoConstant methodsFor: 'as yet unclassified' stamp: 'fm 10/1/2020 21:11'!JSstoreOn: aStream 	(name = 'CAIRO_OPERATOR_SOURCE' or: [name = 'CAIRO_EXTEND_REPEAT']) 		ifTrue: [aStream nextPut: $1] 		ifFalse: [self halt]! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 7/9/2023 21:37'!>>< selector	"returns JavaScript source for plugin-generated methods"	"BitBltSimulation >>< #primitivePixelValueAtX:y:"	JSCodeGenerator beActiveDuring: [| jsCodeGenerator jsMethod |		jsCodeGenerator := self initialize; buildCodeGenerator.		jsMethod := ((Compiler new			parse: (self sourceCodeAt: selector)			in: self			notifying: nil) 				JSprepare: true) 					asTranslationMethodOfClass: jsCodeGenerator translationMethodClass.		jsMethod referencesGlobalStructMakeZero.		^String streamContents: [:s | jsMethod emitJSCodeOn: s generator: jsCodeGenerator]]! !!InflatePlugin methodsFor: 'primitives' stamp: 'fm 2/12/2022 23:01'!primitiveInflateDecompressBlock	"Primitive. Inflate a single block."	| oop1 oop rcvr source collection |	<export: true>	interpreterProxy methodArgumentCount = 2 ifFalse:		[^interpreterProxy primitiveFail].	"distance table"	oop1 := interpreterProxy stackValue: 0.	(interpreterProxy isWords: oop1) ifFalse:		[^interpreterProxy primitiveFail].	zipDistTable := interpreterProxy firstIndexableField: oop1.	zipDistTableSize := interpreterProxy slotSizeOf: oop1.	"literal table"	oop := interpreterProxy stackValue: 1.	(interpreterProxy isWords: oop) ifFalse:		[^interpreterProxy primitiveFail].	zipLitTable := interpreterProxy firstIndexableField: oop.	zipLitTableSize := interpreterProxy slotSizeOf: oop.	"Receiver (InflateStream)"	rcvr := interpreterProxy stackValue: 2.	(interpreterProxy isPointers: rcvr) ifFalse:		[^interpreterProxy primitiveFail].	"All the integer instvars"	readStreamInstSize = 0 ifTrue:		[(self determineSizeOfReadStream: rcvr) ifFalse:			[^interpreterProxy primitiveFail].		 "If the receiver wasn't valid then we derived readStreamInstSize from an invalid source.  discard it."		 (interpreterProxy slotSizeOf: rcvr) < (readStreamInstSize + 8) ifTrue:			[readStreamInstSize := 0.			 ^interpreterProxy primitiveFail]].	(interpreterProxy slotSizeOf: rcvr) < (readStreamInstSize + 8) ifTrue:		[^interpreterProxy primitiveFail].	zipReadLimit := interpreterProxy fetchInteger: 2 ofObject: rcvr.	zipState := interpreterProxy fetchInteger: readStreamInstSize + 0 ofObject: rcvr.	zipBitBuf := interpreterProxy fetchInteger: readStreamInstSize + 1 ofObject: rcvr.	zipBitPos := interpreterProxy fetchInteger: readStreamInstSize + 2 ofObject: rcvr.	zipSourcePos := interpreterProxy fetchInteger: readStreamInstSize + 4 ofObject: rcvr.	zipSourceLimit := interpreterProxy fetchInteger: readStreamInstSize + 5 ofObject: rcvr.	interpreterProxy failed ifTrue:[^nil].	zipReadLimit := zipReadLimit - 1.	zipSourcePos := zipSourcePos - 1.	zipSourceLimit := zipSourceLimit - 1.	collection := interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isBytes: collection) ifFalse:		[^interpreterProxy primitiveFail].	zipCollection := interpreterProxy firstIndexableField: collection.	zipCollectionSize := interpreterProxy byteSizeOf: collection.	source := interpreterProxy fetchPointer: readStreamInstSize + 3 ofObject: rcvr.	(interpreterProxy isBytes: source) ifFalse:		[^interpreterProxy primitiveFail].	zipSource := interpreterProxy firstIndexableField: source.	"do the primitive"	self zipDecompressBlock.	interpreterProxy failed ifFalse: "store modified values back"		[self cCode: 'const origReadLimit = this.pointers[2];collection.string = (origReadLimit === 0 ? "" : collection.string) + String.fromCodePoint(...zipCollection.subarray(origReadLimit, zipReadLimit + 1));collection.dirty = false;'.		interpreterProxy storeInteger: 2 ofObject: rcvr withValue: zipReadLimit + 1.		interpreterProxy storeInteger: readStreamInstSize + 0 ofObject: rcvr withValue: zipState.		interpreterProxy storeInteger: readStreamInstSize + 1 ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: readStreamInstSize + 2 ofObject: rcvr withValue: zipBitPos.		interpreterProxy storeInteger: readStreamInstSize + 4 ofObject: rcvr withValue: zipSourcePos + 1.		interpreterProxy pop: 2]! !!DeflatePlugin methodsFor: 'primitive support' stamp: 'fm 1/9/2022 21:17'!loadZipEncoderFrom: rcvr	| oop |	<inline: false>	writeStreamInstSize = 0 ifTrue:		[(self determineSizeOfWriteStream: rcvr) ifFalse:			[^false].		 "If the receiver wasn't valid then we derived writeStreamInstSize from an invalid source.  discard it."		 (interpreterProxy slotSizeOf: rcvr) < (writeStreamInstSize + 3) ifTrue:			[writeStreamInstSize := 0.			 ^false]].	((interpreterProxy isPointers: rcvr)	 and: [(interpreterProxy slotSizeOf: rcvr) >= (writeStreamInstSize + 3)]) ifFalse:		[^false].	oop := interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isBytes: oop) ifFalse:		[^interpreterProxy primitiveFail].	zipCollection := interpreterProxy firstIndexableField: oop.	zipCollectionSize := interpreterProxy byteSizeOf: oop.	zipPosition := interpreterProxy fetchInteger: 1 ofObject: rcvr.	zipReadLimit := interpreterProxy fetchInteger: 2 ofObject: rcvr.	"zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr."	zipBitBuf := interpreterProxy fetchInteger: writeStreamInstSize ofObject: rcvr.	zipBitPos := interpreterProxy fetchInteger: writeStreamInstSize + 1 ofObject: rcvr.	^interpreterProxy failed not! !!DeflatePlugin methodsFor: 'primitives' stamp: 'fm 1/9/2022 21:17'!primitiveZipSendBlock	| distTree litTree distStream litStream rcvr result |	<export: true>	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	distTree := interpreterProxy stackObjectValue: 0.	litTree := interpreterProxy stackObjectValue: 1.	distStream := interpreterProxy stackObjectValue: 2.	litStream := interpreterProxy stackObjectValue: 3.	rcvr := interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self loadZipEncoderFrom: rcvr)		ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distTree) and:[		(interpreterProxy slotSizeOf: distTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litTree) and:[		(interpreterProxy slotSizeOf: litTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litStream) and:[		(interpreterProxy slotSizeOf: litStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distStream) and:[		(interpreterProxy slotSizeOf: distStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	self cCode:'' inSmalltalk:[		zipMatchLengthCodes := CArrayAccessor on: ZipWriteStream matchLengthCodes.		zipDistanceCodes := CArrayAccessor on: ZipWriteStream distanceCodes.		zipExtraLengthBits := CArrayAccessor on: ZipWriteStream extraLengthBits.		zipExtraDistanceBits := CArrayAccessor on: ZipWriteStream extraDistanceBits.		zipBaseLength := CArrayAccessor on: ZipWriteStream baseLength.		zipBaseDistance := CArrayAccessor on: ZipWriteStream baseDistance].	result := self sendBlock: litStream with: distStream with: litTree with: distTree.	interpreterProxy failed ifFalse:[		interpreterProxy storeInteger: 1 ofObject: rcvr withValue: zipPosition.		interpreterProxy storeInteger: writeStreamInstSize ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: writeStreamInstSize + 1 ofObject: rcvr withValue: zipBitPos.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 5. "rcvr + args"		interpreterProxy pushInteger: result.	].! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:16'!primitiveColorConvertGrayscaleMCU	"Requires:		JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop1 arrayOop2 arrayOop3 |	<export: true>	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask := interpreterProxy stackIntegerValue: 0.	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop3) and:[(interpreterProxy slotSizeOf: arrayOop3) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize := interpreterProxy slotSizeOf: arrayOop2.	jpegBits := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self yColorComponentFrom: arrayOop1)		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertGrayscaleMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:17'!primitiveColorConvertMCU	"Requires:		Array with: 3*JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop1 arrayOop2 arrayOop3 |	<export: true>	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask := interpreterProxy stackIntegerValue: 0.	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop3) and:[(interpreterProxy slotSizeOf: arrayOop3) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize := interpreterProxy slotSizeOf: arrayOop2.	jpegBits := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isPointers: arrayOop1) and:[(interpreterProxy slotSizeOf: arrayOop1) = 3])		ifFalse:[^interpreterProxy primitiveFail].	(self yColorComponentFrom: (interpreterProxy fetchPointer: 0 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	(self cbColorComponentFrom: (interpreterProxy fetchPointer: 1 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	(self crColorComponentFrom: (interpreterProxy fetchPointer: 2 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:20'!primitiveDecodeMCU	"In:		anArray 		WordArray of: DCTSize2		aColorComponent JPEGColorComponent		dcTable			WordArray		acTable			WordArray		stream			JPEGStream	"	| arrayOop1 arrayOop2 arrayOop3 oop1 oop2 anArray |	<export: true>	<var: #anArray type: 'int *'>	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	oop2 := interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self loadJPEGStreamFrom: oop2)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop3)		ifFalse:[^interpreterProxy primitiveFail].	acTableSize := interpreterProxy slotSizeOf: arrayOop3.	acTable := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	dcTableSize := interpreterProxy slotSizeOf: arrayOop2.	dcTable := interpreterProxy firstIndexableField: arrayOop2.	oop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self colorComponent: yComponent from: oop1)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop1 := interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop1)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: arrayOop1) = DCTSize2		ifFalse:[^interpreterProxy primitiveFail].	anArray := interpreterProxy firstIndexableField: arrayOop1.	interpreterProxy failed ifTrue:[^nil].	self decodeBlockInto: anArray component: yComponent.	interpreterProxy failed ifTrue:[^nil].	self storeJPEGStreamOn: (interpreterProxy stackValue: 0).	interpreterProxy 		storeInteger: PriorDCValueIndex 		ofObject: (interpreterProxy stackValue: 3) 		withValue: (yComponent at: PriorDCValueIndex).	interpreterProxy pop: 5.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/12/2021 16:37'!primitiveIdctInt	"In:		anArray: IntegerArray new: DCTSize2		qt: IntegerArray new: DCTSize2.	"	| arrayOop1 arrayOop2 anArray qt |	<export: true>	<var: #anArray type: 'int *'>	<var: #qt type: 'int *'>	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	arrayOop2 := interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop2) and:[(interpreterProxy slotSizeOf: arrayOop2) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	qt := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop1) and:[(interpreterProxy slotSizeOf: arrayOop1) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	anArray := interpreterProxy firstIndexableField: arrayOop1.	self idctBlockInt: anArray qt: qt.	interpreterProxy pop: 2.! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 7/11/2023 22:21'!addMethodsForPrimitives: classAndSelectorList 	| sel aClass source verbose meth |	classAndSelectorList do:[:classAndSelector | 		aClass := Smalltalk at: (classAndSelector at: 1) ifAbsent:[nil].		aClass ifNotNil:[			self addAllClassVarsFor: aClass.			"TPR - should pool vars also be added here?"			"find the method in either the class or the metaclass"			sel := classAndSelector at: 2.			(aClass includesSelector: sel)				ifTrue: [source := aClass sourceCodeAt: sel ifAbsent:[nil]]				ifFalse: [source := aClass class sourceCodeAt: sel ifAbsent:[nil]].		].		source ifNil:[			Transcript cr; show: 'WARNING: Compiled primitive ', classAndSelector first, '>>', classAndSelector last, ' not present'.		] ifNotNil:[			"compile the method source and convert to a suitable translation 			method "			meth := ((Compiler new						parse: source						in: aClass						notifying: nil) 							JSprepare: true) 								asTranslationMethodOfClass: self translationMethodClass.			(aClass includesSelector: sel)				ifTrue: [meth definingClass: aClass]				ifFalse: [meth definingClass: aClass class].			meth primitive > 0 ifTrue:[meth preparePrimitiveName].			"for old-style array accessing: 			meth covertToZeroBasedArrayReferences."			meth replaceSizeMessages.			self addMethod: meth.		].	].	"method preparation"	verbose := false.	self prepareMethods.	verbose		ifTrue: 			[self printUnboundCallWarnings.			self printUnboundVariableReferenceWarnings.			Transcript cr].	"code generation"	self doInlining: true.	methods do:[:m|		"if this method is supposed to be a primitive (rather than a helper 		routine), add assorted prolog and epilog items"		m primitive > 0 ifTrue: [			m preparePrimitivePrologue].		"check for one-based array access"			m oneBasedArrays ifNotNil: [self oneBasedArrays: true].	].! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/18/2020 15:56'!addStructClasses: classes! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 12/12/2020 22:15'!ignoredMethods	^#(halt msg: getModuleName setInterpreter:)! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 1/8/2022 14:16'!initialize	translationDict := Dictionary new.	inlineList := Array new.	constants := Dictionary new: 100.	variables := OrderedCollection new: 100.	variableDeclarations := Dictionary new: 100.	methods := Dictionary new: 500.	macros := Dictionary new.	self initializeJSTranslationDictionary.	receiverDict := Dictionary new.	headerFiles := OrderedCollection new.	globalVariableUsage := Dictionary new.	useSymbolicConstants := false.	generateDeadCode := false.	scopeStack := OrderedCollection new.	logger := (ProvideAnswerNotification new tag: #logger; signal) ifNil: [Transcript].	pools := IdentitySet new.	abstractDeclarations := IdentitySet new.	uncheckedAbstractMethods := OrderedCollection new.	exceptions := Dictionary new.! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/18/2020 19:45'!omSimulator	^omSimulator ifNil: [omSimulator := Smalltalk image endianness == #big				ifTrue: [Smalltalk image wordSize = 4							ifTrue: [ObjectMemorySimulatorMSB basicNew]							ifFalse: [ObjectMemorySimulatorMSB64 basicNew]]				ifFalse: [Smalltalk image wordSize = 4							ifTrue: [ObjectMemorySimulatorLSB basicNew]							ifFalse: [ObjectMemorySimulatorLSB64 basicNew]]]! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/4/2020 11:05'!storeCodeOnFile: fileName doInlining: inlineFlag	"Store JS code for this code base on the given file."	self storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true.	exceptions notEmpty ifTrue: [exceptions inspect].! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 7/13/2023 02:32'!storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store JS code for this code base on the given file."	self removeVariable: 'interpreterProxy'; removeVariable: 'moduleName'.	FileStream forceNewFileNamed: fileName do: [:stream |		self emitJSCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag]! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 10/28/2020 23:16'!storeHeaderFor: interpreterClassName onFile: fileName	"We don't use a separate header file for JavaScript"! !!JSCodeGenerator methodsFor: 'utilities'!checkForGlobalUsage: vars in: aJSMethod 	| item |	vars		do: [:var | 			"TPR - why the use of globalsAsSet here instead of globalVariables? 			JMM - globalVariables is not initialized yet, variables is an OrderedCollection, 				globalsAsSet returns variables as needed set"			(self globalsAsSet includes: var)				ifTrue: ["find the set of method names using this global var"					item := globalVariableUsage								at: var								ifAbsent: [globalVariableUsage at: var put: Set new].					"add this method name to that set"					item add: aJSMethod selector]].	aJSMethod referencesGlobalStructMakeZero! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 7/11/2023 22:21'!compileToJSMethodSelector: selector in: aClass	"Compile a method to a JSMethod"	^((Compiler new		parse: (aClass sourceCodeAt: selector)		in: aClass		notifying: nil) 			JSprepare: true) 				asTranslationMethodOfClass: self translationMethodClass! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 1/8/2022 09:49'!nilOrBooleanConstantReceiverOf: sendNode	"Answer nil or the boolean constant that is the receiver of the given message send. Used to suppress conditional code when the condition is a translation-time constant."	| val | 	val := self nilOrReducibleValueOf: sendNode receiver.	^((val == true) or: [val == false]) ifTrue: [val].! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 7/25/2023 18:50'!nilOrReducibleValueOf: expr	| val |	generateDeadCode ifTrue:[^nil].	expr isConstant ifTrue: [		^expr value.	] ifFalse: [		expr isVariable ifTrue: [			(#('true' 'false') includes: expr name) ifTrue: [^'true' = expr name ].		] ifFalse: [			expr isSend ifTrue: [				(#(failed successful) includes: expr selector) ifTrue: [^#successful = expr selector ].				(methods at: expr selector ifAbsent: []) ifNotNil: [:m |						(m definedAsMacro not						 and: [m statements size = 1						 and: [m statements last isReturn]]) ifTrue: [							^self nilOrReducibleValueOf: m statements last expression ]].				(val := self nilOrReducibleValueOf: expr receiver) notNil ifTrue: [					expr selector == #and: ifTrue: [						(expr args size ~= 1 or: [expr args first statements size ~= 1])							ifTrue: [self halt. ^nil].						^val and: [self nilOrReducibleValueOf: expr args first statements first]					] ifFalse: [						expr selector == #or: ifTrue: [							(expr args size ~= 1 or: [expr args first statements size ~= 1])								ifTrue: [self halt. ^nil].							^val or: [self nilOrReducibleValueOf: expr args first statements first]						] ifFalse: [							expr selector == #ifTrue:ifFalse: ifTrue: [								val ifTrue: [									expr args first statements size ~= 1										ifTrue: [^nil].									^self nilOrReducibleValueOf: expr args first statements first								] ifFalse: [									expr args last statements size ~= 1										ifTrue: [^nil].									^self nilOrReducibleValueOf: expr args last statements first								]							] ifFalse: [								expr selector == #ifFalse:ifTrue: ifTrue: [									val ifTrue: [										expr args last statements size ~= 1											ifTrue: [^nil].										^self nilOrReducibleValueOf: expr args last statements first									] ifFalse: [										expr args first statements size ~= 1											ifTrue: [^nil].										^self nilOrReducibleValueOf: expr args first statements first									]								] ifFalse: [									^val perform: expr selector withArguments: (expr args collect: [:e | (self nilOrReducibleValueOf: e) ifNil: [^nil]])								]							]						]					]				]			]		]	].	^ nil! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 7/25/2023 18:34'!reservedWords	^#(	'arguments'		'break'		'case' 'catch' 'class' 'const' 'continue'		'debugger' 'default' 'delete' 'do'		'else' 'enum' 'eval' 'export' 'extends'		'false' 'finally' 'for' 'function'		'if' 'implements' 'import' 'in' 'instanceof' 'interface'		'let'		'new' 'null'		'package' 'private' 'protected' 'public'		'return'		'static' 'super' 'switch'		'this' 'throw' 'true' 'try' 'typeof'		'var' 'void'		'while' 'with'		'yield')! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 12/27/2021 08:31'!returnPrefixFromVariable: aName	aName = 'class'		ifTrue: [^'sq_class'].	aName = 'in'		ifTrue: [^'in_'].	aName = 'self'		ifTrue: [^'this']. "some primitives just leave the receiver on the stack as a return"	^aName! !!JSCodeGenerator methodsFor: 'private' stamp: 'fm 10/29/2020 18:17'!ifPointerVar: node then: aBlock	(node isSend and: [node selector = #+ or: [node selector = #- and: [node args first isConstant]]]) ifTrue: [		^self ifPointerVar: node receiver then: aBlock].	node isVariable ifTrue: [		(self typeOfVariable: node name) ifNotNil: [:type |			(type includes: $*) ifTrue: [aBlock value: type]]].! !!JSCodeGenerator methodsFor: 'inlining' stamp: 'fm 11/12/2020 14:06'!doBasicInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining.	This method does only the basic inlining suitable for both the core VM and plugins - no bytecode inlining etc"	| pass progress max |	inlineFlag ifFalse: [^self].	self collectInlineList.	pass := 0.	max := 12. "More than this is probably due to infinite recursion" 	progress := true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress := false.		pass > max			ifTrue: [self notify: 'too many inlining steps, inlining terminated']			ifFalse: [('Inlining pass ', (pass := pass + 1) printString, '...')						displayProgressAt: Sensor cursorPoint						from: 0 to: methods size						during: [:bar |							(self sortMethods: methods) doWithIndex: [:m :i | "m selector == #arrayValueOf: ifTrue: [self halt]."								bar value: i.								currentMethod := m.								(m tryToInlineMethodsIn: self)									ifTrue: [progress := true]]]]].! !!JSCodeGenerator methodsFor: 'accessing' stamp: 'fm 9/3/2020 23:50'!exceptions	^exceptions! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 10/29/2020 00:55'!emitInterpreterProxyVersionOn: aStream	aStream		nextPutAll: 'var VM_PROXY_MAJOR = ';		nextPutAll: InterpreterPrimitives vmProxyMajorVersion printString;		cr;		nextPutAll: 'var VM_PROXY_MINOR = ';		nextPutAll: InterpreterPrimitives vmProxyMinorVersion printString;		cr; cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 2/20/2021 20:12'!emitJSCodeOn: aStream doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	self emitJSHeaderOn: aStream.	self emitJSTypesOn: aStream.	self emitJSConstantsOn: aStream.	self emitJSVariablesOn: aStream."'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |"	preparedMethodList doWithIndex: [ :m :i | 		[aStream nextPutAll: (String streamContents: [:s | m emitJSCodeOn: s generator: self. s nextPutAll: ', '])] on: Halt, Error do: [:e | 			"e isResumable ifTrue: [e resumeUnchecked: nil]."			(exceptions at: e signalerContext sender printString ifAbsentPut: [OrderedCollection new]) add: m definingClass name , '>>#' , m selector -> (e printString, ' in ', e signalerContext shortStack) ]]."]."	self emitExportsOn: aStream.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 3/23/2021 18:03'!emitJSConstantsOn: aStream	"Store the global variable declarations on the given stream."	| unused constList node |	unused := constants keys asSet.	methods do: [ :meth |		meth parseTree nodesDo: [ :n |			n isConstant ifTrue: [ unused remove: n name ifAbsent: []]]].	constList := constants keys reject: [ :any | unused includes: any].	constList isEmpty ifTrue: [^self].	aStream nextPutAll: '/*** Constants ***/';		 cr.	constList asSortedCollection do: [ :varName |		node := constants at: varName.		node name isEmpty ifFalse: [			aStream nextPutAll: 'const '.			aStream nextPutAll: node name.			aStream nextPutAll: ' = '.			aStream nextPutAll: (self jsLiteralFor: node value).			aStream nextPut: $;.			aStream cr		].	].	aStream cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 7/13/2023 23:10'!emitJSFunctionsOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }'! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 7/14/2023 15:05'!emitJSHeaderOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: (VMMaker headerNotice copyReplaceAll: ' C ' with: ' JavaScript ').	aStream nextPutAll: ' */';cr.	aStream nextPutAll: (self fileHeaderVersionStampForSourceClass: vmClass).	self emitInterpreterProxyVersionOn: aStream.	self emitJSFunctionsOn: aStream.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 4/2/2021 10:10'!emitJSVariablesOn: aStream 	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection		do: [:var | 	| varString varDecl |			varString := var asString.			aStream nextPutAll: 'let ', varString.			varDecl := variableDeclarations at: varString ifAbsent: [''].			(varDecl includes: $=)				ifTrue: [ | const |					const := ((varDecl copyAfter: $=) replaceAll: ${ with: $[) replaceAll: $} with: $].					aStream nextPutAll: ' =', const]				ifFalse: [(varDecl includesAnyOf: '*[')					ifTrue: [(varDecl includes: $[)						ifTrue: [ | size |							size := (varDecl copyAfter: $[) copyUpTo: $].							size ifEmpty: [self halt].							aStream nextPutAll: ' = new Array(', size, ')']]					ifFalse: [aStream nextPutAll: ' = 0']].			aStream nextPutAll: ';'; cr].	aStream cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 3/9/2021 19:52'!isNonArgumentImplicitReceiverVariableName: aString	^(self typeOfVariable: aString) == #implicit	    or: ['SmalltalkVM' = aString or: [self pluginName = aString or: [vmClass			ifNil: [#('interpreterProxy' 'self') includes: aString]	 		ifNotNil: [vmClass isNonArgumentImplicitReceiverVariableName: aString]]]]! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 5/11/2021 19:17'!typeOfArgument: argIndex in: selector	| method |	method := methods at: selector ifAbsent: [^nil].	^method declarations at: (method args at: argIndex).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:09'!generateAsInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | 0)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:47'!generateAsUnsignedInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt.	aStream nextPutAll: '('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '>>>0)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/30/2020 18:18'!generateAtPut: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| putExpr incExpr arrayNode indexNode subtractOne complex |	arrayNode := msgNode receiver.	(arrayNode isSend and: [arrayNode selector = #cCoerce:to: and: [arrayNode args first isVariable]]) ifTrue: [		arrayNode := arrayNode args first].		indexNode := msgNode args first.	subtractOne := self isOneBasedArray: arrayNode name in: currentMethod.	(subtractOne and: [indexNode isPlusOne]) ifTrue: [		subtractOne := false.		indexNode := indexNode receiver.	"remove + 1"	].	complex := subtractOne and: [indexNode isLeafOrFunc not].	self emitJSExpression: arrayNode on: aStream.	aStream nextPut: $[.	complex ifTrue: [aStream nextPut: $(].	indexNode emitJSCodeAsExpressionOn: aStream level: level + 1 generator: self.	complex ifTrue: [aStream nextPut: $)].	subtractOne ifTrue: [aStream nextPutAll: ' - 1'].	aStream nextPut: $].	(putExpr := msgNode args last) isPlusOne ifTrue: [		((incExpr := putExpr receiver) isSend and: [incExpr selector = #at: and: [			incExpr receiver asString = arrayNode asString and: [			incExpr args first asString = indexNode asString]]])				ifTrue: [^aStream nextPutAll: '++'.]].	aStream nextPutAll: ' = '.	self emitJSExpression: putExpr on: aStream! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 02:05'!generateBaseHeaderSize: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'BASE_HEADER_SIZE'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:29'!generateBitAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	arg isConstant ifTrue: [		arg value >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBANDM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (arg value - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBANDS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: arg value printString;				nextPutAll: ')'.		].	] ifFalse: [		rcvr isConstant ifTrue: [			rcvr value >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBANDM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (rcvr value - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBANDS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: rcvr value printString;					nextPutAll: ')'.			].		] ifFalse: [			aStream nextPutAll: 'UBAND('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/24/2021 12:54'!generateBitClear: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt: 'this cannot work'.	aStream nextPutAll: '(('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ') - '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: '|0))'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:30'!generateBitInvert32: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: '(~('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ') >>> 0)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:29'!generateBitOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	arg isConstant ifTrue: [		arg value >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBORM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (arg value - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBORS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: arg value printString;				nextPutAll: ')'.		].	] ifFalse: [		rcvr isConstant ifTrue: [			rcvr value >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBORM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (rcvr value - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBORS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: rcvr value printString;					nextPutAll: ')'.			].		] ifFalse: [			aStream nextPutAll: 'UBOR('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:30'!generateBitShift: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	arg := msgNode args first.	rcvr := msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		arg value < 0 ifTrue: [			arg value > -32 ifTrue: [				"skip unneeded coercion to unsigned"				(rcvr isSend and: [rcvr selector = #cCoerce:to: and: [rcvr args second value = 'unsigned']])					ifTrue: [self emitJSExpression: rcvr args first on: aStream]					ifFalse: [self emitJSExpression: rcvr on: aStream].				aStream nextPutAll: ' >>> ';					nextPutAll: arg value negated printString.			] ifFalse: [				rcvr isConstant					ifTrue: [(rcvr value bitShift: arg value) JSstoreOn: aStream ]					ifFalse: [self error: 'cannot shift by more than 31']].		] ifFalse: [			"skip unneeded coercion to unsigned"			(rcvr isSend and: [rcvr selector = #cCoerce:to: and: [rcvr args second value = 'unsigned']])				ifTrue: [self emitJSExpression: rcvr args first on: aStream]				ifFalse: [self emitJSExpression: rcvr on: aStream].			aStream nextPutAll: ' << ';				nextPutAll: arg value printString;				nextPutAll: ' >>> 0'.		].	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHIFT('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:30'!generateBitXor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	arg isConstant ifTrue: [		arg value >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBXORM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (arg value - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBXORS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: arg value printString;				nextPutAll: ')'.		].	] ifFalse: [		rcvr isConstant ifTrue: [			rcvr value >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBXORM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (rcvr value - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBXORS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: rcvr value printString;					nextPutAll: ')'.			].		] ifFalse: [			aStream nextPutAll: 'UBXOR('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 02:14'!generateBytesPerWord: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'BYTES_PER_WORD'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/10/2022 19:24'!generateCCoercion: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr cType |.	expr := msgNode args first.	cType := msgNode args second value copyReplaceAll: ' *' with: '*'.	(expr isSend and: [expr receiver name = 'interpreterProxy' and: [expr selector = #firstIndexableField:]]) ifTrue: [		((cType beginsWith: 'unsigned char*') or: [cType beginsWith: 'char*'])			ifTrue: [aStream nextPutAll: 'BYTESOF('. self emitJSExpression: expr args first on: aStream. ^aStream nextPut: $)].		self emitJSExpression: expr args first on: aStream.		((cType beginsWith: 'unsigned int*') or: [cType beginsWith: 'unsigned*'])			ifTrue: [^ aStream nextPutAll: '.words'].		(cType beginsWith: 'int*')			ifTrue: [^ aStream nextPutAll: '.wordsAsInt32Array()'].		(cType beginsWith: 'short*')			ifTrue: [^ aStream nextPutAll: '.wordsAsInt16Array()'].		(cType beginsWith: 'float*')			ifTrue: [^ aStream nextPutAll: '.wordsAsFloat32Array()'].		(cType beginsWith: 'double*')			ifTrue: [^ aStream nextPutAll: '.wordsAsFloat64Array()'].		self halt: 'need to handle ', cType.	] ifFalse: [		(#('int' 'long' 'sqInt' 'sqLong') includes: cType) ifTrue: [			aStream nextPutAll: '('.			self emitJSExpression: expr on: aStream.			^aStream nextPutAll: '|0)'].		(#('unsigned int' 'unsigned' 'unsigned long' 'usqLong' 'usqInt') includes: cType) ifTrue: [				aStream nextPutAll: '('.				self emitJSExpression: expr on: aStream.				^ aStream nextPutAll: '>>>0)'].		((#('double' 'float') includes: cType) or: [('sqInt (*)(*)'match: cType)			or: [#(transformPoint:into:) includes: currentMethod selector]])			ifFalse: [				self ifPointerVar: expr then: [:type | | t | 					self emitJSExpression: expr on: aStream.					^(t := (type copyReplaceAll: ' *' with: '*') first: cType size) = cType 						ifFalse: [							(cType beginsWith: 'char*')								ifTrue: [^ aStream nextPutAll: '.wordsAsInt8Array()'].							((cType beginsWith: 'int*') or: [cType beginsWith: 'sqInt*'])								ifTrue: [^ aStream nextPutAll: '.wordsAsInt32Array()'].							(cType beginsWith: 'short*')								ifTrue: [^ aStream nextPutAll: '.wordsAsInt16Array()'].							(cType beginsWith: 'float*')								ifTrue: [^ aStream nextPutAll: '.wordsAsFloat32Array()'].							(cType beginsWith: 'double*')								ifTrue: [^ aStream nextPutAll: '.wordsAsFloat64Array()'].							(cType beginsWith: 'void*')								ifFalse: [Warning signal: 'here'. self halt: t, ' cannot be coerced to ', cType]]]. 				self halt: cType].		self emitJSExpression: expr on: aStream.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "bytes" ? ('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "words" ? PrimitiveFailed.signal() : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsUint8Array()) : BYTESOF('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:40'!generateCheckIsFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if (!!'.		self generateIsFloatObject: msgNode on: aStream indent: level.		aStream nextPutAll: ') throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [		self halt: 'CHECKEDFLOAT not implemented!!'.		aStream nextPutAll: 'CHECKEDFLOAT('.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: ')'	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:40'!generateCheckIsInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if (!!'.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ') throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [		aStream nextPutAll: 'CHECKEDINTEGER('.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: ')'.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:12'!generateCheckIsNotNumber: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if '.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [self halt.		aStream nextPutAll: 'if (typeof '.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: '.valueOf() === "number") throw Object.create(PrimitiveFailed).setPayload(1)'	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsShorts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "shorts" ? ('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "words" ? PrimitiveFailed.signal() : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsUint16Array()) : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.shorts'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsSignedInts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsInt32Array() : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsSignedShorts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsInt16Array() : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsWords: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.words : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:41'!generateCheckedBoolean: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr |	expr := msgNode args first.	expr isVariable ifTrue: [		aStream nextPutAll: '(typeof ';			nextPutAll: expr name;			nextPutAll: ' === "boolean" ? ';			nextPutAll: expr name;			nextPutAll: ' : PrimitiveFailed.signal())'	] ifFalse: [		(expr isSend and: [expr selector == #not]) ifTrue: [			aStream nextPutAll: '!!'.			self generateCheckedBoolean: (msgNode copyTree arguments: {expr receiver}) on: aStream indent: level		] ifFalse: [			aStream nextPutAll: 'CHECKEDBOOLEAN('.			self emitJSExpression: expr on: aStream.			aStream nextPutAll: ')'		].	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:00'!generateCheckedFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsFloatObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: msgNode args first name;			nextPutAll: '.valueOf() : PrimitiveFailed.signal()';			nextPutAll: ')'	] ifFalse: [self halt.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:34'!generateCheckedInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr |	expr := msgNode args first.	expr isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: expr name;			nextPutAll: ' : PrimitiveFailed.signal())'	 ] ifFalse: [		aStream nextPutAll: 'CHECKEDINTEGER('.		self emitJSExpression: expr on: aStream.		aStream nextPutAll: ')'	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 20:59'!generateCheckedNotNumber: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: 'PrimitiveFailed.signal() : ';			nextPutAll: msgNode args first name;			nextPutAll: ')'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 17:14'!generateCheckedPositive32Bit: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPut: $(;			nextPutAll: varName;			nextPutAll: ' >>> 0) === ';			nextPutAll: varName;			nextPutAll: '.valueOf() ? ';			nextPutAll: varName;			nextPutAll: ' : PrimitiveFailed.signal()'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:10'!generateClassArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Array'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassBitmap: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Bitmap'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassByteArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._ByteArray'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassLargeNegativeInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._LargeNegativeInteger'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassLargePositiveInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._LargePositiveInteger'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassPoint: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Point'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassString: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._String'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:31'!generateDivide: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| rcvr arg divisor |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	msgNode selector == #/ ifTrue: [		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		^self emitJSExpression: arg on: aStream].	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor := arg value) isInteger and:	 [divisor isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.	] ifFalse: [		"use float divide and coerce to integer"		aStream nextPutAll: 'Math.trunc('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/22/2021 00:57'!generateEqual: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| argNode test |	argNode :=  msgNode args first.	"quick test for nil, true, false"	argNode isInterpreterProxyConstant ifTrue: [		test := #(' === nil' ' === true' ' === false') at: (#(nilObject trueObject falseObject) indexOf: argNode selector).		self emitJSExpression: msgNode receiver on: aStream.		^aStream nextPutAll: test].	"cannot compare pointers to 0"	(argNode isConstantNull or: [argNode isConstantZero and: [self isPointer: msgNode receiver]]) ifTrue: [		aStream nextPutAll: '!!'.		^self emitJSExpression: msgNode receiver on: aStream].	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' === '.	self emitJSExpression: argNode on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/29/2020 18:42'!generateFailed: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'false'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:36'!generateFloatObjectOf: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg |	arg := msgNode args first.	arg isConstant ifTrue: [		arg value isFloat ifFalse: [self halt].		arg value asFloat JSstoreOn: aStream	] ifFalse: [		arg isVariable ifTrue: [			aStream nextPutAll: 'typeof ';				nextPutAll: arg name;				nextPutAll: '.valueOf() !!== "number" ? PrimitiveFailed.signal() : ((';				nextPutAll: arg name;				nextPutAll: '.valueOf() | 0 === ';				nextPutAll: arg name;				nextPutAll: '.valueOf()) || Number.isSafeInteger(';				nextPutAll: arg name;				nextPutAll: ') ? new Float(';				nextPutAll: arg name;				nextPutAll: ') : ';				nextPutAll: arg name;				nextPutAll: '.valueOf())'		] ifFalse: [			(arg isSend and: [arg selector == #asFloat]) ifTrue: [				aStream nextPutAll: 'new Float('.				self emitJSExpression: arg receiver on: aStream.				aStream nextPutAll: ')'.			] ifFalse: [				self halt: 'CHECKEDFLOAT not implemented!!'.				aStream nextPutAll: 'new Float(CHECKEDFLOAT('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: '))'.			]		].	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/26/2021 20:02'!generateIfFalse: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if ('.			self generateNot: (TSendNode new					setSelector: #not receiver: msgNode receiver arguments: #())				on: aStream indent: level + 1.			aStream nextPutAll: ') {'; cr.			msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.			level timesRepeat: [aStream tab].			aStream nextPut: $}]		ifNotNil:			[:const |			const ifFalse:				[msgNode args last emitJSCodeOn: aStream level: level - 1 generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/26/2021 19:51'!generateIfFalseAsArgument: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			 msgNode receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.			 aStream crtab: level + 1; nextPutAll: ' ? 0 : '.			 msgNode args last emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			 aStream crtab: level + 1; nextPut: $)]		ifNotNil:			[:const|			const ifFalse:				[msgNode args last emitJSCodeAsArgumentOn: aStream level: level generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/25/2023 13:14'!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level) ifFalse:				[aStream nextPutAll: 'if ('.				msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.				aStream nextPutAll: ') {'; cr.				msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.				aStream tab: level; nextPut: $}; nextPutAll: ' else {'; cr.				msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.				aStream tab: level; nextPut: $}]]		ifNotNil:			[:const |			 (const ifTrue: [msgNode args last] ifFalse: [msgNode args first])				emitJSCodeOn: aStream level: level - 1 generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/26/2021 20:02'!generateIfTrue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPutAll: 'if ('.			msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ') {'; cr.			msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.			level timesRepeat: [ aStream tab ].			aStream nextPut: $}]		ifNotNil:			[:const |			const ifTrue:				[msgNode args first emitJSCodeOn: aStream level: level - 1 generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/25/2023 13:14'!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isNilStmtListNode		ifTrue: [^self generateIfFalse: msgNode on: aStream indent: level].	msgNode args last isNilStmtListNode		ifTrue: [^self generateIfTrue: msgNode on: aStream indent: level].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level) ifFalse:				[aStream nextPutAll: 'if ('.				msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.				aStream nextPutAll: ') {'; cr.				msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.				aStream tab: level; nextPut: $}; nextPutAll: ' else {'; cr.				msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.				aStream tab: level; nextPut: $}]]		ifNotNil:			[:const |			(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])				emitJSCodeOn: aStream level: level - 1 generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 14:58'!generateInlineCppIfElse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| comment alternateBlock alternateBlockIsNil |	aStream cr; nextPutAll: '# if (', msgNode args first value, ')'.	comment := msgNode args third value.	(comment isKindOf: String)		ifTrue: [aStream nextPutAll: '  // ', comment]		ifFalse: ["nil argument, ignore it"].	aStream cr.	msgNode isExpression		ifTrue:			[aStream tab: level + 1; nextPut: $(.			msgNode args fourth asExpression				emitJSCodeOn: aStream level: level + 1 generator: self.			aStream nextPut: $); cr]		ifFalse:			[msgNode args fourth				emitJSCodeOn: aStream level: level generator: self].	alternateBlock := msgNode args fifth.	alternateBlockIsNil := true. "check for nil #else clause"	alternateBlock nodesDo: [:n |		(n ~= alternateBlock and: [n name ~= 'nil'])			ifTrue: [alternateBlockIsNil := false ]].	(alternateBlockIsNil) ifFalse:		[aStream nextPutAll: '# else'; cr.		msgNode isExpression			ifTrue:				[aStream tab: level + 1; nextPut: $(.				alternateBlock asExpression					emitJSCodeOn: aStream level: level + 1 generator: self.				aStream nextPut: $); cr]			ifFalse:				[alternateBlock					emitJSCodeOn: aStream level: level generator: self]].	aStream nextPutAll: '# endif  // ', msgNode args first value; cr; tab: level! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 6/11/2021 14:37'!generateInstantiateClassIndexableSize: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '(function(__size) {const result = '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.primitive_71_impl(__size); return result[0] ? result[1] : PrimitiveFailed.signal()})('.	self emitJSExpression: msgNode args last on: aStream.	aStream nextPut: $)! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateIsArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "pointers" && '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.instSize === 0)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "bytes")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:33'!generateIsFloatObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number" && (';			nextPutAll: varName;			nextPutAll: ' | 0) !!== ';			nextPutAll: varName;			nextPutAll: ' && !!Number.isSafeInteger(';			nextPutAll: varName;			nextPutAll: ') || ';			nextPutAll: varName;			nextPutAll: '._class() === SmalltalkGlobals._Float)'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/14/2022 18:10'!generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number")'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:07'!generateIsIntegerValue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number" && (';			nextPutAll: varName;			nextPutAll: ' | 0) === ';			nextPutAll: varName;			nextPutAll: ')'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/23/2021 17:53'!generateIsMemberOf: aNode on: aStream indent: anInteger	aStream nextPut: $(.	self emitJSExpression: aNode args first on: aStream.	aStream nextPutAll: '._class() === SmalltalkGlobals._';		nextPutAll: aNode args last value;		nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsPointers: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "pointers")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsWords: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsWordsOrBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '(["words", "bytes"].indexOf('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType) !!== -1)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/6/2022 23:18'!generateJSCodeForCcode: cCode on: aStream indent: level	cCode = '' ifTrue: [^self]. 	aStream nextPutAll: (cCodeTranslationDict at: cCode ifAbsent: [		(#('sqrt' 'sin' 'cos' 'tan' 'atan' 'atan2' 'log' 'exp' 'min' 'max' 'floor') anySatisfy: [:fn | fn,'(*)' match: cCode])			ifTrue: ['Math.', cCode] ifFalse: [		('dir_Delimitor()' = cCode)			ifTrue: ['"/"'] ifFalse: [		('opTable[*] = (void *)*' match: cCode)			ifTrue: [cCode copyReplaceAll: '(void *)' with: 'this.'] ifFalse: [		('fn(*Handle, &*Pitch, *)' match: cCode)			ifTrue: [(cCode copyReplaceAll: '&' with: 'function(p){') copyReplaceAll: 'Pitch' with: 'Pitch = p}'] ifFalse: [		(' ((*)querySurfaceFn)*(handle, &destWidth, &destHeight, &destDepth, &destMSB)' match: cCode)			ifTrue: [ 'querySurfaceFn(handle, function(w, h, d, m){destWidth = w; destHeight = h; destDepth = d; destMSB = m; })'] ifFalse: [		(' ((*)querySurfaceFn)*(handle, &sourceWidth, &sourceHeight, &sourceDepth, &sourceMSB)' match: cCode)			ifTrue: [ 'querySurfaceFn(handle, function(w, h, d, m){sourceWidth = w; sourceHeight = h; sourceDepth = d; sourceMSB = m; })'] ifFalse: [		(#('fn(destHandle, affectedL, affectedT, affectedR-affectedL, affectedB-affectedT)',			'fn(sourceHandle, 0, 0, 0, 0)') includes: cCode)			ifTrue: [cCode] ifFalse: [		(constants includesKey: cCode) ifFalse: [self halt: cCode].		cCode]]]]]]]])! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMath: msgNode on: aStream indent: level	"Generate the JS code for the message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.'; nextPutAll: msgNode selector; nextPut: $(.	msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.	aStream nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMax: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.max('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/22/2021 20:35'!generateMergeFnWith: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'mergeFnwith('.	msgNode args do:		[ :arg| arg emitJSCodeAsArgumentOn: aStream level: level generator: self]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/3/2020 01:04'!generateMethodArgumentCount: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'arguments.length'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMin: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.min('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 13:31'!generateMinus: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self ifPointerVar: msgNode receiver then: [:type |		self ifPointerVar: msgNode args first then: [:type1 |			((type copyUpTo: $*) copyWithout: $ ) = ((type1 copyUpTo: $*) copyWithout: $ ) 				ifTrue: [					self generatePointerMinusPointer: msgNode type: type on: aStream indent: level] 				ifFalse: [					self halt: 'cannot do - with ', type, ' and ', type1].				^self].		(self generatePointerMinus: msgNode type: type on: aStream indent: level)			ifTrue: [^self].		self halt: 'cannot do - with ', type].	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' - '.	self emitJSExpression: msgNode args first on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:35'!generateModulo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'MOD('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/8/2021 20:37'!generateNilObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'nil'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/21/2020 13:03'!generateNot: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[| expr |			expr := msgNode receiver.			"generate (a !!= b) instead of !!(a == b)"			expr isEqualityTest ifTrue: [				^(msgNode selector includes: $~)					ifTrue: [self generateEqual: expr on: aStream indent: level]					ifFalse: [self generateNotEqual: expr on: aStream indent: level]].			"eliminate not not"			(expr isSend and: [expr selector = #not]) ifTrue: [				^self emitJSExpression: expr receiver on: aStream].			aStream nextPutAll: '!!'.			self emitJSExpression: expr on: aStream]		ifNotNil: [:const |			aStream nextPutAll: (const ifTrue: ['false'] ifFalse: ['true'])]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/22/2021 00:57'!generateNotEqual: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| argNode test |	argNode :=  msgNode args first.	"quick test for nil, true, false"	argNode isInterpreterProxyConstant ifTrue: [		test := #(' !!== nil' ' !!== true' ' !!== false') at: (#(nilObject trueObject falseObject) indexOf: argNode selector).		self emitJSExpression: msgNode receiver on: aStream.		^aStream nextPutAll: test].	"cannot compare pointers to 0"	(argNode isConstantNull or: [argNode isConstantZero and: [self isPointer: msgNode receiver]]) ifTrue: [		aStream nextPutAll: '!!!!'.		^self emitJSExpression: msgNode receiver on: aStream].	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!== '.	self emitJSExpression: msgNode args first on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 15:09'!generatePerform: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt: msgNode asString.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $(.	(msgNode args copyFrom: 2 to: msgNode args size) do:[:arg|		self emitJSExpression: arg on: aStream.	] separatedBy:[aStream nextPutAll:', '].	aStream nextPut: $)! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:18'!generatePlus: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	msgNode receiver isBitBltPtr ifFalse: [		self checkNonPointer: msgNode args first op: '+'.		self ifPointerVar: msgNode receiver then: [:type |			(self generatePointerPlus: msgNode type: type on: aStream indent: level)				ifTrue: [^self].			self halt: 'cannot do + with ', type].		self emitJSExpression: msgNode receiver on: aStream.		aStream nextPutAll: ' + '].	self emitJSExpression: msgNode args first on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 14:16'!generatePointerMinus: msgNode type: type on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/13/2023 23:12'!generatePointerMinusPointer: msgNode type: type on: aStream indent: level	msgNode selector = #- ifFalse: [self halt].	aStream nextPutAll: 'PTR_PTRSUB('.	msgNode receiver isVariable		ifTrue: [			aStream nextPutAll: msgNode receiver name, ', ']		ifFalse: [msgNode receiver emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true].	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 14:09'!generatePointerPlus: msgNode type: type on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/15/2020 21:01'!generatePointersAt: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ']'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/15/2020 22:34'!generatePointersAtPut: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '] = '.	self emitJSExpression: msgNode args last on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/24/2021 14:17'!generatePositive32BitIntegerFor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '((';			nextPutAll: varName;			nextPutAll: ' >>> 0) !!== ';			nextPutAll: varName;			nextPutAll: '.valueOf() ? PrimitiveFailed.signal() : (';			nextPutAll: varName;			nextPutAll: ' >= 0 ? ';			nextPutAll: varName;			nextPutAll: ' : 4294967296 + ';			nextPutAll: varName;			nextPutAll: '))'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:01'!generatePrimitiveFail: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload(1)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:01'!generatePrimitiveFailFor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:02'!generatePrimitiveReturn: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/31/2020 18:03'!generatePush: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self generatePrimitiveReturn: msgNode on: aStream indent: level! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 20:30'!generatePushBool: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateCheckedBoolean: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/11/2022 22:41'!generatePushFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateFloatObjectOf: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:02'!generatePushInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateCheckedInteger: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/21/2020 00:18'!generateQuestionMarkColon: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[self emitJSExpression: msgNode receiver on: aStream.			aStream nextPutAll: ' ? '.			self emitJSExpression: msgNode args first on: aStream.			aStream nextPutAll: ' : '.			self emitJSExpression: msgNode args last on: aStream]		ifNotNil: [:const |			self emitJSExpression: (const ifTrue: [msgNode args first] ifFalse: [msgNode args last]) on: aStream]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:35'!generateRaisedTo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll:'Math.pow('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ','.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll:')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/21/2020 12:58'!generateSequentialAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[self emitJSExpression: msgNode receiver on: aStream.			aStream nextPutAll: ' && ('.			self emitJSTestBlock: msgNode args first on: aStream.			aStream nextPut: $)]		ifNotNil: [:const |			const ifTrue: [self emitJSTestBlock: msgNode args first on: aStream]]	! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/21/2020 12:59'!generateSequentialOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[self emitJSExpression: msgNode receiver on: aStream.			aStream nextPutAll: ' || ('.			self emitJSTestBlock: msgNode args first on: aStream.			aStream nextPut: $)]		ifNotNil: [:const |			const ifFalse: [self emitJSTestBlock: msgNode args first on: aStream]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:36'!generateShiftLeft: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr result |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	arg isConstant ifTrue: [		"bit shift amount is a constant"		arg value < 32 ifTrue: [			arg value < 0 ifTrue: [self halt].			rcvr isConstant ifTrue: [				rcvr value < 0 ifTrue: [self halt].				result := rcvr value bitShift: arg value.				result > (1 bitShift: 32) ifTrue: [self halt].				aStream nextPutAll: result printString			] ifFalse: [				self emitJSExpression: rcvr on: aStream.				aStream nextPutAll: ' << ';					nextPutAll: arg value printString;					nextPutAll: ' >>> 0'.			].		] ifFalse: [			rcvr isConstant ifTrue: [				rcvr value < 0 ifTrue: [self halt].				result := rcvr value bitShift: arg value.				result > (1 bitShift: 32) ifTrue: [self halt].				aStream nextPutAll: result printString			] ifFalse: [				aStream nextPut: $0]].	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHL('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '. 		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:36'!generateShiftRight: msgNode on: aStream indent: level	"Generate the JS code for unsigned right-shift onto the given stream."	| rcvr arg |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	arg isConstant ifTrue: [		"bit shift amount is a constant"		arg value < 32 ifTrue: [			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ' >>> ';				nextPutAll: arg value printString.		] ifFalse: [			aStream nextPut: $0].	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHR('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:36'!generateSignedBitShift: msgNode on: aStream indent: level	"Generate the JS code for signedBitShift: onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	arg := msgNode args first.	rcvr := msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		(arg value between: -31 and: 31) ifTrue: [			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: (arg value >= 0 ifTrue: [' << '] ifFalse: [' >> ']);				nextPutAll: arg value abs printString.		] ifFalse: [			aStream nextPut: $0].	] ifFalse: [		"bit shift amount is an expression"		self error: 'SSHIFT not implemented'	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 02:25'!generateSignedIntToLong: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/29/2020 19:47'!generateStackValue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	Warning signal:'Here'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:02'!generateSuccess: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'if ('.	self generateNot: (TSendNode new			setSelector: #not receiver: msgNode args first arguments: #())		on: aStream indent: level.	aStream nextPutAll: ') throw Object.create(PrimitiveFailed).setPayload(1)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:17'!generateTimes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitJSExpression: msgNode args first on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/25/2023 21:24'!generateToByDo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	"N.B. MessageNode>>asTranslatorNodeIn: adds the limit var as a hidden fourth argument."	| blockExpr iterationVar limitExpr limitVar step negative initialValue testSelector limitInit |	blockExpr := msgNode args third.	blockExpr args size = 1 ifFalse:		[self error: 'wrong number of block arguments'].	iterationVar := blockExpr args first.	limitExpr := msgNode args first.	initialValue := self nilOrReducibleValueOf: msgNode receiver.	step := self nilOrReducibleValueOf: (msgNode args at: 2).	negative := step notNil and: [step < 0].	testSelector := negative ifTrue: [' >= '] ifFalse: [' <= '].	(msgNode args size = 4) ifTrue: [		limitVar := msgNode args last.		(limitExpr isSend		 and: [limitExpr selector = (negative ifTrue: [#+] ifFalse: [#-])		 and: [limitExpr args first isConstant		 and: [limitExpr args first value = 1]]])			ifTrue: [				testSelector := negative ifTrue: [' > '] ifFalse: [' < '].				limitExpr receiver isVariable ifTrue: [					limitExpr := limitExpr receiver				] ifFalse: [					limitInit := limitExpr receiver.					limitExpr := limitVar]			] ifFalse:				[limitInit := limitExpr.				 limitExpr := limitVar]].	limitInit notNil ifTrue: [		initialValue isNil ifTrue: [			aStream nextPutAll: iterationVar, ' = '.			msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.			aStream nextPut: $;; 				crtab: level].		aStream nextPutAll: 'const ', limitVar name, ' = '.		limitInit emitJSCodeAsExpressionOn: aStream level: 0 generator: self.		aStream nextPut: $;; 			crtab: level].	aStream nextPutAll: 'for ('.	(limitInit isNil or: [initialValue notNil]) ifTrue: [		aStream nextPutAll: iterationVar, ' = '.		msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.	].	aStream nextPutAll: '; ', iterationVar, testSelector.	self emitJSExpression: limitExpr on: aStream.	step = 1		ifTrue: [aStream nextPutAll: '; ', iterationVar, '++']		ifFalse: [step = -1					ifTrue: [aStream nextPutAll: '; ', iterationVar, '--']					ifFalse: [negative								ifTrue: [aStream nextPutAll: '; ', iterationVar, ' -= ', (0 - step)]								ifFalse: [aStream nextPutAll: '; ', iterationVar, ' += '.										(msgNode args at: 2) emitJSCodeAsExpressionOn: aStream level: 0 generator: self]]].	aStream nextPutAll: ') {'; cr.	blockExpr emitJSCodeOn: aStream level: level + 1 generator: self.	aStream tab: level.	aStream nextPut: $}! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/13/2023 22:47'!generateToDo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	]. self halt: 'We should not get here, everything should go via the ...ToByDo... method instead'.	iterationVar := msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:18'!initializeJSTranslationDictionary 	"Initialize the dictionary mapping message names to actions for JS code generation."	| pairs |	translationDict := Dictionary new: 200.	pairs := #(	#checkIsFloat:			#generateCheckIsFloat:on:indent:	#checkIsNotNumber:	#generateCheckIsNotNumber:on:indent:	#checkIsInteger:		#generateCheckIsInteger:on:indent:	#booleanValueOf:			#generateCheckedBoolean:on:indent:	#positive32BitValueOf:		#generateCheckedPositive32Bit:on:indent:	#floatValueOf:				#generateCheckedFloat:on:indent:	#integerValueOf:			#generateIntegerValueOf:on:indent:	#checkedNotNumber:		#generateCheckedNotNumber:on:indent:	#checkedInteger:			#generateCheckedInteger:on:indent:	#positive32BitIntegerFor:	#generatePositive32BitIntegerFor:on:indent:	#floatObjectOf:			#generateFloatObjectOf:on:indent:	#integerObjectOf:			#generateIntegerObjectOf:on:indent: 	#pushBool:				#generatePushBool:on:indent:	#pushFloat:				#generatePushFloat:on:indent:	#pushInteger:			#generatePushInteger:on:indent:	#isFloatObject:			#generateIsFloatObject:on:indent:	#isIntegerObject:		#generateIsIntegerObject:on:indent:	#isIntegerValue:		#generateIsIntegerObject:on:indent:	#fetchInteger:ofObject:		#generateFetchInstVarOfObject:on:indent:	#fetchLong32:ofObject:		#generateFetchLong32OfObject:on:indent:	#fetchFloat:ofObject:			#generateFetchInstVarOfObject:on:indent:	#fetchPointer:ofObject:			#generateFetchInstVarOfObject:on:indent:	#storeInteger:ofObject:withValue:		#generateStoreInstVarOfObject:on:indent:	#storePointer:ofObject:withValue:		#generateStoreInstVarOfObject:on:indent:	#cCoerce:to:				#generateCCoercion:on:indent:	#cCoerceSimple:to:			#generateCCoercion:on:indent:	#signedIntFromLong		#generateSignedIntFromLong:on:indent:	#signedIntToLong			#generateSignedIntToLong:on:indent:	#signedIntFromShort		#generateSignedIntFromShort:on:indent:	#signedIntToShort			#generateSignedIntToShort:on:indent:	#asFloat					#generateAsFloat:on:indent:	#asInteger					#generateAsInteger:on:indent:	#asUnsignedInteger			#generateAsUnsignedInteger:on:indent:	#checkIsBytes:			#generateCheckIsBytes:on:indent:	#checkIsWords:		#generateCheckIsWords:on:indent:	#checkIsShorts:		#generateCheckIsShorts:on:indent:	#checkIsSignedShorts:	#generateCheckIsSignedShorts:on:indent:	#checkIsSignedInts:	#generateCheckIsSignedInts:on:indent:	#isArray:				#generateIsArray:on:indent:	#isBytes:				#generateIsBytes:on:indent:	#isPointers:				#generateIsPointers:on:indent:	#isWords:				#generateIsWords:on:indent:	#isWordsOrBytes:		#generateIsWordsOrBytes:on:indent:	#preIncrement				#generatePreIncrement:on:indent:	#preDecrement				#generatePreDecrement:on:indent:	#raisedTo:					#generateRaisedTo:on:indent:	#anyMask:					#generateBitAnd:on:indent:	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#questionMark:colon:	#generateQuestionMarkColon:on:indent:	#mergeFn:with:			#generateMergeFnWith:on:indent:	#__pointersAt:			#generatePointersAt:on:indent:	#__pointersAt:put:		#generatePointersAtPut:on:indent:	#primitiveFail			#generatePrimitiveFail:on:indent:	#primitiveFailFor:		#generatePrimitiveFailFor:on:indent:	#success:				#generateSuccess:on:indent:	#failed					#generateFailed:on:indent:	#methodArgumentCount	#generateMethodArgumentCount:on:indent:	#stackValue:			#generateStackValue:on:indent:	#push:					#generatePush:on:indent:	#is:MemberOf: 			#generateIsMemberOf:on:indent:	#classArray					#generateClassArray:on:indent:	#classBitmap					#generateClassBitmap:on:indent:	#classByteArray				#generateClassByteArray:on:indent:	#classLargeNegativeInteger	#generateClassLargeNegativeInteger:on:indent:	#classLargePositiveInteger		#generateClassLargePositiveInteger:on:indent:	#classPoint						#generateClassPoint:on:indent:	#classString					#generateClassString:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#negated		#generateNegated:on:indent:	#abs			#generateMath:on:indent:	#sqrt			#generateMath:on:indent:	#sin			#generateMath:on:indent:	#cos			#generateMath:on:indent:	#tan			#generateMath:on:indent:	#atan			#generateMath:on:indent:	#exp			#generateMath:on:indent:	#log			#generateMath:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<			#generateShiftLeft:on:indent:	#>>			#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#between:and:	#generateBetweenAnd:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:		#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#signedBitShift:	#generateSignedBitShift:on:indent:	#bitInvert32		#generateBitInvert32:on:indent:	#bitClear:			#generateBitClear:on:indent:	#<				#generateLessThan:on:indent:	#<=			#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=			#generateGreaterThanOrEqual:on:indent:	#~=			#generateNotEqual:on:indent:	#==			#generateEqual:on:indent:	#~~			#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#whileTrue 		#generateDoWhileTrue:on:indent:	#whileFalse		#generateDoWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#repeat 		#generateRepeat:on:indent:	#ifTrue:			#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#stObject:		#generateAt:on:indent:	#stObject:put:	#generateAtPut:on:indent:	#cCode:					#generateInlineCCode:on:indent:	#cCode:inSmalltalk:			#generateInlineCCode:on:indent:	#addressOf:				#generateAddressOf:on:indent:	#cPreprocessorDirective:	#generateInlineCPreprocessorDirective:on:indent:	#preprocessorExpression:	#generateInlineCppDirective:on:indent:	#isDefined:inSmalltalk:comment:ifTrue:	#generateInlineCppIfDef:on:indent:	#isDefined:inSmalltalk:comment:ifTrue:ifFalse:	#generateInlineCppIfDefElse:on:indent:	#isDefinedTrueExpression:inSmalltalk:comment:ifTrue:ifFalse:	#generateInlineCppIfElse:on:indent:	#inline:						#generateInlineDirective:on:indent:	#asSymbol					#generateAsSymbol:on:indent:	#touch:						#generateTouch:on:indent:	#bytesPerWord		#generateBytesPerWord:on:indent:	#baseHeaderSize		#generateBaseHeaderSize:on:indent:	#sharedCodeNamed:inCase:		#generateSharedCodeDirective:on:indent:	#perform:							#generatePerform:on:indent:	#perform:with:						#generatePerform:on:indent:	#perform:with:with:					#generatePerform:on:indent:	#perform:with:with:with:				#generatePerform:on:indent:	#perform:with:with:with:with:		#generatePerform:on:indent:	#perform:with:with:with:with:with:	#generatePerform:on:indent:	#shouldNotImplement				#generateSmalltalkMetaError:on:indent:	#shouldBeImplemented				#generateSmalltalkMetaError:on:indent:	"optimized interpreterProxy calls"	#instantiateClass:indexableSize:	#generateInstantiateClassIndexableSize:on:indent:	#nilObject							#generateNilObject:on:indent:	#firstIndexableField:				#generateFirstIndexableField:on:indent:	#slotSizeOf:						#generateSlotSizeOf:on:indent:	#stSizeOf:							#generateSlotSizeOf:on:indent:	#byteSizeOfBytes:					#generateByteSizeOf:on:indent:	#byteSizeOf:						#generateByteSizeOf:on:indent:	#fetchClassOf:						#generateFetchClassOf:on:indent:	#superclassOf:						#generateSuperclassOf:on:indent:	#instanceSizeOf:					#generateInstanceSizeOf:on:indent:	#is:KindOf: 							#generateIsKindOf:on:indent:	#is:NotKindOf: 						#generateIsNotKindOf:on:indent:	#cDigitCopyFrom:to:len:				#generateCDigitCopy:on:indent:	#sizeOfSTArrayFromCPrimitive:		#generateSizeOfSTArrayFromCPrimitive:on:indent:	#asciiValue							#generateIdentityUnary:on:indent:	#intAtPointer:						#generateIntAtPointer:on:indent:	#byteAtPointer:						#generateByteAtPointer:on:indent:	#oopForPointer:					#generateOopForPointer:on:indent:	#long32At:							#generateLong32At:on:indent:	#srcLongAt:						#generateSrcLongAt:on:indent:	#dstLongAt:						#generateDstLongAt:on:indent:	#dstLongAt:put:					#generateDstLongAtPut:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].	pairs := #(	#ifTrue:				#generateIfTrueAsArgument:on:indent:		#ifFalse:			#generateIfFalseAsArgument:on:indent:	#ifTrue:ifFalse:		#generateIfTrueIfFalseAsArgument:on:indent:	#ifFalse:ifTrue:		#generateIfFalseIfTrueAsArgument:on:indent:	#cCode:			#generateInlineCCodeAsArgument:on:indent:	#cCode:inSmalltalk:	#generateInlineCCodeAsArgument:on:indent:	).	asArgumentTranslationDict := Dictionary new: 8.	1 to: pairs size by: 2 do: [:i |		asArgumentTranslationDict at: (pairs at: i) put: (pairs at: i + 1)].	cCodeTranslationDict := Dictionary new: 8.	pairs := #(		'fprintf(stderr, "\n%s: %s", moduleName, s)'					'console.log(moduleName + ": " + s)'		'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'	'interpreterProxy.majorVersion() == VM_PROXY_MAJOR'		'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'	'interpreterProxy.minorVersion() >= VM_PROXY_MINOR'		'rand()'														'Math.random()'		'*src++'													'src[_src++]' 			'*dst++ = max'												'dst[_dst++] = max'		'src++'		 												'_src++'		'*dst++ = *src; src += 2'									'dst[_dst++] = src[_src]; _src += 2'		'tX'															'tX'		'tY'															'tY'		'((sqInt (*)(sqInt, sqInt, sqInt))copyBitsFn)(x0, x1, yValue)'	'copyBitsFn(x0, x1, yValue)'		'((sqInt (*)(sqInt))loadBBFn)(bbObj)'							'loadBBFn(bbObj)'	).	1 to: pairs size by: 2 do: [:i |		cCodeTranslationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/18/2020 16:20'!pluginName	^'Interpreter'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/25/2023 13:17'!tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level	"Attempt to generate the code for an ifTrue:ifFalse: if both arms are found to be the same, in which case	 answer true.  Otherwise output nothing and answer false."	(msgNode args first isSameAs: msgNode args second) ifFalse:		[^false].	msgNode receiver hasSideEffect ifTrue:		[msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.		 aStream nextPut: $; ; crtab: level].	msgNode args first emitJSCodeOn: aStream level: level generator: self.	^true! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/29/2020 15:06'!generateByteAtPointer: msgNode on: aStream indent: level	msgNode args first asString = 'sourcePtr + charIndex - 1'		ifTrue: [^aStream nextPutAll: 'sourcePtr[charIndex - 1]'].	self halt: msgNode args first asString	! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 3/23/2021 18:15'!generateFetchClassOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeOn: aStream level: level generator: self.	aStream nextPutAll: '._class()'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 11/23/2020 01:00'!generateFetchInstVarOfObject: msgNode on: aStream indent: level	self emitJSExpression: msgNode args last on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $]! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 4/25/2021 18:41'!generateFetchLong32OfObject: msgNode on: aStream indent: level	self emitJSExpression: msgNode args last on: aStream.	aStream nextPutAll: '.words['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $]! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 1/7/2022 23:24'!generateFirstIndexableField: msgNode on: aStream indent: level	| parent cType accessor parts receiver |	self oneBasedArrays: false.	parts := msgNode asString substrings.	(parts first = 'interpreterProxy' and: [(parts at: 2) = 'firstIndexableField:']) ifFalse: [Warning signal: 'here'].	"HACK: detect cType from parent node"	parent := thisContext sender sender sender.	receiver := parent receiver.	cType := parent method == (TAssignmentNode>>#emitJSCodeOn:level:generator:) ifTrue: [		(self typeOfVariable: receiver variable name) ifNil: [receiver variable name = 'cmLookupTable' ifTrue: ['unsigned int*']]	] ifFalse: [		parent method == (TSendNode>>#emitJSCodeAsFunctionCallOn:level:generator:)			ifTrue: [self typeOfArgument: (receiver args indexOf: msgNode) in: receiver selector] ifFalse: [		parts last = 'mapOop' 			ifTrue: ['unsigned int*'] ifFalse: [		parts last = 'blockOop'			ifTrue: ['int*'] ifFalse: [		parts last = 'bitsOop'			ifTrue: ['int*'] ifFalse: [		parent method == (TReturnNode>>#emitJSCodeOn:level:generator:)			ifTrue: [currentMethod returnType] ifFalse: [		self halt]]]]]].	cType ifNil: [		cType := parts last = 'mapOop' 					ifTrue: ['unsigned int*'] ifFalse: [				parts last = 'blockOop'					ifTrue: ['int*'] ifFalse: [				parts last = 'bitsOop'					ifTrue: ['int*']]]		].	cType ifNotNil: [		cType := cType copyReplaceAll: ' *' with: '* '.		accessor := ((cType beginsWith: 'unsigned char*') or: [cType beginsWith: 'char*']) ifTrue: [aStream nextPutAll: 'BYTESOF('. msgNode args first emitJSCodeOn: aStream level: level generator: self. ^aStream nextPut: $)]			ifFalse: [(cType beginsWith: 'unsigned int*') ifTrue: ['.words']			ifFalse: [(cType beginsWith: 'int*') ifTrue: ['.wordsAsInt32Array()']			ifFalse: [(cType beginsWith: 'short*') ifTrue: ['.wordsAsInt16Array()']			ifFalse: [(cType beginsWith: 'float*') ifTrue: ['.wordsAsFloat32Array()']			ifFalse: [(cType beginsWith: 'double*') ifTrue: ['.wordsAsFloat64Array()']			ifFalse: [self halt: 'need to handle ', cType. nil]]]]]].		accessor ifNotNil: [msgNode args first emitJSCodeOn: aStream level: level generator: self.			^aStream nextPutAll: accessor]].	"generic code below, not needed ever hopefully"	Warning signal: 'here'.	^ msgNode emitJSCodeAsFunctionCallOn: aStream level: level generator: self! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 1/20/2022 20:39'!generateInstanceSizeOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeOn: aStream level: level generator: self.	aStream nextPutAll: '.prototype.instSize'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 11/12/2020 14:26'!generateIntAtPointer: msgNode on: aStream indent: level	msgNode args first asString = 'self cCoerce: argPtr + i to: ''char*'''		ifTrue: [^aStream nextPutAll: 'argPtr[i]'].	msgNode args first asString = 'self pointerForOop: oop'		ifTrue: [^aStream nextPutAll: 'sqMemoryBase[oop]'].	self halt	! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/29/2020 19:16'!generateLong32At: msgNode on: aStream indent: level	| expr index |	expr := msgNode args first.	(expr isSend and: [expr selector = #+]) ifFalse: [^expr isVariable ifTrue: [aStream nextPutAll: expr name; nextPutAll: '[0]'] ifFalse: [self halt: expr asString]].	expr receiver emitJSCodeOn: aStream level: level generator: self.	index := expr args first.	aStream nextPut: $[.	index isTimesFour		ifTrue: [index receiver emitJSCodeOn: aStream level: level generator: self]		ifFalse: [			index emitJSCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ' >>> 2'].	aStream nextPut: $].! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/29/2020 19:05'!generateOopForPointer: msgNode on: aStream indent: level	| arg |	arg := msgNode args first asString.	arg = 'interpreterProxy firstIndexableField: destBits'		ifTrue: [^aStream nextPutAll: 'destBits.wordsOrBytes()'].	arg = 'interpreterProxy firstIndexableField: sourceBits'		ifTrue: [^aStream nextPutAll: 'sourceBits.wordsOrBytes()'].	arg =  'interpreterProxy firstIndexableField: halftoneBits'		ifTrue: [^aStream nextPutAll: 'halftoneBits.wordsOrBytes()'].	arg =  'interpreterProxy firstIndexableField: sourceMapOop'		ifTrue: [^aStream nextPutAll: 'sourceMapOop.wordsOrBytes()'].	msgNode args first isVariable ifFalse: [self halt: arg].	aStream nextPutAll: arg! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 3/8/2021 23:15'!generateStoreInstVarOfObject: msgNode on: aStream indent: level	self emitJSExpression: (msgNode args at: 2) on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '] = '.	self emitJSExpression: msgNode args last on: aStream.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 5/19/2021 20:38'!generateSuperclassOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeOn: aStream level: level generator: self.	aStream nextPutAll: '.pointers[0]'.! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 1/7/2022 17:54'!computePossibleSideEffectsInto: writtenToVars visited: visitedSelectors in: aCodeGen	"Add all variables written to by this method and its callees to writtenToVars.	 Avoid circularity via visitedSelectors"	(visitedSelectors includes: selector) ifTrue:		[^self].	visitedSelectors add: selector.	writtenToGlobalVarsCache ifNotNil:		[writtenToVars addAll: writtenToGlobalVarsCache.		 ^self].	parseTree nodesDo:		[ :node |			(node isAssignment			 and: [(locals includes: node variable name) not])				ifTrue:					[writtenToVars add: node variable name].			(node isSend			 and: [node isBuiltinOperator not			 and: [(node isStructSendIn: aCodeGen) not]]) ifTrue:				[(aCodeGen methodNamed: node selector) ifNotNil:					[:method|					 method						computePossibleSideEffectsInto: writtenToVars						visited: visitedSelectors						in: aCodeGen]]].	writtenToGlobalVarsCache := writtenToVars copy! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 9/21/2020 20:32'!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree endsWithReturn! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 1/7/2022 17:54'!maySubstituteGlobal: globalVar in: aCodeGen	"We can substitute globalVar into this method provided globalVar is only read, not written."	writtenToGlobalVarsCache = nil ifTrue:		[self computePossibleSideEffectsInto: (Set new: 50) visited: (Set new: 50) in: aCodeGen].	^(writtenToGlobalVarsCache includes: globalVar) not! !!JSMethod methodsFor: 'utilities' stamp: 'fm 11/17/2020 14:57'!copy	"Make a deep copy of this JSMethod."	^ (self class basicNew)		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		primitive: primitive		parseTree: parseTree copyTree		labels: labels copy		complete: complete;		sharedLabel: sharedLabel;		sharedCase: sharedCase;		yourself! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 20:10'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList := OrderedCollection new: 100.	substitutionDict := Dictionary new: 100.	meth args with: argList do: [ :argName :exprNode | | val subst |			(self isSubstitutableNode: exprNode as: argName intoMethod: meth in: aCodeGen) ifTrue: [			exprNode isLeaf ifTrue: [				subst := exprNode			] ifFalse: [				val := aCodeGen nilOrReducibleValueOf: exprNode. 				val notNil ifTrue: [					subst := TConstantNode new setValue: val				]			].			subst isNil ifTrue: [				subst := exprNode			].			substitutionDict at: argName put: subst.			locals remove: argName.			declarations removeKey: argName ifAbsent: []		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 13:00'!cleanupUnusedTemps	| modified refs assigns toReplace |	locals isEmpty ifFalse: [		[modified := false.		refs := Dictionary new.		assigns := Dictionary new.		parseTree nodesWithParentsDo: [:node :parent |			node isStmtList ifTrue: [				(parent isNil or: 					[parent isSend and: 					[((#(whileTrue whileTrue: whileFalse whileFalse:) includes: parent selector) not or: [node ~~ parent receiver]) and:					[parent selector ~= #cCode:inSmalltalk: or: [node ~~ parent args last]]]]				) ifTrue: [					(node statements size = 1 and: [node statements first isConstantNull]) ifFalse: [						(node statements anySatisfy: [:stmt | stmt isLeaf and: [stmt isLabel not]]) ifTrue: [							node setStatements: (node statements reject: [:stmt | stmt isLeaf and: [stmt isLabel not]]).							modified := true						]					]				] ifFalse: [					(node statements anySatisfy: [:stmt | stmt isLeaf and: [stmt ~~ node statements last and: [stmt isLabel not]]]) ifTrue: [						node setStatements: (node statements reject: [:stmt | stmt isLeaf and: [stmt ~~ node statements last and: [stmt isLabel not]]]).						modified := true					]				]			] ifFalse: [				node isVariable ifTrue: [					(locals includes: node name) ifTrue: [refs at: node name put: (refs at: node name ifAbsentPut: [0]) + 1]				] ifFalse: [					node isAssignment ifTrue: [						(locals includes: node variable name) ifTrue: [(assigns at: node variable name ifAbsentPut: [OrderedCollection new]) add: node]					]				]			]		].		toReplace := Dictionary new.		refs keysAndValuesDo: [:local :count| 			count = (assigns at: local ifAbsent: [#()]) size ifTrue: [				local = 'mergeFnwith' ifFalse: [					(assigns at: local ifAbsent: [#()]) do: [:a |						toReplace at: a put: a expression					].				locals remove: local				]			]		].		toReplace isEmpty ifFalse: [			parseTree replaceNodesIn: toReplace.			modified := true		].		modified] whileTrue	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:16'!comment	^comment! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:17'!elideAnyFinalReturn	"For super expansions we need to eliminate any final return to prevent premature exit.	 Anything meaningful in the returned expression must be retained."	| stmtList expr |	stmtList := parseTree statements asOrderedCollection.	(stmtList notEmpty and: [stmtList last isReturn]) ifTrue:		[expr := stmtList last expression.		 (expr isVariable and: [expr name = 'self'])			ifTrue: [stmtList := stmtList allButLast]			ifFalse: [stmtList at: stmtList size put: expr].		parseTree setStatements: stmtList]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 7/11/2023 23:43'!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed  endsWithReturnOrIf returns extraneous |	labelUsed := false.	(endsWithReturnOrIf := parseTree endsWithReturnOrIf) ifTrue: [		returns := IdentitySet new.		extraneous := IdentitySet new.		parseTree addFinalIfReturnsTo: returns extraneous: extraneous.		].	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [ :stmt | | parents canUseBreak loop |				stmt isReturn ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TAssignmentNode new								setVariable: (TVariableNode new setName: exitVar)								expression: stmt expression).					].					(endsWithReturnOrIf and: [(returns includes: stmt) or: [extraneous includes: stmt]]) ifFalse: [						parents := OrderedCollection with: node.						parseTree nodesWithParentsDo: [:n :parent | 							n == parents last ifTrue: [parents addLast: parent]].						parents removeLast.						canUseBreak := false.						((parents allSatisfy: [:parent |							parent isStmtList or: [parent isSend and: [#(to:by:do: whileTrue: whileFalse: repeat ifTrue:ifFalse: ifTrue: ifFalse:]) includes: parent selector]]])						and: [(parents select: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: repeat) includes: parent selector]]) size = 1])							ifTrue: [								canUseBreak := true.								loop := parents detect: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: repeat) includes: parent selector]].								(parents indexOf: loop) to: parents size - 1 by: 2 do: [:i | | p pParent |									p := parents at: i.									pParent := parents at: i + 1.									p == pParent lastRealStatement ifFalse: [canUseBreak := false].									]].						canUseBreak ifTrue: [							newStmts add: TBreakNode new.						] ifFalse: [							"generate a goto (this return is NOT the last statement in the method)"							newStmts add: (TGoToNode new setLabel: exitLabel).							labelUsed := true.						].					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:17'!extraVariableNumber	^extraVariableNumber! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:15'!hasProperties	^properties notNil and: [properties notEmpty]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 12/27/2020 12:20'!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp := 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt := stmtNode statements first.				stmt isSend ifTrue: [					sel := stmt selector.					meth := aCodeGen methodNamed: sel.					"Note, original version of this method tested for #hasNoCCode. Removed					the test to permit inlining methods that may contain automatically					generated C code for type conversions. -dtl"					((meth ~= nil) and:					 [meth args size = 0]) ifTrue: [						meth := meth copy.						meth hasReturn ifTrue: [							exitLabel := self unusedLabelForInliningInto: self. Warning signal: 'goto'.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel := nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements := stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addFirst: meth asInlineNode.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars := (locals, args) asSet.	1 to: maxTemp do: [ :i |		v := ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 19:57'!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel := aSendNode selector.	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict := Dictionary new: 100. 	meth args with: aSendNode args do: [ :argName :exprNode | | val subst |			exprNode isLeaf ifTrue: [			subst := exprNode		] ifFalse: [			val := aCodeGen nilOrReducibleValueOf: exprNode. 			val notNil ifTrue: [				subst := TConstantNode new setValue: val			]		].		subst isNil ifTrue: [			subst := exprNode		].		substitutionDict at: argName put: subst.		locals remove: argName.		declarations removeKey: argName ifAbsent: []	].	meth parseTree bindVariablesIn: substitutionDict.	^ meth statements first expression! !!JSMethod methodsFor: 'inlining' stamp: 'fm 12/27/2020 15:50'!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel := aSendNode selector.	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType := meth returnType.		] ifFalse: [			exitLabel := self unusedLabelForInliningInto: self.			labelUsed := meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ Transcript cr; show: sel. "labels add: exitLabel" ^nil ]				ifFalse: [ exitLabel := nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'sqInt']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts := OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add: (TLabeledCommentNode new setLabel: exitLabel comment: 'end ', sel).	] ifFalse: [		inlineStmts add: (TLabeledCommentNode new setComment: 'end ', sel)].	^inlineStmts! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 19:49'!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args with: m args do: [ :a :argName | (self isSubstitutableNode: a as: argName intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 21:03'!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	(aNode receiver isVariable	 and: [(aNode isSelfReference: aNode receiver in: aCodeGen)		or: [aCodeGen isNonArgumentImplicitReceiverVariableName: aNode receiver name]]) ifTrue: [			m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"].		^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 20:05'!isSubstitutableNode: aNode as: argName intoMethod: targetMeth in: aCodeGen	| var atMostOne first |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var := aNode name.		((locals includes: var) or: [(#(self 'true' 'false' 'nil') includes: var) or: [args includes: var]]) ifTrue: [ ^true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^true ].	].	(aCodeGen nilOrReducibleValueOf: aNode) notNil ifTrue: [ ^true ].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			(node isBuiltinOperator or: [(aCodeGen nilOrReducibleValueOf: node) notNil]) ifFalse: [ ^false ].		] ifFalse: [			node isVariable ifTrue: [				var := node name.				((locals includes: var) or: [(args includes: var) or: [(#(self 'true' 'false' 'nil') includes: var) or:				 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^false ].			] ifFalse: [				node isConstant ifFalse: [ ^false ].			].		]	].	atMostOne := true.	first := nil.	targetMeth parseTree nodesDo: [:node |		(node isVariable and: [node name = argName]) ifTrue: [			first isNil ifTrue: [first := node] ifFalse: [atMostOne := false]		]	].	^ atMostOne! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:14'!mergePropertiesOfSuperMethod: superTMethod	superTMethod hasProperties ifFalse:		[^self].	self hasProperties ifFalse:		[properties := superTMethod properties.		 ^self].	superTMethod properties pragmas do:		[:aPragma|		(self shouldIncorporatePragmaFromSuperMethod: aPragma) ifTrue:			[properties := properties copyWith: aPragma]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:15'!properties	^properties! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/7/2022 17:57'!removeUnreferencedDeclarations	"Variables may have been eliminated during inlining. Remove declarations for those variables."	declarations keys copy		do: [:key | (args , locals includes: key)				ifFalse: [declarations removeKey: key]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/7/2022 23:06'!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists := OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue:			[node selector = #cCode:inSmalltalk: ifTrue:				[node nodesDo:					[:ccisNode| stmtLists remove: ccisNode ifAbsent: []]].			((node selector = #and:) or: [node selector = #or:]) ifTrue:				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				[stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: []].			(#(	#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:				#ifNil: #ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil: ) includes: node selector) ifTrue:				[stmtLists remove: node receiver ifAbsent: []].			(#(whileTrue whileTrue: whileFalse whileFalse:) includes: node selector) ifTrue:				"Allow inlining if it is a [...] whileTrue/whileFalse.				This is identified by having more than one statement in the 				receiver block in which case the C code wouldn't work anyways"				[node receiver statements size = 1 ifTrue:					[stmtLists remove: node receiver ifAbsent: []]].			(node selector = #to:do:) ifTrue:				[stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: []].			(node selector = #to:by:do:) ifTrue:				[stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args second ifAbsent: []]].		(node isCaseStmt or: [node isSwitch]) ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:13'!superExpansionNodeFor: aSelector args: argumentNodes	"Answer the expansion of a super send.  Merge the super expansion's	 locals, properties and comment into this method's properties."	(definingClass superclass lookupSelector: aSelector)		ifNil: [self error: 'superclass does not define super method']		ifNotNil:			[:superMethod| | superTMethod commonVars varMap |			superTMethod := superMethod methodNode asTranslationMethodOfClass: self class.			((argumentNodes allSatisfy: [:parseNode| parseNode isVariableNode])			and: [(argumentNodes asOrderedCollection collect: [:parseNode| parseNode key]) = superTMethod args]) ifFalse:				[self error: definingClass name, '>>',selector, ' args ~= ',							superTMethod definingClass name, '>>', aSelector,							(String with: $. with: Character cr),							'For super expansions to be translated correctly each argument must be a variable with the same name as the corresponding argument in the super method.'].			self mergePropertiesOfSuperMethod: superTMethod.			(commonVars := superTMethod locals intersection: self locals) notEmpty ifTrue:				[varMap := Dictionary new.				 commonVars do:					[:k| varMap at: k put: (superTMethod unusedNamePrefixedBy: k avoiding: self allLocals)].				 superTMethod renameVariablesUsing: varMap].			self assert: (superTMethod locals allSatisfy: [:var| (self locals includes: var) not]).			locals addAll: superTMethod locals.			superTMethod declarations keysAndValuesDo:				[:var :decl|				self declarationAt: var put: decl].			superTMethod comment ifNotNil:				[:superComment|				comment := comment								ifNil: [superComment]								ifNotNil: [superComment, comment]].			superTMethod extraVariableNumber ifNotNil:				[:scvn|				extraVariableNumber := extraVariableNumber ifNil: [scvn] ifNotNil: [:cvn| cvn + scvn]].			superTMethod elideAnyFinalReturn.			^superTMethod parseTree]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/8/2022 20:31'!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements sendsToInline |	didSomething := false.	sendsToInline := Dictionary new: 100. 	parseTree		nodesDo:			[:node|			(self inlineableFunctionCall: node in: aCodeGen) ifTrue:				[sendsToInline at: node put: (self inlineFunctionCall: node in: aCodeGen)]].	sendsToInline isEmpty ifFalse:		[didSomething := true.		self removeUnreferencedDeclarations.		parseTree := parseTree replaceNodesIn: sendsToInline].	didSomething ifTrue:		[writtenToGlobalVarsCache := nil.		self cleanupUnusedTemps.		^didSomething].	stmtLists := self statementsListsForInlining.	stmtLists do:		[:stmtList|		newStatements := OrderedCollection new: 100.		stmtList statements do:			[:stmt|			(self inlineCodeOrNilForStatement: stmt in: aCodeGen)				ifNil: [newStatements addLast: stmt]				ifNotNil: [:inlinedStmts|					didSomething := true.					newStatements addAllLast: inlinedStmts]].		stmtList setStatements: newStatements asArray].	didSomething ifTrue:		[writtenToGlobalVarsCache := nil.		self cleanupUnusedTemps.		^didSomething].	complete ifFalse:		[self checkForCompleteness: stmtLists in: aCodeGen.		 complete ifTrue: [ didSomething := true ]].  "marking a method complete is progress"	^didSomething! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/22/2021 00:14'!argConversionExprFor: varName stackIndex: stackIndex 	"Return the parse tree for an expression that fetches and converts the 	primitive argument at the given stack offset."	| exprList decl stmtList |	exprList := OrderedCollection new.	oneBasedArrays ifNil: [oneBasedArrays := Set new]. "only non-nil in a primitive method"	(declarations includesKey: varName) ifTrue: [		decl := declarations at: varName.		(decl includes: $*) ifTrue: ["array" 			(locals includes: varName, 'Oop') ifTrue: [self halt].			args at: args size - stackIndex put: varName, 'Oop'.			locals add: varName.			(decl includesSubString: 'char') ifTrue:[				exprList add: varName , ' := ', 'nil checkIsBytes: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'unsigned int') ifTrue:[				exprList add: varName , ' := nil checkIsWords: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'unsigned short') ifTrue:[				exprList add: varName , ' := nil checkIsShorts: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'short int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedShorts: ', varName, 'Oop'] ifFalse: [			(decl beginsWith: 'int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedInts: ', varName, 'Oop'] ifFalse: [			self halt]]]]].			self beOneBasedArray: varName.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add: 'nil checkIsFloat: ', varName.		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add: 'nil checkIsInteger: ', varName.	].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/6/2021 19:23'!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr := 'rcvr := this'.	^ self statementsFor: expr varName: ''! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 12/26/2020 19:30'!fixUpReturns: argCount postlog: postlog	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	| newStmts |	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [:stmt |				stmt isReturn					ifTrue: [						(stmt expression isSend and:						 ['primitiveFail' = stmt expression selector])							ifTrue: [  "failure return"								newStmts addLast: stmt expression]							ifFalse: [  "normal return"								newStmts addAll: postlog.								newStmts addLast: (TSendNode new									setSelector: #push:									receiver: (TVariableNode new setName: self vmNameString)									arguments: {stmt expression}).								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]]					ifFalse: [						newStmts addLast: stmt]].			node setStatements: newStmts asArray]].! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/22/2021 00:07'!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| exprList decl stmtList |	exprList := OrderedCollection with: varName, ' := this __pointersAt: ', instIndex.	oneBasedArrays ifNil: [oneBasedArrays := Set new]. "only non-nil in a primitive method"	(declarations includesKey: varName) ifTrue: [		decl := declarations at: varName.		(decl includes: $*) ifTrue: ["array"			exprList removeLast.			(decl includesSubString: 'char') ifTrue: [				exprList add: varName , ' := nil checkIsBytes: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'unsigned int') ifTrue:[				exprList add: varName , ' := nil checkIsWords: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'unsigned short') ifTrue:[				exprList add: varName , ' := nil checkIsShorts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'short int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedShorts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl beginsWith: 'int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedInts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			self halt]]]]].			self beOneBasedArray: varName.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add: 'nil checkIsFloat: ', varName.		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add: 'nil checkIsInteger: ', varName.	].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 1/14/2022 18:17'!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr := 'this __pointersAt: ', instIndex, ' put: ', varName.	^ self statementsFor: expr varName: varName! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 11/13/2020 02:06'!preparePrimitiveName	"Prepare the selector for this method in translation"	| aClass |	aClass := definingClass.	primitive = 117 		ifTrue:[selector := ((aClass includesSelector: selector)					ifTrue: [aClass compiledMethodAt: selector]					ifFalse: [aClass class compiledMethodAt: selector]) literals first at: 2.				export := true]		ifFalse:[selector := 'prim', aClass name, selector].! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/21/2021 16:49'!preparePrimitivePrologue	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn aClass |	aClass := definingClass.	prolog := OrderedCollection new.	postlog := OrderedCollection new.	instVarsUsed := self freeVariableReferences asSet.	varsAssignedTo := self variablesAssignedTo asSet.	instVarList := aClass allInstVarNames.	primArgCount := args size.	1 to: args size do: [:argIndex |		varName := args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName := instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	((locals includes: 'this') or: [(locals intersection: args) notEmpty]) ifTrue:		[self error: 'local name conflicts with instance variable name'].	endsWithReturn := self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [parseTree setStatements: prolog, parseTree statements, postlog].! !!JSMethod methodsFor: 'transformations' stamp: 'fm 9/18/2020 16:11'!buildSwitchStmt: aSendNode parent: parentNode	"Build a switch statement node for the given send of caseOf: or caseOf:otherwise:."	| switch |	switch := TSwitchStmtNode new				expression: aSendNode receiver				cases: aSendNode args first				otherwiseOrNil: (aSendNode args at: 2 ifAbsent: [nil]).	(aSendNode receiver isVariable or: [parentNode isStmtList]) ifFalse:		[switch switchVariable: (locals add: (self extraVariableName: 'switch'))].	^switch! !!JSMethod methodsFor: 'transformations' stamp: 'fm 7/11/2023 22:40'!prepareMethodIn: aCodeGen	"Record sends of builtin operators, map sends of the special selector dispatchOn:in:	 with case statement nodes, and map sends of caseOf:[otherwise:] to switch statements.	 As a hack also update the types of variables introduced to implement cascades correctly.	 This has to be done at the same time as this is done, so why not piggy back here?"	extraVariableNumber ifNotNil:		[declarations keysAndValuesDo:			[:varName :decl|			decl isBlock ifTrue:				[self assert: ((varName beginsWith: 'cascade') and: [varName last isDigit]).				 locals add: varName.				 self declarationAt: varName					put: (decl value: self value: aCodeGen), ' ', varName]]].	aCodeGen		pushScope: declarations		while:"N.B.  nodesWithParentsDo: is bottom-up, hence replacement is destructive and conserved."			[parseTree nodesWithParentsDo:				[:node :parent|				 node isSend ifTrue:					[(aCodeGen isBuiltinSelector: node selector)						ifTrue:							[node isBuiltinOperator: true]						ifFalse:							[(CaseStatements includes: node selector) ifTrue:								[parent replaceNodesIn: (Dictionary newFromPairs: { node. self buildCaseStmt: node})].							 (#(caseOf: #caseOf:otherwise:) includes: node selector) ifTrue:								[parent replaceNodesIn: (Dictionary newFromPairs: { node. self buildSwitchStmt: node parent: parent })]]]]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/12/2021 15:18'!checkSendNode: node for: arg	^TSendNode new		setSelector: (node selector caseOf: {											[#stackFloatValue:]->[#checkIsFloat:]. 											[#stackIntegerValue:]->[#checkIsInteger:]. 											[#stackObjectValue:]->[#checkIsNotNumber:]}) 		receiver:  (TVariableNode new setName: 'nil')		arguments: {arg}! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 1/12/2022 22:18'!checkedSendNodeExpr: node for: arg	^TSendNode new		setSelector: (node selector caseOf: {											[#stackFloatValue:]->[#floatValueOf:]. 											[#stackIntegerValue:]->[#checkedInteger:]. 											[#stackObjectValue:]->[#checkedNotNumber:]}) 		receiver:  (TVariableNode new setName: 'nil')		arguments: {arg}! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 7/25/2023 18:48'!definedAsMacro	^properties notNil	  and: [(properties includesKey: #cmacro:)		or: [properties includesKey: #cmacro]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 5/21/2021 20:04'!emitJSCodeOn: aStream generator: aCodeGen	"Emit JS code for this method onto the given stream. All calls to inlined methods should already have been expanded."	aCodeGen currentMethod: self.	args isEmpty ifTrue: [		self replaceStackUsageFor: aCodeGen	].	aCodeGen pushScope: declarations while: [		self emitJSCommentOn: aStream.	"place method comment before function"		self emitJSHeaderOn: aStream generator: aCodeGen.		(self emitJSSpecialOn:  aStream level: 1 generator: aCodeGen)			ifFalse: [parseTree emitJSCodeOn: aStream level: 1 generator: aCodeGen].		aStream nextPutAll: '}'; cr]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 12/11/2020 00:15'!emitJSFunctionHeader: aStream generator: aCodeGen newlineBeforeName: newlineBeforeName "<Boolean>"	"Emit a JS function header for this method onto the given stream."	(returnType last = $)	and: [returnType includesSubString: (aCodeGen jsFunctionNameFor: self selectorForCodeGeneration)]) ifTrue:		["Hack fix for e.g. <returnTypeC: 'void (*setInterruptCheckChain(void (*aFunction)(void)))()'>"		aStream nextPutAll: 'function'.		newlineBeforeName ifTrue: [aStream cr] ifFalse: [aStream space].		 ^self].	aStream		nextPutAll: (aCodeGen jsFunctionNameFor: self selectorForCodeGeneration);		nextPut: $(.	args		do: [:arg | aStream nextPutAll: (aCodeGen returnPrefixFromVariable: arg)]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $)! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/21/2021 16:36'!emitJSHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr. 	self emitJSFunctionHeader: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	self emitGlobalStructReferenceOn: aStream.	locals do: [ :var | | varDecl |		aStream nextPutAll: '	let ', (aCodeGen returnPrefixFromVariable: var).		varDecl := declarations at: var asString ifAbsent: [''].		(varDecl includes: $=)			ifTrue: [ | const |				const := ((varDecl copyAfter: $=) replaceAll: ${ with: $[) replaceAll: $} with: $].				aStream nextPutAll: ' =', const]			ifFalse: [(varDecl includes: $[)					ifTrue: [ | size |						size := (varDecl copyAfter: $[) copyUpTo: $].						size ifEmpty: [self halt].						aStream nextPutAll: ' = new Array(', size, ')']].		aStream nextPutAll: ';'; cr	].	(#(primitiveExtractChannel primitiveCondenseSound) includes: selector)		ifTrue: [#(src dst) do: [:v | aStream nextPutAll: '	var _', v, ' = 0;'; cr]].	locals isEmpty ifFalse: [ aStream cr ].! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/12/2021 18:16'!is: node argumentCountUsing: argCountVarName	^(node isVariable and: [node name = argCountVarName]) or:		[node isSend and: [#methodArgumentCount = node selector]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 1/12/2022 17:33'!replaceStackUsageFor: aCodeGen	| argsDict argCount argCountVar receiver toReplace toInsertBefore toRemove isPrimitive trueArgCount recName receiverHackNeeded |	isPrimitive := primitive > 0 or: [export and: [selector beginsWith: 'prim']].	receiverHackNeeded := #(KedamaPlugin KedamaPlugin2) includes: aCodeGen pluginName.	argCount := -1.	argsDict := Dictionary new.	toRemove := Set new.	toReplace := Dictionary new.	toInsertBefore := Dictionary new.	parseTree nodesWithParentsDo: [:node :parent | | const isReceiver checkNode newStmts argName arg constVal varName receiverIndex firstArg rec sel |		node isSend ifTrue: [			(#(stackValue: stackFloatValue: stackIntegerValue: stackObjectValue:) includes: (sel := node selector)) ifTrue: [				isReceiver := false.				(const := node args first) isConstant ifTrue: [					argCount < const value ifTrue: [argCount := const value]										] ifFalse: [					(self is: const argumentCountUsing: argCountVar) ifTrue: [						isReceiver := true.					] ifFalse: [self halt]				].				constVal := const value.				parent isAssignment ifTrue: [					(locals includes: (varName := parent variable name)) ifTrue: [						arg := parent variable.						(argsDict keyAtValue: varName ifAbsent: [constVal]) = constVal							ifFalse: [self halt].						(argsDict at: constVal ifAbsentPut: [varName]) = varName							ifFalse: ["It can happen because of inlining, it is an alias for the same stack slot"								toReplace at: node put: (TVariableNode new setName: (argsDict at: constVal))							].						(isReceiver or: [isReceiver := ((#(#rcvr #rcvrOop ) includes: varName) and: [receiverHackNeeded not]) or: [trueArgCount = constVal]]) ifTrue: [							(receiver notNil and: [receiver ~= varName])								ifTrue: [self halt].							receiver := varName.							(trueArgCount notNil and: [trueArgCount ~= constVal])								ifTrue: [self halt].							constVal isNumber ifTrue: [								trueArgCount := constVal.							]						]					] ifFalse: [						isReceiver ifTrue: [							receiver := argName := 'this'.						] ifFalse: [							argName := self unusedNamePrefixedBy: 'arg' avoiding: locals, argsDict values.							argsDict at: constVal put: argName.						].						arg := TVariableNode new setName: argName.					].					#stackValue: == sel ifTrue: [						argName isNil ifTrue: [toRemove add: parent] ifFalse: [toReplace at: node put: arg]					] ifFalse: [						toReplace at: (argName isNil ifTrue: [parent] ifFalse: [node]) put: (self checkedSendNodeExpr: node for: arg)					].				] ifFalse: [					toReplace at: node put: ((isReceiver or: [trueArgCount = constVal]) ifTrue: [												TVariableNode new setName: 'this'											] ifFalse: [constVal]).					#stackValue: == sel ifFalse: [						checkNode := self checkSendNode: node for: node.						parent isStmtList ifTrue: [							newStmts := parent statements asOrderedCollection.							newStmts add: checkNode before: node.							parent setStatements: newStmts						] ifFalse: [							toInsertBefore at: parent put: checkNode						]					]				]			] ifFalse: [				#methodArgumentCount = sel ifTrue: [					parent isAssignment ifTrue: [						toRemove add: parent.						argCountVar := parent variable name.						locals remove: argCountVar.					]				] ifFalse: [					rec := node receiver.					((#(= == ~= ~~) includes: sel) and: [(const := (firstArg := node args first)) isConstant or: [(const := rec) isConstant]]) ifTrue: [						((self is: firstArg argumentCountUsing: argCountVar) or:						[self is: rec argumentCountUsing: argCountVar]) ifTrue: [							constVal := const value.							argCount < constVal ifTrue: [argCount := constVal].													trueArgCount isNil ifTrue: [trueArgCount := constVal] ifFalse: [self halt].						]					] ifFalse: [						(#(pop: pop:thenPush:) includes: sel) ifTrue: [							(const := node args first) isConstant ifTrue: [								constVal := const value.								argCount + 1 < constVal ifTrue: [									argCount := constVal - 1.									receiver notNil ifTrue: [										receiverIndex := argsDict keyAtValue: receiver ifAbsent: [argCount].										(receiverIndex isInteger and: [receiverIndex < argCount]) ifTrue: [											"Not a true receiver"											receiver := nil].									].								]													].							#pop:thenPush: == sel ifTrue: [								toReplace at: node put: (TSendNode new															setSelector: #push: 															receiver: rec															arguments: (node args last: 1)).							] ifFalse: [								parent isStmtList ifTrue: [									parent setStatements: (parent statements copyWithout: node)								] ifFalse: [									parent isReturn ifTrue: [										toReplace at: node put: (TVariableNode new setName: 'null').									] ifFalse: [self halt].								]							]						].					].				].			].		] ifFalse: [			(node isVariable and: [node name = receiver and: [receiver ~= 'this']]) ifTrue: [				receiver = 'this' ifTrue: [self halt].				toReplace at: node put: (TVariableNode new setName: 'this')			]		].		parent notNil ifTrue: [			parent isStmtList ifTrue: [				(toRemove includes: node) ifTrue: [					parent setStatements: (parent statements copyWithout: node).					toRemove remove: node				] ifFalse: [					(toInsertBefore includesKey: node) ifTrue: [						newStmts := parent statements asOrderedCollection.						newStmts add: (toInsertBefore removeKey: node) before: node.						parent setStatements: newStmts]				]			] ifFalse: [				(toRemove includes: node) ifTrue: [					toReplace at: node put: node variable.					toRemove remove: node				] ifFalse: [					(toInsertBefore includesKey: node) ifTrue: [						toInsertBefore at: parent put: (toInsertBefore removeKey: node)]				]			]		]	].	(toRemove isEmpty and: [toInsertBefore isEmpty]) ifFalse: [self halt].	trueArgCount notNil ifTrue: [		trueArgCount < argCount  ifTrue: [self halt].		(argsDict includesKey: trueArgCount) ifTrue: [			recName := argsDict at: trueArgCount.			toReplace values do: [:n | 				n isInteger ifFalse: [					(n isVariable and: [n name = recName]) ifTrue: [						n setName: 'this'					] ifFalse: [						(n isSend and: [n args first name = recName]) ifTrue: [							n args first setName: 'this'						]					]				]			]		].	].	(receiver isNil and: [trueArgCount isNil and: [argsDict includesKey: argCount]]) ifTrue: [		argCount := argCount + 1].	argCount - 1 to: 0 by: -1 do: [:i | 		locals remove: (args add: (argsDict at: i ifAbsent: ['_arg', (argCount - i)])) ifAbsent: []].	receiver notNil ifTrue: [		locals remove: receiver].	toReplace associationsDo: [:a | 		a value isInteger ifTrue: [			a value: (TVariableNode new setName: (argsDict at: a value ifAbsent: ['_arg', (argCount - a value)]))		]].	toReplace isEmpty ifFalse: [		parseTree replaceNodesIn: toReplace.	].	isPrimitive ifTrue: [ 		parseTree hasFinalReturn ifFalse: [			parseTree statements add: (TSendNode new											setSelector: #push: 											receiver: (TVariableNode new setName: 'interpreterProxy')											arguments: {TVariableNode new setName: 'this'})					]	]! !!JSMethod methodsFor: 'initialization' stamp: 'fm 4/24/2021 23:10'!setSelector: sel definingClass: class args: argList locals: localList block: aBlockNode primitive: aNumber properties: methodProperties comment: aComment	"Initialize this method using the given information."	selector := sel.selector = #primitivePixelValueAtX:y: ifTrue: [Warning signal: 'here'].	definingClass := class.	returnType := #sqInt. 	 "assume return type is long for now"	args := argList asOrderedCollection collect: [:arg | arg key].	locals := (localList asSortedCollection: [:a :b| a key < b key]) collect: [:arg | arg key].	declarations := Dictionary new.	"self addTypeForSelf." "<- Cog feature to be added later"	primitive := aNumber.	properties := methodProperties.	comment := aComment.	parseTree := aBlockNode asTranslatorNodeIn: self.	labels := OrderedCollection new.	complete := false.  "set to true when all possible inlining has been done"	export := self extractExportDirective.	static := self extractStaticDirective.	canAsmLabel := self extractLabelDirective.	self extractSharedCase.	self removeFinalSelfReturn.	"must preceed recordDeclarations because this may set returnType"	self recordDeclarations.	globalStructureBuildMethodHasFoo := 0! !!JSMethod methodsFor: 'private' stamp: 'fm 3/6/2021 19:25'!printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| stackPointer successFlag ' , varName , ' |';	 cr! !!JSPluginCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 7/14/2023 15:05'!emitJSHeaderOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: (VMMaker headerNotice copyReplaceAll: ' C ' with: ' JavaScript ').	aStream nextPutAll: ' */';cr.	aStream nextPutAll: (self fileHeaderVersionStampForSourceClass: vmClass).	self emitInterpreterProxyVersionOn: aStream.	self emitJSFunctionsOn: aStream.! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 5/11/2021 18:39'!emitJSCodeOn: aStream doAssertions: assertionFlag"FM - moved down from JSCodeGenerator"	self emitJSHeaderOn: aStream.	self emitJSConstantsOn: aStream.	self emitJSVariablesOn: aStream.	aStream cr; cr; nextPutAll: 'globalThis.';		nextPutAll: pluginName;		nextPutAll: ' = {'.	preparedMethodList doWithIndex: [ :m :i | 		aStream nextPutAll: (String streamContents: [:s | m emitJSCodeOn: s generator: self. s nextPutAll: ', '])].	aStream cr; nextPut: $}.! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 7/13/2023 02:41'!generateCodeStringForPrimitives"TPR - moved down from JSCodeGenerator"	| s methodList |	self removeVariable: 'interpreterProxy'; removeVariable: 'moduleName'.	self pruneMethods: self ignoredMethods.	s := ReadWriteStream on: (String new: 1000).	methodList := methods asSortedCollection: [:m1 :m2 | m1 selector < m2 selector].	self emitJSHeaderOn: s.	self emitJSConstantsOn: s.	self emitJSVariablesOn: s.	s cr; cr; nextPutAll: 'globalThis.';		nextPutAll: pluginName;		nextPutAll: ' = {'.	methodList do: [:m | m emitJSCodeOn: s generator: self. s nextPutAll: ', '].	s cr; nextPut: $}.	^ s contents! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 12/12/2020 22:58'!ignoredMethods	pluginName = 'BitBltPlugin' ifTrue: [		^#(dstLongAt: dstLongAt:put: srcLongAt: halt msg: getModuleName setInterpreter:)].	pluginName = 'ScratchPlugin' ifTrue: [			^super ignoredMethods, (ScratchPlugin organization listAtCategoryNamed: 'serial port'), 				(ScratchPlugin organization listAtCategoryNamed: 'os functions')].	pluginName = 'B2DPlugin' ifTrue: [		^super ignoredMethods, (self translatedMethodsB2DPlugin collect: [:ea | ea key])].	^super ignoredMethods! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/13/2023 02:23'!generateAsBooleanObj: aNode on: aStream indent: anInteger	aStream nextPutAll: '!!!!('.	self emitJSExpression: aNode receiver on: aStream.	aStream nextPut: $)	! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 12/26/2021 09:25'!generateAsPositiveIntegerObj: aNode on: aStream indent: anInteger	self emitJSExpression: aNode receiver on: aStream.	aStream nextPutAll: ' >= 0 ? '.	self emitJSExpression: aNode receiver on: aStream.	aStream nextPutAll: ' : 4294967296 + '.	self emitJSExpression: aNode receiver on: aStream.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 3/23/2021 18:11'!generateDebugCode: aNode on: aStream indent: level 	"Generate the C debug code for this message onto the given stream, if  	compiled in debugMode."	self generateDebugCode		ifTrue: 			[aStream nextPutAll: '// DebugCode...';			 cr.			aNode args first				emitJSCodeOn: aStream				level: level				generator: self.			aStream tab: level.			aStream nextPutAll: '// ...DebugCode']		ifFalse: []! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:47'!generateIsBytes: aNode on: aStream indent: anInteger	super generateIsBytes: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsIntegerValue: aNode on: aStream indent: anInteger	super generateIsIntegerValue: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 1/14/2022 20:14'!generateIsKindOf: aNode on: aStream indent: anInteger	| className varName | 	className := aNode args second value.	aNode args first isVariable ifFalse: [self halt]. 	varName := aNode args first name.	'LargePositiveInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() === "bigint" && ';			nextPutAll: varName;			nextPutAll: '.valueOf() >= 0)'].	'LargeNegativeInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() === "bigint" && ';			nextPutAll: varName;			nextPutAll: '.valueOf() < 0)'].	'Integer' = className ifFalse: [self halt: 'isKindOf: ', className].	aStream nextPutAll: '(typeof ';		nextPutAll: varName;		nextPutAll: ' === "number" || typeof ';		nextPutAll: varName;		nextPutAll: '.valueOf() === "bigint")'.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsMemberOf: aNode on: aStream indent: anInteger	super generateIsMemberOf: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 1/14/2022 20:15'!generateIsNotKindOf: aNode on: aStream indent: anInteger	| className varName | 	className := aNode args second value.	aNode args first isVariable ifFalse: [self halt].	varName := aNode args first name.	'LargePositiveInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() !!== "bigint" || ';			nextPutAll: varName;			nextPutAll: '.valueOf() < 0)'].	'LargeNegativeInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() !!== "bigint" || ';			nextPutAll: varName;			nextPutAll: '.valueOf() >= 0)'].	'Integer' = className ifFalse: [self halt: 'isKindOf: ', className].	aStream nextPutAll: '(typeof ';		nextPutAll: varName;		nextPutAll: ' !!== "number" && typeof ';		nextPutAll: varName;		nextPutAll: '.valueOf() !!== "bigint")'.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsPointers: aNode on: aStream indent: anInteger	super generateIsPointers: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:57'!generateIsWords: aNode on: aStream indent: anInteger	super generateIsWords: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 3/11/2021 18:54'!initializeJSTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	super initializeJSTranslationDictionary.	pairs := #(		#asCInt						#generateAsCInt:on:indent:		#asCUnsigned				#generateAsCUnsigned:on:indent:		#asCBoolean					#generateAsCBoolean:on:indent:		#asCDouble					#generateAsCDouble:on:indent:		#asSmallIntegerObj			#generateAsSmallIntegerObj:on:indent:		#asPositiveIntegerObj		#generateAsPositiveIntegerObj:on:indent:		#asBooleanObj				#generateAsBooleanObj:on:indent:		#asFloatObj					#generateAsFloatObj:on:indent:		#asIf:var:					#generateAsIfVar:on:indent:		#asIf:var:asValue:			#generateAsIfVarAsValue:on:indent:		#asIf:var:put:				#generateAsIfVarPut:on:indent:		#field:						#generateField:on:indent:		#field:put:					#generateFieldPut:on:indent:				#class						#generateClass:on:indent:		#stSize						#generateStSize:on:indent:		#stAt:						#generateAt:on:indent:		#stAt:put:					#generateAtPut:on:indent:		#asCharPtr					#generateAsCharPtr:on:indent:		#asIntPtr					#generateAsIntPtr:on:indent:		#cPtrAsOop					#generateCPtrAsOop:on:indent:		#next						#generateNext:on:indent:		#asOop:						#generateAsOop:on:indent:		#asValue:					#generateAsValue:on:indent:		#isFloat						#generateIsFloat:on:indent:		#isIndexable					#generateIsIndexable:on:indent:		#isIntegerOop				#generateIsIntegerOop:on:indent:		#isIntegerValue				#generateIsIntegerValue:on:indent:		#FloatOop					#generateIsFloatValue:on:indent:		#isWords					#generateIsWords:on:indent:		#isWordsOrBytes				#generateIsWordsOrBytes:on:indent:		#isPointers					#generateIsPointers:on:indent:		#isNil						#generateIsNil:on:indent:		#isMemberOf:				#generateIsMemberOf:on:indent:		#isKindOf:					#generateIsKindOf:on:indent:		#fromStack:					#generateFromStack:on:indent:		#clone						#generateClone:on:indent		#new						#generateNew:on:indent		#new:						#generateNewSize:on:indent		#superclass					#generateSuperclass:on:indent:		#remapOop:in:				#generateRemapOopIn:on:indent:		#debugCode:					#generateDebugCode:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'asOop:/asValue:' stamp: 'fm 7/13/2023 02:24'!generateCoerceToBooleanObjectFrom: aNode on: aStream	aStream nextPutAll: '!!!!('.	self emitJSExpression: aNode on: aStream.	aStream nextPut: $)! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 11/29/2020 12:48'!jscgLoad: aBlock expr: aString asBooleanValueFrom: anInteger	"Answer codestring for boolean coercion (with validating side-effect) of object, as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf:';		crtab: 2;		nextPutAll: aString])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asCharPtrFrom: anInteger	"Answer codestring for character pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asCharPtrFrom: anInteger andThen: valBlock	"Answer codestring for character pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *''']))	 ! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asIntPtrFrom: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:40'!jscgLoad: aBlock expr: aString asKindOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'KindOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:40'!jscgLoad: aBlock expr: aString asMemberOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'MemberOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:39'!jscgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: exprString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:39'!jscgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: exprString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:36'!jscgLoad: aBlock expr: aString asRawOopFrom: anInteger	"Answer a string for a Slang expression that will load an oop (without validation) from stack index anInteger.  Apply aBlock, a BlockContext instance that when passed an expression, will return a string assigning the expression to the desired identifier, to the string before answering.  aString is a Slang expression that refers to the stack value, once it has been loaded."	^aBlock value: aString! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asUnsignedPtrFrom: anInteger andThen: valBlock	"Answer a codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''unsigned *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asUnsignedValueFrom: anInteger	"Answer a codestring for positive integer coercion (with validating side-effect) of oop, as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf:';		crtab: 2;		nextPutAll: aString])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asWBCharPtrFrom: anInteger	"Answer codestring for char pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger	"Answer codestring for single-precision float pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asWBIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!JSSmartSyntaxPluginMethod methodsFor: 'private' stamp: 'fm 12/26/2020 19:32'!pop: anInteger thenReturnExpr: anExpression	^TSendNode new		setSelector: #push:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array 			with: anExpression)! !!JSSmartSyntaxPluginMethod methodsFor: 'specifying primitives' stamp: 'fm 4/25/2021 00:05'!handlePrimitiveDirective: aStmt on: sStream	isPrimitive := true.	fullArgs := args.	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec jscgDeclareJSForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec == Oop ifTrue: [					aStmt variable name, ' := this'				] ifFalse: [					rcvrSpec						jscg:	JSSmartSyntaxPluginCodeGenerator new						prolog:  [:expr | aStmt variable name, ' := ', expr]						expr: 	'this'						index: 	fullArgs size				])			varName: '')].	^true.! !!JSSmartSyntaxPluginMethod methodsFor: 'specifying primitives' stamp: 'fm 11/29/2020 18:06'!namedPrimitiveProlog	| cg |	cg := SmartSyntaxPluginCodeGenerator new.	^Array streamContents: [:sStream |		1 to: args size do:			[:i |			 sStream nextPutAll: 				(self 					statementsFor: 						((parmSpecs at: i) 							jscg: 	cg							prolog:  [:expr | expr]							expr: (args at: i)							index: args size - i)					varName: '')]]! !!JSSmartSyntaxPluginMethod methodsFor: 'transforming' stamp: 'fm 12/26/2020 19:35'!fixUpReturnOneStmt: stmt on: sStream	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 ^nil].	 sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: stmt expression).! !!JSSmartSyntaxPluginMethod methodsFor: 'initializing' stamp: 'fm 11/16/2020 23:31'!fromContext: aContext primitive: aString parameters: aClassList receiver: aClass	args := aContext tempNames				copyFrom: 1				to: aContext method numArgs.	self 		primitive: aString		parameters: aClassList		receiver: aClass! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'fm 1/8/2022 00:47'!unsafeByteOf: bytesOop at: ix	"Argument bytesOop must not be aSmallInteger!!"	<inline: true>	^(interpreterProxy cCoerce: (interpreterProxy firstIndexableField: bytesOop) to: #'unsigned char *') at: ix - 1! !!LargeIntegersPlugin methodsFor: 'control & support primitives' stamp: 'fm 9/3/2020 23:05'!primGetModuleName	"If calling this primitive fails, then C module does not exist."	| strLen strOop |	self debugCode: [self msg: 'primGetModuleName'].	self		primitive: 'primGetModuleName'		parameters: #()		receiver: #Oop.	strLen := self strlen: self getModuleName.	strOop := interpreterProxy instantiateClass: interpreterProxy classString indexableSize: strLen.	0 to: strLen-1 do:[:i|		interpreterProxy storeByte: i ofObject: strOop withValue: (self getModuleName at: i)].	^strOop! !!Object class methodsFor: '*vmmakerjs' stamp: 'fm 3/23/2021 10:48'!jscg: cg prolog: aBlock expr: aString index: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'NotKindOf: ''';		nextPutAll:	self asString;		nextPutAll: ''') not.';		crtab;		nextPutAll: (cg 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!Array class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 17:58'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: '(interpreterProxy isIndexable: ';				nextPutAll: aString;				nextPutAll: ') ifFalse: [interpreterProxy primitiveFail]']]! !!BitBltSimulation class methodsFor: 'translation' stamp: 'fm 3/22/2021 17:37'!requiredMethodNames	^(self opTable, #(copyBits:Fallback: copyBitsRule41Test1 copyBitsRule41Test2 copyBitsRule41Test4)) asSet! !!Boolean class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 12:55'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf: ';		nextPutAll: aString])! !!ByteArray class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:30'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsBytes: ';				nextPutAll: aString]]! !!Float class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:18'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'nil checkIsFloat: ';		nextPutAll: aString])! !!FloatArray class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 12:57'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!IntegerArray class methodsFor: '*vmmakerjs' stamp: 'fm 3/21/2021 23:49'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsSignedInts: ';				nextPutAll: aString]]! !!JSCodeGenerator class methodsFor: 'class initialization' stamp: 'fm 7/15/2023 00:45'!exportAll	"JSCodeGenerator exportAll"	| previousDefault |		previousDefault := FileDirectory default pathName.	FileDirectory setDefaultDirectory: 'C:\JsSqueak\backup\plugins'.	[	"JSCodeGenerator beActiveDuring: [(VMMaker default interpreterClass: StackInterpreter) generateInterpreterFile]."	JSCodeGenerator beActiveDuring: [JSCodeGenerator translateAllPluginsIn: FileDirectory default doInlining: true]	] ensure: [FileDirectory setDefaultDirectory: previousDefault].! !!JSCodeGenerator class methodsFor: 'utilities' stamp: 'fm 2/26/2022 23:07'!translateAllPluginsIn: aDirectory doInlining: doInlining	self beActiveDuring: [		#(	ADPCMCodecPlugin			BalloonEnginePlugin			"BMPReadWriterPlugin			--not working yet"			BitBltSimulation			DSAPlugin				DeflatePlugin			FFTPlugin			FloatArrayPlugin			GeniePlugin					JPEGReaderPlugin			KedamaPlugin			KedamaPlugin2			KlattSynthesizerPlugin			LargeIntegersPlugin			Matrix2x3Plugin			MiscPrimitivePlugin			ScratchPlugin			SoundGenerationPlugin			StarSqueakPlugin		) do: [:pluginName |			self environment at: pluginName ifPresent: [:plugin |				plugin translateInDirectory: aDirectory doInlining: doInlining]]		displayingProgress: 'Generating JS plugins'].! !!JSCodeGenerator class methodsFor: 'utilities' stamp: 'fm 11/2/2020 21:31'!translateMainInterpreter	self beActiveDuring: [(VMMaker default interpreterClass: StackInterpreter) initializeAllPlugins; generateInterpreterFile].! !!Oop class methodsFor: '*vmmakerjs' stamp: 'fm 12/5/2020 23:03'!jscg: cg prolog: aBlock expr: aString index: anInteger	^''! !!SmallInteger class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:24'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'nil checkIsInteger: ';		nextPutAll: aString])! !!String class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:30'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsBytes: ';				nextPutAll: aString]]! !!TParseNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not.  By default assume it has.  Nodes that don't override."	^true! !!TParseNode methodsFor: 'testing' stamp: 'fm 11/21/2020 22:23'!isFinalIf	^false! !!TParseNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:19'!isSameAs: aTParseNode	"Answer if the ParseTree rooted at this node is the same as aTParseNode.	 By default answer false and have subclasses override as appropriate."	^self == aTParseNode! !!TAssignmentNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isAssignment		 and: [(variable isSameAs: aTParseNode variable)		 and: [expression isSameAs: aTParseNode expression]]]! !!TBreakNode methodsFor: 'printing' stamp: 'fm 11/18/2020 20:00'!printOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'break'.! !!TBreakNode methodsFor: 'enumerating' stamp: 'fm 11/18/2020 20:02'!nodesDo: aBlock parent: parent	aBlock value: self value: parent! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 11/18/2020 20:01'!copyTree	^self class new! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 11/18/2020 20:00'!emitJSCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'break'.! !!TConstantNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not."	^false! !!TConstantNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isConstant		 and: [value class == aTParseNode value class		 and: [value = aTParseNode value]]]! !!TDefineNode methodsFor: 'as yet unclassified' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [self class == aTParseNode class		  and: [value class == aTParseNode value class		  and: [value = aTParseNode value		  and: [name = aTParseNode nameOrValue]]]]! !!TReturnNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isReturn		 and: [expression isSameAs: aTParseNode expression]]! !!TReturnNode methodsFor: '*vmmakerjs' stamp: 'fm 1/11/2022 22:19'!emitJSCodeOn: aStream level: level generator: aCodeGen	| generated |	(expression isSwitch	 or: [expression isCaseStmt]) ifTrue:		[^expression emitJSCodeOn: aStream addToEndOfCases: self level: level generator: aCodeGen].	('void' = aCodeGen currentMethod returnType) ifTrue: [		"If the function is void, don't say 'return x' instead say ' x; return' "		expression isLeaf ifFalse: [			expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.				aStream nextPutAll: ';'; space.		].		aStream nextPutAll: 'return'.	] ifFalse: [		generated := false.		expression isSend ifTrue: [			generated := true.			expression selector caseOf: {				[#primitiveFail]->[					aCodeGen generatePrimitiveFail: expression on: aStream indent: level].				[#primitiveFailFor:]->[					aCodeGen generatePrimitiveFailFor: expression on: aStream indent: level].				[#push:]->					[aCodeGen generatePrimitiveReturn: expression on: aStream indent: level].				[#pushBool:]->[					aCodeGen generatePushBool: expression on: aStream indent: level].				[#pushFloat:]->[					aCodeGen generatePushFloat: expression on: aStream indent: level].				[#pushInteger:]->[					aCodeGen generatePushInteger: expression on: aStream indent: level].				[#success:]->[					expression args first isConstant ifTrue: [						expression args first value ifTrue: [							aStream nextPutAll: 'return null'						] ifFalse: [							aCodeGen generatePrimitiveFail: expression on: aStream indent: level]					] ifFalse: [						aStream nextPutAll: 'return ('.			 			expression args first emitJSCodeAsArgumentOn: aStream level: level generator: self.						aStream nextPutAll: ') ? null : PrimitiveFailed.signal()'.					]]			} otherwise: [generated := false]		].		generated ifFalse: [			aStream nextPutAll: 'return '.			expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen		].	].! !!TSendNode methodsFor: 'C code generation' stamp: 'fm 10/28/2020 20:53'!shouldExcludeReceiverAsFirstArgument: aCodeGen	"Only include the receiver as the first argument in certain cases.	 The receiver is always included if it is an expression.	 If it is a variable:		 If the vmClass says it is an implicit variable, don't include it.		 If the method's definingClass says it is an implicit variable, don't include it.		 If the variable is 'self' and the method being called is not in		 the method set (i.e. it is some external code), don't include it.		 If it is a struct send of something the vm says is an implicit variable, don't include it."	| m |	(aCodeGen isAssertSelector: selector) ifTrue:		[^true].	(receiver isSend	 and: [receiver receiver isVariable	 and: [(self isSelfReference: receiver receiver in: aCodeGen)		or: [self isStructReference: receiver receiver in: aCodeGen]]]) ifTrue:		[^aCodeGen isNonArgumentImplicitReceiverVariableName: receiver receiver name].	^receiver isVariable	    and: [(aCodeGen isNonArgumentImplicitReceiverVariableName: receiver name)		    or: [(self isSelfReference: receiver in: aCodeGen)			    and: [(m := aCodeGen methodNamed: selector) isNil					or: [m typeForSelf == #implicit]]]]! !!TSendNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not.	 We assume most sends do, but filter-out arithmetic and certain reads."	(#(	baseHeaderSize bytesPerOop bytesPerWord logBytesPerOop		numSmallIntegerBits numSmallIntegerTagBits numTagBits		shiftForWord tagMask wordSize) includes: selector) ifTrue:		[^false].	(#(#+ #- #* #/ #// #\\ #= #== #~= #~~ << >>		"These two important for Spur is:instanceOf:compactClassIndex: et al"		longAt: fetchPointer:ofObject: splObj:) includes: selector) ifFalse:		[^true].	^receiver hasSideEffect or: [arguments first hasSideEffect]! !!TSendNode methodsFor: 'testing' stamp: 'fm 9/21/2020 14:28'!isReturningIf	^(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: selector) 		and: [arguments first endsWithReturn and: [arguments last endsWithReturn]]! !!TSendNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	self == aTParseNode ifTrue: [^true].	(aTParseNode isSend	 and: [selector == aTParseNode selector	 and: [receiver isSameAs: aTParseNode receiver]]) ifFalse:		[^false].	arguments with: aTParseNode args do:		[:a :b|		(a isSameAs: b) ifFalse:			[^false]].	^true! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 7/11/2023 18:28'!emitJSCodeAsFunctionCallOn: aStream level: level generator: aCodeGen	| argsOnStack |	selector = #assert: ifTrue: [^self].	argsOnStack := false.	"Translate this message send into a JS function call"	"Special case for pluggable modules. Replace messages to interpreterProxy	 by interpreterProxy.message(..) if the message is not builtin"	(aCodeGen isGeneratingPluginCode	 and: [receiver isVariable	 and: ['interpreterProxy' = receiver name	 and: [self isBuiltinOperator not]]]) ifTrue: [			aStream nextPutAll: 'SmalltalkVM.'		] ifFalse: [			(aCodeGen isGeneratingPluginCode and: [(self shouldIncludeReceiverAsFirstArgument: aCodeGen) not]) ifTrue: [				aStream nextPutAll: aCodeGen pluginName;nextPut: $..				argsOnStack := arguments isEmpty and: [(aCodeGen currentMethod selector indexOf: $: ) = 0].				].		].	aStream nextPutAll: (aCodeGen jsFunctionNameFor: selector).	argsOnStack ifTrue: [		aStream nextPutAll: '.apply(this, arguments'	] ifFalse: [		aStream nextPut: $(.	].	"Only include the receiver as the first argument in certain cases.	 The receiver is always included if it is an expression.	 If it is a variable:		 If the vmClass says it is an implicit variable, don't include it.		 If the variable is 'self' and the method being called is not in		 the method set (i.e. it is some external code), don't include it."	(self shouldIncludeReceiverAsFirstArgument: aCodeGen) ifTrue:		[receiver emitJSCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse:			[aStream nextPutAll: ', ']].	arguments do:		[ :arg| arg emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $)! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 1/10/2022 19:19'!emitJSPointerArithmetic: type on: aStream level: level generator: aGenerator type: cType top: top	(selector = #+ or: [selector = #-]) ifFalse: [self halt].	receiver isVariable		ifTrue: [ | func |			func := ({'int' -> (selector = #+ ifTrue: ['PTR_ADD'] ifFalse: ['PTR_SUB']). 'unsignedint' -> (selector = #+ ifTrue: ['PTR_ADD'] ifFalse: ['PTR_SUB']). 'char' -> (selector = #+ ifTrue: ['CPTR_ADD'] ifFalse: ['CPTR_SUB']). 'unsignedchar' -> (selector = #+ ifTrue: ['CPTR_ADD'] ifFalse: ['CPTR_SUB']). 'float' -> (selector = #+ ifTrue: ['FPTR_ADD'] ifFalse: ['FPTR_SUB'])} as: Dictionary)				at: ((cType copyUpTo: $*) copyWithout: $ ). 			aStream nextPutAll: func, '(',  receiver name, ', ']		ifFalse: [receiver emitJSPointerArithmetic: type on: aStream level: level generator: aGenerator type: cType top: false.			aStream nextPutAll: ' ', selector, ' '].	aGenerator emitJSExpression: arguments first on: aStream.	top ifTrue: [aStream nextPutAll: ')'].! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/20/2020 14:12'!isLeafOrFunc	selector precedence = 2 ifTrue: [^false].	(#(and: or: bitAnd: bitOr: bitXor: bitShift: questionMark:colon:) includes: selector) ifTrue: [^false].	^true! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 11/21/2020 22:27'!addFinalIfReturnsTo: returns extraneous: extraneous	 | lastRealStatement |	(lastRealStatement := self lastRealStatement) isReturn ifTrue: [		returns add: lastRealStatement	] ifFalse: [		(lastRealStatement isSend and: [#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: lastRealStatement selector]) ifTrue: [			lastRealStatement args first addFinalIfReturnsTo: returns extraneous: extraneous.			lastRealStatement args last addFinalIfReturnsTo: returns extraneous: extraneous]].	"because of inlining, we may have a returning if before a return"	extraneous addAll: (statements copyFrom: (statements indexOf: lastRealStatement) + 1 to: statements size)! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 12/10/2020 00:18'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in a $} character."	^ aStream peekLast = $}! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 3/26/2021 20:09'!endsWithCr: aStream	"Answer true if the given stream ends in a $} character."	^ aStream peekLast = Character cr! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 10/28/2020 18:32'!endsWithReturn	"Answer true if the last statement of this lock is a return."	| lastRealStatement |	^ statements isEmpty not		and: [(lastRealStatement := self lastRealStatement) notNil and: [lastRealStatement isReturn				or: [lastRealStatement isReturningIf]]]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 11/21/2020 22:10'!endsWithReturnOrIf	"Answer true if the last statement of this block is a return."	| lastRealStatement |	^ statements isEmpty not		and: [(lastRealStatement := self lastRealStatement) notNil and: [lastRealStatement isReturn				or: [lastRealStatement isSend and: [#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: lastRealStatement selector]]]]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 3/10/2021 23:19'!hasFinalReturn	| last |	^statements isEmpty ifTrue: [false] ifFalse: [		(last := self lastRealStatement) isReturn ifTrue: [			last expression isSend ifTrue: [#(push: pushBool: pushFloat: pushInteger:) includes: last expression selector] ifFalse: [				statements reverseDo: [:e | e isSend ifTrue: [					^(#(push: pushBool: pushFloat: pushInteger:) includes: e selector) or: 					[(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: e selector) and: [e args first hasFinalReturn and: [e args last hasFinalReturn]]]]]. false]		] ifFalse: [			last isSend and: [				(#(push: pushBool: pushFloat: pushInteger:) includes: last selector) or: 				[(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: last selector) and: [last args first hasFinalReturn and: [last args last hasFinalReturn]]]			]]]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	self == aTParseNode ifTrue: [^true].	(aTParseNode isStmtList	 and: [statements size = aTParseNode statements size]) ifFalse:		[^false].	statements with: aTParseNode statements do:		[:mine :theirs|		 (mine isSameAs: theirs) ifFalse:			[^false]].	^true! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 10/28/2020 18:30'!lastRealStatement	"because of inlining, we may have a returning if before a return"	^ statements isEmpty ifFalse: [statements detect: [:e | e isReturn or: [e isReturningIf]] ifNone: [statements reverseDo: [:e | e isLabel ifFalse: [^e]]. nil]]! !!TStmtListNode methodsFor: '*vmmakerjs' stamp: 'fm 1/7/2022 20:15'!emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen	| statementWasComment | 	statements size ~= 1 ifTrue: [statements isEmpty ifTrue: [aStream nextPutAll: 'nil'] ifFalse: [self halt]].	statementWasComment := false.	statements		do:			[:s |			s emitJSCommentOn: aStream level: level.			s emitJSCodeAsArgumentOn: aStream level: 0 generator: aCodeGen.			statementWasComment := s isComment]		separatedBy:			[((self endsWithCloseBracket: aStream)			  or: [statementWasComment]) ifFalse: [aStream nextPut: $,]]! !!TStmtListNode methodsFor: '*vmmakerjs' stamp: 'fm 3/26/2021 20:12'!emitJSCodeOn: aStream level: level generator: aCodeGen	self emitJSCommentOn: aStream level: level.	statements do: [:s |		s emitJSCommentOn: aStream level: level.		aStream tab: level.		s emitJSCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) not and: [(self endsWithCr: aStream) not			and: [(s isComment) not				and: [s requiresCLineTerminator]]])			ifTrue: [aStream nextPut: $;].		aStream cr].! !!TSwitchStmtNode methodsFor: 'C code generation' stamp: 'fm 9/21/2020 13:15'!emitJSCodeOn: aStream level: level generator: aCodeGen	(aCodeGen nilOrReducibleValueOf: expression)		ifNil: [aStream crtab: level;				nextPutAll: 'switch ('.			expression asExpression emitJSCodeOn: aStream level: level generator: aCodeGen.			aStream nextPutAll: ') {'.			cases do: [:tuple|				 [:labels :case|				  labels do: [:label|					 aStream						crtab: level;						nextPutAll: 'case '.					label asExpression emitJSCodeOn: aStream level: level + 1 generator: aCodeGen.					aStream nextPut: $:].		  		aStream crtab: level + 1.				case emitJSCodeOn: aStream level: level + 1 generator: aCodeGen.				case endsWithReturn ifFalse:					[aStream tab: level + 1; nextPutAll: 'break;']]					valueWithArguments: tuple].			aStream				crtab: level;				nextPutAll: 'default:';				crtab: level + 1.			otherwiseOrNil				ifNotNil:					[otherwiseOrNil emitJSCodeOn: aStream level: level + 1 generator: aCodeGen]				ifNil: [aStream nextPutAll: 'error("Case not found and no otherwise clause");'].			aStream				crtab: level;				nextPut: $}]		ifNotNil: [:const |			(cases detect: [:tuple| tuple first value = const] 				ifNone: [					otherwiseOrNil						ifNotNil:							[otherwiseOrNil emitJSCodeOn: aStream level: level generator: aCodeGen]						ifNil: [aStream nextPutAll: 'error("Case not found and no otherwise clause");'].					^self]			) last emitJSCodeOn: aStream level: level generator: aCodeGen.			].	! !!TVariableNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not."	^false! !!TVariableNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isVariable		 and: [name = aTParseNode name]]! !!TVariableNode methodsFor: '*vmmakerjs' stamp: 'fm 10/29/2020 15:12'!isFloatIn: aCodeGen	| type |	type := aCodeGen typeOfVariable: name.	type isNil ifTrue: [^false].	(type includes: $*) ifTrue: [^false].	(type beginsWithAnyOf: #('register ' 'static ')) ifTrue: [type := type copyAfter: $ ].	(type beginsWithAnyOf: #('double ' 'float ')) ifTrue: [^true].	(type beginsWithAnyOf: #('int ' 'unsigned ' 'sqInt ' 'usqInt ' 'usqLong ' 'sqLong ' 'long ' 'sqImageFile ' 'squeakFileOffsetType ' 'size_t ' 'var ')) ifTrue: [^false].	self halt: 'need to handle ', type! !!Unsigned class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 13:35'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf: ';		nextPutAll: aString])! !!WordArray class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:32'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asUnsignedPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsWords: ';				nextPutAll: aString]]! !Object subclass: #JSMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels writtenToGlobalVarsCache complete export static sharedLabel sharedCase comment definingClass globalStructureBuildMethodHasFoo canAsmLabel mustAsmLabel properties cascadeVariableNumber extraVariableNumber oneBasedArrays loopsWithReturns'	classVariableNames: 'CaseStatements'	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!Object subclass: #JSCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations scopeStack methods macros preparedMethodList variablesSetCache headerFiles globalVariableUsage useSymbolicConstants generateDeadCode doNotRemoveMethodList asArgumentTranslationDict receiverDict vmClass currentMethod logger declareMethodsStatic permitMethodPruning pools abstractDeclarations uncheckedAbstractMethods cCodeTranslationDict oneBasedArrays exceptions omSimulator'	classVariableNames: 'IsActive UseRightShiftForDivide'	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!