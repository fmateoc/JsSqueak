'From Squeak4.5 of 10 April 2015 [latest update: #13712] on 10 November 2023 at 1:41:07 pm'!Object subclass: #JSCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations scopeStack methods macros preparedMethodList variablesSetCache headerFiles globalVariableUsage useSymbolicConstants generateDeadCode doNotRemoveMethodList asArgumentTranslationDict receiverDict vmClass currentMethod logger declareMethodsStatic permitMethodPruning pools abstractDeclarations uncheckedAbstractMethods cCodeTranslationDict oneBasedArrays exceptions omSimulator inlineReturnTypes '	classVariableNames: 'IsActive UseRightShiftForDivide '	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!Object subclass: #JSMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export static sharedLabel sharedCase comment definingClass globalStructureBuildMethodHasFoo canAsmLabel mustAsmLabel properties cascadeVariableNumber extraVariableNumber oneBasedArrays loopsWithReturns writtenToGlobalVarsCache '	classVariableNames: 'CaseStatements '	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!TParseNode subclass: #TBreakNode	instanceVariableNames: 'label'	classVariableNames: ''	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!!Behavior methodsFor: 'testing method dictionary' stamp: 'fm 10/19/2023 00:05'!referencedInstvars	| referenced allInstVars |	referenced := Set new.	1 to: self instSize do: [:i |		(referenced includes: i) ifFalse: [			(self methodDict anySatisfy: [ :method |				(method readsField: i) or: [ method writesField: i ] ]) ifTrue: [					referenced add: i] ] ].	allInstVars := self allInstVarNames.	^referenced collect: [:e | allInstVars at: e]! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:12'!copyBitsRule41Test	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		combinationRule = 41		ifTrue:["fetch the forecolor into componentAlphaModeColor."			interpreterProxy methodArgumentCount >= 4				ifTrue:[					self copyBitsRule41Test4				] ifFalse: [					gammaLookupTable := nil.					ungammaLookupTable := nil.					interpreterProxy methodArgumentCount < 2						ifTrue: [							componentAlphaModeAlpha := 255.							self copyBitsRule41Test1						] ifFalse:[							interpreterProxy methodArgumentCount > 1								ifTrue:[									self copyBitsRule41Test2								] ifFalse:[^ interpreterProxy primitiveFail]]]].	! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:09'!copyBitsRule41Test1	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		interpreterProxy methodArgumentCount = 1		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 0.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail]]! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 19:09'!copyBitsRule41Test2	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	<inline: false>		interpreterProxy methodArgumentCount = 2		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 1.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			componentAlphaModeAlpha := interpreterProxy stackIntegerValue: 0.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail]].	! !!BitBltSimulation methodsFor: 'setup' stamp: 'fm 3/22/2021 17:27'!copyBitsRule41Test4	"Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some variables"	| gammaLookupTableOop ungammaLookupTableOop |	<inline: false>		interpreterProxy methodArgumentCount = 4		ifTrue:[			componentAlphaModeColor := interpreterProxy stackIntegerValue: 3.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			componentAlphaModeAlpha := interpreterProxy stackIntegerValue: 2.			interpreterProxy failed ifTrue: [^ interpreterProxy primitiveFail].			gammaLookupTableOop := interpreterProxy stackObjectValue: 1.			(interpreterProxy isBytes: gammaLookupTableOop) 				ifTrue:[gammaLookupTable := interpreterProxy firstIndexableField: gammaLookupTableOop.].			ungammaLookupTableOop := interpreterProxy stackObjectValue: 0.			(interpreterProxy isBytes: ungammaLookupTableOop) 				ifTrue:[ungammaLookupTable := interpreterProxy firstIndexableField: ungammaLookupTableOop]].	! !!CairoConstant methodsFor: 'as yet unclassified' stamp: 'fm 10/1/2020 21:11'!JSstoreOn: aStream 	(name = 'CAIRO_OPERATOR_SOURCE' or: [name = 'CAIRO_EXTEND_REPEAT']) 		ifTrue: [aStream nextPut: $1] 		ifFalse: [self halt]! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2023 23:22'!>>< selector	"returns JavaScript source for plugin-generated methods"	"BitBltSimulation >>< #primitivePixelValueAtX:y:"	JSCodeGenerator beActiveDuring: [| jsCodeGenerator jsMethod |		(jsCodeGenerator := self initialize; buildCodeGenerator) collectInlineList.		jsMethod := ((Compiler new			parse: (self sourceCodeAt: selector)			in: self			notifying: nil) 				prepareForVmSideInlinedGenerationBy: jsCodeGenerator) asCleanedUpParseTree					asTranslationMethodOfClass: jsCodeGenerator translationMethodClass.		jsMethod referencesGlobalStructMakeZero.		^String streamContents: [:s | jsMethod emitJSCodeOn: s generator: jsCodeGenerator]]! !!InflatePlugin methodsFor: 'primitives' stamp: 'fm 2/12/2022 23:01'!primitiveInflateDecompressBlock	"Primitive. Inflate a single block."	| oop1 oop rcvr source collection |	<export: true>	interpreterProxy methodArgumentCount = 2 ifFalse:		[^interpreterProxy primitiveFail].	"distance table"	oop1 := interpreterProxy stackValue: 0.	(interpreterProxy isWords: oop1) ifFalse:		[^interpreterProxy primitiveFail].	zipDistTable := interpreterProxy firstIndexableField: oop1.	zipDistTableSize := interpreterProxy slotSizeOf: oop1.	"literal table"	oop := interpreterProxy stackValue: 1.	(interpreterProxy isWords: oop) ifFalse:		[^interpreterProxy primitiveFail].	zipLitTable := interpreterProxy firstIndexableField: oop.	zipLitTableSize := interpreterProxy slotSizeOf: oop.	"Receiver (InflateStream)"	rcvr := interpreterProxy stackValue: 2.	(interpreterProxy isPointers: rcvr) ifFalse:		[^interpreterProxy primitiveFail].	"All the integer instvars"	readStreamInstSize = 0 ifTrue:		[(self determineSizeOfReadStream: rcvr) ifFalse:			[^interpreterProxy primitiveFail].		 "If the receiver wasn't valid then we derived readStreamInstSize from an invalid source.  discard it."		 (interpreterProxy slotSizeOf: rcvr) < (readStreamInstSize + 8) ifTrue:			[readStreamInstSize := 0.			 ^interpreterProxy primitiveFail]].	(interpreterProxy slotSizeOf: rcvr) < (readStreamInstSize + 8) ifTrue:		[^interpreterProxy primitiveFail].	zipReadLimit := interpreterProxy fetchInteger: 2 ofObject: rcvr.	zipState := interpreterProxy fetchInteger: readStreamInstSize + 0 ofObject: rcvr.	zipBitBuf := interpreterProxy fetchInteger: readStreamInstSize + 1 ofObject: rcvr.	zipBitPos := interpreterProxy fetchInteger: readStreamInstSize + 2 ofObject: rcvr.	zipSourcePos := interpreterProxy fetchInteger: readStreamInstSize + 4 ofObject: rcvr.	zipSourceLimit := interpreterProxy fetchInteger: readStreamInstSize + 5 ofObject: rcvr.	interpreterProxy failed ifTrue:[^nil].	zipReadLimit := zipReadLimit - 1.	zipSourcePos := zipSourcePos - 1.	zipSourceLimit := zipSourceLimit - 1.	collection := interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isBytes: collection) ifFalse:		[^interpreterProxy primitiveFail].	zipCollection := interpreterProxy firstIndexableField: collection.	zipCollectionSize := interpreterProxy byteSizeOf: collection.	source := interpreterProxy fetchPointer: readStreamInstSize + 3 ofObject: rcvr.	(interpreterProxy isBytes: source) ifFalse:		[^interpreterProxy primitiveFail].	zipSource := interpreterProxy firstIndexableField: source.	"do the primitive"	self zipDecompressBlock.	interpreterProxy failed ifFalse: "store modified values back"		[self cCode: 'const origReadLimit = this.pointers[2];collection.string = (origReadLimit === 0 ? "" : collection.string) + String.fromCodePoint(...zipCollection.subarray(origReadLimit, zipReadLimit + 1));collection.dirty = false;'.		interpreterProxy storeInteger: 2 ofObject: rcvr withValue: zipReadLimit + 1.		interpreterProxy storeInteger: readStreamInstSize + 0 ofObject: rcvr withValue: zipState.		interpreterProxy storeInteger: readStreamInstSize + 1 ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: readStreamInstSize + 2 ofObject: rcvr withValue: zipBitPos.		interpreterProxy storeInteger: readStreamInstSize + 4 ofObject: rcvr withValue: zipSourcePos + 1.		interpreterProxy pop: 2]! !!DeflatePlugin methodsFor: 'primitive support' stamp: 'fm 1/9/2022 21:17'!loadZipEncoderFrom: rcvr	| oop |	<inline: false>	writeStreamInstSize = 0 ifTrue:		[(self determineSizeOfWriteStream: rcvr) ifFalse:			[^false].		 "If the receiver wasn't valid then we derived writeStreamInstSize from an invalid source.  discard it."		 (interpreterProxy slotSizeOf: rcvr) < (writeStreamInstSize + 3) ifTrue:			[writeStreamInstSize := 0.			 ^false]].	((interpreterProxy isPointers: rcvr)	 and: [(interpreterProxy slotSizeOf: rcvr) >= (writeStreamInstSize + 3)]) ifFalse:		[^false].	oop := interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isBytes: oop) ifFalse:		[^interpreterProxy primitiveFail].	zipCollection := interpreterProxy firstIndexableField: oop.	zipCollectionSize := interpreterProxy byteSizeOf: oop.	zipPosition := interpreterProxy fetchInteger: 1 ofObject: rcvr.	zipReadLimit := interpreterProxy fetchInteger: 2 ofObject: rcvr.	"zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr."	zipBitBuf := interpreterProxy fetchInteger: writeStreamInstSize ofObject: rcvr.	zipBitPos := interpreterProxy fetchInteger: writeStreamInstSize + 1 ofObject: rcvr.	^interpreterProxy failed not! !!DeflatePlugin methodsFor: 'primitives' stamp: 'fm 1/9/2022 21:17'!primitiveZipSendBlock	| distTree litTree distStream litStream rcvr result |	<export: true>	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	distTree := interpreterProxy stackObjectValue: 0.	litTree := interpreterProxy stackObjectValue: 1.	distStream := interpreterProxy stackObjectValue: 2.	litStream := interpreterProxy stackObjectValue: 3.	rcvr := interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self loadZipEncoderFrom: rcvr)		ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distTree) and:[		(interpreterProxy slotSizeOf: distTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litTree) and:[		(interpreterProxy slotSizeOf: litTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litStream) and:[		(interpreterProxy slotSizeOf: litStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distStream) and:[		(interpreterProxy slotSizeOf: distStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	self cCode:'' inSmalltalk:[		zipMatchLengthCodes := CArrayAccessor on: ZipWriteStream matchLengthCodes.		zipDistanceCodes := CArrayAccessor on: ZipWriteStream distanceCodes.		zipExtraLengthBits := CArrayAccessor on: ZipWriteStream extraLengthBits.		zipExtraDistanceBits := CArrayAccessor on: ZipWriteStream extraDistanceBits.		zipBaseLength := CArrayAccessor on: ZipWriteStream baseLength.		zipBaseDistance := CArrayAccessor on: ZipWriteStream baseDistance].	result := self sendBlock: litStream with: distStream with: litTree with: distTree.	interpreterProxy failed ifFalse:[		interpreterProxy storeInteger: 1 ofObject: rcvr withValue: zipPosition.		interpreterProxy storeInteger: writeStreamInstSize ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: writeStreamInstSize + 1 ofObject: rcvr withValue: zipBitPos.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 5. "rcvr + args"		interpreterProxy pushInteger: result.	].! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:16'!primitiveColorConvertGrayscaleMCU	"Requires:		JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop1 arrayOop2 arrayOop3 |	<export: true>	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask := interpreterProxy stackIntegerValue: 0.	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop3) and:[(interpreterProxy slotSizeOf: arrayOop3) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize := interpreterProxy slotSizeOf: arrayOop2.	jpegBits := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self yColorComponentFrom: arrayOop1)		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertGrayscaleMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:17'!primitiveColorConvertMCU	"Requires:		Array with: 3*JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop1 arrayOop2 arrayOop3 |	<export: true>	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask := interpreterProxy stackIntegerValue: 0.	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop3) and:[(interpreterProxy slotSizeOf: arrayOop3) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize := interpreterProxy slotSizeOf: arrayOop2.	jpegBits := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isPointers: arrayOop1) and:[(interpreterProxy slotSizeOf: arrayOop1) = 3])		ifFalse:[^interpreterProxy primitiveFail].	(self yColorComponentFrom: (interpreterProxy fetchPointer: 0 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	(self cbColorComponentFrom: (interpreterProxy fetchPointer: 1 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	(self crColorComponentFrom: (interpreterProxy fetchPointer: 2 ofObject: arrayOop1))		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/11/2021 23:20'!primitiveDecodeMCU	"In:		anArray 		WordArray of: DCTSize2		aColorComponent JPEGColorComponent		dcTable			WordArray		acTable			WordArray		stream			JPEGStream	"	| arrayOop1 arrayOop2 arrayOop3 oop1 oop2 anArray |	<export: true>	<var: #anArray type: 'int *'>	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	oop2 := interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self loadJPEGStreamFrom: oop2)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop3 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop3)		ifFalse:[^interpreterProxy primitiveFail].	acTableSize := interpreterProxy slotSizeOf: arrayOop3.	acTable := interpreterProxy firstIndexableField: arrayOop3.	arrayOop2 := interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop2)		ifFalse:[^interpreterProxy primitiveFail].	dcTableSize := interpreterProxy slotSizeOf: arrayOop2.	dcTable := interpreterProxy firstIndexableField: arrayOop2.	oop1 := interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self colorComponent: yComponent from: oop1)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop1 := interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop1)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: arrayOop1) = DCTSize2		ifFalse:[^interpreterProxy primitiveFail].	anArray := interpreterProxy firstIndexableField: arrayOop1.	interpreterProxy failed ifTrue:[^nil].	self decodeBlockInto: anArray component: yComponent.	interpreterProxy failed ifTrue:[^nil].	self storeJPEGStreamOn: (interpreterProxy stackValue: 0).	interpreterProxy 		storeInteger: PriorDCValueIndex 		ofObject: (interpreterProxy stackValue: 3) 		withValue: (yComponent at: PriorDCValueIndex).	interpreterProxy pop: 5.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'fm 3/12/2021 16:37'!primitiveIdctInt	"In:		anArray: IntegerArray new: DCTSize2		qt: IntegerArray new: DCTSize2.	"	| arrayOop1 arrayOop2 anArray qt |	<export: true>	<var: #anArray type: 'int *'>	<var: #qt type: 'int *'>	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	arrayOop2 := interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop2) and:[(interpreterProxy slotSizeOf: arrayOop2) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	qt := interpreterProxy firstIndexableField: arrayOop2.	arrayOop1 := interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop1) and:[(interpreterProxy slotSizeOf: arrayOop1) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	anArray := interpreterProxy firstIndexableField: arrayOop1.	self idctBlockInt: anArray qt: qt.	interpreterProxy pop: 2.! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 10/19/2023 00:05'!addClass: aClass	"Add the variables and methods of the given class to the code base."	aClass prepareToBeAddedToCodeGenerator: self.	self checkClassForNameConflicts: aClass.	self addClassVarsFor: aClass.	"ikp..."	self addPoolVarsFor: aClass.	variables addAll: (aClass referencedInstvars reject: [:e | variables includes: e]).	self retainMethods: aClass requiredMethodNames.	"The identity of the translated class is kept in vmClass for use in identifying the	translated source. Unless otherwise overridden, the first class to be added to the	code generator will provide this identifier."	vmClass ifNil: [self vmClass: aClass].	'Adding Class ' , aClass name , '...'		displayProgressAt: Sensor cursorPoint		from: 0		to: aClass selectors size		during:			[:bar |			 aClass selectors doWithIndex: [:sel :i |				bar value: i.				self addMethodFor: aClass selector: sel]].	aClass declareCVarsIn: self! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 8/5/2023 18:42'!addMethodsForPrimitives: classAndSelectorList 	| sel aClass source verbose meth |	classAndSelectorList do:[:classAndSelector | 		aClass := Smalltalk at: (classAndSelector at: 1) ifAbsent:[nil].		aClass ifNotNil:[			self addAllClassVarsFor: aClass.			"TPR - should pool vars also be added here?"			"find the method in either the class or the metaclass"			sel := classAndSelector at: 2.			(aClass includesSelector: sel)				ifTrue: [source := aClass sourceCodeAt: sel ifAbsent:[nil]]				ifFalse: [source := aClass class sourceCodeAt: sel ifAbsent:[nil]].		].		source ifNil:[			Transcript cr; show: 'WARNING: Compiled primitive ', classAndSelector first, '>>', classAndSelector last, ' not present'.		] ifNotNil:[			"compile the method source and convert to a suitable translation method "			meth := ((Compiler new						parse: source						in: aClass						notifying: nil) 							prepareForVmSideInlinedGenerationBy: self) asCleanedUpParseTree								asTranslationMethodOfClass: self translationMethodClass.			(aClass includesSelector: sel)				ifTrue: [meth definingClass: aClass]				ifFalse: [meth definingClass: aClass class].			meth primitive > 0 ifTrue:[meth preparePrimitiveName].			"for old-style array accessing: 			meth covertToZeroBasedArrayReferences."			meth replaceSizeMessages.			self addMethod: meth.		].	].	"method preparation"	verbose := false.	self prepareMethods.	verbose		ifTrue: 			[self printUnboundCallWarnings.			self printUnboundVariableReferenceWarnings.			Transcript cr].	"code generation"	self doInlining: true.	methods do:[:m|		"if this method is supposed to be a primitive (rather than a helper 		routine), add assorted prolog and epilog items"		m primitive > 0 ifTrue: [			m preparePrimitivePrologue].		"check for one-based array access"			m oneBasedArrays ifNotNil: [self oneBasedArrays: true].	].! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/18/2020 15:56'!addStructClasses: classes! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 12/12/2020 22:15'!ignoredMethods	^#(halt msg: getModuleName setInterpreter:)! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 1/8/2022 14:16'!initialize	translationDict := Dictionary new.	inlineList := Array new.	constants := Dictionary new: 100.	variables := OrderedCollection new: 100.	variableDeclarations := Dictionary new: 100.	methods := Dictionary new: 500.	macros := Dictionary new.	self initializeJSTranslationDictionary.	receiverDict := Dictionary new.	headerFiles := OrderedCollection new.	globalVariableUsage := Dictionary new.	useSymbolicConstants := false.	generateDeadCode := false.	scopeStack := OrderedCollection new.	logger := (ProvideAnswerNotification new tag: #logger; signal) ifNil: [Transcript].	pools := IdentitySet new.	abstractDeclarations := IdentitySet new.	uncheckedAbstractMethods := OrderedCollection new.	exceptions := Dictionary new.! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/18/2020 19:45'!omSimulator	^omSimulator ifNil: [omSimulator := Smalltalk image endianness == #big				ifTrue: [Smalltalk image wordSize = 4							ifTrue: [ObjectMemorySimulatorMSB basicNew]							ifFalse: [ObjectMemorySimulatorMSB64 basicNew]]				ifFalse: [Smalltalk image wordSize = 4							ifTrue: [ObjectMemorySimulatorLSB basicNew]							ifFalse: [ObjectMemorySimulatorLSB64 basicNew]]]! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 9/4/2020 11:05'!storeCodeOnFile: fileName doInlining: inlineFlag	"Store JS code for this code base on the given file."	self storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true.	exceptions notEmpty ifTrue: [exceptions inspect].! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 7/13/2023 02:32'!storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store JS code for this code base on the given file."	self removeVariable: 'interpreterProxy'; removeVariable: 'moduleName'.	FileStream forceNewFileNamed: fileName do: [:stream |		self emitJSCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag]! !!JSCodeGenerator methodsFor: 'public' stamp: 'fm 10/28/2020 23:16'!storeHeaderFor: interpreterClassName onFile: fileName	"We don't use a separate header file for JavaScript"! !!JSCodeGenerator methodsFor: 'utilities'!checkForGlobalUsage: vars in: aJSMethod 	| item |	vars		do: [:var | 			"TPR - why the use of globalsAsSet here instead of globalVariables? 			JMM - globalVariables is not initialized yet, variables is an OrderedCollection, 				globalsAsSet returns variables as needed set"			(self globalsAsSet includes: var)				ifTrue: ["find the set of method names using this global var"					item := globalVariableUsage								at: var								ifAbsent: [globalVariableUsage at: var put: Set new].					"add this method name to that set"					item add: aJSMethod selector]].	aJSMethod referencesGlobalStructMakeZero! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 8/5/2023 19:58'!compileToJSMethodSelector: selector in: aClass	"Compile a method to a JSMethod"	^((Compiler new		parse: (aClass sourceCodeAt: selector)		in: aClass		notifying: nil) 			prepareForVmSideInlinedGenerationBy: self) asCleanedUpParseTree				asTranslationMethodOfClass: self translationMethodClass! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 1/8/2022 09:49'!nilOrBooleanConstantReceiverOf: sendNode	"Answer nil or the boolean constant that is the receiver of the given message send. Used to suppress conditional code when the condition is a translation-time constant."	| val | 	val := self nilOrReducibleValueOf: sendNode receiver.	^((val == true) or: [val == false]) ifTrue: [val].! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 10/13/2023 00:40'!nilOrReducibleValueOf: expr	| val |	generateDeadCode ifTrue:[^nil].	expr isConstant ifTrue: [		^expr value.	] ifFalse: [		expr isVariable ifTrue: [			(#('true' 'false') includes: expr name) ifTrue: [^'true' = expr name ].		] ifFalse: [			expr isSend ifTrue: [				(#(failed successful) includes: expr selector) ifTrue: [^#successful = expr selector ].				(expr selector == #isKindOf: and: [expr receiver isVariable and: [expr receiver name = 'interpreterProxy' and: 				[expr args first printString = 'InterpreterSimulator']]]) ifTrue: [^false].				(methods at: expr selector ifAbsent: []) ifNotNil: [:m |						(m definedAsMacro not						 and: [(m statements collect: [:e | e isLabel not]) size = 1						 and: [m parseTree lastRealStatement isReturn]]) ifTrue: [							^self nilOrReducibleValueOf: m parseTree lastRealStatement expression ]].				(val := self nilOrReducibleValueOf: expr receiver) notNil ifTrue: [					(expr selector == #and: or: [expr selector == #& and: [expr args first hasSideEffect not]]) ifTrue: [						expr args first canBeExpression 							ifFalse: [self halt. ^nil].						^val and: [self nilOrReducibleValueOf: (expr selector == #and: ifTrue: [expr args first lastRealStatement] ifFalse: [expr args first])]					] ifFalse: [						(expr selector == #or: or: [expr selector == #| and: [expr args first hasSideEffect not]]) ifTrue: [							expr args first canBeExpression 								ifFalse: [self halt. ^nil].							^val or: [self nilOrReducibleValueOf: (expr selector == #or: ifTrue: [expr args first lastRealStatement] ifFalse: [expr args first])]						] ifFalse: [							expr selector == #ifTrue:ifFalse: ifTrue: [								val ifTrue: [									expr args first canBeExpression 										ifFalse: [^nil].									^self nilOrReducibleValueOf: expr args first lastRealStatement								] ifFalse: [									expr args first canBeExpression 										ifFalse: [^nil].									^self nilOrReducibleValueOf: expr args last lastRealStatement								]							] ifFalse: [								expr selector == #ifFalse:ifTrue: ifTrue: [									val ifTrue: [										expr args first canBeExpression 											ifFalse: [^nil].										^self nilOrReducibleValueOf: expr args last lastRealStatement									] ifFalse: [										expr args first canBeExpression 											ifFalse: [^nil].										^self nilOrReducibleValueOf: expr args first lastRealStatement									]								] ifFalse: [									^val perform: expr selector withArguments: (expr args collect: [:e | (self nilOrReducibleValueOf: e) ifNil: [^nil]])								]							]						]					]				] ifFalse: [					expr receiver hasSideEffect						ifTrue: [^nil].					(expr selector == #and: or: [expr selector == #& and: [expr args first hasSideEffect not]]) ifTrue: [						expr args first canBeExpression 							ifFalse: [^nil].						val := self nilOrReducibleValueOf: (expr selector == #and: ifTrue: [expr args first lastRealStatement] ifFalse: [expr args first]).						^val == false ifTrue: [false]					] ifFalse: [						(expr selector == #or: or: [expr selector == #| and: [expr args first hasSideEffect not]]) ifTrue: [							expr args first canBeExpression 								ifFalse: [^nil].							val := self nilOrReducibleValueOf: (expr selector == #or: ifTrue: [expr args first lastRealStatement] ifFalse: [expr args first]).							^val == true ifTrue: [true]						]					]								]			]		]	].	^ nil! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 7/25/2023 18:34'!reservedWords	^#(	'arguments'		'break'		'case' 'catch' 'class' 'const' 'continue'		'debugger' 'default' 'delete' 'do'		'else' 'enum' 'eval' 'export' 'extends'		'false' 'finally' 'for' 'function'		'if' 'implements' 'import' 'in' 'instanceof' 'interface'		'let'		'new' 'null'		'package' 'private' 'protected' 'public'		'return'		'static' 'super' 'switch'		'this' 'throw' 'true' 'try' 'typeof'		'var' 'void'		'while' 'with'		'yield')! !!JSCodeGenerator methodsFor: 'utilities' stamp: 'fm 12/27/2021 08:31'!returnPrefixFromVariable: aName	aName = 'class'		ifTrue: [^'sq_class'].	aName = 'in'		ifTrue: [^'in_'].	aName = 'self'		ifTrue: [^'this']. "some primitives just leave the receiver on the stack as a return"	^aName! !!JSCodeGenerator methodsFor: 'error notification' stamp: 'fm 10/19/2023 00:08'!checkClassForNameConflicts: aClass	"Verify that the given class does not have constant, variable, or method names that conflict with	 those of previously added classes. Raise an error if a conflict is found, otherwise just return."	"check for constant name collisions in class pools"	aClass classPool associationsDo:		[:assoc |		(constants includesKey: assoc key asString) ifTrue:			[self error: 'Constant ', assoc key, ' was defined in a previously added class']].	"and in shared pools"	(aClass sharedPools reject: [:pool| pools includes: pool]) do:		[:pool |		pool bindingsDo:			[:assoc |			(constants includesKey: assoc key asString) ifTrue:				[self error: 'Constant ', assoc key, ' was defined in a previously added class']]].	"check for method name collisions"	aClass selectors do:		[:sel |		((methods includesKey: sel) and:			[ | meth |			meth := aClass compiledMethodAt: sel.			meth isAbstract not and: [(meth pragmaAt: #doNotGenerate) isNil]]) ifTrue:				[self error: 'Method ', sel, ' was defined in a previously added class.']]! !!JSCodeGenerator methodsFor: 'private' stamp: 'fm 10/29/2020 18:17'!ifPointerVar: node then: aBlock	(node isSend and: [node selector = #+ or: [node selector = #- and: [node args first isConstant]]]) ifTrue: [		^self ifPointerVar: node receiver then: aBlock].	node isVariable ifTrue: [		(self typeOfVariable: node name) ifNotNil: [:type |			(type includes: $*) ifTrue: [aBlock value: type]]].! !!JSCodeGenerator methodsFor: 'inlining' stamp: 'fm 9/16/2023 10:29'!collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the translator cannot	currently map variable names in inlined C code. The #inline: directive may be	used to override this for cases in which the C code or declarations are harmless.	Methods to be inlined must be small or called from only one place."	| methodsNotToInline callsOf inlineIt nodeCount senderCount sel |	methodsNotToInline := Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf := Dictionary new: methods size * 2.	methods keys do: [ :s | callsOf at: s put: 0 ].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList := Set new: methods size * 2.	inlineReturnTypes := Dictionary new: methods size.	methods do: [ :m | 		inlineIt := #dontCare.		(translationDict includesKey: m selector) ifTrue: [			inlineIt := false.		] ifFalse: [			nodeCount := 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel := node selector.					senderCount := callsOf at: sel ifAbsent: [ nil ].					nil = senderCount ifFalse: [						callsOf at: sel put: senderCount + 1]]].			inlineIt := m extractInlineDirective.  "may be true, false, or #dontCare"		].		inlineIt = false ifTrue: [			methodsNotToInline add: m selector.		] ifFalse: [				inlineList add: m selector.				inlineReturnTypes at: m selector put: m returnType		].	].	callsOf associationsDo: [ :assoc |		((assoc value = 1) and: [(methodsNotToInline includes: assoc key) not]) ifTrue: [			inlineList add: assoc key.		].	].! !!JSCodeGenerator methodsFor: 'inlining' stamp: 'fm 11/12/2020 14:06'!doBasicInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining.	This method does only the basic inlining suitable for both the core VM and plugins - no bytecode inlining etc"	| pass progress max |	inlineFlag ifFalse: [^self].	self collectInlineList.	pass := 0.	max := 12. "More than this is probably due to infinite recursion" 	progress := true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress := false.		pass > max			ifTrue: [self notify: 'too many inlining steps, inlining terminated']			ifFalse: [('Inlining pass ', (pass := pass + 1) printString, '...')						displayProgressAt: Sensor cursorPoint						from: 0 to: methods size						during: [:bar |							(self sortMethods: methods) doWithIndex: [:m :i | "m selector == #arrayValueOf: ifTrue: [self halt]."								bar value: i.								currentMethod := m.								(m tryToInlineMethodsIn: self)									ifTrue: [progress := true]]]]].! !!JSCodeGenerator methodsFor: 'inlining' stamp: 'fm 8/21/2023 17:50'!inlineReturnType: selector	"gets the return type of a given inline selector"	^inlineReturnTypes ifNotNilDo: [ :types | types at: selector ifAbsent: nil ]! !!JSCodeGenerator methodsFor: 'inlining' stamp: 'fm 8/6/2023 14:55'!pruneUnreachableMethods	"Remove any methods that are not reachable. Retain methods needed by the translated classes - see implementors of requiredMethodNames" 		| newMethods |	"add all the exported methods and all the called methods to the dNRML"	methods do: [ :m |		m export ifTrue:[doNotRemoveMethodList add: m selector].		doNotRemoveMethodList addAll: m allCalls].	"build a new dictionary of methods from the collection of all the ones to keep"				newMethods := Dictionary new: doNotRemoveMethodList size.	doNotRemoveMethodList do:[:sel|		methods at: sel ifPresent:[:meth| newMethods at: sel put: meth]].	methods := newMethods! !!JSCodeGenerator methodsFor: 'accessing' stamp: 'fm 9/3/2020 23:50'!exceptions	^exceptions! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 10/29/2020 00:55'!emitInterpreterProxyVersionOn: aStream	aStream		nextPutAll: 'var VM_PROXY_MAJOR = ';		nextPutAll: InterpreterPrimitives vmProxyMajorVersion printString;		cr;		nextPutAll: 'var VM_PROXY_MINOR = ';		nextPutAll: InterpreterPrimitives vmProxyMinorVersion printString;		cr; cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 2/20/2021 20:12'!emitJSCodeOn: aStream doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	self emitJSHeaderOn: aStream.	self emitJSTypesOn: aStream.	self emitJSConstantsOn: aStream.	self emitJSVariablesOn: aStream."'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |"	preparedMethodList doWithIndex: [ :m :i | 		[aStream nextPutAll: (String streamContents: [:s | m emitJSCodeOn: s generator: self. s nextPutAll: ', '])] on: Halt, Error do: [:e | 			"e isResumable ifTrue: [e resumeUnchecked: nil]."			(exceptions at: e signalerContext sender printString ifAbsentPut: [OrderedCollection new]) add: m definingClass name , '>>#' , m selector -> (e printString, ' in ', e signalerContext shortStack) ]]."]."	self emitExportsOn: aStream.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 3/23/2021 18:03'!emitJSConstantsOn: aStream	"Store the global variable declarations on the given stream."	| unused constList node |	unused := constants keys asSet.	methods do: [ :meth |		meth parseTree nodesDo: [ :n |			n isConstant ifTrue: [ unused remove: n name ifAbsent: []]]].	constList := constants keys reject: [ :any | unused includes: any].	constList isEmpty ifTrue: [^self].	aStream nextPutAll: '/*** Constants ***/';		 cr.	constList asSortedCollection do: [ :varName |		node := constants at: varName.		node name isEmpty ifFalse: [			aStream nextPutAll: 'const '.			aStream nextPutAll: node name.			aStream nextPutAll: ' = '.			aStream nextPutAll: (self jsLiteralFor: node value).			aStream nextPut: $;.			aStream cr		].	].	aStream cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 9/21/2023 01:00'!emitJSFunctionsOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/*** Functions ***/function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.longs ? obj.longs.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : obj.longs ? obj.longs.length * 8 : typeof obj === "bigint" ? ((obj >= 0 ? obj : -obj).toString(16).length + 1) >>> 1 : 0 }function BYTESOF(obj) {	if (obj.bytes) return obj.bytes;	if (typeof obj === "bigint") {		let asString = (obj >= 0 ? obj : -obj).toString(16);		const length = (asString.length + 1) >>> 1;		asString = asString.padStart(length << 1, "0");		const bytes = new Uint8Array(length);		for (let i = length - 1, j = 0; i >= 0; i--)			bytes[i] = parseInt(asString.slice(j, j += 2), 16);		return bytes;	}}function CHECKEDINTEGER(val) {	return typeof val === "number" ? val : PrimitiveFailed.signal()}function CHECKEDBOOLEAN(val) {	return typeof val === "boolean"  ? val : PrimitiveFailed.signal()}function UBOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a | b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(a - 2147483648 | (b >= 2147483648 ? b - 2147483648 : b)) + 2147483648 :		(b >= 2147483648 ? (b - 2147483648 | a) + 2147483648 : b | a);	}	//unsigned bit orfunction UBORM(a, maskedB) {	a = a >>> 0;	return (a >= 2147483648 ? a - 2147483648 | maskedB : a | maskedB) + 2147483648;	}	//unsigned bit orfunction UBORS(a, smallB) {	if ((a | 0) === a)		return a | smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 | smallB) + 2147483648 : a | smallB;	}	//unsigned bit orfunction UBAND(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a & b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? (b - 2147483648 & a - 2147483648) + 2147483648 : b & a - 2147483648) :		(b >= 2147483648 ? (b - 2147483648 & a) : b & a);	}	//unsigned bit andfunction UBANDM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 & maskedB) + 2147483648 : a & maskedB;	}	//unsigned bit andfunction UBANDS(a, smallB) {	if ((a | 0) === a)		return a & smallB;	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 & smallB : a & smallB;	}	//unsigned bit andfunction UBXOR(a, b) {	if ((a | 0) === a && (b | 0) === b)		return a ^ b;	a = a >>> 0; b = b >>> 0;	return a >= 2147483648 ?		(b >= 2147483648 ? b - 2147483648 ^ a - 2147483648 : (b ^ a - 2147483648) + 2147483648) :		(b >= 2147483648 ? (b - 2147483648 ^ a) + 2147483648 : b ^ a);	}	//unsigned bit xorfunction UBXORM(a, maskedB) {	a = a >>> 0;	return a >= 2147483648 ? a - 2147483648 ^ maskedB : (a ^ maskedB) + 2147483648;	}	//unsigned bit xorfunction UBXORS(a, smallB) {	if ((a | 0) === a)		return a ^ smallB;	a = a >>> 0;	return a >= 2147483648 ? (a - 2147483648 ^ smallB) + 2147483648 : a ^ smallB;	}	//unsigned bit xorfunction MOD(a, b) {	return a - Math.trunc(a / b) * b >>> 0; }   // signed modulusfunction SHL(a, b) {	return b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0 }function SHR(a, b) {	return b > 31 ? 0 : a >>> b }function SHIFT(a, b) {	b = b | 0;	return b < 0 ? (b < -31 ? 0 : a >>> -b ) : (b > 31 ? (a === 1 && b === 32 ? 4294967296 : 0) : a << b >>> 0) }function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }function CPTR_ADD(p, n) { return new Int8Array(p.buffer, p.byteOffset + n); }function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }function PTR_SUB(p, n) { return new Int32Array(p.buffer, p.byteOffset - n * 4); }function CPTR_SUB(p, n) { return new Int8Array(p.buffer, p.byteOffset - n); }function FPTR_SUB(p, n) { return new Float32Array(p.buffer, p.byteOffset - n * 4); }function PTR_PTRSUB(p1, p2) { return p1.buffer === p2.buffer ? p1.byteOffset - p2.byteOffset : 0 }'! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 7/14/2023 15:05'!emitJSHeaderOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: (VMMaker headerNotice copyReplaceAll: ' C ' with: ' JavaScript ').	aStream nextPutAll: ' */';cr.	aStream nextPutAll: (self fileHeaderVersionStampForSourceClass: vmClass).	self emitInterpreterProxyVersionOn: aStream.	self emitJSFunctionsOn: aStream.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 9/11/2023 14:39'!emitJSTestBlock: aBlockNode on: aStream	"Emit JS code for the given block node to be used as a loop test."	aBlockNode statements size > 1 ifTrue: [		aBlockNode emitJSCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aBlockNode statements first emitJSCodeAsArgumentOn: aStream level: 0 generator: self.	].! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 4/2/2021 10:10'!emitJSVariablesOn: aStream 	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection		do: [:var | 	| varString varDecl |			varString := var asString.			aStream nextPutAll: 'let ', varString.			varDecl := variableDeclarations at: varString ifAbsent: [''].			(varDecl includes: $=)				ifTrue: [ | const |					const := ((varDecl copyAfter: $=) replaceAll: ${ with: $[) replaceAll: $} with: $].					aStream nextPutAll: ' =', const]				ifFalse: [(varDecl includesAnyOf: '*[')					ifTrue: [(varDecl includes: $[)						ifTrue: [ | size |							size := (varDecl copyAfter: $[) copyUpTo: $].							size ifEmpty: [self halt].							aStream nextPutAll: ' = new Array(', size, ')']]					ifFalse: [aStream nextPutAll: ' = 0']].			aStream nextPutAll: ';'; cr].	aStream cr.! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 9/19/2023 18:14'!fileHeaderVersionStampForSourceClass: sourceClass	"Answer a suitable version stamp to include in the header."	|  slangDescription sourceDescription |	slangDescription := self class monticelloDescriptionFor: self class.	sourceClass ifNotNil:		[sourceDescription := [sourceClass monticelloDescription]								on: MessageNotUnderstood								do: [:ex| [self class monticelloDescriptionFor: sourceClass] on: Error do: [:e |]]].	^String streamContents:		[:s|		s nextPutAll: '/* Automatically generated by\	' withCRs.		s nextPutAll: slangDescription.		sourceDescription ifNotNil:			[s nextPutAll: '\   from\	' withCRs; nextPutAll: (sourceDescription copyReplaceAll: '\' withCRs with: '\	' withCRs)].		s cr; nextPutAll: ' */'; cr]! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 8/4/2023 21:30'!isNonArgumentImplicitReceiverVariableName: aString	^(self typeOfVariable: aString) == #implicit	    or: [self pluginName = aString or: [vmClass			ifNil: [#('interpreterProxy' 'self') includes: aString]	 		ifNotNil: [vmClass isNonArgumentImplicitReceiverVariableName: aString]]]! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 5/11/2021 19:17'!typeOfArgument: argIndex in: selector	| method |	method := methods at: selector ifAbsent: [^nil].	^method declarations at: (method args at: argIndex).! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 8/22/2023 22:58'!typeOfExpression: expr "<String>" 	| varName |	(expr isVariable or: [expr isAssignment]) ifTrue: [		varName := expr isVariable ifTrue: [expr name] ifFalse: [expr variable name].		scopeStack reverseDo:			[:dict|			dict at: varName ifPresent: [:t |				^(t beginsWith: 'void') ifFalse: [(t allButLast: varName size) withoutTrailingBlanks]]		].		^((variableDeclarations at: varName ifAbsent: [^nil]) beginsWith: 'void') ifFalse: [			((variableDeclarations at: varName) allButLast: varName size) withoutTrailingBlanks]	] ifFalse: [		(self nilOrReducibleValueOf: expr) ifNotNil: [:val |			val isInteger ifTrue: [				(val < 4294967296 and: [val >= 0]) ifTrue: [^'usqInt'].				(val < 2147483648 and: [val >= -2147483648]) ifTrue: [					(val < 32768 and: [val >= -32768]) ifTrue: [						(val < 128 and: [val >= -128]) ifTrue: [							^'char'						] ifFalse: [							^'short'].					] ifFalse: [						^'sqInt']]].			val isFloat ifTrue: [				^(Float fromIEEE32Bit: val asIEEE32BitWord) = val ifTrue: ['float'] ifFalse: ['double']]].		expr isSend ifTrue: [			(self methodNamed: expr selector) ifNotNil: [:m | m returnType ifNotNil: [:t | ^(t beginsWith: 'void') ifFalse: [t]]]]	].	^nil! !!JSCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 8/17/2023 18:49'!typeOfVariable: varName "<String>" 	scopeStack reverseDo:		[:dict|		((dict includesKey: varName) and: [((dict at: varName) beginsWith: 'void') not]) ifTrue:			[^dict at: varName]].	^variableDeclarations at: varName ifAbsent: nil! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/6/2023 00:02'!emit: receiver questionMark: firstArg colon: secondArg on: aStream 	| firstVal secondVal |	(secondVal := self nilOrReducibleValueOf: secondArg) == false ifTrue: [		self emitJSExpression: receiver on: aStream.		(self nilOrReducibleValueOf: firstArg) == true ifFalse: [			aStream nextPutAll: ' && '.			self emitJSExpression: firstArg on: aStream.		]	] ifFalse: [		(firstVal := self nilOrReducibleValueOf: firstArg) == true ifTrue: [			aStream nextPut: $(.			self emitJSExpression: receiver on: aStream.			aStream nextPutAll: ' || '.			self emitJSExpression: secondArg on: aStream.			aStream nextPut: $).		] ifFalse: [			secondVal == true ifTrue: [				firstVal == false ifFalse: [					aStream nextPut: $( ].				self generateNot: (TSendNode new							setSelector: #not receiver: receiver arguments: #())					on: aStream indent: 0.				firstVal == false ifFalse: [					aStream nextPutAll: ' || '.					self emitJSExpression: firstArg on: aStream.					aStream nextPut: $) ].			] ifFalse: [				firstVal == false ifTrue: [					self generateNot: (TSendNode new							setSelector: #not receiver: receiver arguments: #())						on: aStream indent: 0.					aStream nextPutAll: ' && '.					self emitJSExpression: secondArg on: aStream.				] ifFalse: [					self emitJSExpression: receiver on: aStream.					aStream nextPutAll: ' ? '.					self emitJSExpression: firstArg on: aStream.					aStream nextPutAll: ' : '.					self emitJSExpression: secondArg on: aStream				]			]		]	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/13/2023 00:51'!generateAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode args first)				ifNil:					[msgNode args first hasSideEffect ifTrue: [						aStream nextPutAll: '(function() {const _a = '.						self emitJSExpression: msgNode receiver on: aStream.						aStream nextPutAll: '; const _b = '.						self emitJSExpression: msgNode args first on: aStream.						aStream nextPutAll: '; return _a && _b})()'					] ifFalse: [						self emitJSExpression: msgNode receiver on: aStream.						aStream nextPutAll: ' && '.						self emitJSExpression: msgNode args first on: aStream]]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					const ifTrue: [						self emitJSExpression: msgNode receiver on: aStream					] ifFalse: [						msgNode receiver hasSideEffect ifTrue: [							self emitJSExpression: msgNode receiver on: aStream.							aStream nextPutAll: ' && '						].						aStream nextPutAll: 'false'					]]]		ifNotNil: [:const |			const ifTrue: [self emitJSExpression: msgNode args first on: aStream]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:09'!generateAsInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | 0)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:47'!generateAsUnsignedInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt.	aStream nextPutAll: '('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '>>>0)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/16/2023 15:15'!generateAt: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arrayNode indexNode coerceTo |	arrayNode := msgNode receiver.	indexNode := msgNode args first.	[arrayNode isSend and: [arrayNode selector = #+  or: [arrayNode selector = #-]]] whileTrue: [		indexNode := TSendNode new setSelector: arrayNode selector receiver: indexNode arguments: {arrayNode args first} isBuiltInOp: true.		arrayNode := arrayNode receiver.	].	(arrayNode isSend and: [arrayNode selector = #cCoerce:to: and: [arrayNode args first isVariable]]) ifTrue: [		coerceTo := (arrayNode args second value) copyWithout: $ .		arrayNode := arrayNode args first.		aStream nextPutAll: '('].	(self isOneBasedArray: arrayNode name in: currentMethod) ifTrue: [		indexNode := TSendNode new setSelector: #- receiver: indexNode arguments: {TConstantNode new setValue: 1} isBuiltInOp: true.	].	self emitJSExpression: arrayNode on: aStream.	aStream nextPut: $[.	indexNode emitJSCodeAsExpressionOn: aStream level: level + 1 generator: self.	aStream nextPut: $].	coerceTo ifNotNil: [		coerceTo = 'int*' ifFalse: [self halt].		aStream nextPutAll: '|0)'].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/17/2023 18:24'!generateAtPut: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arrayNode indexNode argNode |	arrayNode := msgNode receiver.	indexNode := msgNode args first.	argNode := msgNode args last.	(argNode isSend and: [(argNode selector = #+  or: [argNode selector = #-]) and: 	[argNode receiver isSend and: [argNode receiver selector == #at: and:	[(indexNode isSameAs: argNode receiver args first) and:	[argNode receiver receiver isSameAs: arrayNode]]]]]) ifTrue: [		self generateAt: (TSendNode new setSelector: #at: receiver: arrayNode arguments: {indexNode} isBuiltInOp: true) on: aStream indent: level.		^(argNode args first isConstant and: [argNode args first value = 1])				ifTrue: [					aStream nextPutAll: argNode selector, argNode selector]				ifFalse: [					aStream nextPutAll: ' ', argNode selector, '= '.					argNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self]	].	[arrayNode isSend and: [arrayNode selector = #+  or: [arrayNode selector = #-]]] whileTrue: [		indexNode := TSendNode new setSelector: arrayNode selector receiver: indexNode arguments: {arrayNode args first} isBuiltInOp: true.		arrayNode := arrayNode receiver.	].	(arrayNode isSend and: [arrayNode selector = #cCoerce:to: and: [arrayNode args first isVariable]]) ifTrue: [		arrayNode := arrayNode args first].		(self isOneBasedArray: arrayNode name in: currentMethod) ifTrue: [		indexNode := TSendNode new setSelector: #- receiver: indexNode arguments: {TConstantNode new setValue: 1} isBuiltInOp: true.	].	self emitJSExpression: arrayNode on: aStream.	aStream nextPut: $[.	indexNode emitJSCodeAsExpressionOn: aStream level: level + 1 generator: self.	aStream nextPut: $].	aStream nextPutAll: ' = '.	self emitJSExpression: argNode on: aStream! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 02:05'!generateBaseHeaderSize: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'BASE_HEADER_SIZE'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/17/2023 23:47'!generateBitAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		val >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBANDM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (val - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBANDS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: val printString;				nextPutAll: ')'.		].	] ifNil: [		(self nilOrReducibleValueOf: rcvr) ifNotNil: [:val |			val >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBANDM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (val - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBANDS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: val printString;					nextPutAll: ')'.			].		] ifNil: [			aStream nextPutAll: 'UBAND('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/24/2021 12:54'!generateBitClear: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt: 'this cannot work'.	aStream nextPutAll: '(('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ') - '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: '|0))'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:30'!generateBitInvert32: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: '(~('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ') >>> 0)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/17/2023 23:19'!generateBitOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	|  rcvr arg |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		val >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBORM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (val - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBORS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: val printString;				nextPutAll: ')'.		].	] ifNil: [		(self nilOrReducibleValueOf: rcvr) ifNotNil: [:val |			val >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBORM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (val - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBORS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: val printString;					nextPutAll: ')'.			].		] ifNil: [			aStream nextPutAll: 'UBOR('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/17/2023 23:54'!generateBitShift: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	arg := msgNode args first.	rcvr := msgNode receiver.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		"bit shift amount is a constant"		val < 0 ifTrue: [			val > -32 ifTrue: [				"skip unneeded coercion to unsigned"				(rcvr isSend and: [rcvr selector = #cCoerce:to: and: [rcvr args second value = 'unsigned']])					ifTrue: [self emitJSExpression: rcvr args first on: aStream]					ifFalse: [self emitJSExpression: rcvr on: aStream].				aStream nextPutAll: ' >>> ';					nextPutAll: val negated printString.			] ifFalse: [				self error: 'cannot shift by more than 31'].		] ifFalse: [			"skip unneeded coercion to unsigned"			(rcvr isSend and: [rcvr selector = #cCoerce:to: and: [rcvr args second value = 'unsigned']])				ifTrue: [self emitJSExpression: rcvr args first on: aStream]				ifFalse: [self emitJSExpression: rcvr on: aStream].			aStream nextPutAll: ' << ';				nextPutAll: val printString;				nextPutAll: ' >>> 0'.		].		] ifNil: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHIFT('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/17/2023 23:49'!generateBitXor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		val >= 2147483648 ifTrue: [			aStream nextPutAll: 'UBXORM('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: (val - 2147483648) printString;				nextPutAll: ')'.		] ifFalse: [			aStream nextPutAll: 'UBXORS('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', ';				nextPutAll: val printString;				nextPutAll: ')'.		].	] ifNil: [		(self nilOrReducibleValueOf: rcvr) ifNotNil: [:val |			val >= 2147483648 ifTrue: [				aStream nextPutAll: 'UBXORM('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: (val - 2147483648) printString;					nextPutAll: ')'.			] ifFalse: [				aStream nextPutAll: 'UBXORS('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: ', ';					nextPutAll: val printString;					nextPutAll: ')'.			].		] ifNil: [			aStream nextPutAll: 'UBXOR('.			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ', '. 			self emitJSExpression: arg on: aStream.			aStream nextPutAll: ')'.		]	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/15/2023 17:27'!generateBytesPerWord: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self pluginName = 'LargeIntegers' ifTrue: [aStream nextPut: $8] ifFalse: [self halt]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/4/2023 23:10'!generateCCoercion: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr cType |.	expr := msgNode args first.	cType := msgNode args second value copyReplaceAll: ' *' with: '*'.	(expr isSend and: [expr receiver name = 'interpreterProxy' and: [expr selector = #firstIndexableField: or: [expr selector = #arrayValueOf:]]]) ifTrue: [		((cType beginsWith: 'unsigned char*') or: [cType beginsWith: 'char*'])			ifTrue: [aStream nextPutAll: 'BYTESOF('. self emitJSExpression: expr args first on: aStream. ^aStream nextPut: $)].		self emitJSExpression: expr args first on: aStream.		((cType beginsWith: 'unsigned int*') or: [cType beginsWith: 'unsigned*'])			ifTrue: [^ aStream nextPutAll: '.words'].		(cType beginsWith: 'int*')			ifTrue: [^ aStream nextPutAll: '.wordsAsInt32Array()'].		(cType beginsWith: 'short*')			ifTrue: [^ aStream nextPutAll: '.wordsAsInt16Array()'].		(cType beginsWith: 'float*')			ifTrue: [^ aStream nextPutAll: '.wordsAsFloat32Array()'].		(cType beginsWith: 'double*')			ifTrue: [^ aStream nextPutAll: '.wordsAsFloat64Array()'].		self halt: 'need to handle ', cType.	] ifFalse: [		(#('int' 'long' 'sqInt' 'sqLong') includes: cType) ifTrue: [			aStream nextPutAll: '('.			self emitJSExpression: expr on: aStream.			^aStream nextPutAll: '|0)'].		(#('unsigned int' 'unsigned' 'unsigned long' 'usqLong' 'usqInt') includes: cType) ifTrue: [				aStream nextPutAll: '('.				self emitJSExpression: expr on: aStream.				^ aStream nextPutAll: '>>>0)'].		((#('double' 'float') includes: cType) or: ['sqInt (*)(*)'match: cType])			ifFalse: [				self ifPointerVar: expr then: [:type | | t | 					expr isSend ifTrue: [						^expr emitJSPointerArithmetic: type on: aStream level: level generator: self type: cType top: true.					].					self emitJSExpression: expr on: aStream.					^(t := (type copyReplaceAll: ' *' with: '*') first: cType size) = cType 						ifFalse: [							(cType beginsWith: 'char*')								ifTrue: [^ aStream nextPutAll: '.wordsAsInt8Array()'].							((cType beginsWith: 'int*') or: [cType beginsWith: 'sqInt*'])								ifTrue: [^ aStream nextPutAll: '.wordsAsInt32Array()'].							(cType beginsWith: 'short*')								ifTrue: [^ aStream nextPutAll: '.wordsAsInt16Array()'].							(cType beginsWith: 'float*')								ifTrue: [^ aStream nextPutAll: '.wordsAsFloat32Array()'].							(cType beginsWith: 'double*')								ifTrue: [^ aStream nextPutAll: '.wordsAsFloat64Array()'].							(cType beginsWith: 'void*')								ifFalse: [Warning signal: 'here'. self halt: t, ' cannot be coerced to ', cType]]]. 				self halt: cType].		self emitJSExpression: expr on: aStream.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/17/2023 18:16'!generateCheckIsBoolean: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'if (typeof '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.valueOf() !!== "boolean") throw Object.create(PrimitiveFailed).setPayload(1)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "bytes" ? ('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "words" ? PrimitiveFailed.signal() : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsUint8Array()) : BYTESOF('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:40'!generateCheckIsFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if (!!'.		self generateIsFloatObject: msgNode on: aStream indent: level.		aStream nextPutAll: ') throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [		self halt: 'CHECKEDFLOAT not implemented!!'.		aStream nextPutAll: 'CHECKEDFLOAT('.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: ')'	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:40'!generateCheckIsInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if (!!'.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ') throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [		aStream nextPutAll: 'CHECKEDINTEGER('.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: ')'.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:12'!generateCheckIsNotNumber: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: 'if '.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' throw Object.create(PrimitiveFailed).setPayload(1)'.	] ifFalse: [self halt.		aStream nextPutAll: 'if (typeof '.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: '.valueOf() === "number") throw Object.create(PrimitiveFailed).setPayload(1)'	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsShorts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "shorts" ? ('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "words" ? PrimitiveFailed.signal() : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsUint16Array()) : '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.shorts'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsSignedInts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsInt32Array() : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsSignedShorts: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.wordsAsInt16Array() : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateCheckIsWords: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words" ? '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.words : PrimitiveFailed.signal()'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:41'!generateCheckedBoolean: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr |	expr := msgNode args first.	expr isVariable ifTrue: [		aStream nextPutAll: '(typeof ';			nextPutAll: expr name;			nextPutAll: ' === "boolean" ? ';			nextPutAll: expr name;			nextPutAll: ' : PrimitiveFailed.signal())'	] ifFalse: [		(expr isSend and: [expr selector == #not]) ifTrue: [			aStream nextPutAll: '!!'.			self generateCheckedBoolean: (msgNode copyTree arguments: {expr receiver}) on: aStream indent: level		] ifFalse: [			aStream nextPutAll: 'CHECKEDBOOLEAN('.			self emitJSExpression: expr on: aStream.			aStream nextPutAll: ')'		].	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:00'!generateCheckedFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsFloatObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: msgNode args first name;			nextPutAll: '.valueOf() : PrimitiveFailed.signal()';			nextPutAll: ')'	] ifFalse: [self halt.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:34'!generateCheckedInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| expr |	expr := msgNode args first.	expr isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: expr name;			nextPutAll: ' : PrimitiveFailed.signal())'	 ] ifFalse: [		aStream nextPutAll: 'CHECKEDINTEGER('.		self emitJSExpression: expr on: aStream.		aStream nextPutAll: ')'	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 20:59'!generateCheckedNotNumber: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isVariable ifTrue: [		aStream nextPutAll: '('.		self generateIsIntegerObject: msgNode on: aStream indent: level.		aStream nextPutAll: ' ? ';			nextPutAll: 'PrimitiveFailed.signal() : ';			nextPutAll: msgNode args first name;			nextPutAll: ')'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 17:14'!generateCheckedPositive32Bit: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPut: $(;			nextPutAll: varName;			nextPutAll: ' >>> 0) === ';			nextPutAll: varName;			nextPutAll: '.valueOf() ? ';			nextPutAll: varName;			nextPutAll: ' : PrimitiveFailed.signal()'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:10'!generateClassArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Array'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassBitmap: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Bitmap'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassByteArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._ByteArray'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:11'!generateClassLargeNegativeInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._LargeNegativeInteger'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassLargePositiveInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._LargePositiveInteger'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassPoint: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._Point'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/26/2020 19:12'!generateClassString: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'SmalltalkGlobals._String'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:31'!generateDivide: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| rcvr arg divisor |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	msgNode selector == #/ ifTrue: [		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		^self emitJSExpression: arg on: aStream].	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor := arg value) isInteger and:	 [divisor isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.	] ifFalse: [		"use float divide and coerce to integer"		aStream nextPutAll: 'Math.trunc('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/11/2023 14:38'!generateDoWhileFalse: msgNode on: aStream indent: level	"Generate do {stmtList} while(!!(cond))"	| testStmt newStatements |	testStmt := msgNode receiver lastRealStatement.	newStatements := msgNode receiver statements copyWithout: testStmt.	newStatements isEmpty ifTrue: [		newStatements := {TVariableNode new setName: 'nil'}].	msgNode receiver setStatements: newStatements.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while(!!('.	testStmt emitJSCodeAsArgumentOn: aStream level: 0 generator: self.	aStream nextPutAll: '))'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/11/2023 14:38'!generateDoWhileTrue: msgNode on: aStream indent: level	"Generate do {stmtList} while(cond)"	| testStmt newStatements |	testStmt := msgNode receiver lastRealStatement.	newStatements := msgNode receiver statements copyWithout: testStmt.	newStatements isEmpty ifTrue: [		newStatements := {TVariableNode new setName: 'nil'}].	msgNode receiver setStatements: newStatements.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while('.	testStmt emitJSCodeAsArgumentOn: aStream level: 0 generator: self.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 12:44'!generateEqual: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| argNode test |	argNode :=  msgNode args first.	"quick test for nil, true, false"	argNode isInterpreterProxyConstant ifTrue: [		test := #(' === nil' ' === true' ' === false') at: (#(nilObject trueObject falseObject) indexOf: argNode selector).		self emitJSExpression: msgNode receiver on: aStream.		^aStream nextPutAll: test].	"cannot compare pointers to 0"	(argNode isConstantNull or: [argNode isConstantZero and: [self isPointer: msgNode receiver]]) ifTrue: [		aStream nextPutAll: '!!'.		^self emitJSExpression: msgNode receiver on: aStream].	(argNode isConstantZero and: [msgNode receiver isSend and: [msgNode receiver selector == #-]]) ifTrue: [		self emitJSExpression: msgNode receiver receiver on: aStream.		aStream nextPutAll: ' === '.		self emitJSExpression: msgNode receiver args first on: aStream.	] ifFalse: [		self emitJSExpression: msgNode receiver on: aStream.		aStream nextPutAll: ' === '.		self emitJSExpression: msgNode args first on: aStream.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/29/2020 18:42'!generateFailed: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'false'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:36'!generateFloatObjectOf: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg |	arg := msgNode args first.	arg isConstant ifTrue: [		arg value isFloat ifFalse: [self halt].		arg value asFloat JSstoreOn: aStream	] ifFalse: [		arg isVariable ifTrue: [			aStream nextPutAll: 'typeof ';				nextPutAll: arg name;				nextPutAll: '.valueOf() !!== "number" ? PrimitiveFailed.signal() : ((';				nextPutAll: arg name;				nextPutAll: '.valueOf() | 0 === ';				nextPutAll: arg name;				nextPutAll: '.valueOf()) || Number.isSafeInteger(';				nextPutAll: arg name;				nextPutAll: ') ? new Float(';				nextPutAll: arg name;				nextPutAll: ') : ';				nextPutAll: arg name;				nextPutAll: '.valueOf())'		] ifFalse: [			(arg isSend and: [arg selector == #asFloat]) ifTrue: [				aStream nextPutAll: 'new Float('.				self emitJSExpression: arg receiver on: aStream.				aStream nextPutAll: ')'.			] ifFalse: [				self halt: 'CHECKEDFLOAT not implemented!!'.				aStream nextPutAll: 'new Float(CHECKEDFLOAT('.				self emitJSExpression: arg on: aStream.				aStream nextPutAll: '))'.			]		].	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/22/2023 00:43'!generateIfFalse: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| newVarName usedVars stmLists |	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode receiver rightmostSide)				ifNil:					[msgNode receiver canBeExpression ifFalse: [							(msgNode receiver isSend and: [(stmLists := msgNode receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [								usedVars := self globalsAsSet copy.								usedVars addAll: currentMethod args; addAll: currentMethod locals.								newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.								stmLists do: [:stmtList | | lastRealStatement |										lastRealStatement := stmtList lastRealStatement.										stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 											(TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: lastRealStatement)].								aStream nextPutAll: 'let ';									nextPutAll: newVarName;									nextPut: $;;									cr.								msgNode receiver									isExpression: false;									emitJSCodeOn: aStream level: level generator: self.								aStream nextPut: $;;									cr.								msgNode receiver: (TVariableNode new setName: newVarName).							] ifFalse: [self halt].						].					msgNode args last isLeafStmtListNode ifTrue: [						^msgNode receiver emitJSCodeOn: aStream level: level generator: self.					].					aStream nextPutAll: 'if ('.					self generateNot: (TSendNode new							setSelector: #not receiver: msgNode receiver arguments: #())						on: aStream indent: level + 1.					aStream nextPutAll: ') {'; cr.					msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.					level timesRepeat: [aStream tab].					aStream nextPut: $}]				ifNotNil:					[:const |					((const == true) or: [const == false]) ifFalse: [self halt].					msgNode receiver emitJSCodeOn: aStream level: level - 1 generator: self.					const ifFalse:						[msgNode args last emitJSCodeOn: aStream level: level - 1 generator: self]]]		ifNotNil:			[:const |			const ifFalse:				[msgNode args last emitJSCodeOn: aStream level: level - 1 generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/26/2021 19:51'!generateIfFalseAsArgument: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			 msgNode receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.			 aStream crtab: level + 1; nextPutAll: ' ? 0 : '.			 msgNode args last emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			 aStream crtab: level + 1; nextPut: $)]		ifNotNil:			[:const|			const ifFalse:				[msgNode args last emitJSCodeAsArgumentOn: aStream level: level generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/2/2023 00:13'!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| newVarName usedVars stmLists a1 a2 |	msgNode args first isLeafStmtListNode		ifTrue: [^self generateIfTrue: (TSendNode new												setSelector: #ifTrue:												receiver: msgNode receiver 												arguments: {msgNode args last}) on: aStream indent: level].	msgNode args last isLeafStmtListNode		ifTrue: [^self generateIfFalse: (TSendNode new												setSelector: #ifFalse:												receiver: msgNode receiver 												arguments: {msgNode args first}) on: aStream indent: level].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode receiver rightmostSide)				ifNil:					[(self tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level) ifFalse:						[						(msgNode args first canBeExpression and: 						[msgNode args last canBeExpression and: 						[(a1 := msgNode args first lastRealStatement) isAssignment and: 						[(a2 := msgNode args last lastRealStatement) isAssignment and: 						[a1 variable name = a2 variable name]]]]) ifTrue: [							a1 variable emitJSCodeAsArgumentOn: aStream level: level generator: self.							aStream nextPutAll: ' = '.							^self emit: msgNode receiver questionMark: a2 expression colon: a1 expression on: aStream.						].						msgNode receiver canBeExpression ifFalse: [							(msgNode receiver isSend and: [(stmLists := msgNode receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [								usedVars := self globalsAsSet copy.								usedVars addAll: currentMethod args; addAll: currentMethod locals.								newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.								stmLists do: [:stmtList | | lastRealStatement |										lastRealStatement := stmtList lastRealStatement.										stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 											(TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: lastRealStatement)].								aStream nextPutAll: 'let ';									nextPutAll: newVarName;									nextPut: $;;									cr.								msgNode receiver									isExpression: false;									emitJSCodeOn: aStream level: level generator: self.								aStream nextPut: $;;									cr.								msgNode receiver: (TVariableNode new setName: newVarName).							] ifFalse: [self halt].						].						aStream nextPutAll: 'if ('.						msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.						aStream nextPutAll: ') {'; cr.						msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.						aStream tab: level; nextPut: $}; nextPutAll: ' else {'; cr.						msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.						aStream tab: level; nextPut: $}]]				ifNotNil:					[:const |					((const == true) or: [const == false]) ifFalse: [self halt].					msgNode receiver emitJSCodeOn: aStream level: level - 1 generator: self.					 (const ifTrue: [msgNode args last] ifFalse: [msgNode args first])						emitJSCodeOn: aStream level: level - 1 generator: self]]		ifNotNil:			[:const |			 (const ifTrue: [msgNode args last] ifFalse: [msgNode args first])				emitJSCodeOn: aStream level: level - 1 generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/16/2023 21:43'!generateIfFalseIfTrueAsArgument: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isNilStmtListNode		ifTrue: [^self generateIfTrueAsArgument: (msgNode copy arguments: {msgNode args last}) on: aStream indent: level].	msgNode args last isNilStmtListNode		ifTrue: [^self generateIfFalseAsArgument: (msgNode copy arguments: {msgNode args first}) on: aStream indent: level].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			msgNode receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.						(msgNode args last isLeafStmtListNode and: 			[(self nilOrReducibleValueOf: msgNode args last lastRealStatement) == true]) ifTrue: [				aStream nextPutAll: ' || '.				msgNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self.				^aStream nextPut: $)].			(msgNode args first isLeafStmtListNode and: 			[(self nilOrReducibleValueOf: msgNode args first lastRealStatement) == false]) ifTrue: [				aStream nextPutAll: ' && '.				msgNode args last emitJSCodeAsArgumentOn: aStream level: level generator: self.				^aStream nextPut: $)].			aStream crtab: level + 1; nextPut: $?; space.			msgNode args last emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream crtab: level + 1; nextPut: $:; space.			msgNode args first emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream nextPut: $)]		ifNotNil:			[:const|			(const				ifTrue: [msgNode args last]				ifFalse: [msgNode args first])					emitJSCodeAsArgumentOn: aStream level: level generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/22/2023 00:42'!generateIfTrue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| newVarName usedVars stmLists |	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode receiver rightmostSide)				ifNil:					[msgNode receiver canBeExpression ifFalse: [							(msgNode receiver isSend and: [(stmLists := msgNode receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [								usedVars := self globalsAsSet copy.								usedVars addAll: currentMethod args; addAll: currentMethod locals.								newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.								stmLists do: [:stmtList | | lastRealStatement |										lastRealStatement := stmtList lastRealStatement.										stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 											(TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: lastRealStatement)].								aStream nextPutAll: 'let ';									nextPutAll: newVarName;									nextPut: $;;									cr.								msgNode receiver									isExpression: false;									emitJSCodeOn: aStream level: level generator: self.								aStream nextPut: $;;									cr.								msgNode receiver: (TVariableNode new setName: newVarName).							] ifFalse: [								(msgNode receiver receiver isSend and: 								[(stmLists := msgNode receiver receiver stmtListsWithTerminalLocalReturns) notEmpty and:								[msgNode receiver args allSatisfy: [:arg | arg canBeExpression]]]) ifTrue: [									usedVars := self globalsAsSet copy.									usedVars addAll: currentMethod args; addAll: currentMethod locals.									newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.									stmLists do: [:stmtList | | lastRealStatement |											lastRealStatement := stmtList lastRealStatement.											stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 												(TAssignmentNode new 													setVariable: (TVariableNode new setName: newVarName) 													expression: (TSendNode new 															setSelector: msgNode receiver selector															receiver: lastRealStatement															arguments: (msgNode receiver args collect: [:arg | arg copy])))].									aStream nextPutAll: 'let ';										nextPutAll: newVarName;										nextPut: $;;										cr.									msgNode receiver receiver										isExpression: false;										emitJSCodeOn: aStream level: level generator: self.									aStream nextPut: $;;										cr.									msgNode receiver: (TVariableNode new setName: newVarName).								] ifFalse: [self halt].							].						].					msgNode args first isLeafStmtListNode ifTrue: [						^msgNode receiver emitJSCodeOn: aStream level: level generator: self.					].					aStream nextPutAll: 'if ('.					msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.					aStream nextPutAll: ') {'; cr.					msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.					level timesRepeat: [ aStream tab ].					aStream nextPut: $}]				ifNotNil:					[:const |					((const == true) or: [const == false]) ifFalse: [self halt].					msgNode receiver emitJSCodeOn: aStream level: level - 1 generator: self.					const ifTrue:						[msgNode args first emitJSCodeOn: aStream level: level - 1 generator: self]]]		ifNotNil:			[:const |			const ifTrue:				[msgNode args first emitJSCodeOn: aStream level: level - 1 generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/2/2023 00:12'!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| newVarName usedVars stmLists a1 a2 |	msgNode args first isLeafStmtListNode		ifTrue: [^self generateIfFalse: (TSendNode new												setSelector: #ifFalse:												receiver: msgNode receiver 												arguments: {msgNode args last}) on: aStream indent: level].	msgNode args last isLeafStmtListNode		ifTrue: [^self generateIfTrue: (TSendNode new												setSelector: #ifTrue:												receiver: msgNode receiver 												arguments: {msgNode args first}) on: aStream indent: level].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode receiver rightmostSide)				ifNil:					[(self tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level) ifFalse:						[						(msgNode args first canBeExpression and: 						[msgNode args last canBeExpression and: 						[(a1 := msgNode args first lastRealStatement) isAssignment and: 						[(a2 := msgNode args last lastRealStatement) isAssignment and: 						[a1 variable name = a2 variable name]]]]) ifTrue: [							a1 variable emitJSCodeAsArgumentOn: aStream level: level generator: self.							aStream nextPutAll: ' = '.							^self emit: msgNode receiver questionMark: a1 expression colon: a2 expression on: aStream.						].						msgNode receiver canBeExpression ifFalse: [							(msgNode receiver isSend and: [(stmLists := msgNode receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [								usedVars := self globalsAsSet copy.								usedVars addAll: currentMethod args; addAll: currentMethod locals.								newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.								stmLists do: [:stmtList | | lastRealStatement |										lastRealStatement := stmtList lastRealStatement.										stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 											(TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: lastRealStatement)].								aStream nextPutAll: 'let ';									nextPutAll: newVarName;									nextPut: $;;									cr.								msgNode receiver									isExpression: false;									emitJSCodeOn: aStream level: level generator: self.								aStream nextPut: $;;									cr.								msgNode receiver: (TVariableNode new setName: newVarName).							] ifFalse: [self halt].						].						aStream nextPutAll: 'if ('.						msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.						aStream nextPutAll: ') {'; cr.						msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.						aStream tab: level; nextPut: $}; nextPutAll: ' else {'; cr.						msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.						aStream tab: level; nextPut: $}						]. 					]				ifNotNil:					[:const |					((const == true) or: [const == false]) ifFalse: [self halt].					msgNode receiver emitJSCodeOn: aStream level: level - 1 generator: self.					(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])						emitJSCodeOn: aStream level: level - 1 generator: self]			]		ifNotNil:			[:const |			(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])				emitJSCodeOn: aStream level: level - 1 generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/16/2023 21:46'!generateIfTrueIfFalseAsArgument: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode args first isNilStmtListNode		ifTrue: [^self generateIfFalseAsArgument: (msgNode copy arguments: {msgNode args last}) on: aStream indent: level].	msgNode args last isNilStmtListNode		ifTrue: [^self generateIfTrueAsArgument: (msgNode copy arguments: {msgNode args first}) on: aStream indent: level].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[aStream nextPut: $(.			msgNode receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.			(msgNode args first isLeafStmtListNode and: 			[(self nilOrReducibleValueOf: msgNode args first lastRealStatement) == true]) ifTrue: [				aStream nextPutAll: ' || '.				msgNode args last emitJSCodeAsArgumentOn: aStream level: level generator: self.				^aStream nextPut: $)].			(msgNode args last isLeafStmtListNode and: 			[(self nilOrReducibleValueOf: msgNode args last lastRealStatement) == false]) ifTrue: [				aStream nextPutAll: ' && '.				msgNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self.				^aStream nextPut: $)].			aStream crtab: level + 1; nextPut: $?; space.			msgNode args first emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream crtab: level + 1; nextPut: $:; space.			msgNode args last emitJSCodeAsArgumentOn: aStream level: level + 2 generator: self.			aStream nextPut: $)]		ifNotNil:			[:const|			(const ifTrue: [msgNode args first] ifFalse: [msgNode args last])				emitJSCodeAsArgumentOn: aStream level: level generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/11/2023 14:40'!generateInlineCppIfDefElse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| alternateBlock alternateBlockIsNil |	aStream nextPutAll: '// skipping ifdef ', msgNode args first value; cr.	alternateBlock := msgNode args fifth.	alternateBlockIsNil := true. "check for nil #else clause"	alternateBlock nodesDo: [:n |		(n ~= alternateBlock and: [n name ~= 'nil'])			ifTrue: [alternateBlockIsNil := false ]].	(alternateBlockIsNil) ifFalse:		[msgNode isExpression			ifTrue:				[aStream tab: level + 1; nextPut: $(.				alternateBlock					emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.				aStream nextPut: $); cr]			ifFalse:				[alternateBlock					emitJSCodeOn: aStream level: level generator: self]].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/11/2023 14:40'!generateInlineCppIfElse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| comment alternateBlock alternateBlockIsNil |	aStream cr; nextPutAll: '# if (', msgNode args first value, ')'.	comment := msgNode args third value.	(comment isKindOf: String)		ifTrue: [aStream nextPutAll: '  // ', comment]		ifFalse: ["nil argument, ignore it"].	aStream cr.	msgNode isExpression		ifTrue:			[aStream tab: level + 1; nextPut: $(.			msgNode args fourth 				emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.			aStream nextPut: $); cr]		ifFalse:			[msgNode args fourth				emitJSCodeOn: aStream level: level generator: self].	alternateBlock := msgNode args fifth.	alternateBlockIsNil := true. "check for nil #else clause"	alternateBlock nodesDo: [:n |		(n ~= alternateBlock and: [n name ~= 'nil'])			ifTrue: [alternateBlockIsNil := false ]].	(alternateBlockIsNil) ifFalse:		[aStream nextPutAll: '# else'; cr.		msgNode isExpression			ifTrue:				[aStream tab: level + 1; nextPut: $(.				alternateBlock 					emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.				aStream nextPut: $); cr]			ifFalse:				[alternateBlock					emitJSCodeOn: aStream level: level generator: self]].	aStream nextPutAll: '# endif  // ', msgNode args first value; cr; tab: level! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/15/2023 17:29'!generateInstantiateClassIndexableSize: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '(function(__size) {const __result = '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.primitive_71_impl(__size); return __result[0] ? __result[1] : PrimitiveFailed.signal()})('.	self emitJSExpression: msgNode args last on: aStream.	aStream nextPut: $)! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:54'!generateIsArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "pointers" && '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.instSize === 0)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "bytes")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 19:33'!generateIsFloatObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number" && (';			nextPutAll: varName;			nextPutAll: ' | 0) !!== ';			nextPutAll: varName;			nextPutAll: ' && !!Number.isSafeInteger(';			nextPutAll: varName;			nextPutAll: ') || ';			nextPutAll: varName;			nextPutAll: '._class() === SmalltalkGlobals._Float)'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/14/2022 18:10'!generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number")'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 22:07'!generateIsIntegerValue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: ' === "number" && (';			nextPutAll: varName;			nextPutAll: ' | 0) === ';			nextPutAll: varName;			nextPutAll: ')'	] ifFalse: [self halt.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/21/2023 00:54'!generateIsLong64s: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "longs")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/23/2021 17:53'!generateIsMemberOf: aNode on: aStream indent: anInteger	aStream nextPut: $(.	self emitJSExpression: aNode args first on: aStream.	aStream nextPutAll: '._class() === SmalltalkGlobals._';		nextPutAll: aNode args last value;		nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 15:58'!generateIsNeitherWordsNorBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '(["words", "bytes"].indexOf('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType) === -1)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 15:56'!generateIsNotArray: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "pointers" || '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.instSize !!== 0)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 15:56'!generateIsNotBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "bytes")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 15:57'!generateIsNotPointers: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "pointers")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 15:58'!generateIsNotWords: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType !!== "words")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsPointers: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "pointers")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsWords: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPut: $(.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType === "words")'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/21/2022 22:55'!generateIsWordsOrBytes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: '(["words", "bytes"].indexOf('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '.storageType) !!== -1)'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/8/2023 21:58'!generateJSCodeForCcode: cCode on: aStream indent: level	cCode = '' ifTrue: [^self]. 	aStream nextPutAll: (cCodeTranslationDict at: cCode ifAbsent: [		(#('sqrt' 'sin' 'cos' 'tan' 'atan' 'atan2' 'log' 'exp' 'min' 'max' 'floor' 'abs') anySatisfy: [:fn | fn,'(*)' match: cCode])			ifTrue: ['Math.', cCode] ifFalse: [		('fabs(*)' match: cCode)			ifTrue: ['Math.', cCode allButFirst] ifFalse: [		('dir_Delimitor()' = cCode)			ifTrue: ['"/"'] ifFalse: [		('opTable[*] = (void *)*' match: cCode)			ifTrue: [cCode copyReplaceAll: '(void *)' with: 'this.'] ifFalse: [		('fn(*Handle, &*Pitch, *)' match: cCode)			ifTrue: [(cCode copyReplaceAll: '&' with: 'function(p){') copyReplaceAll: 'Pitch' with: 'Pitch = p}'] ifFalse: [		(' ((*)querySurfaceFn)*(handle, &destWidth, &destHeight, &destDepth, &destMSB)' match: cCode)			ifTrue: [ 'querySurfaceFn(destBits, function(w, h, d, m){destWidth = w; destHeight = h; destDepth = d; destMSB = m; })'] ifFalse: [		(' ((*)querySurfaceFn)*(handle, &sourceWidth, &sourceHeight, &sourceDepth, &sourceMSB)' match: cCode)			ifTrue: [ 'querySurfaceFn(sourceBits, function(w, h, d, m){sourceWidth = w; sourceHeight = h; sourceDepth = d; sourceMSB = m; })'] ifFalse: [		(#('fn(destHandle, affectedL, affectedT, affectedR-affectedL, affectedB-affectedT)',			'fn(sourceHandle, 0, 0, 0, 0)') includes: cCode)			ifTrue: [cCode] ifFalse: [		(constants includesKey: cCode) ifFalse: [self halt: cCode].		cCode]]]]]]]]])! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMath: msgNode on: aStream indent: level	"Generate the JS code for the message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.'; nextPutAll: msgNode selector; nextPut: $(.	msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.	aStream nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMax: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.max('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/22/2021 20:35'!generateMergeFnWith: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'mergeFnwith('.	msgNode args do:		[ :arg| arg emitJSCodeAsArgumentOn: aStream level: level generator: self]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $).! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/3/2020 01:04'!generateMethodArgumentCount: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'arguments.length'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:34'!generateMin: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'Math.min('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/15/2023 20:05'!generateMinus: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| additions literal subtractions split |	self ifPointerVar: msgNode receiver then: [:type |		self ifPointerVar: msgNode args first then: [:type1 |			((type copyUpTo: $*) copyWithout: $ ) = ((type1 copyUpTo: $*) copyWithout: $ ) 				ifTrue: [					self generatePointerMinusPointer: msgNode type: type on: aStream indent: level] 				ifFalse: [					self halt: 'cannot do - with ', type, ' and ', type1].				^self].		(self generatePointerMinus: msgNode type: type on: aStream indent: level)			ifTrue: [^self].		self halt: 'cannot do - with ', type].	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	split := msgNode splitTermsUsing: self.	(additions := split first) = {msgNode} ifFalse: [		additions isNil ifTrue: [			aStream nextPutAll: (split at: 2) printString.		] ifFalse: [			additions do: [:a | self emitJSExpression: a on: aStream] separatedBy: [ aStream nextPutAll: ' + '].			(literal := split at: 2) > 0 ifTrue: [				aStream nextPutAll: ' + ';					nextPutAll: literal printString			] ifFalse: [				literal < 0 ifTrue: [					aStream nextPutAll: ' - ';						nextPutAll: literal negated printString]]].		^(subtractions := split last) notNil ifTrue: [			subtractions do: [:e | 				aStream nextPutAll: ' - '.				self emitJSExpression: e on: aStream]]].	(self nilOrReducibleValueOf: msgNode receiver) = 0 ifFalse: [		self emitJSExpression: msgNode receiver on: aStream.		(self nilOrReducibleValueOf: msgNode args first) = 0 ifFalse: [			aStream nextPutAll: ' - '.			self emitJSExpression: msgNode args first on: aStream.		]	] ifTrue: [		self emitJSExpression: msgNode args first on: aStream.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:35'!generateModulo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll: 'MOD('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/8/2021 20:37'!generateNilObject: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'nil'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 16:03'!generateNot: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[| expr |			expr := msgNode receiver.			"generate (a !!= b) instead of !!(a == b)"			expr isEqualityTest ifTrue: [				^(expr selector includes: $~)					ifTrue: [self generateEqual: expr on: aStream indent: level]					ifFalse: [self generateNotEqual: expr on: aStream indent: level]].			expr isInequalityTest ifTrue: [				^expr selector caseOf: {					[#<] -> [self generateGreaterThanOrEqual: expr on: aStream indent: level].					[#<=] -> [self generateGreaterThan: expr on: aStream indent: level].					[#>] -> [self generateLessThanOrEqual: expr on: aStream indent: level].					[#>=] -> [self generateLessThan: expr on: aStream indent: level]}].			expr isStorageTypeTest ifTrue: [				^expr selector caseOf: {					[#isArray:] -> [self generateIsNotArray: expr on: aStream indent: level].					[#isBytes:] -> [self generateIsNotBytes: expr on: aStream indent: level].					[#isPointers:] -> [self generateIsNotPointers: expr on: aStream indent: level].					[#isWords:] -> [self generateIsNotWords: expr on: aStream indent: level].					[#isWordsOrBytes:] -> [self generateIsNeitherWordsNorBytes: expr on: aStream indent: level]}].			"eliminate not not"			(expr isSend and: [expr selector = #not]) ifTrue: [				^self emitJSExpression: expr receiver on: aStream].			aStream nextPutAll: '!!'.			self emitJSExpression: expr on: aStream]		ifNotNil: [:const |			aStream nextPutAll: (const ifTrue: ['false'] ifFalse: ['true'])]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 12:44'!generateNotEqual: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| argNode test |	argNode :=  msgNode args first.	"quick test for nil, true, false"	argNode isInterpreterProxyConstant ifTrue: [		test := #(' !!== nil' ' !!== true' ' !!== false') at: (#(nilObject trueObject falseObject) indexOf: argNode selector).		self emitJSExpression: msgNode receiver on: aStream.		^aStream nextPutAll: test].	"cannot compare pointers to 0"	(argNode isConstantNull or: [argNode isConstantZero and: [self isPointer: msgNode receiver]]) ifTrue: [		aStream nextPutAll: '!!!!'.		^self emitJSExpression: msgNode receiver on: aStream].	(argNode isConstantZero and: [msgNode receiver isSend and: [msgNode receiver selector == #-]]) ifTrue: [		self emitJSExpression: msgNode receiver receiver on: aStream.		aStream nextPutAll: ' !!== '.		self emitJSExpression: msgNode receiver args first on: aStream.	] ifFalse: [		self emitJSExpression: msgNode receiver on: aStream.		aStream nextPutAll: ' !!== '.		self emitJSExpression: msgNode args first on: aStream.	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/13/2023 00:50'!generateOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode args first)				ifNil:					[msgNode args first hasSideEffect ifTrue: [						aStream nextPutAll: '(function() {const _a = '.						self emitJSExpression: msgNode receiver on: aStream.						aStream nextPutAll: '; const _b = '.						self emitJSExpression: msgNode args first on: aStream.						aStream nextPutAll: '; return _a || _b})()'					] ifFalse: [						self emitJSExpression: msgNode receiver on: aStream.						aStream nextPutAll: ' || '.						self emitJSExpression: msgNode args first on: aStream]]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					const ifTrue: [						msgNode receiver hasSideEffect ifTrue: [							self emitJSExpression: msgNode receiver on: aStream.							aStream nextPutAll: ' || '						].						aStream nextPutAll: 'true'					] ifFalse: [						self emitJSExpression: msgNode receiver on: aStream]]]		ifNotNil: [:const |			const ifFalse: [self emitJSExpression: msgNode args first on: aStream]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 15:09'!generatePerform: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."self halt: msgNode asString.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $(.	(msgNode args copyFrom: 2 to: msgNode args size) do:[:arg|		self emitJSExpression: arg on: aStream.	] separatedBy:[aStream nextPutAll:', '].	aStream nextPut: $)! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/15/2023 20:04'!generatePlus: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| additions literal subtractions split |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	self checkNonPointer: msgNode args first op: '+'.	self ifPointerVar: msgNode receiver then: [:type |		(self generatePointerPlus: msgNode type: type on: aStream indent: level)			ifTrue: [^self].		self halt: 'cannot do + with ', type].	split := msgNode splitTermsUsing: self.	(additions := split first) = {msgNode} ifFalse: [		additions isNil ifTrue: [			aStream nextPutAll: (split at: 2) printString.		] ifFalse: [			additions do: [:a | self emitJSExpression: a on: aStream] separatedBy: [ aStream nextPutAll: ' + '].			(literal := split at: 2) > 0 ifTrue: [				aStream nextPutAll: ' + ';					nextPutAll: literal printString			] ifFalse: [				literal < 0 ifTrue: [					aStream nextPutAll: ' - ';						nextPutAll: literal negated printString]]].		^(subtractions := split last) notNil ifTrue: [			subtractions do: [:e | 				aStream nextPutAll: ' - '.				self emitJSExpression: e on: aStream]]].	(msgNode receiver isBitBltPtr or: [(self nilOrReducibleValueOf: msgNode receiver) = 0]) ifFalse: [		self emitJSExpression: msgNode receiver on: aStream.		(self nilOrReducibleValueOf: msgNode args first) = 0 ifFalse: [			aStream nextPutAll: ' + '.			self emitJSExpression: msgNode args first on: aStream.		]	] ifTrue: [		(self nilOrReducibleValueOf: msgNode args first) = 0 ifFalse: [			self emitJSExpression: msgNode args first on: aStream.		] ifTrue: [			aStream nextPut: $0.		]	]	! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 14:16'!generatePointerMinus: msgNode type: type on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/13/2023 23:12'!generatePointerMinusPointer: msgNode type: type on: aStream indent: level	msgNode selector = #- ifFalse: [self halt].	aStream nextPutAll: 'PTR_PTRSUB('.	msgNode receiver isVariable		ifTrue: [			aStream nextPutAll: msgNode receiver name, ', ']		ifFalse: [msgNode receiver emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true].	aStream nextPutAll: ', '.	self emitJSExpression: msgNode args first on: aStream.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 14:09'!generatePointerPlus: msgNode type: type on: aStream indent: level	"Generate the JS code for this message onto the given stream."	msgNode emitJSPointerArithmetic: type on: aStream level: level generator: self type: type top: true.	^true! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/15/2020 21:01'!generatePointersAt: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ']'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 11/15/2020 22:34'!generatePointersAtPut: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '] = '.	self emitJSExpression: msgNode args last on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/24/2021 14:17'!generatePositive32BitIntegerFor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| varName |	msgNode args first isVariable ifTrue: [		varName := msgNode args first name.		aStream nextPutAll: '((';			nextPutAll: varName;			nextPutAll: ' >>> 0) !!== ';			nextPutAll: varName;			nextPutAll: '.valueOf() ? PrimitiveFailed.signal() : (';			nextPutAll: varName;			nextPutAll: ' >= 0 ? ';			nextPutAll: varName;			nextPutAll: ' : 4294967296 + ';			nextPutAll: varName;			nextPutAll: '))'	 ] ifFalse: [		self halt	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:01'!generatePrimitiveFail: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload(1)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 3/11/2021 22:01'!generatePrimitiveFailFor: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload('.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/21/2023 00:34'!generatePrimitiveReturn: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| newVarName stmLists usedVars |	msgNode args first canBeExpression ifTrue: [		aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.		self emitJSExpression: msgNode args first on: aStream.		aStream nextPutAll: ')'.	] ifFalse: [		(msgNode args first isSend and: [(stmLists := msgNode args first stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [			usedVars := self globalsAsSet copy.			usedVars addAll: currentMethod args; addAll: currentMethod locals.			newVarName := currentMethod unusedNamePrefixedBy: 'ret' avoiding: usedVars.			stmLists do: [:stmtList | | lastRealStatement |				lastRealStatement := stmtList lastRealStatement.				stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 											(TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: lastRealStatement)].			aStream nextPutAll: 'let ';				nextPutAll: newVarName;				nextPut: $;;				cr.			msgNode args first				isExpression: false;				emitJSCodeOn: aStream level: level generator: self.			aStream nextPut: $;;				cr.			aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload(';				nextPutAll: newVarName;				nextPutAll: ');'.		] ifFalse: [self halt]	]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 12/31/2020 18:03'!generatePush: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self generatePrimitiveReturn: msgNode on: aStream indent: level! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 20:30'!generatePushBool: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateCheckedBoolean: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/11/2022 22:41'!generatePushFloat: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateFloatObjectOf: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/12/2022 21:02'!generatePushInteger: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	aStream nextPutAll: 'throw Object.create(PrimitiveReturn).setPayload('.	self generateCheckedInteger: msgNode on: aStream indent: level.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/2/2023 00:16'!generateQuestionMarkColon: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| a1 a2 |	((a1 := msgNode args first) isLeaf and: [(a2 := msgNode args last) isLeaf]) ifTrue: [		^(self nilOrBooleanConstantReceiverOf: msgNode) ifNil: [			msgNode receiver emitJSCodeOn: aStream level: level generator: self.			]].	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil: [a1 isLeaf ifTrue: [				^self generateIfFalse: (TSendNode new												setSelector: #ifFalse:												receiver: msgNode receiver 												arguments: {TStmtListNode new																setStatements: {a2}}) on: aStream indent: level].			(a2 := msgNode args last) isLeaf ifTrue: [				^self generateIfTrue: (TSendNode new												setSelector: #ifTrue:												receiver: msgNode receiver 												arguments: {TStmtListNode new																setStatements: {msgNode args first}}) on: aStream indent: level].			(a1 isAssignment and: [a2 isAssignment and: [a1 variable name = a2 variable name]]) ifTrue: [				a1 variable emitJSCodeAsArgumentOn: aStream level: level generator: self.				aStream nextPutAll: ' = '.				^self emit: msgNode receiver questionMark: a1 expression colon: a2 expression on: aStream.			].			aStream nextPutAll: 'if ('.			msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ') {'; cr.			a1 emitJSCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPutAll: '} else {'; cr.			a2 emitJSCodeOn: aStream level: level + 1 generator: self.			aStream tab: level; nextPut: $}]		ifNotNil: [:const |			(const ifTrue: [a1] ifFalse: [msgNode args last]) emitJSCodeOn: aStream level: level generator: self]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/2/2023 00:11'!generateQuestionMarkColonAsArgument: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[self emit: msgNode receiver questionMark: msgNode args first colon: msgNode args last on: aStream]		ifNotNil: [:const |			self emitJSExpression: (const ifTrue: [msgNode args first] ifFalse: [msgNode args last]) on: aStream]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:35'!generateRaisedTo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	aStream nextPutAll:'Math.pow('.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ','.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll:')'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/12/2023 23:14'!generateSequentialAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[msgNode args first isStmtList ifFalse: [self halt].			(msgNode args first canBeExpression ifTrue: [self nilOrReducibleValueOf: msgNode args first lastRealStatement])				ifNil:					[self emitJSExpression: msgNode receiver on: aStream.					aStream nextPutAll: ' && '.					self emitJSExpression: msgNode args first on: aStream]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					const ifTrue: [						self emitJSExpression: msgNode receiver on: aStream					] ifFalse: [						msgNode receiver hasSideEffect ifTrue: [							self emitJSExpression: msgNode receiver on: aStream.							aStream nextPutAll: ' && '						].						aStream nextPutAll: 'false'					]]]		ifNotNil: [:const |			const ifTrue: [self emitJSExpression: msgNode args first on: aStream]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/12/2023 23:15'!generateSequentialOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[msgNode args first isStmtList ifFalse: [self halt].			(msgNode args first canBeExpression ifTrue: [self nilOrReducibleValueOf: msgNode args first lastRealStatement])				ifNil:					[self emitJSExpression: msgNode receiver on: aStream.					aStream nextPutAll: ' || '.					self emitJSExpression: msgNode args first on: aStream]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					const ifTrue: [						msgNode receiver hasSideEffect ifTrue: [							self emitJSExpression: msgNode receiver on: aStream.							aStream nextPutAll: ' || '						].						aStream nextPutAll: 'true'					] ifFalse: [						self emitJSExpression: msgNode receiver on: aStream]]]		ifNotNil: [:const |			const ifFalse: [self emitJSExpression: msgNode args first on: aStream]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/20/2023 15:01'!generateShiftLeft: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | val > (1 bitShift: 32) ifTrue: [self halt]. ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		"bit shift amount is a constant"		val < 32 ifTrue: [			val < 0 ifTrue: [self halt].			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ' << ';				nextPutAll: val printString;				nextPutAll: ' >>> 0'.		] ifFalse: [			aStream nextPut: $0].	] ifNil: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHL('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '. 		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/20/2023 14:55'!generateShiftRight: msgNode on: aStream indent: level	"Generate the JS code for unsigned right-shift onto the given stream."	| rcvr arg |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	rcvr := msgNode receiver.	arg := msgNode args first.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		"bit shift amount is a constant"		val < 32 ifTrue: [			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: ' >>> ';				nextPutAll: val printString.		] ifFalse: [			aStream nextPut: $0].	] ifNil: [		"bit shift amount is an expression"		aStream nextPutAll: 'SHR('.		self emitJSExpression: rcvr on: aStream.		aStream nextPutAll: ', '.		self emitJSExpression: arg on: aStream.		aStream nextPutAll: ')'.	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/20/2023 14:56'!generateSignedBitShift: msgNode on: aStream indent: level	"Generate the JS code for signedBitShift: onto the given stream."	| arg rcvr |	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	arg := msgNode args first.	rcvr := msgNode receiver.	(self nilOrReducibleValueOf: arg) ifNotNil: [:val |		"bit shift amount is a constant"		(val between: -31 and: 31) ifTrue: [			self emitJSExpression: rcvr on: aStream.			aStream nextPutAll: (val >= 0 ifTrue: [' << '] ifFalse: [' >> ']);				nextPutAll: val abs printString.		] ifFalse: [			aStream nextPut: $0].	] ifNil: [		"bit shift amount is an expression"		self error: 'SSHIFT not implemented'	].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/29/2020 02:25'!generateSignedIntToLong: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	self emitJSExpression: msgNode receiver on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/10/2023 14:26'!generateStackValue: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(msgNode args size = 1 and: [msgNode args first isSend and: [#methodArgumentCount = msgNode args first selector]]) ifTrue: [		^aStream nextPutAll: 'this'	].	Warning signal:'Here'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/12/2023 19:08'!generateStatementAnd: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode args first)				ifNil:					[aStream nextPutAll: 'if ('.					msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.					aStream nextPutAll: ') {'; cr.					msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.					level timesRepeat: [ aStream tab ].					aStream nextPut: $}]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					(const or: [msgNode receiver hasSideEffect]) ifTrue: [						msgNode receiver emitJSCodeOn: aStream level: level generator: self					]]]		ifNotNil: [:const |			const ifTrue: [msgNode args first emitJSCodeOn: aStream level: level generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/12/2023 22:39'!generateStatementOr: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrBooleanConstantReceiverOf: msgNode)		ifNil:			[(self nilOrReducibleValueOf: msgNode args first)				ifNil:					[aStream nextPutAll: 'if ('.					self generateNot: (TSendNode new							setSelector: #not receiver: msgNode receiver arguments: #())						on: aStream indent: level + 1.					aStream nextPutAll: ') {'; cr.					msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.					level timesRepeat: [aStream tab].					aStream nextPut: $}]				ifNotNil: [:const |					((const == true) or: [const == false]) ifFalse: [self halt].					(const not or: [msgNode receiver hasSideEffect]) ifTrue: [						msgNode receiver emitJSCodeOn: aStream level: level generator: self]]]		ifNotNil: [:const |			const ifFalse: [msgNode args first emitJSCodeOn: aStream level: level generator: self]]! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/31/2023 00:53'!generateSuccess: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| val |	(val := self nilOrReducibleValueOf: msgNode args first) == false ifFalse: [		val == true ifTrue: [^self].		aStream nextPutAll: 'if ('.		self generateNot: (TSendNode new				setSelector: #not receiver: msgNode args first arguments: #())			on: aStream indent: level.		aStream nextPutAll: ') '].	aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload(1)'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 1/8/2022 14:17'!generateTimes: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	(self nilOrReducibleValueOf: msgNode) ifNotNil: [:val | ^aStream nextPutAll: val printString]. 	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitJSExpression: msgNode args first on: aStream.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/25/2023 21:24'!generateToByDo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	"N.B. MessageNode>>asTranslatorNodeIn: adds the limit var as a hidden fourth argument."	| blockExpr iterationVar limitExpr limitVar step negative initialValue testSelector limitInit |	blockExpr := msgNode args third.	blockExpr args size = 1 ifFalse:		[self error: 'wrong number of block arguments'].	iterationVar := blockExpr args first.	limitExpr := msgNode args first.	initialValue := self nilOrReducibleValueOf: msgNode receiver.	step := self nilOrReducibleValueOf: (msgNode args at: 2).	negative := step notNil and: [step < 0].	testSelector := negative ifTrue: [' >= '] ifFalse: [' <= '].	(msgNode args size = 4) ifTrue: [		limitVar := msgNode args last.		(limitExpr isSend		 and: [limitExpr selector = (negative ifTrue: [#+] ifFalse: [#-])		 and: [limitExpr args first isConstant		 and: [limitExpr args first value = 1]]])			ifTrue: [				testSelector := negative ifTrue: [' > '] ifFalse: [' < '].				limitExpr receiver isVariable ifTrue: [					limitExpr := limitExpr receiver				] ifFalse: [					limitInit := limitExpr receiver.					limitExpr := limitVar]			] ifFalse:				[limitInit := limitExpr.				 limitExpr := limitVar]].	limitInit notNil ifTrue: [		initialValue isNil ifTrue: [			aStream nextPutAll: iterationVar, ' = '.			msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.			aStream nextPut: $;; 				crtab: level].		aStream nextPutAll: 'const ', limitVar name, ' = '.		limitInit emitJSCodeAsExpressionOn: aStream level: 0 generator: self.		aStream nextPut: $;; 			crtab: level].	aStream nextPutAll: 'for ('.	(limitInit isNil or: [initialValue notNil]) ifTrue: [		aStream nextPutAll: iterationVar, ' = '.		msgNode receiver emitJSCodeAsExpressionOn: aStream level: 0 generator: self.	].	aStream nextPutAll: '; ', iterationVar, testSelector.	self emitJSExpression: limitExpr on: aStream.	step = 1		ifTrue: [aStream nextPutAll: '; ', iterationVar, '++']		ifFalse: [step = -1					ifTrue: [aStream nextPutAll: '; ', iterationVar, '--']					ifFalse: [negative								ifTrue: [aStream nextPutAll: '; ', iterationVar, ' -= ', (0 - step)]								ifFalse: [aStream nextPutAll: '; ', iterationVar, ' += '.										(msgNode args at: 2) emitJSCodeAsExpressionOn: aStream level: 0 generator: self]]].	aStream nextPutAll: ') {'; cr.	blockExpr emitJSCodeOn: aStream level: level + 1 generator: self.	aStream tab: level.	aStream nextPut: $}! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 7/13/2023 22:47'!generateToDo: msgNode on: aStream indent: level	"Generate the JS code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	]. self halt: 'We should not get here, everything should go via the ...ToByDo... method instead'.	iterationVar := msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitJSExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/9/2023 15:09'!generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level	"Generate while(true) {stmtListA; if(!!(cond)) break; stmtListB}."	| testStmt usedVars newVarName newStatements stmLists |	testStmt := msgNode receiver lastRealStatement.	newStatements := msgNode receiver statements copyWithout: testStmt.	newStatements isEmpty ifTrue: [		newStatements := {TVariableNode new setName: 'nil'}].	msgNode receiver setStatements: newStatements. 	aStream nextPutAll: 'while (true) {'; cr.	msgNode receiver emitJSCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	testStmt canBeExpression ifFalse: [		testStmt isAssignment ifTrue: [			testStmt emitJSCodeOn: aStream level: level + 1 generator: self.			aStream nextPut: $;;				cr.			testStmt := testStmt variable		] ifFalse: [			testStmt isSend ifTrue: [				testStmt receiver canBeExpression ifFalse: [					(testStmt receiver isSend and: [(stmLists := testStmt receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [						usedVars := self globalsAsSet copy.						usedVars addAll: currentMethod args; addAll: currentMethod locals.						newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.						stmLists do: [:stmtList | | lastRealStatement |								lastRealStatement := stmtList lastRealStatement.								stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 									(TAssignmentNode new 										setVariable: (TVariableNode new setName: newVarName) 										expression: lastRealStatement)].						aStream nextPutAll: 'let ';							nextPutAll: newVarName;							nextPut: $;;							crtab: level + 1.						testStmt receiver  							isExpression: false;							emitJSCodeOn: aStream level: level + 1 generator: self.						aStream nextPut: $;;							cr.						testStmt receiver: (TVariableNode new setName: newVarName).					] ifFalse: [self halt].				].				testStmt canBeExpression ifFalse: [					(stmLists := testStmt stmtListsWithTerminalLocalReturns) notEmpty ifTrue: [						usedVars isNil ifTrue: [							usedVars := self globalsAsSet copy.							usedVars addAll: currentMethod args; addAll: currentMethod locals].						newVarName := currentMethod unusedNamePrefixedBy: 'ret' avoiding: usedVars.						stmLists do: [:stmtList | | lastRealStatement |									lastRealStatement := stmtList lastRealStatement.									stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 										(TAssignmentNode new 											setVariable: (TVariableNode new setName: newVarName) 											expression: lastRealStatement)].						aStream nextPutAll: 'let ';							nextPutAll: newVarName;							nextPut: $;;							crtab: level + 1.						testStmt   							isExpression: false;							emitJSCodeOn: aStream level: level + 1 generator: self.						aStream nextPut: $;;							cr.						testStmt := TVariableNode new setName: newVarName					] ifFalse: [self halt]				].			] ifFalse: [self halt]		]	].	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if (!!('.	testStmt emitJSCodeAsArgumentOn: aStream level: 0 generator: self.	aStream nextPutAll: ')) break;'; cr.	msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/9/2023 15:09'!generateWhileForeverBreakTrueLoop: msgNode on: aStream indent: level	"Generate while(true) {stmtListA; if(cond) break; stmtListB}."	| testStmt usedVars newVarName newStatements stmLists |	testStmt := msgNode receiver lastRealStatement.	newStatements := msgNode receiver statements copyWithout: testStmt.	newStatements isEmpty ifTrue: [		newStatements := {TVariableNode new setName: 'nil'}].	msgNode receiver setStatements: newStatements.	aStream nextPutAll: 'while (true) {'; cr.	msgNode receiver emitJSCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	testStmt canBeExpression ifFalse: [		testStmt isAssignment ifTrue: [			testStmt emitJSCodeOn: aStream level: level + 1 generator: self.			aStream nextPut: $;;				cr.			testStmt := testStmt variable		] ifFalse: [			testStmt isSend ifTrue: [				testStmt receiver canBeExpression ifFalse: [					(testStmt receiver isSend and: [(stmLists := testStmt receiver stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [						usedVars := self globalsAsSet copy.						usedVars addAll: currentMethod args; addAll: currentMethod locals.						newVarName := currentMethod unusedNamePrefixedBy: 'rec' avoiding: usedVars.						stmLists do: [:stmtList | | lastRealStatement |								lastRealStatement := stmtList lastRealStatement.								stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 									(TAssignmentNode new 										setVariable: (TVariableNode new setName: newVarName) 										expression: lastRealStatement)].						aStream nextPutAll: 'let ';							nextPutAll: newVarName;							nextPut: $;;							crtab: level + 1.						testStmt receiver  							isExpression: false;							emitJSCodeOn: aStream level: level + 1 generator: self.						aStream nextPut: $;;							cr.						testStmt receiver: (TVariableNode new setName: newVarName).					] ifFalse: [self halt].				].				testStmt canBeExpression ifFalse: [					(stmLists := testStmt stmtListsWithTerminalLocalReturns) notEmpty ifTrue: [						usedVars isNil ifTrue: [							usedVars := self globalsAsSet copy.							usedVars addAll: currentMethod args; addAll: currentMethod locals].						newVarName := currentMethod unusedNamePrefixedBy: 'ret' avoiding: usedVars.						stmLists do: [:stmtList | | lastRealStatement |									lastRealStatement := stmtList lastRealStatement.									stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 										(TAssignmentNode new 											setVariable: (TVariableNode new setName: newVarName) 											expression: lastRealStatement)].						aStream nextPutAll: 'let ';							nextPutAll: newVarName;							nextPut: $;;							crtab: level + 1.						testStmt   							isExpression: false;							emitJSCodeOn: aStream level: level + 1 generator: self.						aStream nextPut: $;;							cr.						testStmt := TVariableNode new setName: newVarName					] ifFalse: [self halt]				].			] ifFalse: [self halt]		]	].	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if ('.	testStmt emitJSCodeAsArgumentOn: aStream level: 0 generator: self.	aStream nextPutAll: ') break;'; cr.	msgNode args first emitJSCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/16/2023 22:39'!generateWhileTrue: msgNode on: aStream indent: level	"Generate C code for a loop in one of the following formats, as appropriate:		while(cond) { stmtList }		do {stmtList} while(cond)		while(true) {stmtListA; if (!!(cond)) break; stmtListB}"	msgNode receiver canBeExpression		ifTrue: [^self generateWhileTrueLoop: msgNode on: aStream indent: level].	(msgNode args first isNilStmtListNode and: [msgNode receiver lastRealStatement canBeExpression])		ifTrue: [^self generateDoWhileTrue: msgNode on: aStream indent: level].	^self generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 10/12/2023 17:53'!initializeJSTranslationDictionary 	"Initialize the dictionary mapping message names to actions for JS code generation."	| pairs |	translationDict := Dictionary new: 200.	pairs := #(	#checkIsFloat:			#generateCheckIsFloat:on:indent:	#checkIsNotNumber:	#generateCheckIsNotNumber:on:indent:	#checkIsInteger:		#generateCheckIsInteger:on:indent:	#booleanValueOf:			#generateCheckIsBoolean:on:indent:	#positive32BitValueOf:		#generateCheckedPositive32Bit:on:indent:	#floatValueOf:				#generateCheckIsFloat:on:indent:	#integerValueOf:			#generateIntegerValueOf:on:indent:	#checkedNotNumber:		#generateCheckIsNotNumber:on:indent:	#checkedInteger:			#generateCheckIsInteger:on:indent:	#positive32BitIntegerFor:	#generatePositive32BitIntegerFor:on:indent:	#floatObjectOf:			#generateFloatObjectOf:on:indent:	#integerObjectOf:			#generateIntegerObjectOf:on:indent: 	#pushBool:				#generatePushBool:on:indent:	#pushFloat:				#generatePushFloat:on:indent:	#pushInteger:			#generatePushInteger:on:indent:	#isFloatObject:			#generateIsFloatObject:on:indent:	#isIntegerObject:		#generateIsIntegerObject:on:indent:	#isIntegerValue:		#generateIsIntegerObject:on:indent:	#fetchInteger:ofObject:		#generateFetchInstVarOfObject:on:indent:	#fetchLong32:ofObject:		#generateFetchLong32OfObject:on:indent:	#fetchFloat:ofObject:			#generateFetchInstVarOfObject:on:indent:	#fetchPointer:ofObject:			#generateFetchInstVarOfObject:on:indent:	#storeInteger:ofObject:withValue:		#generateStoreInstVarOfObject:on:indent:	#storePointer:ofObject:withValue:		#generateStoreInstVarOfObject:on:indent:	#cCoerce:to:				#generateCCoercion:on:indent:	#cCoerceSimple:to:			#generateCCoercion:on:indent:	#signedIntFromLong		#generateSignedIntFromLong:on:indent:	#signedIntToLong			#generateSignedIntToLong:on:indent:	#signedIntFromShort		#generateSignedIntFromShort:on:indent:	#signedIntToShort			#generateSignedIntToShort:on:indent:	#asFloat					#generateAsFloat:on:indent:	#asInteger					#generateAsInteger:on:indent:	#asUnsignedInteger			#generateAsUnsignedInteger:on:indent:	#checkIsBytes:			#generateCheckIsBytes:on:indent:	#checkIsWords:		#generateCheckIsWords:on:indent:	#checkIsShorts:		#generateCheckIsShorts:on:indent:	#checkIsSignedShorts:	#generateCheckIsSignedShorts:on:indent:	#checkIsSignedInts:	#generateCheckIsSignedInts:on:indent:	#isArray:				#generateIsArray:on:indent:	#isBytes:				#generateIsBytes:on:indent:	#isPointers:				#generateIsPointers:on:indent:	#isWords:				#generateIsWords:on:indent:	#isLong64s:			#generateIsLong64s:on:indent:	#isWordsOrBytes:		#generateIsWordsOrBytes:on:indent:	#preIncrement				#generatePreIncrement:on:indent:	#preDecrement				#generatePreDecrement:on:indent:	#raisedTo:					#generateRaisedTo:on:indent:	#anyMask:					#generateBitAnd:on:indent:	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateStatementAnd:on:indent:	#or:			#generateStatementOr:on:indent:	#not			#generateNot:on:indent:	#questionMark:colon:	#generateQuestionMarkColon:on:indent:	#mergeFn:with:			#generateMergeFnWith:on:indent:	#__pointersAt:			#generatePointersAt:on:indent:	#__pointersAt:put:		#generatePointersAtPut:on:indent:	#primitiveFail			#generatePrimitiveFail:on:indent:	#primitiveFailFor:		#generatePrimitiveFailFor:on:indent:	#success:				#generateSuccess:on:indent:	#failed					#generateFailed:on:indent:	#methodArgumentCount	#generateMethodArgumentCount:on:indent:	#stackValue:			#generateStackValue:on:indent:	#push:					#generatePush:on:indent:	#is:MemberOf: 			#generateIsMemberOf:on:indent:	#classArray					#generateClassArray:on:indent:	#classBitmap					#generateClassBitmap:on:indent:	#classByteArray				#generateClassByteArray:on:indent:	#classLargeNegativeInteger	#generateClassLargeNegativeInteger:on:indent:	#classLargePositiveInteger		#generateClassLargePositiveInteger:on:indent:	#classPoint						#generateClassPoint:on:indent:	#classString					#generateClassString:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#negated		#generateNegated:on:indent:	#abs			#generateMath:on:indent:	#sqrt			#generateMath:on:indent:	#sin			#generateMath:on:indent:	#cos			#generateMath:on:indent:	#tan			#generateMath:on:indent:	#atan			#generateMath:on:indent:	#exp			#generateMath:on:indent:	#log			#generateMath:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<			#generateShiftLeft:on:indent:	#>>			#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#between:and:	#generateBetweenAnd:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:		#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#signedBitShift:	#generateSignedBitShift:on:indent:	#bitInvert32		#generateBitInvert32:on:indent:	#bitClear:			#generateBitClear:on:indent:	#<				#generateLessThan:on:indent:	#<=			#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=			#generateGreaterThanOrEqual:on:indent:	#~=			#generateNotEqual:on:indent:	#==			#generateEqual:on:indent:	#~~			#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#whileTrue 		#generateDoWhileTrue:on:indent:	#whileFalse		#generateDoWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#repeat 		#generateRepeat:on:indent:	#ifTrue:			#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#stObject:		#generateAt:on:indent:	#stObject:put:	#generateAtPut:on:indent:	#cCode:					#generateInlineCCode:on:indent:	#cCode:inSmalltalk:			#generateInlineCCode:on:indent:	#addressOf:				#generateAddressOf:on:indent:	#cPreprocessorDirective:	#generateInlineCPreprocessorDirective:on:indent:	#preprocessorExpression:	#generateInlineCppDirective:on:indent:	#isDefined:inSmalltalk:comment:ifTrue:	#generateInlineCppIfDef:on:indent:	#isDefined:inSmalltalk:comment:ifTrue:ifFalse:	#generateInlineCppIfDefElse:on:indent:	#isDefinedTrueExpression:inSmalltalk:comment:ifTrue:ifFalse:	#generateInlineCppIfElse:on:indent:	#inline:						#generateInlineDirective:on:indent:	#asSymbol					#generateAsSymbol:on:indent:	#touch:						#generateTouch:on:indent:	#bytesPerWord		#generateBytesPerWord:on:indent:	#baseHeaderSize		#generateBaseHeaderSize:on:indent:	#sharedCodeNamed:inCase:		#generateSharedCodeDirective:on:indent:	#perform:							#generatePerform:on:indent:	#perform:with:						#generatePerform:on:indent:	#perform:with:with:					#generatePerform:on:indent:	#perform:with:with:with:				#generatePerform:on:indent:	#perform:with:with:with:with:		#generatePerform:on:indent:	#perform:with:with:with:with:with:	#generatePerform:on:indent:	#shouldNotImplement				#generateSmalltalkMetaError:on:indent:	#shouldBeImplemented				#generateSmalltalkMetaError:on:indent:	"optimized interpreterProxy calls"	#instantiateClass:indexableSize:	#generateInstantiateClassIndexableSize:on:indent:	#nilObject							#generateNilObject:on:indent:	#firstIndexableField:				#generateFirstIndexableField:on:indent:	#slotSizeOf:						#generateSlotSizeOf:on:indent:	#stSizeOf:							#generateSlotSizeOf:on:indent:	#byteSizeOfBytes:					#generateByteSizeOf:on:indent:	#byteSizeOf:						#generateByteSizeOf:on:indent:	#fetchClassOf:						#generateFetchClassOf:on:indent:	#superclassOf:						#generateSuperclassOf:on:indent:	#instanceSizeOf:					#generateInstanceSizeOf:on:indent:	#is:KindOf: 							#generateIsKindOf:on:indent:	#is:NotKindOf: 						#generateIsNotKindOf:on:indent:	#cDigitCopyFrom:to:len:				#generateCDigitCopy:on:indent:	#sizeOfSTArrayFromCPrimitive:		#generateSizeOfSTArrayFromCPrimitive:on:indent:	#asciiValue							#generateIdentityUnary:on:indent:	#intAtPointer:						#generateIntAtPointer:on:indent:	#byteAtPointer:						#generateByteAtPointer:on:indent:	#oopForPointer:					#generateOopForPointer:on:indent:	#long32At:							#generateLong32At:on:indent:	#srcLongAt:						#generateSrcLongAt:on:indent:	#dstLongAt:						#generateDstLongAt:on:indent:	#dstLongAt:put:					#generateDstLongAtPut:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].	pairs := #(	#questionMark:colon:		#generateQuestionMarkColonAsArgument:on:indent:	#or:						#generateSequentialOr:on:indent:		#and:						#generateSequentialAnd:on:indent:	#ifTrue:						#generateIfTrueAsArgument:on:indent:		#ifFalse:					#generateIfFalseAsArgument:on:indent:	#ifTrue:ifFalse:				#generateIfTrueIfFalseAsArgument:on:indent:	#ifFalse:ifTrue:				#generateIfFalseIfTrueAsArgument:on:indent:	#cCode:					#generateInlineCCodeAsArgument:on:indent:	#cCode:inSmalltalk:			#generateInlineCCodeAsArgument:on:indent:	#cDigitCopyFrom:to:len:		#generateCDigitCopyAsArgument:on:indent:	#booleanValueOf:			#generateCheckedBoolean:on:indent:	#floatValueOf:				#generateCheckedFloat:on:indent:	#checkedNotNumber:		#generateCheckedNotNumber:on:indent:	#checkedInteger:			#generateCheckedInteger:on:indent:	).	asArgumentTranslationDict := Dictionary new: 8.	1 to: pairs size by: 2 do: [:i |		asArgumentTranslationDict at: (pairs at: i) put: (pairs at: i + 1)].	cCodeTranslationDict := Dictionary new: 8.	pairs := #(		'fprintf(stderr, "\n%s: %s", moduleName, s)'					'console.log(moduleName + ": " + s)'		'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'	'interpreterProxy.majorVersion() == VM_PROXY_MAJOR'		'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'	'interpreterProxy.minorVersion() >= VM_PROXY_MINOR'		'rand()'														'Math.random()'		'*src++'													'src[_src++]' 			'*dst++ = max'												'dst[_dst++] = max'		'src++'		 												'_src++'		'*dst++ = *src; src += 2'									'dst[_dst++] = src[_src]; _src += 2'		'tX'															'tX'		'tY'															'tY'		'((sqInt (*)(sqInt, sqInt, sqInt))copyBitsFn)(x0, x1, yValue)'	'copyBitsFn(targetX0, targetX1, targetY)'		'((sqInt (*)(sqInt))loadBBFn)(bbObj)'							'loadBBFn(engine.pointers[2])'	).	1 to: pairs size by: 2 do: [:i |		cCodeTranslationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 9/18/2020 16:20'!pluginName	^'Interpreter'! !!JSCodeGenerator methodsFor: 'JS translation' stamp: 'fm 8/16/2023 17:56'!tryToCollapseBothArmsOfConditional: msgNode on: aStream indent: level	"Attempt to generate the code for an ifTrue:ifFalse: if both arms are found to be the same, in which case	 answer true.  Otherwise output nothing and answer false."	(msgNode args first isSameAs: msgNode args second) ifFalse:		[^false].	msgNode receiver hasSideEffect ifTrue:		[msgNode receiver emitJSCodeOn: aStream level: level generator: self.		 aStream nextPut: $; ; crtab: level].	msgNode args first emitJSCodeOn: aStream level: level generator: self.	^true! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/29/2020 15:06'!generateByteAtPointer: msgNode on: aStream indent: level	msgNode args first asString = 'sourcePtr + charIndex - 1'		ifTrue: [^aStream nextPutAll: 'sourcePtr[charIndex - 1]'].	self halt: msgNode args first asString	! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 16:58'!generateByteSizeOf: msgNode on: aStream indent: level	aStream nextPutAll: 'BYTESIZEOF('.	msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.	aStream nextPutAll: ')'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/18/2023 17:22'!generateCDigitCopy: msgNode on: aStream indent: level	"LargeIntegerPlugin>>cDigitReplace:from:to:with:startingAt: uses pointer arithmetic. Replace it here"	| limit split additions |	msgNode args first selector = #+ ifFalse: [		^msgNode emitJSCodeAsFunctionCallOn: aStream level: level generator: self]. 	(msgNode args at: 2) selector = #+ ifFalse: [self halt: 'not handled: ', msgNode asString]. 	aStream nextPut: ${;		crtab: level;		nextPutAll: '// inlining ';		nextPutAll: msgNode asString.	((limit := msgNode args last) isLeaf or: 	[(additions := (split := limit splitTermsUsing: self) first) ~= {limit} and:	[split last isNil and: 	[additions isNil or: [additions size = 1 and: [(split at: 2) = 0]]]]]) ifTrue: [		limit isLeaf ifFalse: [				limit := additions ifNil: [split at: 2] ifNotNil: [additions first]		].		aStream crtab: level;			nextPutAll: 'for (let i = 0; i < '.		limit emitJSCodeAsArgumentOn: aStream level: level generator: self.		aStream nextPutAll: '; i++) '	] ifFalse: [		aStream crtab: level;			nextPutAll: 'const len = '.		limit emitJSCodeAsArgumentOn: aStream level: level generator: self.		aStream crtab: level;			nextPutAll: 'for (let i = 0; i < len; i++) '	].	aStream crtab: level + 1.	(msgNode args at: 2) receiver emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.	aStream nextPutAll: '[i'.	(msgNode args at: 2) args first isConstantZero ifFalse: [		aStream nextPutAll: ' + '.		(msgNode args at: 2) args first emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.	].	aStream nextPutAll: '] = '.	msgNode args first receiver emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.	aStream nextPutAll: '[i'.	msgNode args first args first isConstantZero ifFalse: [		aStream nextPutAll: ' + '.		msgNode args first args first emitJSCodeAsArgumentOn: aStream level: level + 1 generator: self.	].	aStream nextPutAll: '];';		crtab: level;		nextPut: $}! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/18/2023 17:22'!generateCDigitCopyAsArgument: msgNode on: aStream indent: level	"LargeIntegerPlugin>>cDigitReplace:from:to:with:startingAt: uses pointer arithmetic. Replace it here"	| limit split additions |	msgNode args first selector = #+ ifFalse: [		^msgNode emitJSCodeAsFunctionCallOn: aStream level: level generator: self]. 	(msgNode args at: 2) selector = #+ ifFalse: [self halt: 'not handled: ', msgNode asString]. 	aStream nextPutAll: '(function() {';		crtab: level;		nextPutAll: '// inlining ';		nextPutAll: msgNode asString.	((limit := msgNode args last) isLeaf or: 	[(additions := (split := limit splitTermsUsing: self) first) ~= {limit} and:	[split last isNil and: 	[additions isNil or: [additions size = 1 and: [(split at: 2) = 0]]]]]) ifTrue: [		limit isLeaf ifFalse: [				limit := additions ifNil: [split at: 2] ifNotNil: [additions first]		].		aStream crtab: level;			nextPutAll: 'for (let i = 0; i < '.		limit emitJSCodeAsArgumentOn: aStream level: level generator: self.		aStream nextPutAll: '; i++) '	] ifFalse: [		aStream crtab: level;			nextPutAll: 'const len = '.		limit emitJSCodeAsArgumentOn: aStream level: level generator: self.		aStream crtab: level;			nextPutAll: 'for (let i = 0; i < len; i++) '	].	aStream crtab: level + 1.	(msgNode args at: 2) receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.	aStream nextPutAll: '[i'.	(msgNode args at: 2) args first isConstantZero ifFalse: [		aStream nextPutAll: ' + '.		(msgNode args at: 2) args first emitJSCodeAsArgumentOn: aStream level: level generator: self.	].	aStream nextPutAll: '] = '.	msgNode args first receiver emitJSCodeAsArgumentOn: aStream level: level generator: self.	aStream nextPutAll: '[i'.	msgNode args first args first isConstantZero ifFalse: [		aStream nextPutAll: ' + '.		msgNode args first args first emitJSCodeAsArgumentOn: aStream level: level generator: self.	].	aStream nextPutAll: ']}';		crtab: level;		nextPutAll: 'return 0})()'! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 16:59'!generateDstLongAtPut: msgNode on: aStream indent: level	aStream nextPutAll: 'destBits['.	msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.	aStream nextPutAll: ' >>> 2] = '.	msgNode args second emitJSCodeAsExpressionOn: aStream level: level generator: self.	! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 16:59'!generateFetchClassOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.	aStream nextPutAll: '._class()'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 11/23/2020 01:00'!generateFetchInstVarOfObject: msgNode on: aStream indent: level	self emitJSExpression: msgNode args last on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $]! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 4/25/2021 18:41'!generateFetchLong32OfObject: msgNode on: aStream indent: level	self emitJSExpression: msgNode args last on: aStream.	aStream nextPutAll: '.words['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPut: $]! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 9/10/2023 12:04'!generateFirstIndexableField: msgNode on: aStream indent: level	| parent cType accessor parts receiver |	self oneBasedArrays: false.	parts := msgNode asString substrings.	(parts first = 'interpreterProxy' and: [(parts at: 2) = 'firstIndexableField:']) ifFalse: [Warning signal: 'here'].	"HACK: detect cType from parent node"	parent := thisContext sender sender sender.	receiver := parent receiver.	cType := parent method == (TAssignmentNode>>#emitJSCodeOn:level:generator:) ifTrue: [		self typeOfVariable: receiver variable name	] ifFalse: [		parent method == (TSendNode>>#emitJSCodeAsFunctionCallOn:level:generator:)			ifTrue: [self typeOfArgument: (receiver args indexOf: msgNode) in: receiver selector] ifFalse: [		(parts last beginsWith: 'mapOop')			ifTrue: ['unsigned int*'] ifFalse: [		(parts last beginsWith: 'blockOop')			ifTrue: ['int*'] ifFalse: [		(parts last beginsWith: 'bitsOop')			ifTrue: ['int*'] ifFalse: [		parent method == (TReturnNode>>#emitJSCodeOn:level:generator:)			ifTrue: [currentMethod returnType] ifFalse: [		(self pluginName = 'FloatArrayPlugin' and: [parts last = 'this'])			ifTrue: ['unsigned int*'] ifFalse: [		self halt]]]]]]].	cType ifNil: [		cType := (parts last beginsWith: 'mapOop')					ifTrue: ['unsigned int*'] ifFalse: [				(parts last beginsWith: 'blockOop')					ifTrue: ['int*'] ifFalse: [				(parts last beginsWith: 'bitsOop')					ifTrue: ['int*']]]		].	cType ifNotNil: [		cType := cType copyReplaceAll: ' *' with: '* '.		accessor := ((cType beginsWith: 'unsigned char*') or: [cType beginsWith: 'char*']) ifTrue: [aStream nextPutAll: 'BYTESOF('. msgNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self. ^aStream nextPut: $)]			ifFalse: [(cType beginsWith: 'unsigned int*') ifTrue: ['.words']			ifFalse: [(cType beginsWith: 'int*') ifTrue: ['.wordsAsInt32Array()']			ifFalse: [(cType beginsWith: 'short*') ifTrue: ['.wordsAsInt16Array()']			ifFalse: [(cType beginsWith: 'float*') ifTrue: ['.wordsAsFloat32Array()']			ifFalse: [(cType beginsWith: 'double*') ifTrue: ['.wordsAsFloat64Array()']			ifFalse: [self halt: 'need to handle ', cType. nil]]]]]].		accessor ifNotNil: [msgNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self.			^aStream nextPutAll: accessor]].	"generic code below, not needed ever hopefully"	Warning signal: 'here'.	^ msgNode emitJSCodeAsFunctionCallOn: aStream level: level generator: self! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 17:00'!generateIdentityUnary: msgNode on: aStream indent: level	"ignore this send, just use its value"	msgNode receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 17:01'!generateInstanceSizeOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.	aStream nextPutAll: '.prototype.instSize'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 11/12/2020 14:26'!generateIntAtPointer: msgNode on: aStream indent: level	msgNode args first asString = 'self cCoerce: argPtr + i to: ''char*'''		ifTrue: [^aStream nextPutAll: 'argPtr[i]'].	msgNode args first asString = 'self pointerForOop: oop'		ifTrue: [^aStream nextPutAll: 'sqMemoryBase[oop]'].	self halt	! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/6/2023 11:43'!generateLoadPointShort: msgNode on: aStream indent: level	| name |	msgNode args second isVariable ifFalse: [self halt].	((name := msgNode args second name) beginsWith: 'points') ifFalse: [self halt].	aStream nextPut: $(;		nextPutAll: name;		nextPutAll: '.int16Array || (';		nextPutAll: name;		nextPutAll: '.int16Array = new Int16Array(';		nextPutAll: name;		nextPutAll: '.buffer, ';		nextPutAll: name;		nextPutAll: '.byteOffset)))['.	 msgNode args first emitJSCodeAsExpressionOn: aStream level: 0 generator: self.	aStream nextPutAll: ']'.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 17:01'!generateLong32At: msgNode on: aStream indent: level	| expr index |	expr := msgNode args first.	(expr isSend and: [expr selector = #+]) ifFalse: [^expr isVariable ifTrue: [aStream nextPutAll: expr name; nextPutAll: '[0]'] ifFalse: [self halt: expr asString]].	expr receiver emitJSCodeAsExpressionOn: aStream level: level generator: self.	index := expr args first.	aStream nextPut: $[.	index isTimesFour		ifTrue: [index receiver emitJSCodeAsExpressionOn: aStream level: level generator: self]		ifFalse: [			index emitJSCodeAsExpressionOn: aStream level: level generator: self.			aStream nextPutAll: ' >>> 2'].	aStream nextPut: $].! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 10/29/2020 19:05'!generateOopForPointer: msgNode on: aStream indent: level	| arg |	arg := msgNode args first asString.	arg = 'interpreterProxy firstIndexableField: destBits'		ifTrue: [^aStream nextPutAll: 'destBits.wordsOrBytes()'].	arg = 'interpreterProxy firstIndexableField: sourceBits'		ifTrue: [^aStream nextPutAll: 'sourceBits.wordsOrBytes()'].	arg =  'interpreterProxy firstIndexableField: halftoneBits'		ifTrue: [^aStream nextPutAll: 'halftoneBits.wordsOrBytes()'].	arg =  'interpreterProxy firstIndexableField: sourceMapOop'		ifTrue: [^aStream nextPutAll: 'sourceMapOop.wordsOrBytes()'].	msgNode args first isVariable ifFalse: [self halt: arg].	aStream nextPutAll: arg! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 17:02'!generateSizeOfSTArrayFromCPrimitive: msgNode on: aStream indent: level	| cType sizer |	cType := self typeOfVariable: msgNode args first name.	cType ifNotNil: [		sizer := (cType includesSubString: 'char *') ifTrue: ['.length'] ifFalse: [			(cType beginsWith: 'int *') ifTrue: ['.length'] 			ifFalse: [self halt: 'need to handle ', cType]]].		sizer ifNotNil: [msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.			^aStream nextPutAll: sizer].	self halt.	"generic code below, not needed ever hopefully"	aStream nextPutAll: 'interpreterProxy.'.	^ msgNode emitJSCodeAsFunctionCallOn: aStream level: level generator: self! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/17/2023 01:52'!generateSlotSizeOf: msgNode on: aStream indent: level	aStream nextPutAll: 'SIZEOF('.	msgNode args first emitJSCodeAsArgumentOn: aStream level: level generator: self.	aStream nextPut: $).! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 3/8/2021 23:15'!generateStoreInstVarOfObject: msgNode on: aStream indent: level	self emitJSExpression: (msgNode args at: 2) on: aStream.	aStream nextPutAll: '.pointers['.	self emitJSExpression: msgNode args first on: aStream.	aStream nextPutAll: '] = '.	self emitJSExpression: msgNode args last on: aStream.! !!JSCodeGenerator methodsFor: 'JS hacks' stamp: 'fm 8/18/2023 17:02'!generateSuperclassOf: msgNode on: aStream indent: level	msgNode args first emitJSCodeAsExpressionOn: aStream level: level generator: self.	aStream nextPutAll: '.pointers[0]'.! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 9/16/2023 14:19'!computePossibleSideEffectsInto: writtenToVars visited: visitedSelectors in: aCodeGen	"Add all variables written to by this method and its callees to writtenToVars.	 Avoid circularity via visitedSelectors"	(visitedSelectors includes: selector) ifTrue:		[^self].	visitedSelectors add: selector.	writtenToGlobalVarsCache ifNotNil:		[writtenToVars addAll: writtenToGlobalVarsCache.		 ^self].	parseTree nodesDo:		[ :node |			(node isAssignment			 and: [(locals includes: node variable name) not])				ifTrue:					[writtenToVars add: node variable name].			(node isSend			 and: [node hasSideEffect			 and: [node isBuiltinOperator not			 and: [(node isStructSendIn: aCodeGen) not]]]) ifTrue:				[(aCodeGen methodNamed: node selector) ifNotNil:					[:method|					 method						computePossibleSideEffectsInto: writtenToVars						visited: visitedSelectors						in: aCodeGen]]].	writtenToGlobalVarsCache := writtenToVars copy! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 9/21/2020 20:32'!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree endsWithReturn! !!JSMethod methodsFor: 'inlining support' stamp: 'dtl 9/19/2010 13:20'!extractInlineDirective	"Scan the top-level statements for an inlining directive of the form:		self inline: <boolean>	 and remove the directive from the method body. Return the argument of the directive or #dontCare if there is no inlining directive."	| result newStatements methodDirectiveFound |	sharedCase ifNotNil:[^false]. "don't auto-inline shared code; it gets handled specially"	result := #dontCare.	methodDirectiveFound := false.	newStatements := OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #inline:]) ifTrue: [			methodDirectiveFound := true.			result := stmt args first value = true.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	methodDirectiveFound ifTrue: [^ result].	"no method declaration was used, so check for a pragma declaration"	sharedCase ifNotNil: [^false]. "don't auto-inline shared code; it gets handled specially"	^self		extractDirective: #inline:		valueBlock: [:sendNode| sendNode args first value = true]		default: #dontCare! !!JSMethod methodsFor: 'inlining support' stamp: 'fm 1/7/2022 17:54'!maySubstituteGlobal: globalVar in: aCodeGen	"We can substitute globalVar into this method provided globalVar is only read, not written."	writtenToGlobalVarsCache = nil ifTrue:		[self computePossibleSideEffectsInto: (Set new: 50) visited: (Set new: 50) in: aCodeGen].	^(writtenToGlobalVarsCache includes: globalVar) not! !!JSMethod methodsFor: 'utilities' stamp: 'fm 11/17/2020 14:57'!copy	"Make a deep copy of this JSMethod."	^ (self class basicNew)		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		primitive: primitive		parseTree: parseTree copyTree		labels: labels copy		complete: complete;		sharedLabel: sharedLabel;		sharedCase: sharedCase;		yourself! !!JSMethod methodsFor: 'inlining' stamp: 'fm 8/19/2023 23:25'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList := OrderedCollection new: 100.	substitutionDict := Dictionary new: 100.	meth args with: argList do: [ :argName :exprNode | | val subst |			(self isSubstitutableNode: exprNode as: argName intoMethod: meth in: aCodeGen) ifTrue: [			exprNode isLeaf ifTrue: [				subst := exprNode.				(exprNode isVariable and: [declarations includesKey: argName]) ifTrue: [					declarations at: exprNode name put: ((declarations at: argName) allButLast: argName size), exprNode name				]			] ifFalse: [				val := aCodeGen nilOrReducibleValueOf: exprNode. 				val notNil ifTrue: [					subst := TConstantNode new setValue: val				] ifFalse: [					(exprNode isSend and: [exprNode receiver name = 'interpreterProxy' and: 					[exprNode selector = #firstIndexableField: and: [declarations includesKey: argName]]]) ifTrue: [						subst := TSendNode new									setSelector: #cCoerce:to: 									receiver: exprNode receiver copy 									arguments: {exprNode . TConstantNode new setValue: ((declarations at: argName) allButLast: argName size)}					]				]			].			subst isNil ifTrue: [				subst := exprNode			].			substitutionDict at: argName put: subst.			locals remove: argName.			declarations removeKey: argName ifAbsent: []		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList! !!JSMethod methodsFor: 'inlining' stamp: 'fm 9/11/2023 14:44'!checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete := true.	stmtLists do: [ :stmtList |		stmtList statements do: [ :node |			(((self potentiallyInlineableSend: node in: aCodeGen) and: [(self inlineableSend: node in: aCodeGen) not]) or:			[(node isReturn or: [node isAssignment]) and: 			[(self potentiallyInlineableSend: node expression in: aCodeGen) and: [(self inlineableSend: node expression in: aCodeGen) not]]]) ifTrue: [				complete := false.  "more inlining to do"				^self			].		].	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/8/2023 19:22'!cleanupUnusedTemps	| modified refs assigns toReplace |	locals isEmpty ifFalse: [		[modified := false.		refs := Dictionary new.		assigns := Dictionary new.		parseTree nodesWithParentsDo: [:node :parent | | lastRealStatement |			node isStmtList ifTrue: [				lastRealStatement := node lastRealStatement.				(node statements anySatisfy: [:stmt | stmt isLeaf and: [stmt ~~ lastRealStatement and: [stmt isLabel not]]]) ifTrue: [					node statements do: [:stmt | 						(stmt isVariable and: [stmt ~~ lastRealStatement and: [locals includes: stmt name]]) ifTrue: [							refs at: stmt name put: (refs at: stmt name) - 1						]					].					node setStatements: (node statements reject: [:stmt | stmt isLeaf and: [stmt ~~ lastRealStatement and: [stmt isLabel not]]]).					modified := true				]			] ifFalse: [				node isVariable ifTrue: [					(locals includes: node name) ifTrue: [refs at: node name put: (refs at: node name ifAbsentPut: [0]) + 1]				] ifFalse: [					node isAssignment ifTrue: [						(locals includes: node variable name) ifTrue: [(assigns at: node variable name ifAbsentPut: [OrderedCollection new]) add: node]					]				]			]		].		toReplace := Dictionary new.		refs keysAndValuesDo: [:local :count| 			count = (assigns at: local ifAbsent: [#()]) size ifTrue: [				(#('mergeFnwith' 'l' 'r' 't' 'b' 'fn') includes: local) ifFalse: [					(assigns at: local ifAbsent: [#()]) do: [:a |						toReplace at: a put: a expression					].				locals remove: local				]			]		].		toReplace isEmpty ifFalse: [			parseTree replaceNodesIn: toReplace.			modified := true		].		modified] whileTrue	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:16'!comment	^comment! !!JSMethod methodsFor: 'inlining' stamp: 'fm 8/5/2023 18:29'!elideAnyFinalReturn	"For super expansions we need to eliminate any final return to prevent premature exit.	 Anything meaningful in the returned expression must be retained."	| stmtList expr lastRealStatement |	stmtList := parseTree statements asOrderedCollection.	lastRealStatement := parseTree lastRealStatement.	(stmtList notEmpty and: [lastRealStatement isReturn]) ifTrue:		[expr := lastRealStatement expression.		 (expr isVariable and: [expr name = 'self'])			ifTrue: [stmtList := stmtList reject: [:a | a == lastRealStatement]]			ifFalse: [stmtList at: (stmtList indexOf: lastRealStatement) put: expr].		parseTree setStatements: stmtList]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/15/2023 23:36'!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed  endsWithReturnOrIf returns extraneous |	labelUsed := false.	(endsWithReturnOrIf := parseTree endsWithReturnOrIf) ifTrue: [		returns := IdentitySet new.		extraneous := IdentitySet new.		endsWithReturnOrIf := (parseTree addFinalIfReturnsTo: returns extraneous: extraneous) notNil.		].	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [ :stmt | | parents loop loopParent brokenFromLoopVar ix newLoopParentStatements returnAlreadyExists breakLabel loopIndexWithinParents brokenFromLoopVarName newExitVar expression needsConditionalAfterLoop maybeConditional |				stmt isReturn ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: ["evaluate return expression even when value isn't used"							newStmts add: stmt expression].					] ifFalse: [						"assign return expression to exit variable"						expression := stmt expression.						(expression isSend and: [expression hasSideEffect and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: expression selector]]) ifTrue: [							expression stmtListsWithTerminalLocalReturns do: [:stmtList | | lastRealStatement |								lastRealStatement := stmtList lastRealStatement.								stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 									(TAssignmentNode new 										setVariable: (TVariableNode new setName: exitVar) 										expression: lastRealStatement)].							newStmts add: expression						] ifFalse: [							(expression isVariable and: [expression name = exitVar]) ifFalse: [								newStmts add:									(TAssignmentNode new										setVariable: (TVariableNode new setName: exitVar)										expression: stmt expression)]]].					(endsWithReturnOrIf and: [(returns includes: stmt) or: [extraneous includes: stmt]]) ifFalse: [						parents := OrderedCollection with: node.						parseTree nodesWithParentsDo: [:n :parent | 							n == parents last ifTrue: [parents addLast: parent]].						parents removeLast;	"nil"							removeLast.		"parseTree"						returnAlreadyExists := parents last isReturn.						returnAlreadyExists ifTrue: [							parents removeLast						] ifFalse: [							parents addLast: parseTree].						((parents allSatisfy: [:parent | parent isStmtList or: [parent isSend													and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse:) includes: parent selector]]])						and: [(parents select: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat) includes: parent selector]]) size >= 1]) ifTrue: [							needsConditionalAfterLoop := false.							loop := parents detect: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat) includes: parent selector]].							loopIndexWithinParents := parents indexOf: loop.							loopIndexWithinParents								to: parents size - 1								by: 2								do: [:i | | p pParent |									p := parents at: i.									pParent := parents at: i + 1.									((i + 1 = parents size or: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse:) includes: (parents at: i + 2) selector]) and: [p == pParent lastRealStatement])										ifFalse: [needsConditionalAfterLoop := true]].							breakLabel := 'Loop_', (selector copyWithout: $:), '_', loop identityHash.							exitVar isNil ifTrue: [								(needsConditionalAfterLoop or: [stmt expression isVariable not or: [stmt expression name ~= 'self']]) ifTrue: [									newExitVar := 'returnValueFrom', breakLabel.									newStmts removeLast;											addLast: (TAssignmentNode new															setVariable: (TVariableNode new setName: newExitVar)															expression: stmt expression).									(locals includes: newExitVar) ifFalse: [										locals addLast: newExitVar]]].							needsConditionalAfterLoop ifTrue: [								brokenFromLoopVarName := 'brokenFrom', breakLabel.								brokenFromLoopVar := TVariableNode new setName: brokenFromLoopVarName.								newStmts add:									(TAssignmentNode new										setVariable: brokenFromLoopVar										expression: (TConstantNode new setValue: true))].							loopParent := parents at: loopIndexWithinParents + 1. 							ix := loopParent statements indexOf: loop.							(loopParent lastRealStatement ~~ loop and: 							[maybeConditional := loopParent statements at: ix + 1.							(needsConditionalAfterLoop and: [maybeConditional isSend and: [maybeConditional selector == #ifTrue:ifFalse: and: [maybeConditional receiver isVariable and: [maybeConditional receiver name = brokenFromLoopVarName]]]]) or: 								[needsConditionalAfterLoop not and: 									[(newExitVar notNil and: [self isReturn: maybeConditional forBreakIn: 'Loop_', (selector copyWithout: $:) , '_' alreadyAddedIf: returnAlreadyExists]) or:									[exitVar isNil and: [maybeConditional isLeaf]]]]]) ifFalse: [								newLoopParentStatements := loopParent statements first: ix - 1.								needsConditionalAfterLoop ifTrue: [									locals addLast: brokenFromLoopVarName.									newLoopParentStatements										add: (TAssignmentNode new												setVariable: brokenFromLoopVar												expression: (TConstantNode new setValue: false));										add: loop;										add: (TSendNode new												setSelector: #ifTrue:ifFalse: 												receiver: brokenFromLoopVar 												arguments: {													TStmtListNode new 														setArguments: #() 														statements: (															OrderedCollection with: (																"we are processing the parseTree bottom-up, 																so the return will get processed .when the nodesDo: iteration gets to the loop's parent"																self returnFor: (exitVar ifNil: (newExitVar ifNil: 'nil')) given: returnAlreadyExists)).																										TStmtListNode new 														setArguments: #() 														statements: (loopParent lastRealStatement == loop 																		ifTrue: [{TVariableNode new setName: 'nil'}] 																		ifFalse: [loopParent statements allButFirst: ix])}).								] ifFalse: [									newExitVar notNil ifTrue: [										newLoopParentStatements											add: loop;											add: (self returnFor: newExitVar given: returnAlreadyExists).									].								].								(newLoopParentStatements includes: loop) ifTrue: [									loopParent setStatements: newLoopParentStatements.									"we broke the traversal, we have to restart it"									^self exitVar: exitVar label: exitLabel								].							].							newStmts add: (TBreakNode new).						] ifFalse: [							"generate a goto (this return is NOT the last statement in the method)"							newStmts add: (TGoToNode new setLabel: exitLabel).							labelUsed := true.						].					].				] ifFalse: [					(stmt isLeaf not or: [newStmts isEmpty]) ifTrue: [						newStmts addLast: stmt					].				].			].			node setStatements: (newStmts isEmpty ifTrue: [{TVariableNode new setName: 'nil'}] ifFalse: [newStmts])..		].	].	^labelUsed! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/7/2023 18:18'!exitVar: exitVar label: exitLabel valueUsed: aBool	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If aBool is false, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed endsWithReturnOrIf returns extraneous loopIdentifierPrefix stmtListsWithTerminalReturns |	labelUsed := false. 	(endsWithReturnOrIf := parseTree endsWithReturnOrIf) ifTrue: [		returns := IdentitySet new.		extraneous := IdentitySet new.		endsWithReturnOrIf := (parseTree addFinalIfReturnsTo: returns extraneous: extraneous) notNil.		aBool ifFalse: [			stmtListsWithTerminalReturns := IdentitySet new.			returns do: [:e | (e expression isSend and: [e expression hasSideEffect]) ifTrue: [				stmtListsWithTerminalReturns addAll: e expression stmtListsWithTerminalLocalReturns]]]].	loopIdentifierPrefix := 'Loop_', (selector copyWithout: $:) , '_'.	parseTree nodesDo: [ :node | | valueStatement |		node isStmtList ifTrue: [			valueStatement := (stmtListsWithTerminalReturns notNil and: [stmtListsWithTerminalReturns includes: node]) ifTrue: [node lastRealStatement].			newStmts := OrderedCollection new: 100.			node statements do: [ :stmt | | parents loop loopParent brokenFromLoopVar ix newLoopParentStatements returnAlreadyExists loopIdentifier loopIndexWithinParents brokenFromLoopVarName newExitVar expression needsConditionalAfterLoop terminalLocalReturns maybeConditional |				stmt isReturn ifTrue: [					exitVar = nil ifTrue: [						(aBool or: [stmt expression isLeaf not]) ifTrue: ["evaluate return expression even when value isn't used"							newStmts add: stmt expression].					] ifFalse: [						"assign return expression to exit variable"						expression := stmt expression.						((expression isSend and: [expression hasSideEffect]) and: [(terminalLocalReturns := expression stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [							terminalLocalReturns do: [:stmtList | | lastRealStatement |								lastRealStatement := stmtList lastRealStatement.								stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 									(TAssignmentNode new 										setVariable: (TVariableNode new setName: exitVar) 										expression: lastRealStatement)].							newStmts add: expression						] ifFalse: [							(expression isVariable and: [expression name = exitVar]) ifFalse: [								newStmts add:									(TAssignmentNode new										setVariable: (TVariableNode new setName: exitVar)										expression: stmt expression)]]].					(endsWithReturnOrIf and: [(returns includes: stmt) or: [extraneous includes: stmt]]) ifFalse: [						parents := OrderedCollection with: node.						parseTree nodesWithParentsDo: [:n :parent | 							n == parents last ifTrue: [parents addLast: parent]].						parents removeLast;	"nil"							removeLast.		"parseTree"						returnAlreadyExists := parents last isReturn.						returnAlreadyExists ifTrue: [							parents removeLast						] ifFalse: [							parents addLast: parseTree].						(labelUsed not and: [(parents allSatisfy: [:parent | parent isStmtList or: [parent isSend													and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse:) includes: parent selector]]])						and: [(parents select: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat) includes: parent selector]]) size >= 1]]) ifTrue: [							needsConditionalAfterLoop := false.							loop := parents detect: [:parent | parent isSend and: [#(to:by:do: whileTrue: whileFalse: whileTrue whileFalse repeat) includes: parent selector]].							loopIndexWithinParents := parents indexOf: loop.							loopIndexWithinParents								to: parents size - 1								by: 2								do: [:i | | p pParent lastRealStatement |									p := parents at: i.									pParent := parents at: i + 1.									((i + 1 = parents size or: 									[#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse:) includes: (parents at: i + 2) selector]) and: 										[p == (lastRealStatement := pParent lastRealStatement) or: 										[p == (pParent statements at: (pParent statements indexOf: lastRealStatement) - 1) and: 											[exitVar isNil and: 												[(aBool and: [self isReturn: lastRealStatement forBreakIn: loopIdentifierPrefix alreadyAddedIf: returnAlreadyExists]) or:												[aBool not and: [lastRealStatement isLeaf]]]]]])										ifFalse: [needsConditionalAfterLoop := true]].							loopIdentifier := loopIdentifierPrefix , loop identityHash.							(exitVar isNil and: [aBool]) ifTrue: [								(needsConditionalAfterLoop or: [stmt expression isVariable not or: [stmt expression name ~= 'self']]) ifTrue: [									newExitVar := 'returnValueFrom', loopIdentifier.									newStmts removeLast;											addLast: (TAssignmentNode new															setVariable: (TVariableNode new setName: newExitVar)															expression: stmt expression).									(locals includes: newExitVar) ifFalse: [										locals addLast: newExitVar]]].							needsConditionalAfterLoop ifTrue: [								brokenFromLoopVarName := 'brokenFrom' , loopIdentifier.								brokenFromLoopVar := TVariableNode new setName: brokenFromLoopVarName.								newStmts									add: (TAssignmentNode new											setVariable: brokenFromLoopVar											expression: (TConstantNode new setValue: true))].							loopParent := parents at: loopIndexWithinParents + 1. 							ix := loopParent statements indexOf: loop.							(loopParent lastRealStatement ~~ loop and: 							[maybeConditional := loopParent statements at: ix + 1.							(needsConditionalAfterLoop and: [maybeConditional isSend and: [maybeConditional selector == #ifTrue:ifFalse: and: [maybeConditional receiver isVariable and: [maybeConditional receiver name = brokenFromLoopVarName]]]]) or: 								[needsConditionalAfterLoop not and: 									[(newExitVar notNil and: [self isReturn: maybeConditional forBreakIn: loopIdentifierPrefix alreadyAddedIf: returnAlreadyExists]) or:									[aBool not and: [maybeConditional isLeaf]]]]]) ifFalse: [								newLoopParentStatements := loopParent statements first: ix - 1.								needsConditionalAfterLoop ifTrue: [									locals addLast: brokenFromLoopVarName.									newLoopParentStatements										add: (TAssignmentNode new												setVariable: brokenFromLoopVar												expression: (TConstantNode new setValue: false));										add: loop;										add: (TSendNode new												setSelector: #ifTrue:ifFalse: 												receiver: brokenFromLoopVar 												arguments: {													TStmtListNode new 														setArguments: #() 														statements: (															OrderedCollection with: (																"we are processing the parseTree bottom-up, 																so the return will get processed .when the nodesDo: iteration gets to the loop's parent"																self returnFor: (exitVar ifNil: (newExitVar ifNil: 'nil')) given: returnAlreadyExists)).																										TStmtListNode new 														setArguments: #() 														statements: (loopParent lastRealStatement == loop 																		ifTrue: [{TVariableNode new setName: 'nil'}] 																		ifFalse: [loopParent statements allButFirst: ix])}).								] ifFalse: [									newExitVar notNil ifTrue: [										newLoopParentStatements											add: loop;											add: (self returnFor: newExitVar given: returnAlreadyExists).									].								].								(newLoopParentStatements includes: loop) ifTrue: [									loopParent setStatements: newLoopParentStatements.									"we broke the traversal, we have to restart it"									^self exitVar: exitVar label: exitLabel valueUsed: aBool								].							].							newStmts add: (TBreakNode new).						] ifFalse: [							"generate a goto (this return is NOT the last statement in the method)"							newStmts add: (TGoToNode new setLabel: exitLabel).							labelUsed := true.						].					].				] ifFalse: [					(aBool or: [valueStatement isNil or: [stmt ~~ valueStatement or: [stmt isLeaf not or: [newStmts isEmpty]]]]) ifTrue: [						newStmts addLast: stmt					].				].			].			node setStatements: (newStmts isEmpty ifTrue: [{TVariableNode new setName: 'nil'}] ifFalse: [newStmts]).		].	] unless:		[:node |		node isSend		and: [node receiver printString = 'interpreterProxy isKindOf: InterpreterSimulator' 		and: [node selector == #ifTrue: or: 			[(node selector == #ifTrue:ifFalse: and: [node args last isNilStmtListNode]) or: 			[node selector == #ifFalse:ifTrue: and: [node args first isNilStmtListNode]]]]]].	^labelUsed! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:17'!extraVariableNumber	^extraVariableNumber! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:15'!hasProperties	^properties notNil and: [properties notEmpty]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/15/2023 23:29'!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp := 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt := stmtNode statements first.				stmt isSend ifTrue: [					sel := stmt selector.					meth := aCodeGen methodNamed: sel.					"Note, original version of this method tested for #hasNoCCode. Removed					the test to permit inlining methods that may contain automatically					generated C code for type conversions. -dtl"					((meth ~= nil) and:					 [meth args size = 0]) ifTrue: [						meth := meth copy.						meth hasReturn ifTrue: [							exitLabel := self unusedLabelForInliningInto: self. Warning signal: 'goto'.							meth exitVar: nil label: exitLabel valueUsed: false.							labels add: exitLabel.						] ifFalse: [ exitLabel := nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements := stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addFirst: meth asInlineNode.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars := (locals, args) asSet.	1 to: maxTemp do: [ :i |		v := ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/15/2023 22:54'!inlineChildrenOfSend: aNode in: aCodeGen	| statements valueStatement ix newVarName terminalLocalReturns statementsForTrue statementsForFalse newStatements value usedVars | 	aNode isSend ifFalse: [^ nil].	(self inlineableSend: aNode receiver in: aCodeGen) ifTrue: [		statements := (self inlineSend: aNode receiver directReturn: false exitVar: nil in: aCodeGen valueUsed: true) ifNil: [^nil].		valueStatement := statements reversed detect: [:e | e isLabel not].		value := aCodeGen nilOrReducibleValueOf: valueStatement rightmostSide.		((#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: aNode selector) and: 		[(#(true false) includes: value) or: [valueStatement isSend and: [valueStatement hasSideEffect and: [(terminalLocalReturns := valueStatement stmtListsWithTerminalLocalReturns) notEmpty]]]]) ifTrue: [			((#(true false) includes: value) or: 			[terminalLocalReturns anySatisfy: [:a | 					#(true false) includes: (aCodeGen nilOrReducibleValueOf: a lastRealStatement rightmostSide)]]) ifTrue: [				statementsForTrue := (#(ifTrue: ifTrue:ifFalse: and:) includes: aNode selector)											ifTrue: [aNode args first statements]											ifFalse: [#ifFalse:ifTrue: = aNode selector														ifTrue: [aNode args last statements]														ifFalse: [#ifFalse: = aNode selector																	ifTrue: [#()]																	ifFalse: [{TConstantNode new setValue: true}]]].				(statementsForTrue size = 1 and: [statementsForTrue first isConstantNull])					ifTrue: [statementsForTrue := #()].				statementsForFalse := (#(#ifFalse: #ifFalse:ifTrue: or:) includes: aNode selector)											ifTrue: [aNode args first statements]											ifFalse: [#ifTrue:ifFalse: = aNode selector														ifTrue: [aNode args last statements]														ifFalse: [#ifTrue: = aNode selector																	ifTrue: [#()]																	ifFalse: [{TConstantNode new setValue: false}]]].				(statementsForFalse size = 1 and: [statementsForFalse first isConstantNull])					ifTrue: [statementsForFalse := #()].				(#(true false) includes: value) ifTrue: [					valueStatement isAssignment ifFalse: [						statements remove: valueStatement].					value ifTrue: [						statements addAll: statementsForTrue					] ifFalse: [						statements addAll: statementsForFalse					].				] ifFalse: [					terminalLocalReturns do: [:stmtList | | lastRealStatement val |						lastRealStatement := stmtList lastRealStatement.						val := aCodeGen nilOrReducibleValueOf: lastRealStatement rightmostSide.						ix := stmtList statements indexOf: lastRealStatement.						val isNil ifTrue: [							stmtList statements at: ix put: 								(aNode copyTree receiver: lastRealStatement)						] ifFalse: [							(#(true false) includes: val) ifFalse: [self halt].							lastRealStatement isAssignment ifTrue: [								newStatements := stmtList statements first: ix.							] ifFalse: [								newStatements := stmtList statements first: ix - 1].							val ifTrue: [								newStatements := newStatements , statementsForTrue							] ifFalse: [								newStatements := newStatements , statementsForFalse							].							newStatements isEmpty ifTrue: [								newStatements := {TVariableNode new setName: 'nil'}].							stmtList setStatements: newStatements						]					].				]			] ifFalse: [				usedVars := aCodeGen globalsAsSet copy.				usedVars addAll: args; addAll: locals.				newVarName := 'ret_', (aNode receiver selector copyWithout: $:), '_', aNode receiver identityHash.				locals add: newVarName.				terminalLocalReturns do: [:stmtList | | lastRealStatement |					lastRealStatement := stmtList lastRealStatement.					stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 						(TAssignmentNode new 							setVariable: (TVariableNode new setName: newVarName) 							expression: lastRealStatement)].				statements 					add: (aNode copyTree receiver: (TVariableNode new setName: newVarName))					after: valueStatement.			]		] ifFalse: [			statements at: (statements indexOf: valueStatement) put: 				(aNode copyTree receiver: valueStatement).		].	].	((newVarName notNil or: [valueStatement isNil or: [(statements indexOf: valueStatement) = 0]]) and:	[aNode args anySatisfy: [:a | a isSend and: [self inlineableSend: a in: aCodeGen]]]) ifTrue: [ | lastRealStatement toBeMoved |		newVarName isNil ifTrue: [			usedVars := aCodeGen globalsAsSet copy.			usedVars addAll: args; addAll: locals].		statements isNil ifTrue: [			statements := OrderedCollection with: aNode].		ix := aNode args indexOf: (aNode args reversed detect: [:a | a isSend and: [self inlineableSend: a in: aCodeGen]]).		toBeMoved := aNode args first: ix.		lastRealStatement := statements reversed detect: [:e | e isLabel not].		valueStatement isNil ifTrue: [			valueStatement := aNode receiver].		(valueStatement isConstant not and: [valueStatement isVariable not or: [valueStatement name ~= 'self' and: [valueStatement name ~= 'interpreterProxy' and: 		[(args includes: valueStatement name) not and: [(locals includes: valueStatement name) not or: 		[toBeMoved anySatisfy: [:arg | arg isAssignment and: [arg variable name = valueStatement name]]]]]]]]) ifTrue: [			newVarName := self unusedNamePrefixedBy: 'rec' avoiding: usedVars. 			statements add: (TAssignmentNode new 								setVariable: (TVariableNode new setName: newVarName) 								expression: valueStatement)						before: lastRealStatement.			locals add: newVarName.			lastRealStatement receiver: (TVariableNode new setName: newVarName)].		toBeMoved withIndexDo: [:a :i | | stmts |			(a isConstant not and: [a isVariable not or: [a name ~= 'self' and: [(args includes: a name) not and: [(locals includes: a name) not or: 			[toBeMoved anySatisfy: [:arg | arg isAssignment and: [arg variable name = a name]]]]]]]) ifTrue: [				newVarName := self unusedNamePrefixedBy: 'arg', i avoiding: usedVars. "newVarName = 'arg11' ifTrue: [self halt]."				locals add: newVarName.				((self inlineableSend: a in: aCodeGen) and: 				[(stmts := self inlineSend: a directReturn: false exitVar: newVarName in: aCodeGen valueUsed: true) notNil]) 					ifFalse: [						statements add: (TAssignmentNode new 												setVariable: (TVariableNode new setName: newVarName) 												expression: a)										before: lastRealStatement					] ifTrue: [						stmts do: [:stmt | 							statements add: stmt										before: lastRealStatement					]].				aNode args at: i put: (TVariableNode new setName: newVarName)]].	].	^statements! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/6/2023 17:59'!inlineCodeOrNilForStatement: aNode in: aCodeGen valueUsed: aBool	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| statements valueStatement | 	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen valueUsed: true].		statements := (self inlineChildrenOfSend: aNode expression in: aCodeGen) ifNil: [^nil].		valueStatement := statements reversed detect: [:e | e isLabel not].		statements at: (statements indexOf: valueStatement) put: 			(TReturnNode new				setExpression: valueStatement).		^statements	]. 	aNode isAssignment ifTrue: [		(aNode expression isAssignment and: [self inlineableSend: aNode rightmostSide in: aCodeGen]) ifTrue: [			"self halt"].		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen valueUsed: true].		statements := (self inlineChildrenOfSend: aNode expression in: aCodeGen) ifNil: [^nil].		valueStatement := statements reversed detect: [:e | e isLabel not].		statements at: (statements indexOf: valueStatement) put: 			(TAssignmentNode new 				setVariable: (aNode variable copy) 				expression: valueStatement).		^statements	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen valueUsed: aBool].		^self inlineChildrenOfSend: aNode in: aCodeGen	].	^nil! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/13/2023 00:33'!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict expr |	sel := aSendNode selector. 	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict := Dictionary new: 100. 	meth args with: aSendNode args do: [ :argName :exprNode | | val subst |			exprNode isLeaf ifTrue: [			subst := exprNode		] ifFalse: [			val := aCodeGen nilOrReducibleValueOf: exprNode. 			val notNil ifTrue: [				subst := TConstantNode new setValue: val			]		].		subst isNil ifTrue: [			subst := exprNode		].		substitutionDict at: argName put: subst.		locals remove: argName.		declarations removeKey: argName ifAbsent: []	].	meth parseTree bindVariablesIn: substitutionDict.	expr := meth statements first expression.	expr isConstant ifFalse: [		(aCodeGen nilOrReducibleValueOf: expr) ifNotNil: [:val | self halt.			^TConstantNode new setValue: val			]		].	^ meth statements first expression! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/18/2023 18:14'!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen valueUsed: aBool	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel := aSendNode selector.	meth := (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType := meth returnType.		] ifFalse: [			exitLabel := self unusedLabelForInliningInto: self. 			labelUsed := meth exitVar: exitVar label: exitLabel valueUsed: aBool.			labelUsed				ifTrue: [ Transcript cr; show: sel. "labels add: exitLabel" ^nil ]				ifFalse: [ exitLabel := nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'sqInt']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	meth cleanupUnusedTemps;		removeUnreferencedDeclarations.	self addVarsDeclarationsAndLabelsOf: meth.	inlineStmts := OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add: (TLabeledCommentNode new setLabel: exitLabel comment: 'end ', sel).	] ifFalse: [		inlineStmts add: (TLabeledCommentNode new setComment: 'end ', sel)].	^inlineStmts! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/6/2023 20:17'!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args with: m args do: [ :a :argName | (self isSubstitutableNode: a as: argName intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].! !!JSMethod methodsFor: 'inlining' stamp: 'fm 8/4/2023 21:20'!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	(aNode receiver isVariable	 and: [aCodeGen isNonArgumentImplicitReceiverVariableName: aNode receiver name]) ifTrue: [			m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"].		^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 8/13/2023 23:18'!isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	parseTree statements do: [:s | 		s isLabel ifFalse: [			s isReturn ifFalse: [ ^false ].			s expression nodesDo: [ :n | | c |				n isReturn ifTrue: [ ^false ].				(n isStmtList and: [n statements size > 1]) ifTrue: [					c := 0.					n statements do: [:ns | 						ns isLabel ifFalse: [							c > 0 ifTrue: [ ^false ]. 							c := c + 1]]]]]].	^true! !!JSMethod methodsFor: 'inlining' stamp: 'fm 8/12/2023 23:08'!isReturn: stmt forBreakIn: loopIdentifierPrefix alreadyAddedIf: returnAlreadyExists	^(returnAlreadyExists and: [stmt isVariable and: [stmt name beginsWith: 'returnValueFrom', loopIdentifierPrefix]]) or: 	[stmt isReturn and: [self isReturn: stmt expression forBreakIn: loopIdentifierPrefix alreadyAddedIf: returnAlreadyExists not]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 9/16/2023 14:20'!isSubstitutableNode: aNode as: argName intoMethod: targetMeth in: aCodeGen	| var atMostOne first |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var := aNode name.		((locals includes: var) or: [(#(self 'true' 'false' 'nil') includes: var) or: [args includes: var]]) ifTrue: [ ^true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^true ].	].	(aCodeGen nilOrReducibleValueOf: aNode) notNil ifTrue: [ ^true ].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			(node hasSideEffect not or: [node isBuiltinOperator or: [(aCodeGen nilOrReducibleValueOf: node) notNil]]) ifFalse: [ ^false ].		] ifFalse: [			node isVariable ifTrue: [				var := node name.				((locals includes: var) or: [(args includes: var) or: [(#(self 'true' 'false' 'nil') includes: var) or:				 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^false ].			] ifFalse: [				node isConstant ifFalse: [ ^false ].			].		]	].	atMostOne := true.	first := nil.	targetMeth parseTree nodesDo: [:node |		(node isVariable and: [node name = argName]) ifTrue: [			first isNil ifTrue: [first := node] ifFalse: [atMostOne := false]		]	].	^ atMostOne! !!JSMethod methodsFor: 'inlining' stamp: 'fm 9/16/2023 14:22'!isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var := aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			(node hasSideEffect not or: [node isBuiltinOperator or: [(aCodeGen nilOrReducibleValueOf: node) notNil]]) ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var := node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:14'!mergePropertiesOfSuperMethod: superTMethod	superTMethod hasProperties ifFalse:		[^self].	self hasProperties ifFalse:		[properties := superTMethod properties.		 ^self].	superTMethod properties pragmas do:		[:aPragma|		(self shouldIncorporatePragmaFromSuperMethod: aPragma) ifTrue:			[properties := properties copyWith: aPragma]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 9/10/2023 22:21'!potentiallyInlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	(aNode receiver isVariable	 and: [aCodeGen isNonArgumentImplicitReceiverVariableName: aNode receiver name]) ifTrue: [			m := aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"].		^(m ~= nil) and: [aCodeGen mayInline: m selector]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:15'!properties	^properties! !!JSMethod methodsFor: 'inlining' stamp: 'fm 1/7/2022 17:57'!removeUnreferencedDeclarations	"Variables may have been eliminated during inlining. Remove declarations for those variables."	declarations keys copy		do: [:key | (args , locals includes: key)				ifFalse: [declarations removeKey: key]]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/8/2023 00:26'!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining.	 We do not want to inline code strings within cCode:inSmalltalk: blocks (those with a	 proper block for the cCode: argument are inlined in MessageNode>>asTranslatorNodeIn:).	 We do not want to inline code within assert: sends (because we want the assert to read nicely)."	| stmtLists |	stmtLists := OrderedCollection new: 10.	parseTree		nodesDo:			[:node|			(node isStmtList and: [node isNilStmtListNode not]) ifTrue: [stmtLists add: node]]		unless:			[:node|			node isSend			and: [node selector == #cCode:inSmalltalk:]].	parseTree nodesDo: [ :node | 		node isSend ifTrue:			[node selector = #cCode:inSmalltalk: ifTrue:				[node nodesDo:					[:ccisNode| stmtLists remove: ccisNode ifAbsent: []]]].	].	^stmtLists! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/8/2023 00:18'!stmtListsWithTerminalReturns	| stmtLists lastRealExpression | 	stmtLists := IdentitySet new: 10.	(parseTree lastRealStatement isReturn and: [		((lastRealExpression := parseTree lastRealStatement rightmostSide) isLeaf and: [lastRealExpression isVariable not or: [lastRealExpression name ~= 'self']]) or:		[lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]]	) ifTrue: [		stmtLists add: parseTree].	parseTree nodesDo: [:node |		(node isAssignment and: [node rightmostSide isSend]) ifTrue: [			stmtLists addAll: node rightmostSide stmtListsWithTerminalLocalReturnsNoTransform		] ifFalse: [			(node isReturn and: [node expression isSend]) ifTrue: [				stmtLists addAll: node expression stmtListsWithTerminalLocalReturnsNoTransform			] ifFalse: [				node isSend ifTrue: [					(#(whileTrue whileFalse whileTrue: whileFalse:) includes: node selector) ifTrue: [						lastRealExpression := node receiver lastRealStatement rightmostSide.						(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [							stmtLists add: node receiver.						]					] ifFalse: [						stmtLists addAll: node stmtListsWithTerminalLocalReturnsNoTransform.						node receiver isSend ifTrue: [							stmtLists addAll: node receiver stmtListsWithTerminalLocalReturnsNoTransform].						node args do: [:a |							a isSend ifTrue: [								stmtLists addAll: a stmtListsWithTerminalLocalReturnsNoTransform.							]						]					]				] ifFalse: [					node isCaseStmt ifTrue: [						stmtLists addAll: node stmtListsWithTerminalLocalReturnsNoTransform.					]				]			]		]	].	^stmtLists! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/28/2020 18:13'!superExpansionNodeFor: aSelector args: argumentNodes	"Answer the expansion of a super send.  Merge the super expansion's	 locals, properties and comment into this method's properties."	(definingClass superclass lookupSelector: aSelector)		ifNil: [self error: 'superclass does not define super method']		ifNotNil:			[:superMethod| | superTMethod commonVars varMap |			superTMethod := superMethod methodNode asTranslationMethodOfClass: self class.			((argumentNodes allSatisfy: [:parseNode| parseNode isVariableNode])			and: [(argumentNodes asOrderedCollection collect: [:parseNode| parseNode key]) = superTMethod args]) ifFalse:				[self error: definingClass name, '>>',selector, ' args ~= ',							superTMethod definingClass name, '>>', aSelector,							(String with: $. with: Character cr),							'For super expansions to be translated correctly each argument must be a variable with the same name as the corresponding argument in the super method.'].			self mergePropertiesOfSuperMethod: superTMethod.			(commonVars := superTMethod locals intersection: self locals) notEmpty ifTrue:				[varMap := Dictionary new.				 commonVars do:					[:k| varMap at: k put: (superTMethod unusedNamePrefixedBy: k avoiding: self allLocals)].				 superTMethod renameVariablesUsing: varMap].			self assert: (superTMethod locals allSatisfy: [:var| (self locals includes: var) not]).			locals addAll: superTMethod locals.			superTMethod declarations keysAndValuesDo:				[:var :decl|				self declarationAt: var put: decl].			superTMethod comment ifNotNil:				[:superComment|				comment := comment								ifNil: [superComment]								ifNotNil: [superComment, comment]].			superTMethod extraVariableNumber ifNotNil:				[:scvn|				extraVariableNumber := extraVariableNumber ifNil: [scvn] ifNotNil: [:cvn| cvn + scvn]].			superTMethod elideAnyFinalReturn.			^superTMethod parseTree]! !!JSMethod methodsFor: 'inlining' stamp: 'fm 10/18/2023 18:40'!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements sendsToInline stmtListsWithTerminalReturns worthTryingThisRound |	didSomething := false.	sendsToInline := Dictionary new: 100. 	parseTree		nodesDo:			[:node|			(self inlineableFunctionCall: node in: aCodeGen) ifTrue:				[sendsToInline at: node put: (self inlineFunctionCall: node in: aCodeGen)]].	sendsToInline isEmpty ifFalse:		[didSomething := true.		self cleanupUnusedTemps.		parseTree := parseTree replaceNodesIn: sendsToInline].	didSomething ifTrue:		[writtenToGlobalVarsCache := nil. 		^didSomething].	complete ifFalse: [		worthTryingThisRound := false.		parseTree nodesDo: [:node |			(self inlineableSend: node in: aCodeGen) ifTrue: [				worthTryingThisRound := true]].		worthTryingThisRound ifTrue: [			stmtLists := self statementsListsForInlining.			stmtListsWithTerminalReturns := self stmtListsWithTerminalReturns.			stmtLists do:				[:stmtList | | valueStatement |				newStatements := OrderedCollection new: 100.				valueStatement := (stmtListsWithTerminalReturns includes: stmtList) ifTrue: [stmtList lastRealStatement].				stmtList statements do:					[:stmt| 					(self inlineCodeOrNilForStatement: stmt in: aCodeGen valueUsed: valueStatement == stmt)						ifNil: [(stmt == valueStatement or: [stmt isLabel or: [stmt isLeaf not]]) ifTrue: [								newStatements addLast: stmt]]						ifNotNil: [:inlinedStmts|							didSomething := true.							newStatements addAllLast: inlinedStmts]].				stmtList setStatements: newStatements asArray].			didSomething ifTrue:				[writtenToGlobalVarsCache := nil.				self cleanupUnusedTemps.				^didSomething].			self checkForCompleteness: stmtLists in: aCodeGen.		] ifFalse: [			complete := true.			parseTree nodesDo: [:node |				(self potentiallyInlineableSend: node in: aCodeGen) ifTrue: [					complete := false]].		].		complete ifTrue: [ didSomething := true ]  "marking a method complete is progress"	].	^didSomething! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/22/2021 00:14'!argConversionExprFor: varName stackIndex: stackIndex 	"Return the parse tree for an expression that fetches and converts the 	primitive argument at the given stack offset."	| exprList decl stmtList |	exprList := OrderedCollection new.	oneBasedArrays ifNil: [oneBasedArrays := Set new]. "only non-nil in a primitive method"	(declarations includesKey: varName) ifTrue: [		decl := declarations at: varName.		(decl includes: $*) ifTrue: ["array" 			(locals includes: varName, 'Oop') ifTrue: [self halt].			args at: args size - stackIndex put: varName, 'Oop'.			locals add: varName.			(decl includesSubString: 'char') ifTrue:[				exprList add: varName , ' := ', 'nil checkIsBytes: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'unsigned int') ifTrue:[				exprList add: varName , ' := nil checkIsWords: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'unsigned short') ifTrue:[				exprList add: varName , ' := nil checkIsShorts: ', varName, 'Oop'] ifFalse: [			(decl includesSubString: 'short int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedShorts: ', varName, 'Oop'] ifFalse: [			(decl beginsWith: 'int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedInts: ', varName, 'Oop'] ifFalse: [			self halt]]]]].			self beOneBasedArray: varName.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add: 'nil checkIsFloat: ', varName.		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add: 'nil checkIsInteger: ', varName.	].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/6/2021 19:23'!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr := 'rcvr := this'.	^ self statementsFor: expr varName: ''! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 12/26/2020 19:30'!fixUpReturns: argCount postlog: postlog	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	| newStmts |	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			newStmts := OrderedCollection new: 100.			node statements do: [:stmt |				stmt isReturn					ifTrue: [						(stmt expression isSend and:						 ['primitiveFail' = stmt expression selector])							ifTrue: [  "failure return"								newStmts addLast: stmt expression]							ifFalse: [  "normal return"								newStmts addAll: postlog.								newStmts addLast: (TSendNode new									setSelector: #push:									receiver: (TVariableNode new setName: self vmNameString)									arguments: {stmt expression}).								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]]					ifFalse: [						newStmts addLast: stmt]].			node setStatements: newStmts asArray]].! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/22/2021 00:07'!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| exprList decl stmtList |	exprList := OrderedCollection with: varName, ' := this __pointersAt: ', instIndex.	oneBasedArrays ifNil: [oneBasedArrays := Set new]. "only non-nil in a primitive method"	(declarations includesKey: varName) ifTrue: [		decl := declarations at: varName.		(decl includes: $*) ifTrue: ["array"			exprList removeLast.			(decl includesSubString: 'char') ifTrue: [				exprList add: varName , ' := nil checkIsBytes: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'unsigned int') ifTrue:[				exprList add: varName , ' := nil checkIsWords: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'unsigned short') ifTrue:[				exprList add: varName , ' := nil checkIsShorts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl includesSubString: 'short int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedShorts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			(decl beginsWith: 'int') ifTrue:[				exprList add: varName , ' := nil checkIsSignedInts: (this __pointersAt: ', instIndex, ')'] ifFalse: [			self halt]]]]].			self beOneBasedArray: varName.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add: 'nil checkIsFloat: ', varName.		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add: 'nil checkIsInteger: ', varName.	].	stmtList := OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 1/14/2022 18:17'!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr := 'this __pointersAt: ', instIndex, ' put: ', varName.	^ self statementsFor: expr varName: varName! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 11/13/2020 02:06'!preparePrimitiveName	"Prepare the selector for this method in translation"	| aClass |	aClass := definingClass.	primitive = 117 		ifTrue:[selector := ((aClass includesSelector: selector)					ifTrue: [aClass compiledMethodAt: selector]					ifFalse: [aClass class compiledMethodAt: selector]) literals first at: 2.				export := true]		ifFalse:[selector := 'prim', aClass name, selector].! !!JSMethod methodsFor: 'primitive compilation' stamp: 'fm 3/21/2021 16:49'!preparePrimitivePrologue	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn aClass |	aClass := definingClass.	prolog := OrderedCollection new.	postlog := OrderedCollection new.	instVarsUsed := self freeVariableReferences asSet.	varsAssignedTo := self variablesAssignedTo asSet.	instVarList := aClass allInstVarNames.	primArgCount := args size.	1 to: args size do: [:argIndex |		varName := args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName := instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	((locals includes: 'this') or: [(locals intersection: args) notEmpty]) ifTrue:		[self error: 'local name conflicts with instance variable name'].	endsWithReturn := self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [parseTree setStatements: prolog, parseTree statements, postlog].! !!JSMethod methodsFor: 'transformations' stamp: 'fm 9/18/2020 16:11'!buildSwitchStmt: aSendNode parent: parentNode	"Build a switch statement node for the given send of caseOf: or caseOf:otherwise:."	| switch |	switch := TSwitchStmtNode new				expression: aSendNode receiver				cases: aSendNode args first				otherwiseOrNil: (aSendNode args at: 2 ifAbsent: [nil]).	(aSendNode receiver isVariable or: [parentNode isStmtList]) ifFalse:		[switch switchVariable: (locals add: (self extraVariableName: 'switch'))].	^switch! !!JSMethod methodsFor: 'transformations' stamp: 'fm 7/26/2023 12:59'!prepareMethodIn: aCodeGen	"Record sends of builtin operators, map sends of the special selector dispatchOn:in:	 with case statement nodes, and map sends of caseOf:[otherwise:] to switch statements.	 As a hack also update the types of variables introduced to implement cascades correctly.	 This has to be done at the same time as this is done, so why not piggy back here?"	extraVariableNumber ifNotNil:		[declarations keysAndValuesDo:			[:varName :decl|			decl isBlock ifTrue:				[self assert: ((varName beginsWith: 'cascade') and: [varName last isDigit]).				 locals add: varName.				 self declarationAt: varName					put: (decl value: self value: aCodeGen), ' ', varName]]].	aCodeGen		pushScope: declarations		while:"N.B.  nodesWithParentsDo: is bottom-up, hence replacement is destructive and conserved."			[parseTree nodesWithParentsDo:				[:node :parent|				 node isSend ifTrue:					[(aCodeGen isBuiltinSelector: node selector)						ifTrue:							[node isBuiltinOperator: true]						ifFalse:							[(CaseStatements includes: node selector) ifTrue:								[parent replaceNodesIn: (Dictionary newFromPairs: { node. self buildCaseStmt: node})].							 (#(caseOf: #caseOf:otherwise:) includes: node selector) ifTrue:								[parent replaceNodesIn: (Dictionary newFromPairs: { node. self buildSwitchStmt: node parent: parent })].							(node receiver isVariable							 and: [node receiver name = #Character							 and: [node selector isUnary]]) ifTrue:								[parent replaceNodesIn: (Dictionary newFromPairs: { node. TConstantNode new setValue: (Character perform: node selector) })]]]]]! !!JSMethod methodsFor: 'transformations' stamp: 'fm 8/5/2023 18:29'!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList expr lastRealStatement |	stmtList := parseTree statements asOrderedCollection.	lastRealStatement := parseTree lastRealStatement.	(stmtList notEmpty and: [lastRealStatement isReturn]) ifTrue:		[expr := lastRealStatement expression.		 (expr isVariable and: [expr name = 'self'])			ifTrue: [parseTree setStatements: (stmtList reject: [:a | a == lastRealStatement])]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/12/2021 15:18'!checkSendNode: node for: arg	^TSendNode new		setSelector: (node selector caseOf: {											[#stackFloatValue:]->[#checkIsFloat:]. 											[#stackIntegerValue:]->[#checkIsInteger:]. 											[#stackObjectValue:]->[#checkIsNotNumber:]}) 		receiver:  (TVariableNode new setName: 'nil')		arguments: {arg}! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 1/12/2022 22:18'!checkedSendNodeExpr: node for: arg	^TSendNode new		setSelector: (node selector caseOf: {											[#stackFloatValue:]->[#floatValueOf:]. 											[#stackIntegerValue:]->[#checkedInteger:]. 											[#stackObjectValue:]->[#checkedNotNumber:]}) 		receiver:  (TVariableNode new setName: 'nil')		arguments: {arg}! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 7/25/2023 18:48'!definedAsMacro	^properties notNil	  and: [(properties includesKey: #cmacro:)		or: [properties includesKey: #cmacro]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 10/18/2023 18:39'!emitJSCodeOn: aStream generator: aCodeGen	"Emit JS code for this method onto the given stream. All calls to inlined methods should already have been expanded."	aCodeGen currentMethod: self.	args isEmpty ifTrue: [		self replaceStackUsageFor: aCodeGen	].	aCodeGen pushScope: declarations while: [ 		self emitJSCommentOn: aStream.	"place method comment before function"		self emitJSHeaderOn: aStream generator: aCodeGen.		parseTree nodesWithParentsDo: [:node :parent | | stmLists |			(node isAssignment and: [node expression isSend and: 			[(node expression args anySatisfy: [:a | a canBeExpression not]) and:			[(stmLists := node expression stmtListsWithTerminalLocalReturns) notEmpty]]]) ifTrue: [				parent statements at: (parent statements indexOf: node) put: node expression.				stmLists do: [:s | | lastRealStatement |					lastRealStatement := s lastRealStatement.					s statements at: (s statements indexOf: lastRealStatement) put: (TAssignmentNode new 																							setVariable: node variable copy																							expression: lastRealStatement)]].			(node isReturn and: [node expression isSend and: 			[(node expression args anySatisfy: [:a | a canBeExpression not]) and:			[(stmLists := node expression stmtListsWithTerminalLocalReturns) notEmpty]]]) ifTrue: [				parent statements at: (parent statements indexOf: node) put: node expression.				stmLists do: [:s | | lastRealStatement |					lastRealStatement := s lastRealStatement.					s statements at: (s statements indexOf: lastRealStatement) put: (TReturnNode new setExpression: lastRealStatement)]]].		parseTree emitJSCodeOn: aStream level: 1 generator: aCodeGen.		aStream nextPutAll: '}'; cr]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 12/11/2020 00:15'!emitJSFunctionHeader: aStream generator: aCodeGen newlineBeforeName: newlineBeforeName "<Boolean>"	"Emit a JS function header for this method onto the given stream."	(returnType last = $)	and: [returnType includesSubString: (aCodeGen jsFunctionNameFor: self selectorForCodeGeneration)]) ifTrue:		["Hack fix for e.g. <returnTypeC: 'void (*setInterruptCheckChain(void (*aFunction)(void)))()'>"		aStream nextPutAll: 'function'.		newlineBeforeName ifTrue: [aStream cr] ifFalse: [aStream space].		 ^self].	aStream		nextPutAll: (aCodeGen jsFunctionNameFor: self selectorForCodeGeneration);		nextPut: $(.	args		do: [:arg | aStream nextPutAll: (aCodeGen returnPrefixFromVariable: arg)]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $)! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/21/2021 16:36'!emitJSHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr. 	self emitJSFunctionHeader: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	self emitGlobalStructReferenceOn: aStream.	locals do: [ :var | | varDecl |		aStream nextPutAll: '	let ', (aCodeGen returnPrefixFromVariable: var).		varDecl := declarations at: var asString ifAbsent: [''].		(varDecl includes: $=)			ifTrue: [ | const |				const := ((varDecl copyAfter: $=) replaceAll: ${ with: $[) replaceAll: $} with: $].				aStream nextPutAll: ' =', const]			ifFalse: [(varDecl includes: $[)					ifTrue: [ | size |						size := (varDecl copyAfter: $[) copyUpTo: $].						size ifEmpty: [self halt].						aStream nextPutAll: ' = new Array(', size, ')']].		aStream nextPutAll: ';'; cr	].	(#(primitiveExtractChannel primitiveCondenseSound) includes: selector)		ifTrue: [#(src dst) do: [:v | aStream nextPutAll: '	var _', v, ' = 0;'; cr]].	locals isEmpty ifFalse: [ aStream cr ].! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 3/12/2021 18:16'!is: node argumentCountUsing: argCountVarName	^(node isVariable and: [node name = argCountVarName]) or:		[node isSend and: [#methodArgumentCount = node selector]]! !!JSMethod methodsFor: 'JS code generation' stamp: 'fm 9/21/2023 00:49'!replaceStackUsageFor: aCodeGen	| argsDict argCount argCountVar receiver toReplace toInsertBefore toRemove isPrimitive trueArgCount recName receiverHackNeeded |	isPrimitive := primitive > 0 or: [export and: [selector beginsWith: 'prim']].	receiverHackNeeded := #(KedamaPlugin KedamaPlugin2) includes: aCodeGen pluginName.	argCount := -1.	argsDict := Dictionary new.	toRemove := Set new.	toReplace := Dictionary new.	toInsertBefore := Dictionary new.	parseTree nodesWithParentsDo: [:node :parent | | const isReceiver checkNode newStmts argName arg constVal varName receiverIndex firstArg rec sel |		node isSend ifTrue: [			(#(stackValue: stackFloatValue: stackIntegerValue: stackObjectValue:) includes: (sel := node selector)) ifTrue: [				isReceiver := false.				(const := node args first) isConstant ifTrue: [					argCount < const value ifTrue: [argCount := const value]										] ifFalse: [					(self is: const argumentCountUsing: argCountVar) ifTrue: [						isReceiver := true.					] ifFalse: [self halt]				].				constVal := const value.				parent isAssignment ifTrue: [					(locals includes: (varName := parent variable name)) ifTrue: [						arg := parent variable.						(argsDict keyAtValue: varName ifAbsent: [constVal]) = constVal							ifFalse: [self halt].						(argsDict at: constVal ifAbsentPut: [varName]) = varName							ifFalse: ["It can happen because of inlining, it is an alias for the same stack slot"								toReplace at: node put: (TVariableNode new setName: (argsDict at: constVal))							].						(isReceiver or: [isReceiver := ((#(#rcvr #rcvrOop ) includes: varName) and: [receiverHackNeeded not]) or: [trueArgCount = constVal]]) ifTrue: [							(receiver notNil and: [receiver ~= varName])								ifTrue: [self halt].							receiver := varName.							(trueArgCount notNil and: [trueArgCount ~= constVal])								ifTrue: [self halt].							constVal isNumber ifTrue: [								trueArgCount := constVal.							]						]					] ifFalse: [						isReceiver ifTrue: [							receiver := argName := 'this'.						] ifFalse: [							argName := self unusedNamePrefixedBy: 'arg' avoiding: locals, argsDict values.							argsDict at: constVal put: argName.						].						arg := TVariableNode new setName: argName.					].					#stackValue: == sel ifTrue: [						argName isNil ifTrue: [toRemove add: parent] ifFalse: [toReplace at: node put: arg]					] ifFalse: [						toReplace at: (argName isNil ifTrue: [parent] ifFalse: [node]) put: (self checkedSendNodeExpr: node for: arg)					].				] ifFalse: [					toReplace at: node put: ((isReceiver or: [trueArgCount = constVal]) ifTrue: [												TVariableNode new setName: 'this'											] ifFalse: [constVal]).					#stackValue: == sel ifFalse: [						checkNode := self checkSendNode: node for: node.						parent isStmtList ifTrue: [							newStmts := parent statements asOrderedCollection.							newStmts add: checkNode before: node.							parent setStatements: newStmts						] ifFalse: [							toInsertBefore at: parent put: checkNode						]					]				]			] ifFalse: [				#methodArgumentCount = sel ifTrue: [					parent isAssignment ifTrue: [						toRemove add: parent.						argCountVar := parent variable name.						locals remove: argCountVar.					]				] ifFalse: [					rec := node receiver.					((#(= == ~= ~~) includes: sel) and: [(const := (firstArg := node args first)) isConstant or: [(const := rec) isConstant]]) ifTrue: [						((self is: firstArg argumentCountUsing: argCountVar) or:						[self is: rec argumentCountUsing: argCountVar]) ifTrue: [							constVal := const value.							argCount < constVal ifTrue: [argCount := constVal].													trueArgCount isNil ifTrue: [trueArgCount := constVal] ifFalse: [self halt].						]					] ifFalse: [						(#(pop: pop:thenPush: methodReturnBool: methodReturnFloat: methodReturnInteger: methodReturnReceiver methodReturnValue:) includes: sel) ifTrue: [							(#(pop: pop:thenPush:) includes: sel) ifTrue: [								(const := node args first) isConstant ifTrue: [									constVal := const value.									argCount + 1 < constVal ifTrue: [										argCount := constVal - 1.										receiver notNil ifTrue: [											receiverIndex := argsDict keyAtValue: receiver ifAbsent: [argCount].											(receiverIndex isInteger and: [receiverIndex < argCount]) ifTrue: [												"Not a true receiver"												receiver := nil].										].									]									]												].							sel caseOf: {								[#methodReturnBool:]->[toReplace at: node put: (TSendNode new															setSelector: #pushBool: 															receiver: rec															arguments: (node args last: 1))].								[#methodReturnFloat:]->[toReplace at: node put: (TSendNode new															setSelector: #pushFloat: 															receiver: rec															arguments: (node args last: 1))].								[#methodReturnInteger:]->[toReplace at: node put: (TSendNode new															setSelector: #pushInteger: 															receiver: rec															arguments: (node args last: 1))].								[#methodReturnValue:]->[toReplace at: node put: (TSendNode new															setSelector: #push: 															receiver: rec															arguments: (node args last: 1))].								[#pop:thenPush:]->[toReplace at: node put: (TSendNode new															setSelector: #push: 															receiver: rec															arguments: (node args last: 1))].							} otherwise: [								parent isStmtList ifTrue: [									parent setStatements: (parent statements copyWithout: node)								] ifFalse: [									parent isReturn ifTrue: [										toReplace at: node put: (TVariableNode new setName: 'null').									] ifFalse: [self halt].								]							].						].					].				].			].		] ifFalse: [			(node isVariable and: [node name = receiver and: [receiver ~= 'this']]) ifTrue: [				receiver = 'this' ifTrue: [self halt].				toReplace at: node put: (TVariableNode new setName: 'this')			]		].		parent notNil ifTrue: [			parent isStmtList ifTrue: [				(toRemove includes: node) ifTrue: [					parent setStatements: (parent statements copyWithout: node).					toRemove remove: node				] ifFalse: [					(toInsertBefore includesKey: node) ifTrue: [						newStmts := parent statements asOrderedCollection.						newStmts add: (toInsertBefore removeKey: node) before: node.						parent setStatements: newStmts]				]			] ifFalse: [				(toRemove includes: node) ifTrue: [					toReplace at: node put: node variable.					toRemove remove: node				] ifFalse: [					(toInsertBefore includesKey: node) ifTrue: [						toInsertBefore at: parent put: (toInsertBefore removeKey: node)]				]			]		]	].	(toRemove isEmpty and: [toInsertBefore isEmpty]) ifFalse: [self halt].	trueArgCount notNil ifTrue: [		trueArgCount < argCount  ifTrue: [self halt].		(argsDict includesKey: trueArgCount) ifTrue: [			recName := argsDict at: trueArgCount.			toReplace values do: [:n | 				n isInteger ifFalse: [					(n isVariable and: [n name = recName]) ifTrue: [						n setName: 'this'					] ifFalse: [						(n isSend and: [n args first name = recName]) ifTrue: [							n args first setName: 'this'						]					]				]			]		].	].	(receiver isNil and: [trueArgCount isNil and: [argsDict includesKey: argCount]]) ifTrue: [		argCount := argCount + 1].	argCount - 1 to: 0 by: -1 do: [:i | 		locals remove: (args add: (argsDict at: i ifAbsent: ['_arg', (argCount - i)])) ifAbsent: []].	receiver notNil ifTrue: [		locals remove: receiver].	toReplace associationsDo: [:a | 		a value isInteger ifTrue: [			a value: (TVariableNode new setName: (argsDict at: a value ifAbsent: ['_arg', (argCount - a value)]))		]].	toReplace isEmpty ifFalse: [		parseTree replaceNodesIn: toReplace.	].	isPrimitive ifTrue: [ 		parseTree hasFinalReturn ifFalse: [			parseTree statements add: (TSendNode new											setSelector: #push: 											receiver: (TVariableNode new setName: 'interpreterProxy')											arguments: {TVariableNode new setName: 'this'})					]	]! !!JSMethod methodsFor: 'initialization' stamp: 'fm 4/24/2021 23:10'!setSelector: sel definingClass: class args: argList locals: localList block: aBlockNode primitive: aNumber properties: methodProperties comment: aComment	"Initialize this method using the given information."	selector := sel.selector = #primitivePixelValueAtX:y: ifTrue: [Warning signal: 'here'].	definingClass := class.	returnType := #sqInt. 	 "assume return type is long for now"	args := argList asOrderedCollection collect: [:arg | arg key].	locals := (localList asSortedCollection: [:a :b| a key < b key]) collect: [:arg | arg key].	declarations := Dictionary new.	"self addTypeForSelf." "<- Cog feature to be added later"	primitive := aNumber.	properties := methodProperties.	comment := aComment.	parseTree := aBlockNode asTranslatorNodeIn: self.	labels := OrderedCollection new.	complete := false.  "set to true when all possible inlining has been done"	export := self extractExportDirective.	static := self extractStaticDirective.	canAsmLabel := self extractLabelDirective.	self extractSharedCase.	self removeFinalSelfReturn.	"must preceed recordDeclarations because this may set returnType"	self recordDeclarations.	globalStructureBuildMethodHasFoo := 0! !!JSMethod methodsFor: 'private' stamp: 'fm 3/6/2021 19:25'!printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| stackPointer successFlag ' , varName , ' |';	 cr! !!JSMethod methodsFor: 'private' stamp: 'fm 9/9/2023 21:06'!returnFor: exitVar given: returnAlreadyExists	^returnAlreadyExists		ifTrue: [TVariableNode new setName: exitVar]		ifFalse: [TReturnNode new setExpression: (TVariableNode new setName: exitVar)]! !!JSPluginCodeGenerator methodsFor: 'JS code generator' stamp: 'fm 7/14/2023 15:05'!emitJSHeaderOn: aStream	"Write a JS file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: (VMMaker headerNotice copyReplaceAll: ' C ' with: ' JavaScript ').	aStream nextPutAll: ' */';cr.	aStream nextPutAll: (self fileHeaderVersionStampForSourceClass: vmClass).	self emitInterpreterProxyVersionOn: aStream.	self emitJSFunctionsOn: aStream.! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 5/11/2021 18:39'!emitJSCodeOn: aStream doAssertions: assertionFlag"FM - moved down from JSCodeGenerator"	self emitJSHeaderOn: aStream.	self emitJSConstantsOn: aStream.	self emitJSVariablesOn: aStream.	aStream cr; cr; nextPutAll: 'globalThis.';		nextPutAll: pluginName;		nextPutAll: ' = {'.	preparedMethodList doWithIndex: [ :m :i | 		aStream nextPutAll: (String streamContents: [:s | m emitJSCodeOn: s generator: self. s nextPutAll: ', '])].	aStream cr; nextPut: $}.! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 7/13/2023 02:41'!generateCodeStringForPrimitives"TPR - moved down from JSCodeGenerator"	| s methodList |	self removeVariable: 'interpreterProxy'; removeVariable: 'moduleName'.	self pruneMethods: self ignoredMethods.	s := ReadWriteStream on: (String new: 1000).	methodList := methods asSortedCollection: [:m1 :m2 | m1 selector < m2 selector].	self emitJSHeaderOn: s.	self emitJSConstantsOn: s.	self emitJSVariablesOn: s.	s cr; cr; nextPutAll: 'globalThis.';		nextPutAll: pluginName;		nextPutAll: ' = {'.	methodList do: [:m | m emitJSCodeOn: s generator: self. s nextPutAll: ', '].	s cr; nextPut: $}.	^ s contents! !!JSPluginCodeGenerator methodsFor: 'public' stamp: 'fm 12/12/2020 22:58'!ignoredMethods	pluginName = 'BitBltPlugin' ifTrue: [		^#(dstLongAt: dstLongAt:put: srcLongAt: halt msg: getModuleName setInterpreter:)].	pluginName = 'ScratchPlugin' ifTrue: [			^super ignoredMethods, (ScratchPlugin organization listAtCategoryNamed: 'serial port'), 				(ScratchPlugin organization listAtCategoryNamed: 'os functions')].	pluginName = 'B2DPlugin' ifTrue: [		^super ignoredMethods, (self translatedMethodsB2DPlugin collect: [:ea | ea key])].	^super ignoredMethods! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/13/2023 02:23'!generateAsBooleanObj: aNode on: aStream indent: anInteger	aStream nextPutAll: '!!!!('.	self emitJSExpression: aNode receiver on: aStream.	aStream nextPut: $)	! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 12/26/2021 09:25'!generateAsPositiveIntegerObj: aNode on: aStream indent: anInteger	self emitJSExpression: aNode receiver on: aStream.	aStream nextPutAll: ' >= 0 ? '.	self emitJSExpression: aNode receiver on: aStream.	aStream nextPutAll: ' : 4294967296 + '.	self emitJSExpression: aNode receiver on: aStream.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 3/23/2021 18:11'!generateDebugCode: aNode on: aStream indent: level 	"Generate the C debug code for this message onto the given stream, if  	compiled in debugMode."	self generateDebugCode		ifTrue: 			[aStream nextPutAll: '// DebugCode...';			 cr.			aNode args first				emitJSCodeOn: aStream				level: level				generator: self.			aStream tab: level.			aStream nextPutAll: '// ...DebugCode']		ifFalse: []! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:47'!generateIsBytes: aNode on: aStream indent: anInteger	super generateIsBytes: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsIntegerValue: aNode on: aStream indent: anInteger	super generateIsIntegerValue: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 1/14/2022 20:14'!generateIsKindOf: aNode on: aStream indent: anInteger	| className varName | 	className := aNode args second value.	aNode args first isVariable ifFalse: [self halt]. 	varName := aNode args first name.	'LargePositiveInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() === "bigint" && ';			nextPutAll: varName;			nextPutAll: '.valueOf() >= 0)'].	'LargeNegativeInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() === "bigint" && ';			nextPutAll: varName;			nextPutAll: '.valueOf() < 0)'].	'Integer' = className ifFalse: [self halt: 'isKindOf: ', className].	aStream nextPutAll: '(typeof ';		nextPutAll: varName;		nextPutAll: ' === "number" || typeof ';		nextPutAll: varName;		nextPutAll: '.valueOf() === "bigint")'.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsMemberOf: aNode on: aStream indent: anInteger	super generateIsMemberOf: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 1/14/2022 20:15'!generateIsNotKindOf: aNode on: aStream indent: anInteger	| className varName | 	className := aNode args second value.	aNode args first isVariable ifFalse: [self halt].	varName := aNode args first name.	'LargePositiveInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() !!== "bigint" || ';			nextPutAll: varName;			nextPutAll: '.valueOf() < 0)'].	'LargeNegativeInteger' = className ifTrue: [		^aStream nextPutAll: '(typeof ';			nextPutAll: varName;			nextPutAll: '.valueOf() !!== "bigint" || ';			nextPutAll: varName;			nextPutAll: '.valueOf() >= 0)'].	'Integer' = className ifFalse: [self halt: 'isKindOf: ', className].	aStream nextPutAll: '(typeof ';		nextPutAll: varName;		nextPutAll: ' !!== "number" && typeof ';		nextPutAll: varName;		nextPutAll: '.valueOf() !!== "bigint")'.! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:58'!generateIsPointers: aNode on: aStream indent: anInteger	super generateIsPointers: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 7/11/2023 23:57'!generateIsWords: aNode on: aStream indent: anInteger	super generateIsWords: aNode on: aStream indent: anInteger! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'translating builtins' stamp: 'fm 9/21/2023 01:01'!initializeJSTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	super initializeJSTranslationDictionary.	pairs := #(		#asCInt						#generateAsCInt:on:indent:		#asCUnsigned				#generateAsCUnsigned:on:indent:		#asCBoolean					#generateAsCBoolean:on:indent:		#asCDouble					#generateAsCDouble:on:indent:		#asSmallIntegerObj			#generateAsSmallIntegerObj:on:indent:		#asPositiveIntegerObj		#generateAsPositiveIntegerObj:on:indent:		#asBooleanObj				#generateAsBooleanObj:on:indent:		#asFloatObj					#generateAsFloatObj:on:indent:		#asIf:var:					#generateAsIfVar:on:indent:		#asIf:var:asValue:			#generateAsIfVarAsValue:on:indent:		#asIf:var:put:				#generateAsIfVarPut:on:indent:		#field:						#generateField:on:indent:		#field:put:					#generateFieldPut:on:indent:				#class						#generateClass:on:indent:		#stAt:						#generateAt:on:indent:		#stAt:put:					#generateAtPut:on:indent:		#asCharPtr					#generateAsCharPtr:on:indent:		#asIntPtr					#generateAsIntPtr:on:indent:		#cPtrAsOop					#generateCPtrAsOop:on:indent:		#next						#generateNext:on:indent:		#asOop:						#generateAsOop:on:indent:		#asValue:					#generateAsValue:on:indent:		#isFloat						#generateIsFloat:on:indent:		#isIndexable					#generateIsIndexable:on:indent:		#isIntegerOop				#generateIsIntegerOop:on:indent:		#isIntegerValue				#generateIsIntegerValue:on:indent:		#FloatOop					#generateIsFloatValue:on:indent:		#isWords					#generateIsWords:on:indent:		#isWordsOrBytes				#generateIsWordsOrBytes:on:indent:		#isPointers					#generateIsPointers:on:indent:		#isNil						#generateIsNil:on:indent:		#isMemberOf:				#generateIsMemberOf:on:indent:		#isKindOf:					#generateIsKindOf:on:indent:		#fromStack:					#generateFromStack:on:indent:		#clone						#generateClone:on:indent		#new						#generateNew:on:indent		#new:						#generateNewSize:on:indent		#superclass					#generateSuperclass:on:indent:		#remapOop:in:				#generateRemapOopIn:on:indent:		#debugCode:					#generateDebugCode:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'asOop:/asValue:' stamp: 'fm 7/13/2023 02:24'!generateCoerceToBooleanObjectFrom: aNode on: aStream	aStream nextPutAll: '!!!!('.	self emitJSExpression: aNode on: aStream.	aStream nextPut: $)! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 11/29/2020 12:48'!jscgLoad: aBlock expr: aString asBooleanValueFrom: anInteger	"Answer codestring for boolean coercion (with validating side-effect) of object, as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf:';		crtab: 2;		nextPutAll: aString])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asCharPtrFrom: anInteger	"Answer codestring for character pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asCharPtrFrom: anInteger andThen: valBlock	"Answer codestring for character pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *''']))	 ! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asIntPtrFrom: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:40'!jscgLoad: aBlock expr: aString asKindOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'KindOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:40'!jscgLoad: aBlock expr: aString asMemberOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'MemberOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:39'!jscgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: exprString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:39'!jscgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: exprString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:36'!jscgLoad: aBlock expr: aString asRawOopFrom: anInteger	"Answer a string for a Slang expression that will load an oop (without validation) from stack index anInteger.  Apply aBlock, a BlockContext instance that when passed an expression, will return a string assigning the expression to the desired identifier, to the string before answering.  aString is a Slang expression that refers to the stack value, once it has been loaded."	^aBlock value: aString! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asUnsignedPtrFrom: anInteger andThen: valBlock	"Answer a codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to jscgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''unsigned *''']))! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asUnsignedValueFrom: anInteger	"Answer a codestring for positive integer coercion (with validating side-effect) of oop, as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf:';		crtab: 2;		nextPutAll: aString])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asWBCharPtrFrom: anInteger	"Answer codestring for char pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:37'!jscgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger	"Answer codestring for single-precision float pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!JSSmartSyntaxPluginCodeGenerator methodsFor: 'coercing' stamp: 'fm 12/5/2020 23:38'!jscgLoad: aBlock expr: aString asWBIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (with validating side-effect), as described in comment to jscgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!JSSmartSyntaxPluginMethod methodsFor: 'private' stamp: 'fm 12/26/2020 19:32'!pop: anInteger thenReturnExpr: anExpression	^TSendNode new		setSelector: #push:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array 			with: anExpression)! !!JSSmartSyntaxPluginMethod methodsFor: 'specifying primitives' stamp: 'fm 4/25/2021 00:05'!handlePrimitiveDirective: aStmt on: sStream	isPrimitive := true.	fullArgs := args.	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec jscgDeclareJSForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec == Oop ifTrue: [					aStmt variable name, ' := this'				] ifFalse: [					rcvrSpec						jscg:	JSSmartSyntaxPluginCodeGenerator new						prolog:  [:expr | aStmt variable name, ' := ', expr]						expr: 	'this'						index: 	fullArgs size				])			varName: '')].	^true.! !!JSSmartSyntaxPluginMethod methodsFor: 'specifying primitives' stamp: 'fm 11/29/2020 18:06'!namedPrimitiveProlog	| cg |	cg := SmartSyntaxPluginCodeGenerator new.	^Array streamContents: [:sStream |		1 to: args size do:			[:i |			 sStream nextPutAll: 				(self 					statementsFor: 						((parmSpecs at: i) 							jscg: 	cg							prolog:  [:expr | expr]							expr: (args at: i)							index: args size - i)					varName: '')]]! !!JSSmartSyntaxPluginMethod methodsFor: 'transforming' stamp: 'fm 12/26/2020 19:35'!fixUpReturnOneStmt: stmt on: sStream	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 ^nil].	 sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: stmt expression).! !!JSSmartSyntaxPluginMethod methodsFor: 'initializing' stamp: 'fm 11/16/2020 23:31'!fromContext: aContext primitive: aString parameters: aClassList receiver: aClass	args := aContext tempNames				copyFrom: 1				to: aContext method numArgs.	self 		primitive: aString		parameters: aClassList		receiver: aClass! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'fm 1/8/2022 00:47'!unsafeByteOf: bytesOop at: ix	"Argument bytesOop must not be aSmallInteger!!"	<inline: true>	^(interpreterProxy cCoerce: (interpreterProxy firstIndexableField: bytesOop) to: #'unsigned char *') at: ix - 1! !!LargeIntegersPlugin methodsFor: 'control & support primitives' stamp: 'fm 9/3/2020 23:05'!primGetModuleName	"If calling this primitive fails, then C module does not exist."	| strLen strOop |	self debugCode: [self msg: 'primGetModuleName'].	self		primitive: 'primGetModuleName'		parameters: #()		receiver: #Oop.	strLen := self strlen: self getModuleName.	strOop := interpreterProxy instantiateClass: interpreterProxy classString indexableSize: strLen.	0 to: strLen-1 do:[:i|		interpreterProxy storeByte: i ofObject: strOop withValue: (self getModuleName at: i)].	^strOop! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/8/2023 18:28'!recoverConditionalExpressionsForInlining	| anyTransformed |	anyTransformed := false. 	block accept: 		(ParseNodeWithParentsEnumerator ofBlock: [:node :parents |			| trueBlock falseBlock trueReturns falseReturns falseValue trueValue isLocalReturn parent parentStatements parentLast replacement |			(node isMessage and: 			[node isOptimized and: 			[node selector key == #ifTrue:ifFalse: and: 			[(trueBlock := node arguments first) statements size = 1 and:			[(trueBlock statements first hasSideEffect) not and:			[(falseBlock := node arguments last) statements size = 1 and:			[(falseBlock statements first hasSideEffect) not]]]]]]) ifTrue: [				trueReturns := trueBlock returns.				falseReturns := falseBlock returns.				trueValue := trueBlock statements first.				falseValue := falseBlock statements first.				parent := parents last.				anyTransformed := trueReturns ifTrue: [					falseReturns ifTrue: [						falseValue class == ReturnNode and: 						[falseValue expr isJSexpression and: 						[trueValue class == ReturnNode and: 						[trueValue expr isJSexpression and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue expr. falseValue expr}								precedence: 3								from: encoder.							parent replace: node with: replacement asReturnNode]]]]					] ifFalse: [						(falseValue isKindOf: LeafNode) and: 						[trueValue class == ReturnNode and: 						[trueValue expr isJSexpression and: 						[parent isBlockNode and:						[parent returns and:						[((parentStatements := parent statements) indexOf: node) + 1 = parentStatements size and:						[(parentLast := parentStatements last) class == ReturnNode and:						[parentLast expr isJSexpression and:						[(self isLocalReturn: node withParents: parents) not and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue expr. parentLast expr}								precedence: 3								from: encoder.							parent statements: parentStatements allButLast;								replace: node with: replacement asReturnNode]]]]]]]]]]				] ifFalse: [					falseReturns ifTrue: [						(trueValue isKindOf: LeafNode) and: 						[falseValue class == ReturnNode and: 						[falseValue expr isJSexpression and: 						[parent isBlockNode and:						[parent returns and:						[((parentStatements := parent statements) indexOf: node) + 1 = parentStatements size and:						[(parentLast := parentStatements last) class == ReturnNode and:						[parentLast expr isJSexpression and:						[(self isLocalReturn: node withParents: parents) not and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {parentLast expr. falseValue expr}								precedence: 3								from: encoder.							parent statements: parentStatements allButLast;								replace: node with: replacement asReturnNode]]]]]]]]]					] ifFalse: [						(falseValue isJSexpression and:						[trueValue isJSexpression and: 						[(parent := parents last) isBlockNode not or: [isLocalReturn := self isLocalReturn: node withParents: parents]]]) and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue. falseValue}								precedence: 3								from: encoder.							parent replace: node with: replacement]					]				].				(anyTransformed and: [node arguments anySatisfy: [:a | a temporaries notEmpty]]) ifTrue: [					self moveTempsFrom: node arguments to: (parents reversed detect: [:e | e isBlockNode])				]			]		]). 	^anyTransformed! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 10/12/2023 18:26'!prepareForVmSideInlinedGenerationBy: cg	| returnCount |	((properties pragmas		detect: [:p | 			(p keyword = #export: and: [p arguments first == true]) or:			[p keyword = #inline: and: [p arguments first == false]]]		ifNone: [			block statements 				detect: [:s | 					s isMessageNode and: 					[s receiver isSelfPseudoVariable and:					[(s selector key = #export: and: [s arguments first isVariableNode and: [s arguments first key = 'true']]) or:					[s selector key = #inline: and: [s arguments first isVariableNode and: [s arguments first key = 'false']]]]]]				ifNone: []]) notNil or: [self selector beginsWith: 'prim']) ifTrue: [^self prepareForVmSideNonInlinedGeneration].	self basicNormalize. 	[self recoverConditionalExpressionsForInlining] whileTrue.	self makeValueBlocksExpressionsStatements. 	self cacheCaseReceivers. 	self makeLoopExpressionsStatements. 	self recoverCaseOfExpressions. 	[self compactIfTrueIfFalse | self moveReturnIntoPrecedingIfTrueIfFalse	| self ascendValueBlocksReturrns] whileTrue."	Transcript cr; show: self printString size printString."	self ascendValueBlocksAssignments.	self recoverBooleanExpressions.	[self recoverConditionalExpressionsForInlining] whileTrue."	Transcript cr; show: self printString size printString."	[self descendAssignmentsIntoValueBlocks 	| self transformValueBlocksReceivers  	| self transformValueBlocksArguments 	| self removeComplexAnd | self removeComplexOr] whileTrue.	self removeRedundantAssignments."	Transcript cr; show: self printString size printString."	[self removeReturnsFromPrecedingIfTrueIfFalse 	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	[self removeNoOps | self removeWriteOnlyTemps] whileTrue."	Transcript cr; show: self printString size printString."	[self removeReturnsFromPrecedingIfTrueIfFalse 	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	self removeSpuriousReturns.	returnCount := 0.	block nodesDo: [:n | 		n class == ReturnNode			ifTrue: [returnCount := returnCount + 1]].	(returnCount > 1 and: [(self asCleanedUpParseTree asTranslationMethodOfClass: cg translationMethodClass) exitVar: nil label: nil valueUsed: false])		ifTrue: [ ^self prepareForVmSideNonInlinedGeneration].	self fixupMacroSelectors.! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 10/12/2023 18:26'!prepareForVmSideNonInlinedGeneration	self basicNormalize. 	[self recoverConditionalExpressionsForInlining] whileTrue.	self makeValueBlocksExpressionsStatements. 	self cacheCaseReceivers. 	self makeLoopExpressionsStatements. 	self recoverCaseOfExpressions. 	[self moveReturnIntoPrecedingIfTrueIfFalse	| self ascendValueBlocksReturrns] whileTrue."	Transcript cr; show: self printString size printString."	self descendReturnsIntoValueBlocks.	[self removeReturnsFromPrecedingIfTrueIfFalse	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	self ascendValueBlocksReturrns.	self ascendValueBlocksAssignments.	self recoverBooleanExpressions.	[self recoverConditionalExpressionsForInlining] whileTrue."	Transcript cr; show: self printString size printString."	self descendAssignmentsIntoValueBlocks.	self descendReturnsIntoValueBlocks.	self makeValueBlocksExpressionsStatements.	self removeRedundantAssignments."	Transcript cr; show: self printString size printString."	[self removeReturnsFromPrecedingIfTrueIfFalse 	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	[self removeNoOps | self removeWriteOnlyTemps] whileTrue."	Transcript cr; show: self printString size printString."	[self removeReturnsFromPrecedingIfTrueIfFalse 	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	self removeSpuriousReturns.	self fixupMacroSelectors.! !!Object class methodsFor: '*vmmakerjs' stamp: 'fm 3/23/2021 10:48'!jscg: cg prolog: aBlock expr: aString index: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: ';		nextPutAll: aString;		crtab: 2;		nextPutAll: 	'NotKindOf: ''';		nextPutAll:	self asString;		nextPutAll: ''') not.';		crtab;		nextPutAll: (cg 						jscgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!Array class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 17:58'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: '(interpreterProxy isIndexable: ';				nextPutAll: aString;				nextPutAll: ') ifFalse: [interpreterProxy primitiveFail]']]! !!BitBltSimulation class methodsFor: 'translation' stamp: 'fm 3/22/2021 17:37'!requiredMethodNames	^(self opTable, #(copyBits:Fallback: copyBitsRule41Test1 copyBitsRule41Test2 copyBitsRule41Test4)) asSet! !!Boolean class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 12:55'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf: ';		nextPutAll: aString])! !!ByteArray class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:30'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsBytes: ';				nextPutAll: aString]]! !!Float class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:18'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'nil checkIsFloat: ';		nextPutAll: aString])! !!FloatArray class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 12:57'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: aString;		nextPutAll:	')';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!IntegerArray class methodsFor: '*vmmakerjs' stamp: 'fm 3/21/2021 23:49'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsSignedInts: ';				nextPutAll: aString]]! !!JSCodeGenerator class methodsFor: 'class initialization' stamp: 'fm 7/15/2023 00:45'!exportAll	"JSCodeGenerator exportAll"	| previousDefault |		previousDefault := FileDirectory default pathName.	FileDirectory setDefaultDirectory: 'C:\JsSqueak\backup\plugins'.	[	"JSCodeGenerator beActiveDuring: [(VMMaker default interpreterClass: StackInterpreter) generateInterpreterFile]."	JSCodeGenerator beActiveDuring: [JSCodeGenerator translateAllPluginsIn: FileDirectory default doInlining: true]	] ensure: [FileDirectory setDefaultDirectory: previousDefault].! !!JSCodeGenerator class methodsFor: 'utilities' stamp: 'fm 9/19/2023 19:00'!translateAllPluginsIn: aDirectory doInlining: doInlining	self beActiveDuring: [		#(	ADPCMCodecPlugin			BalloonEnginePlugin			"BMPReadWriterPlugin	-- not working yet"			BitBltSimulation			DSAPlugin				DeflatePlugin			FFTPlugin			FloatArrayPlugin			Float64ArrayPlugin			GeniePlugin					JPEGReaderPlugin			KedamaPlugin			KedamaPlugin2			KlattSynthesizerPlugin			LargeIntegersPlugin			Matrix2x3Plugin			MiscPrimitivePlugin			ScratchPlugin			SoundGenerationPlugin			StarSqueakPlugin		) do: [:pluginName |			self environment at: pluginName ifPresent: [:plugin |				plugin translateInDirectory: aDirectory doInlining: doInlining]]		displayingProgress: 'Generating JS plugins'].! !!JSCodeGenerator class methodsFor: 'utilities' stamp: 'fm 11/2/2020 21:31'!translateMainInterpreter	self beActiveDuring: [(VMMaker default interpreterClass: StackInterpreter) initializeAllPlugins; generateInterpreterFile].! !!Oop class methodsFor: '*vmmakerjs' stamp: 'fm 12/5/2020 23:03'!jscg: cg prolog: aBlock expr: aString index: anInteger	^''! !!SmallInteger class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:24'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'nil checkIsInteger: ';		nextPutAll: aString])! !!String class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:30'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsBytes: ';				nextPutAll: aString]]! !!TParseNode methodsFor: 'converting' stamp: 'fm 8/16/2023 22:29'!canBeExpression	^true! !!TParseNode methodsFor: 'transformations' stamp: 'fm 8/10/2023 12:22'!rightmostSide	^self! !!TParseNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not.  By default assume it has.  Nodes that don't override."	^true! !!TParseNode methodsFor: 'testing' stamp: 'fm 11/21/2020 22:23'!isFinalIf	^false! !!TParseNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:42'!isReturnLike	^false! !!TParseNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:19'!isSameAs: aTParseNode	"Answer if the ParseTree rooted at this node is the same as aTParseNode.	 By default answer false and have subclasses override as appropriate."	^self == aTParseNode! !!TParseNode methodsFor: 'testing' stamp: 'fm 9/10/2023 15:14'!isThrow	^false! !!TParseNode methodsFor: 'testing' stamp: 'fm 10/15/2023 19:20'!splitTermsUsing: aCodeGen	self halt! !!TParseNode methodsFor: '*vmmakerjs' stamp: 'fm 9/10/2023 16:04'!isInequalityTest	^false! !!TParseNode methodsFor: '*vmmakerjs' stamp: 'fm 9/10/2023 16:04'!isStorageTypeTest	^false! !!TAssignmentNode methodsFor: 'transformations' stamp: 'fm 10/15/2023 23:01'!replaceNodesIn: aDictionary	| terminalLocalReturns |	^aDictionary at: self ifAbsent: [		variable := variable replaceNodesIn: aDictionary.		expression := expression replaceNodesIn: aDictionary.		(expression isVariable and: [expression name = variable name]) ifTrue: [			^variable].		(expression isSend and: [expression hasSideEffect and: [(terminalLocalReturns := expression stmtListsWithTerminalLocalReturns) notEmpty]]) ifTrue: [			terminalLocalReturns do: [:stmtList | | lastRealStatement ix |				lastRealStatement := stmtList lastRealStatement.				ix := stmtList statements indexOf: lastRealStatement.				(lastRealStatement isVariable and: [lastRealStatement name = variable name]) ifFalse: [					stmtList statements at: ix put: (self copy setVariable: variable copy expression: lastRealStatement)]].			^expression			].		self]! !!TAssignmentNode methodsFor: 'transformations' stamp: 'fm 8/10/2023 12:22'!rightmostSide	^expression rightmostSide! !!TAssignmentNode methodsFor: 'testing' stamp: 'fm 8/16/2023 22:54'!canBeExpression	^expression canBeExpression! !!TAssignmentNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isAssignment		 and: [(variable isSameAs: aTParseNode variable)		 and: [expression isSameAs: aTParseNode expression]]]! !!TAssignmentNode methodsFor: '*vmmakerjs' stamp: 'fm 10/15/2023 22:59'!emitJSCodeOn: aStream level: level generator: aCodeGen	| leftSide rightSide variableNames |	leftSide := self.	rightSide := expression.	variableNames := Set with: variable name.	[rightSide isAssignment] whileTrue: [		(variableNames includes: rightSide variable name) ifTrue: [			leftSide setVariable: leftSide variable expression: rightSide expression		] ifFalse: [			variableNames add: rightSide variable name.			leftSide := rightSide.		].		rightSide := rightSide expression].	(variableNames size = 1 and: [rightSide isVariable and: [rightSide name = variable name]]) ifTrue: [		^rightSide emitJSCodeOn: aStream level: level generator: aCodeGen].	rightSide isSwitch ifTrue:		[^rightSide emitJSCodeOn: aStream addToEndOfCases: self level: level generator: aCodeGen].		(self isVariableUpdatingAssignment and: [(aCodeGen isPointer: variable) not])		ifTrue:			[(expression args first isConstant and: [expression args first value = 1])				ifTrue: [aStream nextPutAll: expression selector, expression selector.					variable emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen]				ifFalse: [					variable emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.					aStream nextPutAll: ' ', expression selector, '= '.					expression args first emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen]]		ifFalse:			[ | coerceToInt |			coerceToInt := (variable isFloatIn: aCodeGen) not and: [rightSide isFloatIn: aCodeGen].			rightSide canBeExpression ifTrue: [				variableNames size > 1 ifTrue: [					variableNames do: [:varName |						(variable copy setName: varName) emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.						aStream nextPutAll: ' = ']				] ifFalse: [					variable emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.					aStream nextPutAll: ' = '.				].				rightSide emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.				coerceToInt ifTrue: [aStream nextPutAll: '|0'].			] ifFalse: [ | stmLists |				variableNames size > 1 ifTrue: [self halt].				(rightSide isSend and: [rightSide canBeExpression not and: [(stmLists := rightSide stmtListsWithTerminalLocalReturns) notEmpty]]) ifTrue: [					stmLists do: [:stmtList | | lastRealStatement |						lastRealStatement := stmtList lastRealStatement.						stmtList statements 							at: (stmtList statements indexOf: lastRealStatement) 							put: (TAssignmentNode new 									setVariable: variable copy									expression: (coerceToInt ifTrue: [													TSendNode new 														setSelector: #bitOr:														receiver: lastRealStatement														arguments: {TConstantNode new setValue: 0}												] ifFalse: [													lastRealStatement]))].					rightSide  						isExpression: false;						emitJSCodeOn: aStream level: level generator: aCodeGen.				] ifFalse: [					(rightSide isSend and: [rightSide receiver isSend and: [rightSide receiver canBeExpression not and:					[(stmLists := rightSide receiver stmtListsWithTerminalLocalReturns) notEmpty and:					[rightSide args allSatisfy: [:arg | arg canBeExpression]]]]]) ifTrue: [						stmLists do: [:stmtList | | lastRealStatement |							lastRealStatement := stmtList lastRealStatement.							stmtList statements 								at: (stmtList statements indexOf: lastRealStatement) 								put: (TAssignmentNode new 										setVariable: variable copy										expression: (coerceToInt ifTrue: [														TSendNode new 															setSelector: #bitOr:															receiver: (																TSendNode new 																	setSelector: rightSide selector																	receiver: lastRealStatement																	arguments: (rightSide args collect: [:arg | arg copy]))															arguments: {TConstantNode new setValue: 0}													] ifFalse: [														TSendNode new 															setSelector: rightSide selector															receiver: lastRealStatement															arguments: (rightSide args collect: [:arg | arg copy])]))].						rightSide receiver 							isExpression: false;							emitJSCodeOn: aStream level: level generator: aCodeGen.					] ifFalse: [						variable emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.						aStream nextPutAll: ' = '.						rightSide emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.						coerceToInt ifTrue: [aStream nextPutAll: '|0'].					].				].			]]! !!TBreakNode methodsFor: 'printing' stamp: 'fm 11/18/2020 20:00'!printOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'break'.! !!TBreakNode methodsFor: 'enumerating' stamp: 'fm 11/18/2020 20:02'!nodesDo: aBlock parent: parent	aBlock value: self value: parent! !!TBreakNode methodsFor: 'enumerating' stamp: 'fm 8/11/2023 20:43'!stmtListsWithTerminalLocalReturns	^#()! !!TBreakNode methodsFor: 'enumerating' stamp: 'fm 10/8/2023 00:17'!stmtListsWithTerminalLocalReturnsNoTransform	^#()! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 9/11/2023 12:54'!canBeExpression	^false! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 11/18/2020 20:01'!copyTree	^self class new! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 8/12/2023 00:38'!emitJSCodeOn: aStream level: level generator: aCodeGen	"Emit a C/JS break statement."	aStream nextPutAll: 'break'! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 9/11/2023 12:42'!isReturnLike	^true! !!TBreakNode methodsFor: '*vmmakerjs' stamp: 'fm 8/3/2023 18:29'!setLabel: aString	label := aString.! !!TCaseStmtNode methodsFor: 'transformations' stamp: 'fm 10/15/2023 23:32'!processSharedCodeBlocks: caseTree forCase: caseIndex in: codeGen method: aTMethod	"Process any shared code blocks in the case parse tree for the given case, either inlining them or making them a 'goto sharedLabel'."	| map meth sharedNode exitLabel |	exitLabel := nil.self halt.	[sharedNode := nil.	map := IdentityDictionary new.	caseTree nodesDo:[:node|		(node isSend 			and:[(meth := codeGen methodNamed: node selector) notNil			and:[meth sharedCase notNil]]) ifTrue:[			meth sharedCase = caseIndex ifTrue:[				sharedNode := meth.				map at: node put: (TLabeledCommentNode new setComment: 'goto ', meth sharedLabel).			] ifFalse:[				map at: node put: (TGoToNode new setLabel: meth sharedLabel).			].		].	].	caseTree replaceNodesIn: map.	"recursively expand"	sharedNode == nil] whileFalse:[		meth := sharedNode copy.		(meth hasReturn) ifTrue: [			exitLabel ifNil:[				exitLabel := aTMethod unusedLabelForInliningInto: aTMethod.				aTMethod labels add: exitLabel.			].			meth exitVar: nil label: exitLabel.		].		meth renameLabelsForInliningInto: aTMethod.		aTMethod labels addAll: meth labels.		caseTree setStatements: (caseTree statements copyWith: meth asInlineNode).	].	exitLabel ifNotNil:[		caseTree setStatements: (caseTree statements copyWith:			(TLabeledCommentNode new setLabel: exitLabel comment: 'end case')).	].! !!TCaseStmtNode methodsFor: 'testing' stamp: 'fm 8/17/2023 12:17'!canBeExpression	^false! !!TCaseStmtNode methodsFor: 'testing' stamp: 'fm 9/10/2023 22:36'!stmtListsWithTerminalLocalReturns	| stmtLists |	stmtLists := OrderedCollection new.	cases do: [:case | | lastRealExpression extraStmtList send |		case endsWithReturn ifFalse: [			lastRealExpression := case lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: case.			] ifFalse: [				lastRealExpression isSend ifTrue: [					send := lastRealExpression.					(#(ifTrue: ifFalse:) includes: send selector) ifTrue: [						extraStmtList := TStmtListNode new 												setArguments: #() 												statements: {TVariableNode new setName: 'nil'}.						send renameSelector: #ifTrue: as: #ifTrue:ifFalse:;							renameSelector: #ifFalse: as: #ifFalse:ifTrue:;							arguments: (send args copyWith: extraStmtList).					] ifFalse: [						#or: == send selector ifTrue: [							extraStmtList := TStmtListNode new 													setArguments: #() 													statements: {TConstantNode new setValue: true}.							send renameSelector: #or: as: #ifFalse:ifTrue:;								arguments: (send args copyWith: extraStmtList).						] ifFalse: [							#and: == send selector ifTrue: [								extraStmtList := TStmtListNode new 														setArguments: #() 														statements: {TConstantNode new setValue: false}.								send renameSelector: #or: as: #ifTrue:ifFalse:;									arguments: (send args copyWith: extraStmtList).							].						].					].				].				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturns			].		].	].	^stmtLists! !!TCaseStmtNode methodsFor: 'testing' stamp: 'fm 10/8/2023 00:16'!stmtListsWithTerminalLocalReturnsNoTransform	| stmtLists |	stmtLists := OrderedCollection new.	cases do: [:case | | lastRealExpression |		case endsWithReturn ifFalse: [			lastRealExpression := case lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: case.			] ifFalse: [				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturnsNoTransform			].		].	].	^stmtLists! !!TCaseStmtNode methodsFor: '*vmmakerjs' stamp: 'fm 9/11/2023 14:36'!emitJSCodeOn: aStream level: level generator: aCodeGen	| indent |	indent := (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitJSCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!TConstantNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not."	^false! !!TConstantNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isConstant		 and: [value class == aTParseNode value class		 and: [value = aTParseNode value]]]! !!TConstantNode methodsFor: 'testing' stamp: 'fm 10/15/2023 19:19'!splitTermsUsing: aCodeGen	^{nil. value. nil}! !!TConstantNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 00:47'!emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen jsLiteralFor: value).! !!TConstantNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 02:10'!emitJSCodeAsExpressionOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen jsLiteralFor: value).! !!TConstantNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 00:48'!emitJSCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."! !!TDefineNode methodsFor: 'as yet unclassified' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [self class == aTParseNode class		  and: [value class == aTParseNode value class		  and: [value = aTParseNode value		  and: [name = aTParseNode nameOrValue]]]]! !!TNotImplementedNode methodsFor: '*vmmakerjs' stamp: 'fm 9/12/2023 16:54'!emitJSCodeOn: aStream level: level generator: aCodeGen	"Emit a comment only"self halt.	aStream cr; nextPutAll: '/*** ';		nextPutAll: self printString;		nextPutAll: ' cannot translate: '; cr;		nextPutAll: parseNode printString;		cr; nextPutAll: ' ***/'; cr! !!TReturnNode methodsFor: 'transformations' stamp: 'fm 8/7/2023 23:27'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression := expression replaceNodesIn: aDictionary.		"(expression isSend and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: expression selector]) ifTrue: [			expression stmtListsWithTerminalLocalReturns do: [:stmtList | | lastRealStatement |				lastRealStatement := stmtList lastRealStatement.				(lastRealStatement isReturn or: [lastRealStatement isReturningIf]) ifFalse: [					stmtList statements at: (stmtList statements indexOf: lastRealStatement) put: 						(TReturnNode new							setExpression: lastRealStatement)				]			].			^expression		]."			self]! !!TReturnNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:54'!canBeExpression	^false! !!TReturnNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:41'!isReturnLike	^true! !!TReturnNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:20'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isReturn		 and: [expression isSameAs: aTParseNode expression]]! !!TReturnNode methodsFor: '*vmmakerjs' stamp: 'fm 9/10/2023 15:04'!emitJSCodeOn: aStream level: level generator: aCodeGen	| generated |	(expression isSwitch	 or: [expression isCaseStmt]) ifTrue:		[^expression emitJSCodeOn: aStream addToEndOfCases: self level: level generator: aCodeGen].	('void' = aCodeGen currentMethod returnType) ifTrue: [		"If the function is void, don't say 'return x' instead say ' x; return' "		expression isLeaf ifFalse: [			expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.				aStream nextPutAll: ';'; space.		].		aStream nextPutAll: 'return'.	] ifFalse: [		generated := false.		expression isSend ifTrue: [			generated := true.			expression selector caseOf: {				[#primitiveFail]->[					aCodeGen generatePrimitiveFail: expression on: aStream indent: level].				[#primitiveFailFor:]->[					aCodeGen generatePrimitiveFailFor: expression on: aStream indent: level].				[#push:]->					[aCodeGen generatePrimitiveReturn: expression on: aStream indent: level].				[#pushBool:]->[					aCodeGen generatePushBool: expression on: aStream indent: level].				[#pushFloat:]->[					aCodeGen generatePushFloat: expression on: aStream indent: level].				[#pushInteger:]->[					aCodeGen generatePushInteger: expression on: aStream indent: level].				[#success:]->[ | val |					(val := aCodeGen nilOrReducibleValueOf: expression args first) == false ifFalse: [						val == true ifTrue: [^aStream nextPutAll: 'return null'].						aStream nextPutAll: 'if ('.						expression args first emitJSCodeAsArgumentOn: aStream level: level generator: self.						aStream nextPutAll: ')';							crtab: level + 1;							nextPutAll: 'return null;';							crtab: level;							nextPutAll: 'else';							crtab: level + 1].					aStream nextPutAll: 'throw Object.create(PrimitiveFailed).setPayload(1)']			} otherwise: [generated := false]		].		generated ifFalse: [			expression canBeExpression ifTrue: [				aStream nextPutAll: 'return '.				expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.			] ifFalse: [ | stmLists |				(expression isSend and: [(stmLists := expression stmtListsWithTerminalLocalReturns) notEmpty]) ifTrue: [					stmLists do: [:stmtList | | lastRealStatement |						lastRealStatement := stmtList lastRealStatement.						stmtList statements 							at: (stmtList statements indexOf: lastRealStatement) 							put: (TReturnNode new 									setExpression: lastRealStatement)].					expression  						isExpression: false;						emitJSCodeOn: aStream level: level generator: aCodeGen.				] ifFalse: [					(expression isSend and: [expression receiver isSend and: 					[(stmLists := expression receiver stmtListsWithTerminalLocalReturns) notEmpty and:					[expression args allSatisfy: [:arg | arg canBeExpression]]]]) ifTrue: [						stmLists do: [:stmtList | | lastRealStatement |							lastRealStatement := stmtList lastRealStatement.							stmtList statements 								at: (stmtList statements indexOf: lastRealStatement) 								put: (TReturnNode new 										setExpression: (TSendNode new 															setSelector: expression selector															receiver: lastRealStatement															arguments: (expression args collect: [:arg | arg copy])))].						expression receiver 							isExpression: false;							emitJSCodeOn: aStream level: level generator: aCodeGen.					] ifFalse: [self halt].				].			].		].	].! !!TSendNode methodsFor: 'converting' stamp: 'fm 8/17/2023 12:14'!canBeExpression	"Sender expects to use this node as a simple expression rather than as as statement"	self nodesDo: [:n | (n ~~ self and: [n canBeExpression not]) ifTrue: [^false]].	^true! !!TSendNode methodsFor: 'C code generation' stamp: 'fm 8/4/2023 21:16'!isSelfReference: varNode in: aCodeGen	^(varNode name beginsWith: 'self')	  and: [varNode name size = 4 or: [varNode name beginsWith: 'self_in_']]! !!TSendNode methodsFor: 'C code generation' stamp: 'fm 10/28/2020 20:53'!shouldExcludeReceiverAsFirstArgument: aCodeGen	"Only include the receiver as the first argument in certain cases.	 The receiver is always included if it is an expression.	 If it is a variable:		 If the vmClass says it is an implicit variable, don't include it.		 If the method's definingClass says it is an implicit variable, don't include it.		 If the variable is 'self' and the method being called is not in		 the method set (i.e. it is some external code), don't include it.		 If it is a struct send of something the vm says is an implicit variable, don't include it."	| m |	(aCodeGen isAssertSelector: selector) ifTrue:		[^true].	(receiver isSend	 and: [receiver receiver isVariable	 and: [(self isSelfReference: receiver receiver in: aCodeGen)		or: [self isStructReference: receiver receiver in: aCodeGen]]]) ifTrue:		[^aCodeGen isNonArgumentImplicitReceiverVariableName: receiver receiver name].	^receiver isVariable	    and: [(aCodeGen isNonArgumentImplicitReceiverVariableName: receiver name)		    or: [(self isSelfReference: receiver in: aCodeGen)			    and: [(m := aCodeGen methodNamed: selector) isNil					or: [m typeForSelf == #implicit]]]]! !!TSendNode methodsFor: 'testing' stamp: 'fm 11/5/2023 00:42'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not.	 We assume most sends do, but filter-out arithmetic and certain reads."	(#(	baseHeaderSize bytesPerOop bytesPerWord logBytesPerOop		numSmallIntegerBits numSmallIntegerTagBits numTagBits		nilObject trueObject falseObject classPoint classString classArray		classBitmap classByteArray classLargeNegativeInteger classLargePositiveInteger 		shiftForWord tagMask wordSize) includes: selector) ifTrue:		[^false].	(#(	negated abs sqrt sin cos tan atan exp log bitInvert32		size basicSize class isNil notNil isEmpty notEmpty) includes: selector) ifTrue:		[^receiver hasSideEffect].	(#(ifTrue:ifFalse: or: and:) includes: selector) ifTrue: [		arguments do: [:arg |			arg statements do: [:s |				s hasSideEffect ifTrue: [^true]]].		^receiver hasSideEffect].	(#(caseOf: caseOf:otherwise:) includes: selector) ifTrue: [		arguments first do: [:array |			array do: [:assoc |				assoc key statements do: [:s |					s hasSideEffect ifTrue: [^true]].				assoc value statements do: [:s |					s hasSideEffect ifTrue: [^true]]]].		arguments size = 2 ifTrue: [			arguments last statements do: [:s |				s hasSideEffect ifTrue: [^true]]].		^receiver hasSideEffect].	(#(	questionMark:colon: is:MemberOf: is:KindOf:	fetchInteger:ofObject: fetchLong32:ofObject: fetchFloat:ofObject: fetchPointer:ofObject:) includes: selector) ifTrue: [		arguments do: [:arg |			arg hasSideEffect ifTrue: [^true]].		^receiver hasSideEffect].	(#(+ - * / // \\ = == ~= ~~ << >> bitAnd: bitOr: bitXor: bitShift: signedBitShift: < > <= >= min: max:		 fetchClassOf: isArray: isBytes: isPointers: isWords: isWordsOrBytes:  & |		at: basicAt:		"Reads among kernel selectors"		oopAt: oopAtPointer: 		 byteAt: byteAtPointer: 		 shortAt: shortAtPointer: 		 intAt: intAtPointer: 		 longAt: longAtPointer: 		 longLongAt: longLongAtPointer: 		 pointerForOop: oopForPointer:		splObj:) includes: selector) ifFalse:		[^true].	^receiver hasSideEffect or: [arguments first hasSideEffect]! !!TSendNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:41'!isReturnLike	^self isReturningIf or: [self isThrow]! !!TSendNode methodsFor: 'testing' stamp: 'fm 9/21/2020 14:28'!isReturningIf	^(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: selector) 		and: [arguments first endsWithReturn and: [arguments last endsWithReturn]]! !!TSendNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	self == aTParseNode ifTrue: [^true].	(aTParseNode isSend	 and: [selector == aTParseNode selector	 and: [receiver isSameAs: aTParseNode receiver]]) ifFalse:		[^false].	arguments with: aTParseNode args do:		[:a :b|		(a isSameAs: b) ifFalse:			[^false]].	^true! !!TSendNode methodsFor: 'testing' stamp: 'fm 9/21/2023 00:51'!isThrow	^#(methodReturnBool: methodReturnFloat: methodReturnInteger: methodReturnReceiver methodReturnValue:		primitiveFail					primitiveFailFor:				push:							pushBool:						pushFloat:						pushInteger:					shouldNotImplement					shouldBeImplemented	) includes: selector! !!TSendNode methodsFor: 'testing' stamp: 'fm 10/15/2023 20:00'!splitTermsUsing: aCodeGen	| additions literal positive string subtractions somethingChanged terms split |	self hasSideEffect ifFalse: [			positive := IdentityDictionary new.		literal := 0.		somethingChanged := false.		self nodesDo: [:n | | rec arg sub add |			rec := n receiver.			(rec isSend and: [#(+ -) includes: rec selector]) ifFalse: [				(positive at: rec) ifTrue: [					(aCodeGen nilOrReducibleValueOf: rec) 						ifNil: [string := rec fullPrintString.							(subtractions notNil and: [(sub := subtractions detect: [:a | a = string] ifNone: []) notNil]) ifTrue: [								subtractions removeKey: (subtractions keyAtValue: sub).								somethingChanged := true.							] ifFalse: [								(terms ifNil: [terms := OrderedCollection new]) add: rec.								(additions ifNil: [additions := IdentityDictionary new]) at: rec put: string]]						ifNotNil: [:val | 							(literal ~= 0 or: [val = 0]) ifTrue: [somethingChanged := true].							literal := literal + val]. 				] ifFalse: [					(aCodeGen nilOrReducibleValueOf: rec) 						ifNil: [string := rec fullPrintString.							(additions notNil and: [(add := additions detect: [:a | a = string] ifNone: []) notNil]) ifTrue: [								additions removeKey: (additions keyAtValue:add).								somethingChanged := true.							] ifFalse: [								(terms ifNil: [terms := OrderedCollection new]) add: rec.								(subtractions ifNil: [subtractions := IdentityDictionary new]) at: rec put: string]]						ifNotNil: [:val | 							(literal ~= 0 or: [val = 0]) ifTrue: [somethingChanged := true].							literal := literal - val]]]. 			arg := n args first.			(arg isSend and: [#(+ -) includes: arg selector]) ifFalse: [				(positive at: arg) ifTrue: [					(aCodeGen nilOrReducibleValueOf: arg) 						ifNil: [string := arg fullPrintString.							(subtractions notNil and: [(sub := subtractions detect: [:a | a = string] ifNone: []) notNil]) ifTrue: [								subtractions removeKey: (subtractions keyAtValue: sub).								somethingChanged := true.							] ifFalse: [								(terms ifNil: [terms := OrderedCollection new]) add: arg.								(additions ifNil: [additions := IdentityDictionary new]) at: arg put: string]]						ifNotNil: [:val | 							(literal ~= 0 or: [val = 0]) ifTrue: [somethingChanged := true].							literal := literal + val]. 				] ifFalse: [					(aCodeGen nilOrReducibleValueOf: arg) 						ifNil: [string := arg fullPrintString.							(additions notNil and: [(add := additions detect: [:a | a = string] ifNone: []) notNil]) ifTrue: [								additions removeKey: (additions keyAtValue:add).								somethingChanged := true.							] ifFalse: [								(terms ifNil: [terms := OrderedCollection new]) add: arg.								(subtractions ifNil: [subtractions := IdentityDictionary new]) at: arg put: string]]						ifNotNil: [:val | 							(literal ~= 0 or: [val = 0]) ifTrue: [somethingChanged := true].							literal := literal - val]]]. 		] unless: [:n | | current |			(n isSend and: [#(+ -) includes: n selector]) ifTrue: [				current := positive at: n ifAbsent: true.				positive at: n receiver put: current;					at: n args first put: (n selector == #+ ifTrue: [current] ifFalse: [current not]).				false			] ifFalse: [				true].		].		somethingChanged ifTrue: [			^{additions ifNotNil: [terms select: [:e | additions includesKey: e]]. literal. subtractions ifNotNil: [terms select: [:e | subtractions includesKey: e]]}			]].	(#(+ -) includes: selector) ifTrue: [		receiver hasSideEffect ifFalse: [				split := receiver splitTermsUsing: aCodeGen.			split first = {receiver} ifFalse: [				^selector == #+ ifTrue: [					split at: 1 put: (split first ifNil: [{arguments first}] ifNotNil: [split first copyWith: arguments first]); yourself				] ifFalse: [					split at: 3 put: (split last ifNil: [{arguments first}] ifNotNil: [split last copyWith: arguments first]); yourself]]].		arguments first hasSideEffect ifFalse: [				split := arguments first splitTermsUsing: aCodeGen.			split first = {arguments first} ifFalse: [				^selector == #+ ifTrue: [					split at: 1 put: (split first ifNil: [{receiver}] ifNotNil: [split first copyWith: receiver]); yourself				] ifFalse: [					^{split last ifNil: [{receiver}] ifNotNil: [split last copyWith: receiver]. 0 - (split at: 2). split first}]]].	].	^{{self}. 0. nil}! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/11/2023 15:49'!emitJSCodeAsFunctionCallOn: aStream level: level generator: aCodeGen	| argsOnStack |	selector = #assert: ifTrue: [^self].	argsOnStack := false.	"Translate this message send into a JS function call"	"Special case for pluggable modules. Replace messages to interpreterProxy	 by interpreterProxy.message(..) if the message is not builtin"	(aCodeGen isGeneratingPluginCode	 and: [receiver isVariable	 and: ['interpreterProxy' = receiver name	 and: [self isBuiltinOperator not]]]) ifTrue: [			aStream nextPutAll: 'SmalltalkVM.'		] ifFalse: [			(aCodeGen isGeneratingPluginCode and: [(self shouldIncludeReceiverAsFirstArgument: aCodeGen) not]) ifTrue: [				aStream nextPutAll: aCodeGen pluginName;nextPut: $..				argsOnStack := arguments isEmpty and: [(aCodeGen currentMethod selector indexOf: $: ) = 0].				].		].	aStream nextPutAll: (aCodeGen jsFunctionNameFor: selector).	argsOnStack ifTrue: [		aStream nextPutAll: '.apply(this, arguments'	] ifFalse: [		aStream nextPut: $(.	].	"Only include the receiver as the first argument in certain cases.	 The receiver is always included if it is an expression.	 If it is a variable:		 If the vmClass says it is an implicit variable, don't include it.		 If the variable is 'self' and the method being called is not in		 the method set (i.e. it is some external code), don't include it."	(self shouldIncludeReceiverAsFirstArgument: aCodeGen) ifTrue:		[receiver emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse:			[aStream nextPutAll: ', ']].	arguments do:		[ :arg| arg emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $)! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/12/2023 16:59'!emitJSCodeOn: aStream level: level generator: aCodeGen	"Emit the receiver as a statement."	"If the selector is a built-in construct, translate it and return"	(self isExpression			ifFalse: [self hasSideEffect not or: [aCodeGen emitBuiltinConstructFor: self on: aStream level: level]]			ifTrue: [aCodeGen emitBuiltinConstructAsArgumentFor: self on: aStream level: level]) 	ifFalse:		["If it is a pointer dereference generate it"		(self emitJSCodeAsPointerDereferenceOn: aStream level: level generator: aCodeGen) ifFalse:			["Otherwise generate the vanilla C function call."			 self emitJSCodeAsFunctionCallOn: aStream level: level generator: aCodeGen]]! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 1/10/2022 19:19'!emitJSPointerArithmetic: type on: aStream level: level generator: aGenerator type: cType top: top	(selector = #+ or: [selector = #-]) ifFalse: [self halt].	receiver isVariable		ifTrue: [ | func |			func := ({'int' -> (selector = #+ ifTrue: ['PTR_ADD'] ifFalse: ['PTR_SUB']). 'unsignedint' -> (selector = #+ ifTrue: ['PTR_ADD'] ifFalse: ['PTR_SUB']). 'char' -> (selector = #+ ifTrue: ['CPTR_ADD'] ifFalse: ['CPTR_SUB']). 'unsignedchar' -> (selector = #+ ifTrue: ['CPTR_ADD'] ifFalse: ['CPTR_SUB']). 'float' -> (selector = #+ ifTrue: ['FPTR_ADD'] ifFalse: ['FPTR_SUB'])} as: Dictionary)				at: ((cType copyUpTo: $*) copyWithout: $ ). 			aStream nextPutAll: func, '(',  receiver name, ', ']		ifFalse: [receiver emitJSPointerArithmetic: type on: aStream level: level generator: aGenerator type: cType top: false.			aStream nextPutAll: ' ', selector, ' '].	aGenerator emitJSExpression: arguments first on: aStream.	top ifTrue: [aStream nextPutAll: ')'].! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/10/2023 15:49'!isInequalityTest	^#(<= >= < >) includes: self selector! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/12/2023 13:56'!isLeafOrFunc	selector precedence = 2 ifTrue: [^false].	(#(and: or: bitAnd: bitOr: bitXor: bitShift: signedBitShift: questionMark:colon: ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:) includes: selector) ifTrue: [^false].	^true! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 9/10/2023 15:55'!isStorageTypeTest	^#(isArray: isBytes: isPointers: isWords: isWordsOrBytes:) includes: self selector! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 10/7/2023 17:53'!stmtListsWithTerminalLocalReturns	| stmtLists |	(#(ifTrue: ifFalse:) includes: selector) ifTrue: [		self renameSelector: #ifTrue: as: #ifTrue:ifFalse:;			renameSelector: #ifFalse: as: #ifFalse:ifTrue:;			arguments: (arguments copyWith: (TStmtListNode new 												setArguments: #() 												statements: {TVariableNode new setName: 'nil'})).	] ifFalse: [		#or: == selector ifTrue: [ 			self renameSelector: #or: as: #ifFalse:ifTrue:;				arguments: (arguments copyWith: (TStmtListNode new 													setArguments: #() 													statements: {TConstantNode new setValue: true})).		] ifFalse: [			#and: == selector ifTrue: [				self renameSelector: #and: as: #ifTrue:ifFalse:;					arguments: (arguments copyWith: (TStmtListNode new 														setArguments: #() 														statements: {TConstantNode new setValue: false})).			] ifFalse: [				(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: selector) 					ifFalse: [^#()].			]]].	stmtLists := OrderedCollection new.	arguments do: [:arg | | lastRealExpression |		arg endsWithReturn ifFalse: [			lastRealExpression := arg lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: arg.			] ifFalse: [				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturns]]].	^stmtLists! !!TSendNode methodsFor: '*vmmakerjs' stamp: 'fm 10/8/2023 00:06'!stmtListsWithTerminalLocalReturnsNoTransform	| stmtLists |	(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: selector) 		ifFalse: [^#()].	stmtLists := OrderedCollection new.	arguments do: [:arg | | lastRealExpression |		arg endsWithReturn ifFalse: [			lastRealExpression := arg lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: arg.			] ifFalse: [				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturnsNoTransform]]].	^stmtLists! !!TStmtListNode methodsFor: 'accessing' stamp: 'fm 10/7/2023 23:50'!setArguments: argList statements: statementList	"Initialize this method using the given information."statementList isEmpty ifTrue: [self halt].	arguments := argList.	statements := statementList.! !!TStmtListNode methodsFor: 'accessing' stamp: 'fm 10/8/2023 00:47'!setStatements: stmtList	statements := stmtList asOrderedCollection.! !!TStmtListNode methodsFor: 'converting' stamp: 'fm 8/15/2023 23:21'!asExpression	| actual |	^ (statements size = 1)		ifTrue: [statements first asExpression]		ifFalse: [			(actual := statements reject: [:s | s isLabel]) size = 1 ifTrue: [				actual first asExpression			] ifFalse: [				self error: 'multiple statements can not serve as a simple expression']].! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 8/11/2023 17:24'!addFinalIfReturnsTo: returns extraneous: extraneous	 | lastRealStatement |	(lastRealStatement := self lastRealStatement) isReturn ifTrue: [		returns add: lastRealStatement	] ifFalse: [		(lastRealStatement isSend and: [#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: lastRealStatement selector]) ifTrue: [			(lastRealStatement args first addFinalIfReturnsTo: returns extraneous: extraneous) ifNil: [^nil].			(lastRealStatement args last addFinalIfReturnsTo: returns extraneous: extraneous) ifNil: [^nil]		] ifFalse: [^nil]].	"because of inlining, we may have a returning if before a return"	extraneous addAll: (statements copyFrom: (statements indexOf: lastRealStatement) + 1 to: statements size)! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:53'!canBeExpression	| count stmt |	count := 0.	statements do: [:s | s isLabel ifFalse: [stmt := s. count := count + 1. s isReturnLike ifTrue: [^count = 1 and: [s isThrow]]]].	count = 1 ifFalse: [^false].	^ stmt canBeExpression! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 12/10/2020 00:18'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in a $} character."	^ aStream peekLast = $}! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 3/26/2021 20:09'!endsWithCr: aStream	"Answer true if the given stream ends in a $} character."	^ aStream peekLast = Character cr! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:42'!endsWithReturn	"Answer true if the last statement of this lock is a return."	^ statements isEmpty not		and: [self lastRealStatement isReturnLike]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:57'!endsWithReturnOrIf	"Answer true if the last statement of this block is a return."	| lastRealStatement |	^ statements isEmpty not		and: [(lastRealStatement := self lastRealStatement) isReturnLike				or: [lastRealStatement isSend and: [#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: lastRealStatement selector]]]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/10/2023 15:25'!hasFinalReturn	| last |	^statements isEmpty ifTrue: [false] ifFalse: [		(last := self lastRealStatement) isReturn ifTrue: [			last expression isSend ifTrue: [last expression isThrow] ifFalse: [				statements reverseDo: [:e | e isSend ifTrue: [					^e isThrow or: 					[(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: e selector) and: [e args first hasFinalReturn and: [e args last hasFinalReturn]]]]]. false]		] ifFalse: [			last isSend and: [				last isThrow or: 				[(#(ifTrue:ifFalse: ifFalse:ifTrue:) includes: last selector) and: [last args first hasFinalReturn and: [last args last hasFinalReturn]]]			]]]! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:49'!isLeafStmtListNode	| count stmt |	count := 0.	statements do: [:s | s isLabel ifFalse: [stmt := s. count := count + 1. s isReturnLike ifTrue: [^false]]].	count = 1 ifFalse: [^false].	^ stmt isLeaf! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 8/16/2023 21:27'!isNilStmtListNode	| count stmt |	count := 0.	statements do: [:s | s isLabel ifFalse: [stmt := s. count := count + 1]].	count = 1 ifFalse: [^false].	^ stmt isVariable and: [stmt name = 'nil']! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	self == aTParseNode ifTrue: [^true].	(aTParseNode isStmtList	 and: [statements size = aTParseNode statements size]) ifFalse:		[^false].	statements with: aTParseNode statements do:		[:mine :theirs|		 (mine isSameAs: theirs) ifFalse:			[^false]].	^true! !!TStmtListNode methodsFor: 'testing' stamp: 'fm 9/11/2023 12:44'!lastRealStatement	"because of inlining, we may have a returning if before a return"	^ statements isEmpty ifFalse: [statements detect: [:e | e isReturnLike] ifNone: [statements reverseDo: [:e | e isLabel ifFalse: [^e]]. self halt]]! !!TStmtListNode methodsFor: '*vmmakerjs' stamp: 'fm 10/12/2023 23:04'!emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen	| actualStatements returnValue | 	(actualStatements := (statements first: (returnValue := statements indexOf: self lastRealStatement)) reject: [:s | s isLabel]) size ~= 1 ifTrue: [		actualStatements isEmpty ifTrue: [			aStream nextPutAll: 'nil'		] ifFalse: [					aStream nextPutAll: '(function() {'.			statements do: [:s |				aStream crtab: level + 1.				s == returnValue ifTrue: [					aStream nextPutAll: 'return '].				s emitJSCodeOn: aStream level: level + 1 generator: aCodeGen].			aStream nextPutAll: '})()'.			^self halt]].	actualStatements do: [:s |		s emitJSCodeAsArgumentOn: aStream level: 0 generator: aCodeGen]! !!TStmtListNode methodsFor: '*vmmakerjs' stamp: 'fm 9/11/2023 10:23'!emitJSCodeOn: aStream level: level generator: aCodeGen	| lastIndex |	self emitJSCommentOn: aStream level: level.	lastIndex := statements indexOf: self lastRealStatement.	statements withIndexDo: [:s :i | | asString |		(i <= lastIndex or: [s isLabel]) ifTrue: [			asString := String streamContents: [ :str |				s emitJSCommentOn: str level: level.				str tab: level.				s emitJSCodeOn: str level: level generator: aCodeGen].			asString withoutLeadingBlanks isEmpty ifFalse: [				aStream nextPutAll: asString.				((self endsWithCloseBracket: aStream) not and: [(self endsWithCr: aStream) not					and: [(s isComment) not						and: [s requiresCLineTerminator]]])					ifTrue: [aStream nextPut: $;].				aStream cr]]]! !!TSwitchStmtNode methodsFor: 'accessing' stamp: 'fm 9/10/2023 22:38'!stmtListsWithTerminalLocalReturns	| stmtLists lastRealExpression extraStmtList send |	stmtLists := OrderedCollection new.	(otherwiseOrNil ifNil: [cases] ifNotNil: [cases copyWith: {otherwiseOrNil}]) do: [:arr | | arg |		arg := arr last.		arg endsWithReturn ifFalse: [ 			lastRealExpression := arg lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: arg.			] ifFalse: [				lastRealExpression isSend ifTrue: [					send := lastRealExpression.					(#(ifTrue: ifFalse:) includes: send selector) ifTrue: [						extraStmtList := TStmtListNode new 												setArguments: #() 												statements: {TVariableNode new setName: 'nil'}.						send renameSelector: #ifTrue: as: #ifTrue:ifFalse:;							renameSelector: #ifFalse: as: #ifFalse:ifTrue:;							arguments: (send args copyWith: extraStmtList).					] ifFalse: [						#or: == send selector ifTrue: [							extraStmtList := TStmtListNode new 													setArguments: #() 													statements: {TConstantNode new setValue: true}.							send renameSelector: #or: as: #ifFalse:ifTrue:;								arguments: (send args copyWith: extraStmtList).						] ifFalse: [							#and: == send selector ifTrue: [								extraStmtList := TStmtListNode new 														setArguments: #() 														statements: {TConstantNode new setValue: false}.								send renameSelector: #or: as: #ifTrue:ifFalse:;									arguments: (send args copyWith: extraStmtList).							].						].					].				].				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturns			].		]	].	^stmtLists! !!TSwitchStmtNode methodsFor: 'accessing' stamp: 'fm 10/8/2023 00:17'!stmtListsWithTerminalLocalReturnsNoTransform	| stmtLists lastRealExpression |	stmtLists := OrderedCollection new.	(otherwiseOrNil ifNil: [cases] ifNotNil: [cases copyWith: {otherwiseOrNil}]) do: [:arr | | arg |		arg := arr last.		arg endsWithReturn ifFalse: [ 			lastRealExpression := arg lastRealStatement rightmostSide.			(lastRealExpression isLeaf or: [lastRealExpression isSend and: [(#(ifTrue:ifFalse: ifFalse:ifTrue: ifTrue: ifFalse: or: and:) includes: lastRealExpression selector) not]]) ifTrue: [				stmtLists add: arg.			] ifFalse: [				stmtLists addAll: lastRealExpression stmtListsWithTerminalLocalReturnsNoTransform			].		]	].	^stmtLists! !!TSwitchStmtNode methodsFor: 'C code generation' stamp: 'fm 9/11/2023 14:37'!emitJSCodeOn: aStream level: level generator: aCodeGen	(aCodeGen nilOrReducibleValueOf: expression)		ifNil: [aStream crtab: level;				nextPutAll: 'switch ('.			expression emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen.			aStream nextPutAll: ') {'.			cases do: [:tuple|				 [:labels :case|				  labels do: [:label|					 aStream						crtab: level;						nextPutAll: 'case '.					label emitJSCodeAsArgumentOn: aStream level: level + 1 generator: aCodeGen.					aStream nextPut: $:].		  		aStream crtab: level + 1.				case emitJSCodeOn: aStream level: level + 1 generator: aCodeGen.				case endsWithReturn ifFalse:					[aStream tab: level + 1; nextPutAll: 'break;']]					valueWithArguments: tuple].			aStream				crtab: level;				nextPutAll: 'default:';				crtab: level + 1.			otherwiseOrNil				ifNotNil:					[otherwiseOrNil emitJSCodeOn: aStream level: level + 1 generator: aCodeGen]				ifNil: [aStream nextPutAll: 'error("Case not found and no otherwise clause");'].			aStream				crtab: level;				nextPut: $}]		ifNotNil: [:const |			(cases detect: [:tuple| tuple first value = const] 				ifNone: [					otherwiseOrNil						ifNotNil:							[otherwiseOrNil emitJSCodeOn: aStream level: level generator: aCodeGen]						ifNil: [aStream nextPutAll: 'error("Case not found and no otherwise clause");'].					^self]			) last emitJSCodeOn: aStream level: level generator: aCodeGen.			].	! !!TSwitchStmtNode methodsFor: 'testing' stamp: 'fm 8/17/2023 12:16'!canBeExpression	^false! !!TVariableNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:26'!hasSideEffect	"Answer if the parse tree rooted at this node has a side-effect or not."	^false! !!TVariableNode methodsFor: 'testing' stamp: 'fm 7/25/2023 13:21'!isSameAs: aTParseNode	^self == aTParseNode	 or: [aTParseNode isVariable		 and: [name = aTParseNode name]]! !!TVariableNode methodsFor: 'testing' stamp: 'fm 10/15/2023 19:20'!splitTermsUsing: aCodeGen	^{{self}. 0. nil}! !!TVariableNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 00:47'!emitJSCodeAsArgumentOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen jsLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: (aCodeGen returnPrefixFromVariable: name) ].! !!TVariableNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 01:51'!emitJSCodeAsExpressionOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen jsLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: (aCodeGen returnPrefixFromVariable: name) ].! !!TVariableNode methodsFor: '*vmmakerjs' stamp: 'fm 8/17/2023 01:57'!emitJSCodeOn: aStream level: level generator: aCodeGen! !!TVariableNode methodsFor: '*vmmakerjs' stamp: 'fm 9/19/2023 18:55'!isFloatIn: aCodeGen	| type |	type := aCodeGen typeOfVariable: name.	type isNil ifTrue: [^false].	(type includes: $*) ifTrue: [^false].	(type beginsWithAnyOf: #('register ' 'static ')) ifTrue: [type := type copyAfter: $ ].	(type beginsWithAnyOf: #('double ' 'float ')) ifTrue: [^true].	(type beginsWithAnyOf: #('int ' 'unsigned ' 'sqInt ' 'usqInt ' 'usqLong ' 'sqLong ' 'long ' 'sqImageFile ' 'squeakFileOffsetType ' 'size_t ' 'var ' 'uint32_t ')) ifTrue: [^false].	self halt: 'need to handle ', type! !!Unsigned class methodsFor: '*vmmakerjs' stamp: 'fm 11/29/2020 13:35'!jscg: cg prolog: aBlock expr: aString index: anInteger	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf: ';		nextPutAll: aString])! !!VariableNode methodsFor: 'transforming' stamp: 'fm 9/15/2023 13:08'!couldBeAffectedByReordering	^(self isArg or: [self isSelfPseudoVariable or: [self isFixedValue or: [#('interpreterProxy' 'super') includes: key]]]) not! !!WordArray class methodsFor: '*vmmakerjs' stamp: 'fm 12/30/2020 23:32'!jscg: cg prolog: aBlock expr: aString index: anInteger	^cg 		jscgLoad: aBlock 		expr: aString 		asUnsignedPtrFrom: anInteger		andThen: [:index | String streamContents:			[:aStream | aStream				nextPutAll: 'nil checkIsWords: ';				nextPutAll: aString]]! !TSendNode removeSelector: #endsWithReturn!TReturnNode removeSelector: #endsWithReturn!TParseNode removeSelector: #endsWithReturn!JSSmartSyntaxPluginMethod removeSelector: #removeFinalSelfReturn!Object subclass: #JSMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels writtenToGlobalVarsCache complete export static sharedLabel sharedCase comment definingClass globalStructureBuildMethodHasFoo canAsmLabel mustAsmLabel properties cascadeVariableNumber extraVariableNumber oneBasedArrays loopsWithReturns'	classVariableNames: 'CaseStatements'	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!Object subclass: #JSCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations scopeStack methods macros preparedMethodList variablesSetCache headerFiles globalVariableUsage useSymbolicConstants generateDeadCode doNotRemoveMethodList asArgumentTranslationDict receiverDict vmClass currentMethod logger declareMethodsStatic permitMethodPruning pools abstractDeclarations uncheckedAbstractMethods cCodeTranslationDict oneBasedArrays exceptions omSimulator inlineReturnTypes'	classVariableNames: 'IsActive UseRightShiftForDivide'	poolDictionaries: ''	category: 'VMMakerJS-Translation to JS'!