'From Squeak4.5 of 10 April 2015 [latest update: #13712] on 3 July 2023 at 11:34:58 pm'!ParseNodeEnumerator subclass: #ParseNodePostOrderEnumerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!InstructionPrinter subclass: #RelativeInstructionPrinter	instanceVariableNames: 'printCode labels labelling temps vectors '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!Array methodsFor: 'printing' stamp: 'eem 4/3/2017 15:35'!printAsLiteralOn: aStream	aStream nextPut: $#; nextPut: $(.	self do: [:each| each printAsLiteralOn: aStream] separatedBy: [aStream space].	aStream nextPut: $)! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'fm 1/31/2022 21:01'!fileOutCommentOn: aFileStream moveSource: moveSource toFile: fileIndex	"Copy the class comment to aFileStream.  If moveSource is true (as in compressChanges or compressSources, then update classComment to point to the new file."	| fileComment |	classComment ifNotNil: [		classComment text ifNotNil: [:t |			aFileStream cr.			fileComment := RemoteString newString: t							onFileNumber: fileIndex toFile: aFileStream.			moveSource ifTrue: [classComment := fileComment]]]! !!Boolean methodsFor: 'printing' stamp: 'eem 4/3/2017 15:44'!printAsLiteralOn: aStream	^self printOn: aStream! !!ByteArray methodsFor: 'printing' stamp: 'eem 4/3/2017 15:18'!printAsLiteralOn: aStream	aStream nextPut: $#; nextPut: $[.	self do: [:each| each storeOn: aStream]		separatedBy: [aStream nextPut: $ ].	aStream nextPut: $]! !!Character methodsFor: 'printing' stamp: 'eem 4/3/2017 15:21'!printAsLiteralOn: aStream	aStream nextPut: $$; nextPut: self! !!CompiledMethod methodsFor: 'comparing' stamp: 'fm 6/16/2023 10:59'!hasSameLiteralsAs: aMethod	"Answer whether the receiver has the same sequence of literals as the argument.	 Compare the last literal, which is the class association, specially so as not to	 differentiate between otherwise identical methods installed in different classes.	 Compare the first literal carefully if it is the binding informaiton for an FFI or	 external primitive call.  Don't compare all of the state so that linked and unlinked	 methods are still considered equal."	| numLits fakeLiterals aMethodLits selfLits aMethodActualLits aMethodLast aMethodProps selfActualLits selfLast selfProps |	fakeLiterals := MessageNode classPool at: #MacroSelectors.	selfLits := self literals.	selfActualLits := selfLits reject: [:lit | fakeLiterals includes: lit].	aMethodLits := aMethod literals.	aMethodActualLits := aMethodLits reject: [:lit | fakeLiterals includes: lit].	numLits := selfActualLits size.	numLits = aMethodActualLits size ifFalse: [^false].	selfProps := selfLits at: selfLits size - 1.	selfLast := selfLits last.	aMethodProps := aMethodLits at: aMethodLits size - 1.	aMethodLast := aMethodLits last.	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := selfActualLits at: i.		lit2 := aMethodActualLits at: i.		(lit1 == lit2 or: [lit1 isCompiledCode ifTrue: [lit1 sameWithoutTrailerAs: lit2] ifFalse: [lit1 literalEqual: lit2]]) ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue:					[lit1 isArray						ifTrue:							[(lit2 isArray and: [(lit1 first: 2) = (lit2 first: 2)]) ifFalse:								[^false]]						ifFalse: "ExternalLibraryFunction"							[(lit1 analogousCodeTo: lit2) ifFalse:								[^false]]]				ifFalse:					[i = (numLits - 1)						ifTrue: "properties"							[(self properties analogousCodeTo: aMethod properties)								ifFalse: [^false]]						ifFalse: "last literal (methodClassAssociation) of class-side methods is not unique"							[(lit1== selfLast and: [lit2 == aMethodLast							 and: [lit1 isVariableBinding and: [lit1 value isBehavior							 and: [lit2 isVariableBinding and: [lit2 value isBehavior]]]]]) ifFalse:								[^false]]]]].	^true! !!CompiledMethod methodsFor: 'decompiling' stamp: 'fm 6/18/2023 14:07'!decompileWithTemps	"Return the decompiled parse tree that represents self, but with the temp names obtained	 either by compiling the sourcecode, or directly if the method has temps in its trailer."	| class selector tempNames source cm |	cm := self methodForDecompile.	class := cm methodClass ifNil: [^cm decompile].	selector := cm selector ifNil: [^cm decompile].	cm isQuick ifTrue: [^cm decompile].	cm holdsTempNames		ifTrue: [			tempNames := cm tempNamesString]		ifFalse:			["No source file or no source (e.g. doits) and no temp names			 -- decompile without temp names "			((cm fileIndex > 0 and: [(SourceFiles at: cm fileIndex) isNil]) 			or: [(source := cm getSourceFromFile) isNil]) ifTrue:				[^cm decompile].			tempNames := [ | methodNode newMethod |							newMethod := (class newParser								encoderClass: cm encoderClass;								parse: source class: class) generate.							(newMethod selector == selector and: [cm sameWithoutTrailerAs: newMethod]) ifFalse: [								self isInstalled ifTrue: [self halt]. 								^cm decompile].							methodNode := class newParser								encoderClass: cm encoderClass;								parse: source class: class.							methodNode replaceReusedVarNames.							cm := methodNode generate.							methodNode schematicTempNamesString] on: SyntaxErrorNotification do: [:ex | nil].			tempNames ifNil: ["broken source, give up tempNames" ^cm decompile]].	^(class decompilerClass new withTempNames: tempNames)		decompile: selector		in: class		method: cm 	! !!Decompiler methodsFor: 'control' stamp: 'fm 6/16/2023 11:35'!blockTo: end	"Decompile a range of code as in statementsTo:, but return a block node. NB: end is an exclusive index."	| block oldBase |	oldBase := blockStackBase.	blockStackBase := stack size.	block := constructor codeBlock: (self statementsTo: end) returns: lastReturnPc = lastPc.	blockStackBase := oldBase.	lastReturnPc := -1.  "So as not to mislead outer calls"	^block! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/10/2023 20:09'!decompile: aSelector in: aClass method: aMethod using: aConstructor	^(self		decompileNoPreen: aSelector		in: aClass		method: aMethod		using: aConstructor) preen! !!Decompiler methodsFor: 'public access' stamp: 'fm 2/9/2023 15:37'!decompileNoPreen: aSelector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	^self		decompileNoPreen: aSelector		in: aClass		method: aMethod		using: (self constructorForMethod: aMethod)! !!Fraction methodsFor: 'printing' stamp: 'fm 6/21/2023 23:42'!printAsLiteralOn: aStream	denominator = (10 raisedToInteger: denominator log rounded) ifTrue: [		numerator printOn: aStream.		aStream nextPutAll: 'e-'.		denominator log rounded printOn: aStream	] ifFalse: [ | powers quo maxExp |		powers := Array new: 11.		quo := denominator abs.		maxExp := 0.		#(2 3 5 7 11 13 17 19 23 29 31) withIndexDo: [:e :i | | exp raised |			exp := 0.			raised := e.			[quo > raised and: [quo \\ raised = 0]] whileTrue: [				raised := raised * e.				exp := exp + 1.			].			exp > maxExp ifTrue: [maxExp := exp].			quo := quo / (raised / e).			powers at: i put: exp		].		quo > 1 ifTrue: [			self halt		] ifFalse: [ | scaledNumerator base exponentialForm |			scaledNumerator := numerator abs.			base := 1.			#(2 3 5 7 11 13 17 19 23 29 31) with: powers do: [:e :exp | | raised |				exp > 0 ifTrue: [					raised := e raisedToInteger: (maxExp - exp).					scaledNumerator := scaledNumerator * raised.					base := base * e				]			].			exponentialForm := String streamContents: [ :s |				self < 0 ifTrue: [s nextPut: $-].				base printOn: s.				s nextPut: $r.				scaledNumerator printOn: s base: base.				s nextPutAll: 'e-'.				maxExp printOn: s]. 			(Compiler evaluate: exponentialForm) = self ifTrue: [				aStream nextPutAll: exponentialForm			] ifFalse: [				self halt]		].	] ! !!HandMorph methodsFor: 'private events' stamp: 'fm 4/23/2023 23:58'!mouseTrailFrom: currentBuf 	"Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the positions inbetween."	| nextEvent trail |	trail := WriteStream on: (Array new: 1).	trail nextPut: currentBuf third @ currentBuf fourth.	[(nextEvent := Sensor peekEvent) isNil] whileFalse: 			[nextEvent first = currentBuf first 				ifFalse: [^trail contents	"different event type"].			nextEvent fifth = currentBuf fifth 				ifFalse: [^trail contents	"buttons changed"].			nextEvent sixth = currentBuf sixth 				ifFalse: [^trail contents	"modifiers changed"].			"nextEvent is similar.  Remove it from the queue, and check the next."			trail nextPut: nextEvent third @ nextEvent fourth.			Sensor nextEvent].	^trail contents! !!ImmX11 methodsFor: 'keyboard' stamp: 'fm 11/29/2021 18:18'!keyboardFocusForAMorph: aMorph	aMorph ifNil: [^ self].	[		| left bottom pos |		pos := aMorph preferredKeyboardPosition.		left := (pos x min: Display width max: 0) asInteger.		bottom := (pos y min: Display height max: 0) asInteger.		self setCompositionWindowPositionX: left y: bottom	] on: Error	do: [:ex |].! !!Integer methodsFor: 'printing' stamp: 'eem 4/3/2017 15:26'!printAsLiteralOn: aStream	^self printOn: aStream base: 10! !!MCAncestry methodsFor: 'ancestry' stamp: 'fm 10/6/2020 02:55'!allAncestors		| allAncestors |	allAncestors := IdentityDictionary new.	self allAncestorsDo: [ :each | ] visitedAncestors: allAncestors.	^allAncestors ! !!MCAncestry methodsFor: 'ancestry' stamp: 'fm 10/6/2020 08:57'!allAncestorsDo: aBlock		self allAncestorsDo: aBlock visitedAncestors: IdentityDictionary new! !!MCAncestry methodsFor: 'ancestry' stamp: 'fm 10/6/2020 02:59'!allAncestorsDo: aBlock visitedAncestors: visitedAncestors	self ancestors do: [ :each |		(visitedAncestors includesKey: each) ifFalse: [			visitedAncestors at: each put: nil.			aBlock value: each.			each isMCInfoProxy ifFalse: [			each allAncestorsDo: aBlock visitedAncestors: visitedAncestors ] ] ]! !!MCAncestry methodsFor: 'ancestry' stamp: 'fm 10/6/2020 03:10'!ancestorsDoWhileTrue: aBlock	self ancestors do:		[:ea | ea isMCInfoProxy ifFalse: [		(aBlock value: ea) ifTrue: 			[ea ancestorsDoWhileTrue: aBlock]]]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'fm 10/6/2020 09:00'!stubAncestry	"Stub all but the most recent 10 of my ancestry tree to save memory with a proxy which can be transparently accessed later, if necessary."	self ancestors ifEmpty: [ ^ self ].	repositoryGroup ifNotNil:		[		ancestry ancestors do:		[:ea | ea isMCInfoProxy ifFalse: [		ea			stubAncestryFor: self			using: repositoryGroup ]]]! !!NewParagraph methodsFor: 'private' stamp: 'fm 4/23/2023 23:49'!lines	lines == nil ifTrue: [self composeAll].	^ lines! !!ParseNode methodsFor: 'transforming' stamp: 'fm 3/9/2023 21:05'!isParentOf: aChildNode	self == aChildNode ifTrue: [^false].	self nodesDo: [:n | aChildNode == n ifTrue: [^true]].	^false! !!BlockNode methodsFor: 'accessing' stamp: 'fm 10/25/2014 22:42'!optimizedMessageNode	^optimizedMessageNode! !!BlockNode methodsFor: 'printing' stamp: 'fm 1/21/2023 18:25'!printArgumentsOn: aStream indent: level	| actualArgs |	arguments size = 0 ifTrue: [		optimized ifTrue: [			actualArgs := self actualScope temporaries select: [:e | e isBlockArg and: [e definingScope == self and: [e scope >= -1]]]].		(actualArgs isNil or: [actualArgs isEmpty]) ifTrue: [^ self]	] ifFalse: [		actualArgs := arguments	].	actualArgs do:		[:arg | aStream nextPut: $:;  nextPutAll: arg key;  space].	aStream nextPut: $|; space.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue:		[aStream crtab: level]! !!BlockNode methodsFor: 'printing' stamp: 'fm 3/6/2023 23:56'!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	| tempStream seen |	tempSequence ifNil:		[^false].	tempStream := (String new: 16) writeStream.	"This is for the decompiler which cannot work out which optimized block a particular temp is	 local to and hence may produce diplicates as in		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"	seen := Set new.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 (seen includes: tempVariableNode key) ifFalse:						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]			ifFalse:				[(tempNode scope >= -1				  and: ["This is for the decompiler which may create a block arg when converting						a while into a to:do: but won't remove it form temporaries"					   tempNode isBlockArg not				  and: [(seen includes: tempNode key) not]]) ifTrue:					[tempStream space; nextPutAll: (seen add: tempNode key)]]].	tempStream position = 0 ifTrue:		[^false].	aBlock value.	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.	^true! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'fm 10/3/2014 11:16'!makeTemporariesRemovable	"Utilities for when we want to remove some temporaries."		temporaries isNil ifTrue:		[temporaries := OrderedCollection new]	ifFalse: [temporaries isArray ifTrue:		[temporaries := temporaries asOrderedCollection]]! !!Encoder methodsFor: 'private' stamp: 'fm 1/5/2023 18:37'!bindUniquedTemp: variableNode	| original uniqueName |	original := variableNode name.	(scopeTable at: original ifAbsent: nil) == variableNode ifTrue: [		uniqueName := self uniqueNameStartingFrom: original.		scopeTable removeKey: original	] ifFalse: [		uniqueName := self uniqueNameStartingFrom: original , '1'.	].	scopeTable at: uniqueName put: variableNode.	variableNode name: uniqueName key: uniqueName code: variableNode code! !!Encoder methodsFor: 'private' stamp: 'fm 10/4/2014 16:02'!uniqueNameStartingFrom: name 	| uniqueName counter |	uniqueName := name.	counter := 0.	[scopeTable 		at: uniqueName		ifPresent: [:e | true]		ifAbsent: [self lookupInPools: uniqueName ifFound: [:assoc | true]]] whileTrue: [			counter := counter + 1.			uniqueName := name , counter printString].	^uniqueName! !!FutureNode methodsFor: 'JavaScript generation' stamp: 'fm 10/25/2022 14:52'!printOn: aStream	(futureArgs isNil or: [futureSelector isNil]) 		ifTrue: [			aStream nextPutAll: 'FutureMaker new setDeltaMSecs: ';				nextPutAll: (futureDelta isNil ifTrue: ['0.0'] ifFalse: [futureDelta key printString]);				nextPutAll: ' target: '.			receiver printOn: aStream			]		ifFalse: [			receiver printOn: aStream.			aStream nextPutAll: ' futureSend: '.			futureSelector storeOn: aStream.			aStream nextPutAll: ' at: '.			aStream nextPutAll: (futureDelta isNil ifTrue: ['0'] ifFalse: [futureDelta key printString]);				nextPutAll: ' args: {'.			futureArgs do: [:each | each printOn: aStream] separatedBy: [aStream nextPutAll: '. '].			aStream nextPut: $}			].	! !!FutureNode methodsFor: 'JavaScript generation' stamp: 'fm 10/25/2022 14:53'!printOn: aStream indent: level 	(futureArgs isNil or: [futureSelector isNil]) 		ifTrue: [			aStream nextPutAll: 'FutureMaker new setDeltaMSecs: ';				nextPutAll: (futureDelta isNil ifTrue: ['0.0'] ifFalse: [futureDelta key printString]);				nextPutAll: ' target: '.			receiver printOn: aStream indent: level 			]		ifFalse: [			receiver printOn: aStream indent: level .			aStream nextPutAll: ' futureSend: '.			futureSelector storeOn: aStream.			aStream nextPutAll: ' at: '.			aStream nextPutAll: (futureDelta isNil ifTrue: ['0'] ifFalse: [futureDelta key printString]);				nextPutAll: ' args: {'.			futureArgs do: [:each | each printOn: aStream indent: level ] separatedBy: [aStream nextPutAll: '. '].			aStream nextPut: $}			].	! !!FutureNode methodsFor: 'JavaScript generation' stamp: 'fm 10/13/2020 00:49'!printOn: aStream indent: level precedence: p	aStream nextPut: $(.	self printOn: aStream indent: level.	aStream nextPut: $)! !!LiteralNode methodsFor: 'printing' stamp: 'fm 6/20/2023 23:45'!printOn: aStream indent: level	key isVariableBinding		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##'; nextPutAll: key key]]		ifFalse:			[key printAsLiteralOn: aStream]! !!MessageNode methodsFor: 'equation translation' stamp: 'fm 6/6/2023 01:24'!originalArguments	^originalArguments! !!MessageNode methodsFor: 'printing' stamp: 'fm 6/19/2023 18:48'!printIfNilNotNil: aStream indent: level	(arguments first isJust: NodeNil) ifTrue: [		arguments second arguments isEmpty ifTrue: [			self printReceiver: receiver ifNilReceiver on: aStream indent: level.		] ifFalse: [			self printReceiver: receiver ifNilReceiver value on: aStream indent: level.		].		^ self			printKeywords: #ifNotNil:			arguments: { arguments second }			on: aStream indent: level].				arguments second arguments isEmpty ifTrue: [		self printReceiver: receiver ifNilReceiver on: aStream indent: level.	] ifFalse: [		self printReceiver: receiver ifNilReceiver value on: aStream indent: level.	].	^ self		printKeywords: #ifNil:ifNotNil:		arguments: arguments		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'fm 6/9/2023 00:32'!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(arguments size >= 7 and: [(arguments at: 3) arguments isEmpty]) ifTrue: [		(arguments at: 3) arguments: {(arguments at: 6) variable}	].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'testing' stamp: 'fm 9/24/2014 00:51'!toDoIncrement: variable	(receiver = variable and: [selector key = #+ or: [selector key = #-]]) 		ifFalse: [^ nil].	^arguments first isConstantNumber		ifTrue: [selector key = #+ 					ifTrue: [arguments first] 					ifFalse: [LiteralNode new key: arguments first key negated index: nil type: LdLitType]]! !!MessageNode methodsFor: 'visiting' stamp: 'fm 5/30/2022 19:34'!argumentsInEvaluationOrder	"Answer the receiver's arguments in evaluation order.	 If the receiver is a transformed to:do: node this will undo the misordering done by the transformation."	^(special > 0	   and: [(MacroTransformers at: special) == #transformToDo:	   and: [arguments size >= 7]])		"arguments are in a weird order and may be nil in a transformed to:do: loop.  sigh...		 c.f. emitCodeForToDo:encoder:value:"		ifTrue:			[(arguments at: 7)	"limitInit"				ifNil: [{	arguments at: 4.	"initStmt"						arguments at: 5.	"test"						arguments at: 3.	"block"						arguments at: 6 	"incStmt" }]				ifNotNil: [:limitInit|						{ arguments at: 4.	"initStmt"						limitInit.						arguments at: 5.	"test"						arguments at: 3.	"block"						arguments at: 6 	"incStmt" }]]		ifFalse:			[arguments]! !!MessageNode methodsFor: 'visiting' stamp: 'fm 10/11/2020 14:59'!receiverInEvaluationOrder	"Answer the receivers arguments in evaluation order.	 If the receiver is a transformed to:do: node this will undo the misordering done by the transformation."	^(special > 0	   and: [(MacroTransformers at: special) == #transformToDo:	   and: [arguments size >= 7]])		"arguments include the former receiver in a transformed to:do: loop.  sigh...		 c.f. emitCodeForToDo:encoder:value:"		ifFalse:			[receiver]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 9/28/2020 13:10'!isTimesRepeat	^arguments size = 1 and: [arguments first isBlockNode and: [arguments first numberOfArguments = 0 and: 	[#timesRepeat: = selector key]]]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 9/28/2020 12:04'!isLoopStatement	^(special > 0	   and: [#(transformWhile: transformToDo: transformRepeat:) includes: (MacroTransformers at: special)])		or: [self isTimesRepeat]! !!MethodNode methodsFor: 'printing' stamp: 'fm 1/10/2023 12:42'!printPragmasOn: aStream	properties ifNil: [^self].	properties pragmas do:		[:pragma|		"Primitives are printed in printPrimitiveOn:; skip these"		(Parser primitivePragmaSelectors includes: pragma keyword) ifFalse:			[aStream crtab: 1; nextPutAll: '< '; print: pragma message; nextPutAll: ' >']]! !!MethodNode methodsFor: 'printing' stamp: 'fm 9/19/2020 00:12'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primDecl |	primitive = 0 ifTrue:		[^self].	primitive = 120 ifTrue: "External call spec"		[^aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primitive = 117		ifTrue:			[primDecl := encoder literals at: 1.			 (primDecl at: 2) asString printOn: aStream.			 (primDecl at: 1) ifNotNil:				[:moduleName|				aStream nextPutAll:' module: '.				moduleName asString printOn: aStream]]		ifFalse:			[aStream print: primitive].	self primitiveErrorVariableName ifNotNil:		[:primitiveErrorVariableName|		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].	aStream nextPut: $>.	Smalltalk at: #InterpreterPrimitives ifPresent:[:cls|		aStream nextPutAll: ' "',							((cls classPool at: #PrimitiveTable) at: primitive + 1),							'" ']! !!MethodNode methodsFor: 'printing' stamp: 'fm 10/12/2022 18:56'!printPropertiesOn: aStream	properties ifNil: [^self].	properties propertyKeysAndValuesDo:		[:prop :val|		prop = #source ifFalse: [			aStream crtab; nextPut: $<.			prop = #on:in:				ifTrue:					[prop keywords with: val do:						[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]				ifFalse:					[prop = #on						ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 						ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 			aStream nextPut: $>]]! !!MethodNode methodsFor: 'converting' stamp: 'fm 5/6/2023 23:59'!preen	"Preen for pretty-printing and/or decompilation.	 i.e. post-process to cover up for inadequacies in both algorithms.	 Currently one case, hiding the assignment to the arg of an inlined block arg to ifNotNil:,		(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...]."	self preenLocalIfNotNilArg.	self preenWhileLoopValue.	self preenIfValue.! !!MethodNode methodsFor: 'converting' stamp: 'fm 5/7/2023 00:58'!preenIfValue	"Try and spot a ... ifTrue: [^...]. nil sequence, or ... ifFalse: [^...].nil one,	 and convert it to ... ifTrue: [^...], respectively ... ifFalse: [^...].  "	block nodesDo:		[:node| | s last penultimate |		(node isBlockNode and: 		[(s := node statements) size > 1 and: 		[(last := s last) == NodeNil and: 		[(penultimate := s at: s size - 1) isMessageNode and: 		[(penultimate macroPrinter == #printIfOn:indent: or: [#(ifFalse: ifTrue: ifTrue:ifFalse: ifFalse:ifTrue:) includes: penultimate selector key]) and: 		[penultimate arguments allSatisfy: [:a | (a isJust: NodeNil) or: [a isBlockNode and: [a returns]]]]]]]]) ifTrue: 			[node statements: s allButLast]]! !!MethodNode methodsFor: 'converting' stamp: 'fm 5/6/2023 23:59'!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo: [:node | | variable nilArg notNilArg canBeArg | 			(node isMessageNode					and: [(node macroPrinter == #printIfNilNotNil:indent:								or: [(#(#ifNil:ifNotNil: #ifNotNil: #ifNotNil:ifNil: ) includes: node selector key)										or: [node selector key == #ifFalse:												and: [node receiver notNil 												and: [node receiver														isMessage: #==														receiver: nil														arguments: [:argNode | argNode == NodeNil]]]]])							and: [node receiver ifNilReceiver isAssignmentNode									and: [(variable := node receiver ifNilReceiver variable) isTemp											and: [variable isRemote not													and: [(variable isOnlySubnodeOf: node in: self)															and: [(node receiver ifNilReceiver value isParentOf: variable) not]]]]]])				ifTrue: [					node arguments size = 1 						ifTrue: [nilArg := BlockNode withJust: NodeNil.							notNilArg := node arguments first]						ifFalse: [(node macroPrinter == #printIfNilNotNil:indent:									or: [node selector key == #ifNil:ifNotNil:])							ifTrue: [nilArg := node arguments first.								notNilArg := node arguments second]							ifFalse: [nilArg := node arguments second.								notNilArg := node arguments first]].					(nilArg isParentOf: variable) ifFalse: [						canBeArg := true.						notNilArg arguments isEmpty							ifTrue: [								notNilArg nodesDo: [:e | 									(e isAssignmentNode and: [e variable key = variable key]) ifTrue: 										[canBeArg := false]].								canBeArg ifTrue: [									notNilArg arguments: {variable}.									varsToHide add: variable]]							ifFalse: [self assert: notNilArg arguments asArray = {variable}].						canBeArg ifTrue: [							node receiver isMessageNode								ifTrue: [node selector key == #ifFalse:										ifTrue: [node												receiver: node receiver receiver value												selector: (SelectorNode new key: #ifNotNil: code: nil)												arguments: {notNilArg}												precedence: 3]										ifFalse: [node receiver receiver: node receiver receiver value]]								ifFalse: [node receiver: node receiver value]]]]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!MethodNode methodsFor: 'converting' stamp: 'fm 2/22/2023 23:00'!preenWhileLoopValue	"Try and spot a [...] while... [...]. ^nil sequence, or [...[...] while... [...].nil] one,	 and convert it to ^[...] while... [...], respectively [ ...[...] while... [...]].  "	block nodesDo:		[:node| | s last penultimate |		(node isBlockNode and: 		[(s := node statements) size > 1 and: 		[((last := s last) == NodeNil or: [(last isKindOf: ReturnNode) and: [last expr == NodeNil]]) and: 		[(penultimate := s at: s size - 1) isMessageNode and: 		[penultimate macroPrinter == #printWhileOn:indent: or: [#(whileFalse: whileTrue: whileFalse whileTrue) includes: penultimate selector key]]]]]) ifTrue: 			[node statements: (last == NodeNil				ifTrue: [s allButLast]				ifFalse: [last expr: penultimate. s copyWithout: penultimate])]]! !!MethodNode methodsFor: 'transforming' stamp: 'fm 3/8/2023 23:43'!replaceReusedVarNames	| declarations |	self assert: block blockExtent isNil.	"this has to be done after parsing but before generation"	declarations := Dictionary new.	self nodesDo: [:n |		(n == self or: [n isBlockNode]) ifTrue: [			n arguments do: [:arg | | sameNameCollection |				sameNameCollection := declarations at: arg name ifAbsentPut: [OrderedCollection new].				(sameNameCollection includes: arg) ifFalse: [sameNameCollection add: arg]].			n temporaries do: [:temp | | sameNameCollection |				sameNameCollection := declarations at: temp name ifAbsentPut: [OrderedCollection new].				(sameNameCollection includes: temp) ifFalse: [sameNameCollection add: temp]]]].	declarations keysAndValuesDo: [:name :sameNameCollection | 		sameNameCollection size > 1 ifTrue: [			2 to: sameNameCollection size do: [:i |				encoder bindUniquedTemp: (sameNameCollection at: i)]]]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'fm 10/11/2020 15:01'!visitMessageNode: aMessageNode	aMessageNode receiverInEvaluationOrder notNil ifTrue: "receiver is nil for cascades and transformed to:do: loops"		[aMessageNode receiver accept: self].	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:42'!visitAssignmentNode: anAssignmentNode	(theSelectBlock isNil or: [theSelectBlock value: anAssignmentNode]) ifFalse:		[^nil].	anAssignmentNode value accept: self.	anAssignmentNode variable accept: self.	theBlock value: anAssignmentNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:43'!visitBlockNode: aBlockNode	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:		[^nil].	aBlockNode statements do:		[:statement| statement accept: self].	theBlock value: aBlockNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:43'!visitBraceNode: aBraceNode	(theSelectBlock isNil or: [theSelectBlock value: aBraceNode]) ifFalse:		[^nil].	aBraceNode elements do:		[:element| element accept: self].	theBlock value: aBraceNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:43'!visitCascadeNode: aCascadeNode	(theSelectBlock isNil or: [theSelectBlock value: aCascadeNode]) ifFalse:		[^nil].	aCascadeNode receiver accept: self.	aCascadeNode messages do:		[:message| self visitMessageNodeInCascade: message].	theBlock value: aCascadeNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:43'!visitFutureNode: aFutureNode	(theSelectBlock isNil or: [theSelectBlock value: aFutureNode]) ifFalse:		[^nil].	aFutureNode receiver accept: self.	(aFutureNode originalSelector isKindOf: SelectorNode) ifTrue:		[aFutureNode originalSelector accept: self].	theBlock value: aFutureNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:52'!visitMessageNode: aMessageNode	(theSelectBlock isNil or: [theSelectBlock value: aMessageNode]) ifFalse:		[^nil].	aMessageNode receiverInEvaluationOrder notNil ifTrue: "receiver is nil for cascades and transformed to:do: loops"		[aMessageNode receiver accept: self].	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self].	aMessageNode selector accept: self.	theBlock value: aMessageNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:53'!visitMessageNodeInCascade: aMessageNodeInCascade	(theSelectBlock isNil or: [theSelectBlock value: aMessageNodeInCascade]) ifFalse:		[^nil].	aMessageNodeInCascade argumentsInEvaluationOrder do:		[:argument| argument accept: self].	aMessageNodeInCascade selector accept: self.	theBlock value: aMessageNodeInCascade.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:44'!visitMethodNode: aMethodNode	(theSelectBlock isNil or: [theSelectBlock value: aMethodNode]) ifFalse:		[^nil].	aMethodNode block accept: self.	theBlock value: aMethodNode.! !!ParseNodePostOrderEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 20:44'!visitReturnNode: aReturnNode	(theSelectBlock isNil or: [theSelectBlock value: aReturnNode]) ifFalse:		[^nil].	aReturnNode expr accept: self.	theBlock value: aReturnNode.! !!Parser methodsFor: 'expression types' stamp: 'fm 3/17/2023 23:37'!statements: argNodes innerBlock: inner blockNode: theBlockNode	| stmts returns start |	"give initial comment to block, since others trail statements"	theBlockNode comment: currentComment.	currentComment := nil.	stmts := OrderedCollection new.	returns := false.	hereType ~~ #rightBracket ifTrue:		[[theBlockNode startOfLastStatement: (start := self startOfNextToken).		  (returns := self matchReturn)			ifTrue: 				[self expression ifFalse:					[^self expected: 'Expression to return'].				 self addComment.				 stmts addLast: (parseNode isReturningIf								ifTrue: [parseNode]								ifFalse: [ReturnNode new											expr: parseNode											encoder: encoder											sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						"if both branches return, following code is unreachable, let's avoid this.						But only if interactive, we don't want to prevent loading of legacy code"						self interactive ifTrue: [returns := parseNode isReturningIf].						 stmts addLast: parseNode]					ifFalse: 						[self addComment.						 stmts size = 0 ifTrue: 							[stmts addLast: 								(encoder encodeVariable:									(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		  returns ifTrue: 			[self match: #period.			 (hereType == #rightBracket or: [hereType == #doIt]) ifFalse:				[^self expected: 'End of block']].		  returns not and: [self match: #period]] whileTrue].	stmts size = 0 ifTrue: 		[self addComment.			stmts addLast: 				(encoder encodeVariable:					(inner ifTrue: ['nil'] ifFalse: ['self']))].	theBlockNode		arguments: argNodes		statements: stmts		returns: returns		from: encoder.	parseNode := theBlockNode.	^true! !!Player class methodsFor: 'housekeeping' stamp: 'fm 6/29/2022 19:25'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables referencesto instances of themselves that are housekeepingwise unreachable. Thismethod allows such loops to be garbage collected. This is done in threesteps:	1. Remove user-created subclasses from the 'subclasses' set and fromSmalltalk. Only remove classes whose name begins with 'Player' and whichhave no references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance'ssuperclass is this class. Reset the subclasses set to this set ofclasses, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| oldFree candidatesForRemoval class globalCandidates |	oldFree := Smalltalk garbageCollect.	candidatesForRemoval := self subclasses asOrderedCollection select:		[:aClass | (aClass name beginsWith: 'Player') and: [aClass nameendsWithDigit]].	"Break all system links and then perform garbage collection."	globalCandidates := WeakSet new.	candidatesForRemoval do: [:c | | globalCandidate |		self removeSubclass: c.  "Break downward subclass pointers."		globalCandidate := Smalltalk globals removeKey: c name ifAbsent: [].  "Break binding of global name"		globalCandidate notNil ifTrue: [globalCandidates add: globalCandidate].		(c instVarAt: 10) ~~ Environment default ifTrue: [Environment default removeObserver: (c instVarAt: 10)]		].	candidatesForRemoval := nil.	Smalltalk garbageCollect.  "Now this should reclaim all unusedsubclasses"	"Now reconstruct system links to subclasses with valid references."	"First restore any global references via associations"	(Association allSubInstances select:			[:assn | (assn key isSymbol)					and: [(assn key beginsWith: 'Player')					and: [assn key endsWithDigit]]])		do: [:assn | class := assn value.			(class isKindOf: self class) ifTrue:				[self addSubclass: class.				(globalCandidates includes: class) ifTrue: [					Smalltalk add: assn]]].	"Then restore any further direct references, creating newassociations."	(Metaclass allInstances select:			[:m | (m soleInstance name beginsWith: 'Player')					and: [m soleInstance name endsWithDigit]])		do: [:m | class := m soleInstance.			((class isKindOf: self class) and: [(Smalltalk includesKey: classname) not]) ifTrue:				[self addSubclass: class.				(globalCandidates includes: class) ifTrue: [					Smalltalk at: class name put: class]]].	SystemOrganization removeMissingClasses.	^ Smalltalk garbageCollect - oldFree! !!Pragma methodsFor: 'printing' stamp: 'fm 3/18/2023 15:36'!printOn: aStream	aStream		nextPutAll: '< ';		print: self message;		nextPutAll: ' >'.! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:36'!jump: offset	"Print the Unconditional Jump bytecode."	labelling		ifTrue:			[labels at: scanner pc + offset + 1 put: true]		ifFalse:			[self print: 'jumpTo: ', (labels at: scanner pc + offset + 1)]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:37'!jump: offset if: condition 	"Print the Conditional Jump bytecode."	labelling		ifTrue:			[labels at: scanner pc + offset + 1 put: true]		ifFalse:			[self print: 				(condition ifTrue: ['jumpTrueTo: '] ifFalse: ['jumpFalseTo: ']), (labels at: scanner pc + offset + 1)]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:39'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	| remoteTemps |		labelling 		ifTrue:			[remoteTemps := vectors at: tempVectorIndex ifAbsentPut: ['v', vectors size printString -> Dictionary new].			remoteTemps value at: remoteTempIndex ifAbsentPut: ['rt', remoteTemps value size printString]]		ifFalse:			[remoteTemps := vectors at: tempVectorIndex.			self print: 'popIntoTemp: ', (remoteTemps value at: remoteTempIndex), ' inVector: ', remoteTemps key]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:41'!popIntoTemporaryVariable: offset	"Print the Remove Top Of Stack And Store Into Temporary Variable bytecode."	labelling		ifTrue:			[temps at: offset ifAbsentPut: ['t', temps size printString]]		ifFalse:			[self print: 'popIntoTemp: ' , (temps at: offset)]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:49'!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self print: (String streamContents:				[:s |				s nextPutAll: 'pushConstant: '.				obj isVariableBinding					ifTrue:						[obj key							ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]							ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]					ifFalse:						[obj isClosure							ifTrue: [s nextPutAll: obj sourceString]							ifFalse: [obj printOn: s]]]).	obj isCompiledMethod ifTrue:		[obj longPrintRelativeOn: stream indent: self indent + 2.		^self]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 23:32'!pushFullClosure: aCompiledBlock numCopied: numCopied		self print: 'pushFullClosure numCopied: ', numCopied printString,						' numArgs: ', aCompiledBlock numArgs printString.		(RelativeInstructionPrinter on: aCompiledBlock)		indent: self indent + 1;		printCode: false;		printInstructionsOn: stream! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:51'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	| remoteTemps |	labelling		ifTrue:			[remoteTemps := vectors at: tempVectorIndex ifAbsentPut: ['v', vectors size printString -> Dictionary new].			remoteTemps value at: remoteTempIndex ifAbsentPut: ['rt', remoteTemps value size printString]]		ifFalse:			[remoteTemps := vectors at: tempVectorIndex.			self print: 'pushTemp: ', (remoteTemps value at: remoteTempIndex), ' inVector: ', remoteTemps key]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:52'!pushTemporaryVariable: offset	"Print the Push Contents Of Temporary Variable Whose Index Is the argument, offset, On Top Of Stack bytecode."	labelling		ifTrue:			[temps at: offset ifAbsentPut: ['t', temps size printString]]		ifFalse:			[self print: 'pushTemp: ' , (temps at: offset)]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:53'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	| remoteTemps |	labelling		ifTrue:			[remoteTemps := vectors at: tempVectorIndex ifAbsentPut: ['v', vectors size printString -> Dictionary new].			remoteTemps value at: remoteTempIndex ifAbsentPut: ['rt', remoteTemps value size printString]]		ifFalse:			[remoteTemps := vectors at: tempVectorIndex.			self print: 'storeIntoTemp: ', (remoteTemps value at: remoteTempIndex), ' inVector: ', remoteTemps key]! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 16:53'!storeIntoTemporaryVariable: offset	"Print the Store Top Of Stack Into Temporary Variable Of Method bytecode."		labelling		ifTrue:			[temps at: offset ifAbsentPut: ['t', temps size printString]]		ifFalse:			[self print: 'storeIntoTemp: ' , (temps at: offset)]! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'fm 6/9/2023 23:40'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	labelling ifTrue:		[^self].		stream tab: self indent + (innerIndents at: oldPC) + 1.	self printCode ifTrue:		[stream nextPut: $<.		 oldPC to: scanner pc - 1 do: 			[:i | | code |			code := (method at: i) radix: 16.			stream				nextPut: (code size < 2 ifTrue: [$0] ifFalse: [code at: 1]);				nextPut: code last;				space].		 stream skip: -1; nextPut: $>; space].	stream nextPutAll: instruction.	stream cr.	(labels at: scanner pc + 1) ~~ false ifTrue:		[stream nextPutAll: (labels at: scanner pc + 1); nextPut: $:; cr].	oldPC := scanner pc! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'fm 6/9/2023 23:40'!printInstructionsOn: aStream	"Append to the stream, aStream, a description of each bytecode in the instruction stream."		| label initialPC |	labelling := true.	labels := Array new: method size + 1 withAll: false.	temps := Dictionary new.	vectors := Dictionary new.	super printInstructionsOn: (String new: 1024) writeStream.	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	initialPC := method initialPC.	(labels at: initialPC) ~~ false ifTrue:		[stream nextPutAll: (labels at: initialPC); nextPut: $:; cr].	super printInstructionsOn: aStream! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'fm 6/9/2023 16:47'!printInstructionsOn: aStream do: aBlock	"Append to the stream, aStream, a description of each bytecode in the instruction stream.	  Evaluate aBlock with the receiver, the scanner and the stream after each instruction."		| label |	labelling := true.	labels := Array new: method size withAll: false.	temps := Dictionary new.	vectors := Dictionary new.	super printInstructionsOn: (String new: 1024) writeStream do: [:ig :no :re|].	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	super printInstructionsOn: aStream do: aBlock! !!RelativeInstructionPrinter methodsFor: 'initialize-release' stamp: 'fm 2/22/2023 00:17'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	self print: 'closureNumCopied: ', numCopied printString			, ' numArgs: ', numArgs printString			, ' bytes: ', blockSize printString.	innerIndents		atAll: (scanner pc to: scanner pc + blockSize - 1)		put: (innerIndents at: scanner pc - 1) + 1! !!SHTextStyler methodsFor: 'styling' stamp: 'fm 10/28/2022 17:36'!styleInBackgroundProcess: aText	self terminateBackgroundStylingProcess.	stylingEnabled ifFalse: [ ^self ].		(backgroundProcess := [ | text |		view text string = aText string ifTrue: [			(self rangesIn: aText setWorkspace: true) ifNotNil: [:ranges |				text := aText copy.				self setAttributesIn: text fromRanges: ranges.				Project current addDeferredUIMessage: [					backgroundProcess notNil ifTrue: [						view stylerStyledInBackground: text ] ] ] ]	] newProcess)		priority: Processor userBackgroundPriority;		resume.! !!ScaledDecimal methodsFor: 'printing' stamp: 'eem 4/3/2017 15:29'!printAsLiteralOn: aStream	^self printOn: aStream! !!String methodsFor: 'printing' stamp: 'eem 4/3/2017 15:30'!printAsLiteralOn: aStream	"Print inside string quotes, doubling embedded quotes."	self storeOn: aStream! !!StringMorph methodsFor: 'accessing' stamp: 'fm 1/17/2023 18:41'!font: aFontOrNil 	"Set the font my text will use. The emphasis remains unchanged."	aFontOrNil ifNil: [^ self].	font := aFontOrNil emphasized: emphasis.		self fitContents.! !!SystemReporter methodsFor: 'updating' stamp: 'fm 1/28/2022 00:16'!updateReport	report := Text streamContents: [:stream | 						self categoryList do: [:each |					(categoriesSelected includes: each) ifTrue: [						self perform: ((categories at: each), ':') asSymbol with: stream.						stream cr]]].	self changed: #reportText! !!TempVariableNode methodsFor: 'initialize-release' stamp: 'fm 6/9/2023 22:42'!beVisibleTemp	scope := 0.	argType := nil! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'fm 10/2/2020 15:20'!definingScope: scopeBlock "<BlockNode>"	definingScope ifNotNil:		[definingScope ~~ scopeBlock ifTrue: [self error: 'temp has more than one defining scope.  This is probably a parser error']].	definingScope := scopeBlock! !!TestCase methodsFor: 'running' stamp: 'fm 4/23/2023 13:42'!debug	self resources do:		[:res | res isAvailable ifFalse: [ ^ res signalInitializationError ] ].	[[ self setUp.	   self performTest 	]		ensure: [ self tearDown ]	] 		ensure: [ self resources do: [:each | each reset ] ] ! !!TestCase methodsFor: 'extensions' stamp: 'fm 6/4/2021 14:04'!should: aBlock notTakeMoreThan: aDuration    "Evaluate aBlock in a forked process and if it takes more than anInteger milliseconds    to run we terminate the process and report a test failure.  It'' important to    use the active process for the test failure so that the failure reporting works correctly    in the context of the exception handlers."    | evaluated evaluationProcess result delay testProcess |    evaluated := false.    delay := Delay forDuration: aDuration.    testProcess := Processor activeProcess.    "Create a new process to evaluate aBlock"    evaluationProcess := [        result := aBlock value.        evaluated := true.        delay unschedule;            signalWaitingProcess. ] forkNamed: 'Process to evaluate should: notTakeMoreThanMilliseconds:'.    "Wait the milliseconds they asked me to"    delay wait.    "After this point either aBlock was evaluated or not..."    evaluated ifFalse: [        evaluationProcess terminate.        self assert: false description: ('Block evaluation took more than the expected <1p>' expandMacrosWith: aDuration)].       ^result! !!DecompilerTests methodsFor: 'utilities' stamp: 'fm 7/3/2023 19:40'!checkDecompileMethod: cm	| originalMethod cls selector decompiledNode compiledDecompiledNode compiledDecompiledMethod decompiledString reparsedString recompiledMethod recompiledNode originalSource sourceUndeclared reparsedPreGenerationString reparsedNoPreenString compiledDecompiledNoTempsMethod compiledDecompiledNoTempsNode decompiledNoTempsNode decompiledNoTempsString matchedSource |	originalMethod := cm methodForDecompile. 	cls := originalMethod methodClass.	self assert: cls notNil		description: 'No baseline to compare against'		resumable: true.	selector := originalMethod selector.	self assert: selector notNil		description: 'No baseline to compare against'		resumable: true. 	originalSource := (originalMethod fileIndex > 0 and: [(SourceFiles at: originalMethod fileIndex) notNil]) ifTrue: [originalMethod getSourceFromFile].	sourceUndeclared := OrderedCollection new.	(originalSource notNil and:	[(recompiledNode := self parse: originalSource in: cls usingSameEncoderAs: originalMethod  										onSyntaxErrorDo: [:ex | ]										onNotificationDo: [:e |											(e class name beginsWith: 'Undeclared') ifTrue: [												sourceUndeclared add: originalMethod reference -> (e instVarAt: Notification instSize + 1)].											e resume]	) notNil and:	[recompiledNode nodesDo: [:n | n comment: nil].	reparsedPreGenerationString := recompiledNode fullPrintString.	recompiledMethod := recompiledNode generate.	recompiledMethod selector == selector and: [originalMethod sameWithoutTrailerAs: recompiledMethod]]]) ifTrue: ["the original source is good"		decompiledNode := (cls decompilerClass new withTempNames: recompiledNode schematicTempNamesString)								decompile: selector								in: cls								method: originalMethod.		decompiledString := decompiledNode fullPrintString.		recompiledNode nodesDo: [:n | n isBlockNode ifTrue: [[n statements first isAssignmentNode and: [n statements first value isKindOf: NewArrayNode]] whileTrue: [n statements: n statements allButFirst]]].		reparsedNoPreenString := recompiledNode fullPrintString.		reparsedString := recompiledNode preen fullPrintString.		matchedSource := false.		(reparsedPreGenerationString = decompiledString or: [(Scanner new scanTokens: reparsedPreGenerationString) = (Scanner new scanTokens: decompiledString)]) ifFalse: [			"we actually don't know yet if reparsedPreGenerationString is or isn't compilable, and there's no point in comparing with an uncompilable source"			(self parse: reparsedPreGenerationString in: cls usingSameEncoderAs: originalMethod								onSyntaxErrorDo: [:ex | ]								onNotificationDo: [:e | | assoc |									assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).									((e class name beginsWith: 'Undeclared') not or: [sourceUndeclared includes: assoc]) ifTrue: [e resume]								]				) ifNotNil: [:c | | rcm |					compiledDecompiledNode := self parse: decompiledString in: cls usingSameEncoderAs: originalMethod									onSyntaxErrorDo: [:ex | ]									onNotificationDo: [:e | | assoc |										assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).										((e class name beginsWith: 'Undeclared') not or: [sourceUndeclared includes: assoc]) ifTrue: [e resume]									].					compiledDecompiledNode notNil ifTrue: [						compiledDecompiledMethod := compiledDecompiledNode generate.						rcm := c generate.						"We have to check that decompilation essentially reconstitutes the original"						((rcm sameWithoutTrailerAs: compiledDecompiledMethod) or: 						[rcm abstractSymbolic = compiledDecompiledMethod abstractSymbolic])							ifTrue: [matchedSource := true]							ifFalse: [								"(StringHolder new textContents:									(TextDiffBuilder buildDisplayPatchFrom: decompiledString to: reparsedPreGenerationString))										openLabel: 'Decompilation Differences for ', cls name,'>>',selector"								"(StringHolder new textContents:									(TextDiffBuilder buildDisplayPatchFrom: rcm abstractSymbolic to: compiledDecompiledNoPreenMethod abstractSymbolic))										openLabel: 'Bytecode Differences for ', cls name,'>>',selector"							]				]			].		].		(matchedSource or: [reparsedPreGenerationString = reparsedNoPreenString or: 		[reparsedNoPreenString = decompiledString or: [(Scanner new scanTokens: reparsedNoPreenString) = (Scanner new scanTokens: decompiledString)]]]) ifFalse: [			"we actually don't know yet if reparsedNoPreenString is or isn't compilable, and there's no point in comparing with an uncompilable source"			(self parse: reparsedNoPreenString in: cls usingSameEncoderAs: originalMethod								onSyntaxErrorDo: [:ex | ]								onNotificationDo: [:e | | assoc |									assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).									((e class name beginsWith: 'Undeclared') not or: [sourceUndeclared includes: assoc]) ifTrue: [e resume]								]				) ifNotNil: [:c | | rcm |					compiledDecompiledNode isNil ifTrue: [						compiledDecompiledNode := self parse: decompiledString in: cls usingSameEncoderAs: originalMethod										onSyntaxErrorDo: [:ex | ]										onNotificationDo: [:e | | assoc |											assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).											((e class name beginsWith: 'Undeclared') not or: [sourceUndeclared includes: assoc]) ifTrue: [e resume]										].						compiledDecompiledNode notNil ifTrue: [							compiledDecompiledMethod := compiledDecompiledNode generate.							rcm := c generate.							"We have to check that decompilation essentially reconstitutes the original"							((rcm sameWithoutTrailerAs: compiledDecompiledMethod) or: 							[rcm abstractSymbolic = compiledDecompiledMethod abstractSymbolic])								ifTrue: [matchedSource := true]								ifFalse: [									"(StringHolder new textContents:										(TextDiffBuilder buildDisplayPatchFrom: decompiledString to: reparsedNoPreenString))											openLabel: 'Decompilation Differences for ', cls name,'>>',selector"									"(StringHolder new textContents:										(TextDiffBuilder buildDisplayPatchFrom: rcm abstractSymbolic to: compiledDecompiledMethod abstractSymbolic))											openLabel: 'Bytecode Differences for ', cls name,'>>',selector"								]					]				]			].		].		(matchedSource or: [reparsedPreGenerationString = reparsedString or: [reparsedNoPreenString = reparsedString or: 		[reparsedString = decompiledString or: [(Scanner new scanTokens: reparsedString) = (Scanner new scanTokens: decompiledString)]]]]) ifFalse: [			"we actually don't know yet if reparsedString is or isn't compilable, and there's no point in comparing with an uncompilable source"			(self parse: reparsedString in: cls usingSameEncoderAs: originalMethod							onSyntaxErrorDo: [:ex | ]							onNotificationDo: [:e | | assoc |								assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).								((e class name beginsWith: 'Undeclared') not or: [sourceUndeclared includes: assoc]) ifTrue: [e resume]							]			) ifNotNil: [:c | | rcm |				"No syntax error handling around the next compilation, any syntax errors here should bubble up; also signal as error any newly introduced undeclared"				compiledDecompiledNode := self parse: decompiledString in: cls usingSameEncoderAs: originalMethod												onSyntaxErrorDo: [:ex | TestResult exError signal: originalMethod reference , ' - ' , ex description , ex errorMessage]												onNotificationDo: [:e | | assoc |													(e class name beginsWith: 'Undeclared') ifTrue: [														assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).														(sourceUndeclared includes: assoc) ifFalse: [															TestResult exError signal: originalMethod reference , ' - ' , assoc value , ' is undeclared']].													e resume].				compiledDecompiledMethod := compiledDecompiledNode generate.				rcm := c generate.				"We have to check that decompilation essentially reconstitutes the original, but this time raise an assert failure if not"				self					assert: ((rcm sameWithoutTrailerAs: compiledDecompiledMethod) or: 							[rcm abstractSymbolic = compiledDecompiledMethod abstractSymbolic])					description: cls name asString , ' ' , selector asString					resumable: true.				"(StringHolder new textContents:					(TextDiffBuilder buildDisplayPatchFrom: decompiledString to: reparsedString))						openLabel: 'Decompilation Differences for ', cls name,'>>',selector"				"(StringHolder new textContents:					(TextDiffBuilder buildDisplayPatchFrom: rcm abstractSymbolic to: compiledDecompiledMethod abstractSymbolic))						openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		]]	].	"We also want to check decompiling without temps"	decompiledNoTempsNode := cls decompilerClass new										decompile: selector										in: cls										method: originalMethod.	decompiledNoTempsString := decompiledNoTempsNode fullPrintString.	"No syntax error handling around the next compilation, any syntax errors here should bubble up; also signal as error any newly introduced undeclared"	compiledDecompiledNoTempsNode := self parse: decompiledNoTempsString in: cls usingSameEncoderAs: originalMethod										onSyntaxErrorDo: [:ex | TestResult exError signal: originalMethod reference , ' - ' , ex description , ex errorMessage]										onNotificationDo: [:e | | assoc |											(e class name beginsWith: 'Undeclared') ifTrue: [												assoc := originalMethod reference -> (e instVarAt: Notification instSize + 1).												(sourceUndeclared includes: assoc) ifFalse: [													TestResult exError signal: originalMethod reference , ' - ' , assoc value , ' is undeclared']].											e resume].	compiledDecompiledNoTempsMethod := compiledDecompiledNoTempsNode generate.	"We have to check that decompilation essentially reconstitutes the original"	self assert: ((originalMethod sameWithoutTrailerAs: compiledDecompiledNoTempsMethod) or: 				[originalMethod abstractSymbolic = compiledDecompiledNoTempsMethod abstractSymbolic])		description: cls name asString, ' ', selector asString		resumable: true.	"(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: originalMethod abstractSymbolic to: compiledDecompiledNoTempsMethod abstractSymbolic))			openLabel: 'Bytecode Differences for ', cls name,'>>',selector" ! !!DecompilerTests methodsFor: 'utilities' stamp: 'fm 5/6/2023 19:54'!decompileClassesSelect: aBlock	CurrentReadOnlySourceFiles cacheDuring: [ | failure error |		failure := error := false.		(self classNames select: aBlock) do:			[:cn | | cls |			cls := Smalltalk globals at: cn.			cls selectorsAndMethodsDo:				[:selector :meth |				[[self checkDecompileMethod: meth] 					on: TestResult failure					do: [:signal | 						failure := (BreakPoint signal: signal printString) isNil.						Transcript cr; show: signal printString]]							on: TestResult exError							do: [:signal |								error := (BreakPoint signal: signal printString) isNil.								Transcript cr; show: signal printString]]].			error ifTrue: [TestResult exError signal].			failure ifTrue: [TestResult failure signal].	]! !!DecompilerTests methodsFor: 'utilities' stamp: 'fm 6/18/2023 16:51'!parse: source in: cls usingSameEncoderAs: compiledMethod onSyntaxErrorDo: errorBlock onNotificationDo: notificationBlock	^[[[cls newParser			encoderClass: compiledMethod encoderClass;			parse: source class: cls] 				on: SyntaxErrorNotification 				do: errorBlock]					on: OutOfScopeNotification					do: [:ex | ex resume: true]] 						on: Notification 						do: notificationBlock! !!TestRunner methodsFor: 'actions' stamp: 'fm 1/22/2023 13:33'!debugSuite: aTestSuite		(aTestSuite tests allSatisfy: [:a | errorList includes: a]) ifTrue: [		self basicRunSuite: aTestSuite do: [ :each | 			[each debug]				on: BreakPoint				do: [:signal | 					((signal messageText beginsWith: TestResult failure name) or:					[signal messageText beginsWith: TestResult resumableFailure name]) ifFalse: [						self halt: signal messageText					].					signal resume: true ] ].	] ifFalse: [		self basicRunSuite: aTestSuite do: [ :each | 			[each debug]				on: BreakPoint				do: [:signal | 					self halt: signal messageText.					signal resume: true ] ].	]! !!UndefinedObject methodsFor: 'printing' stamp: 'eem 4/3/2017 15:32'!printAsLiteralOn: aStream	^self printOn: aStream! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'fm 3/6/2023 23:43'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aMessageNode receiverInEvaluationOrder notNil ifTrue: "receiver is nil for cascades and transformed to:do: loops"								[aBlock value: aMessageNode receiver].							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!WorldState methodsFor: 'stepping' stamp: 'fm 7/29/2022 19:16'!runLocalStepMethodsIn: aWorld 	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now morphToStep stepTime |	now := Time millisecondClockValue.		aWorld becomeActiveDuring: [ 		self triggerAlarmsBefore: now.				stepList ifEmpty: [^ self].				(now < lastStepTime or: [now - lastStepTime > 5000]) ifTrue: [			self adjustWakeupTimes: now].	"clock slipped"				[stepList notEmpty and: [stepList first scheduledTime < now]] whileTrue: [			lastStepMessage := stepList removeFirst.			lastStepMessage ifNotNil: [				morphToStep := lastStepMessage receiver.				(morphToStep shouldGetStepsFrom: aWorld) ifTrue: [					lastStepMessage ifNotNil: [						lastStepMessage value: now.						lastStepMessage ifNotNil: [							stepTime := lastStepMessage stepTime ifNil: [morphToStep stepTime].							lastStepMessage ifNotNil: [								lastStepMessage scheduledTime: now + (stepTime max: 1).								lastStepMessage ifNotNil: [									stepList add: lastStepMessage]]]]]].			lastStepMessage := nil].				lastStepTime := now].! !InstructionPrinter subclass: #RelativeInstructionPrinter	instanceVariableNames: 'printCode labels labelling temps vectors'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!