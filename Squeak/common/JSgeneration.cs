'From Squeak4.5 of 10 April 2015 [latest update: #13712] on 3 July 2023 at 6:19:16 pm'!"Change Set:		JSgenerationDate:			23 June 2022Author:			Florin Mateoc<Create empty definitions for potentially missing classes>"(Smalltalk classNamed: #CompiledCode) isNil ifTrue: [	ByteArray variableByteSubclass: #CompiledCode		instanceVariableNames: ''		classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'		poolDictionaries: ''		category: 'Kernel-Methods'.	CompiledCode variableByteSubclass: #CompiledBlock		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Methods'.	BlockClosure variableSubclass: #FullBlockClosure		instanceVariableNames: 'receiver'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Methods'.	FloatArray variableWordSubclass: #Float32Array		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Collections-Arrayed'.	FloatArray variableWordSubclass: #Float64Array		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Collections-Arrayed'.	].(Smalltalk classNamed: #TestEmptyClass) ifNotNil: [:t |	Class subclasses size = 1 ifTrue: [		Class addSubclass: t class		]	]!Object subclass: #JavaScriptTranspiler	instanceVariableNames: 'jsBootstrapClasses primitiveJSmappings jsEnvironmentPrefix mirrorHandler generationPath valueTypes inlineablePrimitiveBodies behaviorsDict'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!JavaScriptTranspiler class	instanceVariableNames: 'singleton'!ParseNodeVisitor subclass: #ParseNodeWithParentsEnumerator	instanceVariableNames: 'theBlock theSelectBlock parents'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!SourceFileArray subclass: #MemorySourceFileArray	instanceVariableNames: 'files'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-System'!!MemorySourceFileArray commentStamp: 'fm 2/4/2022 14:21' prior: 0!This is a variation on StandardSourceFileArray that provides a memory-based (string instead of file) changes stream!!Object methodsFor: 'testing' stamp: 'fm 10/1/2020 10:18'!JSshouldBePrintedAsLiteral	^self isLiteral! !!Object methodsFor: 'testing' stamp: 'fm 10/1/2020 10:17'!JSshouldBePrintedAsLiteralVisiting: aSet	^self isLiteral! !!Object methodsFor: 'testing' stamp: 'eem 3/23/2017 09:44'!isCompiledCode	^false! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 19:35'!JSdoStoreOn: aStream visiting: aDict indent: level	| size count |	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	self class isPointers ifTrue: [		size := 0.		self class isVariable ifTrue: [			size := self basicSize.			aStream nextPutAll: ', "@size": ';				nextPutAll: size printString.			].		1 to: self class instSize + size do: [:i | 			(self instVarAt: i) ifNotNil: [:var |				aStream nextPutAll: ', ';					nextPutAll: (i - 1) printString;					nextPutAll: ': '.				(var class inheritsFrom: Object) ifTrue: [					var JSstoreOn: aStream visiting: aDict indent: level				] ifFalse: [					JavaScriptTranspiler instance objJSstore: var on: aStream visiting: aDict indent: level				].				].			].	] ifFalse: [		count := 0.		1 to: (size := self basicSize) do: [:i |			(self basicAt: i) = 0 ifFalse: [				count := count + 1				].			].		count * 2 < size ifTrue: [			aStream nextPutAll: ', "@size": ';				nextPutAll: size printString.			count = 0 ifFalse: [				1 to: size do: [:i | | var |					(var := self basicAt: i) = 0 ifFalse: [						aStream nextPutAll: ', ';							nextPutAll: (i - 1) printString;							nextPutAll: ': '.						var JSstoreOn: aStream						].					].				].		] ifFalse: [			aStream nextPutAll: ', "@';				nextPutAll: self class JSstorageType;				nextPutAll: '": '.			self class jsEncapsulateArgs: ((1 to: size) collect: [:i | self basicAt: i]) 						on: aStream						argsBlock: [:arg | arg JSstoreOn: aStream].		].	]! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 8/27/2020 00:44'!JSprimitiveOn: aStream 	aStream nextPut: $(.	self JSstoreOn:  aStream.	aStream nextPutAll: ').valueOf()'! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 01:03'!JSprintOn: aStream	"Assumes non-recursive structures"	self class JSinstantiationOn: aStream 		withArgs: ((1 to: self class instSize + self basicSize) collect: [:i | self instVarAt: i]) 		argsBlock: [:arg | 			((arg class inheritsFrom: Object) and: [arg JSshouldBePrintedAsLiteral]) ifTrue: [				arg JSstoreOn: aStream			] ifFalse: [				(arg class inheritsFrom: Object) ifTrue: [					arg JSprintOn: aStream				] ifFalse: [					JavaScriptTranspiler instance objJSprint: arg on: aStream				].			]		].! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 23:51'!JSprintOn: aStream indent: level	"Assumes non-recursive structures"	self class JSinstantiationOn: aStream 		withArgs: ((1 to: self class instSize + self basicSize) collect: [:i | self instVarAt: i]) 		argsBlock: [:arg | 			aStream cr; space: level.			((arg class inheritsFrom: Object) and: [arg JSshouldBePrintedAsLiteral]) ifTrue: [				arg JSstoreOn: aStream			] ifFalse: [				(arg class inheritsFrom: Object) ifTrue: [					arg JSprintOn: aStream indent: level + 1				] ifFalse: [					JavaScriptTranspiler instance objJSprint: arg on: aStream indent: level + 1				].			]		].! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 19:44'!JSstoreOn: aStream	aStream nextPutAll: '(function () {this.readFrom('.	self JSstoreOn: aStream visiting: (IdentityDictionary new: 8 * self basicSize) indent: 0.	aStream nextPutAll: ')}).apply(';			nextPutAll: JavaScriptTranspiler instance defaultJsEnvironment;			nextPut: $)! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 00:39'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreWithIdOn: aStream visiting: aDict indent: level! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 1/3/2021 12:45'!JSstoreWithIdOn: aStream visiting: aDict indent: level	| id |	id := aDict at: self ifAbsent: [].	id isNil ifTrue: [		id := aDict at: self put: aDict size + 1.				aStream cr; space: level + 1;			nextPutAll: '{"@id": ';			nextPutAll: id printString.		id + 1 // 3000 ~= (id // 3000) ifTrue: [			aStream flush].		self JSdoStoreOn: aStream visiting: aDict indent: level + 1.		(aDict size > id and: [aStream peekLast ~~ Character space]) ifTrue: [			aStream cr; space: level + 1].		aStream nextPut: $}.		aDict size > id ifTrue: [			aStream cr; space: level].	] ifFalse: [		aStream nextPutAll: '{"@ref": ';			nextPutAll: id printString;			nextPut: $}.	].! !!Object methodsFor: 'JavaScript generation' stamp: 'fm 6/4/2021 14:57'!checkFor53Changes: description! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 11/23/2022 23:56'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	(self class == Association and: [(#(NewSymbols SymbolTable) includes: key) and: [value class == WeakSet]]) ifTrue: [		aStream nextPutAll: ', 0: '.		key JSstoreOn: aStream visiting: aDict indent: level.		aStream nextPutAll: ', 1: nil'.		^self	].	1 to: self class instSize do: [:i | 		(self instVarAt: i) ifNotNil: [:var |			aStream nextPutAll: ', ';				nextPutAll: (i - 1) printString;				nextPutAll: ': '.			(var class inheritsFrom: Object) ifTrue: [				var JSstoreOn: aStream visiting: aDict indent: level			] ifFalse: [				JavaScriptTranspiler instance objJSstore: var on: aStream visiting: aDict indent: level			].		].	].! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:53'!JSprintOn: aStream	(key isSymbol and: [(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream].! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:53'!JSprintOn: aStream indent: level	(key isSymbol and: [(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream indent: level].! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 11/19/2021 23:09'!JSprintValueOn: aStream	"This is only for global bindings"	(key isSymbol and: [(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: key; nextPutAll: '[1]'	] ifFalse: [		self halt.	].! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:53'!JSstoreOn: aStream	(key isSymbol and: [(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSstoreOn: aStream].! !!Association methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:53'!JSstoreOn: aStream visiting: aDict indent: level	(key isSymbol and: [(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		self JSstoreWithIdOn: aStream visiting: aDict indent: level].! !!Behavior methodsFor: 'accessing' stamp: 'fm 5/14/2022 14:19'!traits	^#()! !!Behavior methodsFor: 'testing' stamp: 'fm 10/27/2020 21:05'!isImmediateClass	"Answer whether the receiver has immediate instances.  Immediate instances	 store their value in their object pointer, not in an object body.  Hence immediates	 take no space and are immutable.  The immediates are distinguished by tag bits	 in the pointer. They include SmallIntegers and Characters.  Hence in the 32-bit	 system SmallIntegers are 31-bit signed integers and Characters are 30-bit	 unsigned character codes."	^self instSpec = 7! !!Behavior methodsFor: 'testing' stamp: 'fm 8/23/2022 20:05'!isLongs	^self instSpec = 9! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 1/12/2018 15:23'!homeMethod	^outerContext method! !!BlockClosure methodsFor: 'testing' stamp: 'eem 12/15/2017 12:52'!isFullBlock	^false! !!BlockClosure methodsFor: 'scanning' stamp: 'fm 1/17/2023 17:54'!pcAfterBlockPush	"Answer the pc for the bytecode after pushing the receiver."	| method encoderClass end byte pc extA byte2 |	self class == BlockClosure ifTrue: [		^self startpc].		"Following is the implementation for FullBlockClosure.	It is put here instead of overriden in FullBlockClosure to allow it to be part of a changset loadable in an image without FullBlockClosure"		method := self startpcOrMethod outerCode.	pc := method initialPC.	end := method endPC.	encoderClass := method encoderClass.	[pc <= end] whileTrue: 		[extA := 0.		[byte := method at: pc.		 pc := pc + 1.		 byte >= 224 and: [byte <= 225]] whileTrue:			[| extByte |			 extByte := method at: pc.			 pc := pc + 1.			 byte = 224				ifTrue:					[extA := extByte]].		 byte = 249 ifTrue:			[byte2 := method at: pc.			(method literalAt: (extA bitShift: 8) + byte2 + 1) == self startpcOrMethod ifTrue: 				[^pc + 2]].		 pc := pc + (encoderClass bytecodeSize: byte) - 1].	^self halt! !!BlockClosure methodsFor: 'JavaScript generation' stamp: 'fm 3/14/2023 22:31'!JSstoreOn: aStream visiting: aDict indent: level	"| result | result := Dictionary new. Smalltalk garbageCollect. BlockClosure allInstances do: [:e | 		(((1 to: e numCopiedValues) collect: [:i | e copiedValueAt: i]) allSatisfy: [:c | c isLiteral]) ifTrue: [			(result at: #done ifAbsentPut: [IdentityDictionary new]) at: e put: (String streamContents: [:s | e JSstoreOn: s visiting: (IdentityDictionary new: 8 * e basicSize) indent: 0])		] ifFalse: [			(result at: #problematicStandalone ifAbsentPut: [IdentitySet new]) add: e]]. result"	| foundIt numCopiedValues prepared propsDict remotes currentJsEnvironmentPrefix instvarRef methodNode fullBlocks	  noBlockParents selfPC compiledMethod normalizedCompiledMethod | 		numCopiedValues := self numCopiedValues.	fullBlocks := self method encoderClass supportsFullBlocks.	compiledMethod := fullBlocks ifTrue: [self homeMethod] ifFalse: [self method].	[methodNode := compiledMethod decompileWithTemps] on: Error do: [:e | methodNode := compiledMethod decompile].	noBlockParents := fullBlocks not or: [self startpcOrMethod outerCode isCompiledMethod].	selfPC := self pcAfterBlockPush.	methodNode accept: 		(ParseNodeWithParentsEnumerator 			ofBlock: [:n :parents | | blockNodeParents compiledBlockParent blockNodeParent |				(n isBlockNode and: 				[n numberOfArguments = numArgs and: 				[n pc value = selfPC]]) ifTrue: [					(noBlockParents or: [						blockNodeParents := parents select: [:e | e isBlockNode and: [e ~~ methodNode block and: [e optimized not]]].						compiledBlockParent := self startpcOrMethod outerCode.						[blockNodeParents notEmpty and: [compiledBlockParent isCompiledMethod not]] whileTrue: [							blockNodeParent := blockNodeParents removeLast.							blockNodeParent pc value = compiledBlockParent pcAfterBlockPush ifTrue: [								compiledBlockParent := compiledBlockParent outerCode.							]						].						blockNodeParents isEmpty and: [compiledBlockParent isCompiledMethod]					]) ifTrue: [						foundIt := n. 						n statements: (n statements copyWithFirst: (MessageNode new	"Insert a marker for easy identification"																		receiver: (BlockNode statements: #() returns: false)																		selector: #repeat																		arguments: #()																		precedence: 1																		from: nil))]]]			select: [:n :parents | foundIt isNil]).			foundIt := nil.	prepared := (Parser new encoderClass: self method encoderClass;														parse: methodNode fullPrintString														class: compiledMethod methodClass)										JSprepare: false.		prepared accept: 			(ParseNodeEnumerator 				ofBlock: [:n | | m r |					(n isBlockNode and: 					[(m := n firstRealStatement) isMessageNode and: 		"Look for our marker"					[m selector key == #repeat and: 					[(r := m receiver) isBlockNode and: 					[r statements size = 1 and: 					[r statements first isVariableNode and: 					[r statements first key = 'nil']]]]]]) ifTrue: [						foundIt := n.						n statements size = 1 ifTrue: [							n statements: r statements						] ifFalse: [							n statements: n statements allButFirst						]]]				select: [:n | foundIt isNil]).	(foundIt notNil and: [foundIt numberOfArguments = numArgs and: [foundIt optimized not and:	[normalizedCompiledMethod := prepared generate.	(foundIt computeCopiedValues: prepared) size = numCopiedValues]]]) ifTrue: [		prepared removeCascades; removeIfNil.		propsDict := prepared JSPropertiesFor: normalizedCompiledMethod.		propsDict at: #ThisBlock put: foundIt.		propsDict at: #ActualStream put: aStream.		propsDict at: #selfInsideBlock put: nil.		instvarRef := false.		self outerContext notNil ifTrue: [			foundIt accept: (ParseNodeEnumerator 				ofBlock: [:n |					n isVariableNode ifTrue: [						(n isKindOf: InstanceVariableNode) ifTrue: [							instvarRef := true						]					]				] select: [:n | instvarRef not]).		].		remotes := Dictionary new.		aStream nextPutAll: '{"@clos": function setCopiedValues('.		1 to: numCopiedValues do: [:i | | e |			e := foundIt copiedValues at: i.			e isIndirectTempVector ifTrue: [				remotes at: i put: e remoteTemps size.				e remoteTemps do: [:t |						aStream nextPut: $_; nextPutAll: t key]					separatedBy: [aStream nextPutAll: ', ']			] ifFalse: [				aStream nextPut: $_;					nextPutAll: e key.			].			aStream nextPutAll: ', '].		aStream nextPutAll: 'self, compiledMethod) {return '.		instvarRef ifTrue: [			propsDict at: #Instvars put: foundIt		].		currentJsEnvironmentPrefix := JavaScriptTranspiler instance jsEnvironmentPrefix.		[			JavaScriptTranspiler instance jsEnvironmentPrefix: JavaScriptTranspiler instance defaultJsEnvironment, '._'.			prepared printJSOn: (WriteStream on: (String new: 1000)) properties: propsDict.				] ensure: [			JavaScriptTranspiler instance jsEnvironmentPrefix: currentJsEnvironmentPrefix].		aStream nextPutAll: '}, "@args": ['.		1 to: numCopiedValues do: [:i | | c |			c := self copiedValueAt: i.			(remotes at: i ifAbsent: []) 				ifNil: [					c JSstoreOn: aStream visiting: aDict indent: level.				]				ifNotNil: [:size |					(c isArray and: [c size = size]) ifFalse: [self halt].					c do: [:e | e JSstoreOn: aStream visiting: aDict indent: level] 						separatedBy: [aStream nextPutAll: ', ']				].			aStream nextPutAll: ', '].		self receiver JSstoreOn: aStream visiting: aDict indent: level.		aStream nextPutAll: ', '.		normalizedCompiledMethod JSstoreOn: aStream visiting: aDict indent: level.		aStream nextPutAll: ']}'.	] ifFalse: [		aStream nextPutAll: 'nil']! !!BlockClosure methodsFor: 'JavaScript generation' stamp: 'fm 3/14/2023 22:30'!testJSstoreOn	"Smalltalk garbageCollect. BlockClosure allInstances do: [:e | e testJSstoreOn]"	"Smalltalk garbageCollect. FullBlockClosure allInstances do: [:e | e testJSstoreOn]"	| foundIt numCopiedValues prepared propsDict methodNode fullBlocks	  noBlockParents selfPC compiledMethod normalizedCompiledMethod | 		numCopiedValues := self numCopiedValues.	fullBlocks := self method encoderClass supportsFullBlocks.	compiledMethod := fullBlocks ifTrue: [self homeMethod] ifFalse: [self method].	[methodNode := compiledMethod decompileWithTemps] on: Error do: [:e | methodNode := compiledMethod decompile].	noBlockParents := fullBlocks not or: [self startpcOrMethod outerCode isCompiledMethod].	selfPC := self pcAfterBlockPush.	methodNode accept: 		(ParseNodeWithParentsEnumerator 			ofBlock: [:n :parents | | blockNodeParents compiledBlockParent blockNodeParent |				(n isBlockNode and: 				[n numberOfArguments = numArgs and: 				[n pc value = selfPC]]) ifTrue: [					(noBlockParents or: [						blockNodeParents := parents select: [:e | e isBlockNode and: [e ~~ methodNode block and: [e optimized not]]].						compiledBlockParent := self startpcOrMethod outerCode.						[blockNodeParents notEmpty and: [compiledBlockParent isCompiledMethod not]] whileTrue: [							blockNodeParent := blockNodeParents removeLast.							blockNodeParent pc value = compiledBlockParent pcAfterBlockPush ifTrue: [								compiledBlockParent := compiledBlockParent outerCode.							]						].						blockNodeParents isEmpty and: [compiledBlockParent isCompiledMethod]					]) ifTrue: [						foundIt := n. 						n statements: (n statements copyWithFirst: (MessageNode new	"Insert a marker for easy identification"																		receiver: (BlockNode statements: #() returns: false)																		selector: #repeat																		arguments: #()																		precedence: 1																		from: nil))]]]			select: [:n :parents | foundIt isNil]).			foundIt := nil.	prepared := (Parser new encoderClass: self method encoderClass;														parse: methodNode fullPrintString														class: compiledMethod methodClass)										JSprepare: false.		prepared accept: 			(ParseNodeEnumerator 				ofBlock: [:n | | m r |					(n isBlockNode and: 					[(m := n firstRealStatement) isMessageNode and: 		"Look for our marker"					[m selector key == #repeat and: 					[(r := m receiver) isBlockNode and: 					[r statements size = 1 and: 					[r statements first isVariableNode and: 					[r statements first key = 'nil']]]]]]) ifTrue: [						foundIt := n.						n statements size = 1 ifTrue: [							n statements: r statements						] ifFalse: [							n statements: n statements allButFirst						]]]				select: [:n | foundIt isNil]).	(foundIt notNil and: [foundIt numberOfArguments = numArgs and: [foundIt optimized not and:	[normalizedCompiledMethod := prepared generate.	(foundIt computeCopiedValues: prepared) size = numCopiedValues]]]) ifTrue: [		prepared removeCascades; removeIfNil.		propsDict := prepared JSPropertiesFor: normalizedCompiledMethod	] ifFalse: [		self halt]! !!Boolean methodsFor: 'controlling' stamp: 'fm 10/25/2014 21:48'!questionMark: trueAlternative colon: falseAlternative	self subclassResponsibility! !!Boolean methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:28'!JSprimitiveOn: aStream 	self JSstoreOn:  aStream.! !!Boolean methodsFor: 'JavaScript generation' stamp: 'fm 7/21/2020 16:21'!JSstoreOn: aStream 	"Refer to the comment in Object|storeOn:."	self printOn: aStream! !!Boolean methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 14:44'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreOn: aStream! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:28'!JSprimitiveOn: aStream	self JSstoreOn:  aStream.! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 1/1/2021 15:06'!JSprintOn: aStream	"(Compiler new parse: (Character >> #JSprintOn:) getSource in: Character notifying: nil) preen generate"	 | val |	self JSshouldBePrintedAsLiteral ifTrue: [		(self = $' or: [self = $\ or: [self = $" or: [self = $` or: [self = $$]]]]) ifTrue: [aStream nextPut: $\].		aStream nextPut: self	] ifFalse: [		val := self asInteger.		val caseOf: {			[8] -> [aStream nextPutAll: '\b'].			[9] -> [aStream nextPutAll: '\t'].			[10] -> [aStream nextPutAll: '\n'].			[11] -> [aStream nextPutAll: '\v'].			[12] -> [aStream nextPutAll: '\f'].			[13] -> [aStream nextPutAll: '\r'].		} otherwise: [			val < 256 ifTrue: [				aStream nextPutAll: '\x'.				val printOn: aStream base: 16 length: 2 padded: true.			] ifFalse: [				aStream nextPutAll: '\u'.				val < 65536 ifTrue: [					val printOn: aStream base: 16 length: 4 padded: true.				] ifFalse: [					aStream nextPut: ${.					self asUnicode printOn: aStream base: 16.					aStream nextPut: $}.				]			].		]	].! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 7/16/2022 17:12'!JSshouldBePrintedAsLiteral	| val |		^((val := self asInteger) between: 32 and: 255) and: [val ~= 127]! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 10:17'!JSshouldBePrintedAsLiteralVisiting: aSet	^self JSshouldBePrintedAsLiteral! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 7/16/2022 17:29'!JSstoreOn: aStream	self asInteger <= 16r3FFFFF ifTrue: [		aStream nextPut: $`.		self JSprintOn: aStream.		aStream nextPut: $`	] ifFalse: [		aStream nextPutAll: self class JSname;			nextPutAll: '.from(';			nextPutAll: self asInteger printString;			nextPut: $)	]! !!Character methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 14:44'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreOn: aStream! !!ClassBinding methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 22:55'!JSprintOn: aStream	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream].! !!ClassBinding methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 22:55'!JSprintOn: aStream indent: level	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream indent: level].! !!ClassBinding methodsFor: 'JavaScript generation' stamp: 'fm 11/19/2021 23:09'!JSprintValueOn: aStream	aStream nextPutAll: key! !!ClassBinding methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 22:55'!JSstoreOn: aStream	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSstoreOn: aStream].! !!ClassBinding methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 22:56'!JSstoreOn: aStream visiting: aDict indent: level	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		self JSstoreWithIdOn: aStream visiting: aDict indent: level].! !!ClassDescription methodsFor: 'compiling' stamp: 'ul 5/31/2018 20:09'!compileSilently: code 	"Compile the code, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ self compileSilently: code classified: ClassOrganizer default.! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 5/28/2022 15:06'!>>| selector	"returns JavaScript source for image-side Smalltalk methods"	"Character class >>| #allByteCharacters"	^(Compiler new		parse: (self sourceCodeAt: selector)		in: self		notifying: nil) 			asJavaScript value! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 11/23/2022 23:41'!JSdoStoreOn: aStream visiting: aDict indent: level	| translatedMethods |	aStream nextPutAll: ', "@name": ';		nextPutAll: self JSname.	(self isMeta ifTrue: [6] ifFalse: [8]) to: self class instSize do: [:i | 		(i ~= 11 or: [self isMeta]) ifTrue: [			(self instVarAt: i) ifNotNil: [:var |				aStream nextPutAll: ', ';					nextPutAll: (i - 1) printString;					nextPutAll: ': '.				(var class inheritsFrom: Object) ifTrue: [					var JSstoreOn: aStream visiting: aDict indent: level				] ifFalse: [					JavaScriptTranspiler instance objJSstore: var on: aStream visiting: aDict indent: level				].			].		].	].	self isMeta ifFalse: [		"hidden class pointer"		aDict at: self class ifAbsent: [			aStream nextPutAll: ', "@meta": '.			self class JSstoreWithIdOn: aStream visiting: aDict indent: level].	].	"Method literals are not installed yet for installed methods"	translatedMethods := JavaScriptTranspiler instance behaviorsDict at: self.	translatedMethods notEmpty ifTrue: [		aStream nextPutAll: ', "@lit": {'.		translatedMethods keysAndValuesDo: [:sel :assoc | | transformedCM |			transformedCM := assoc key.			aStream nextPutAll: sel JSmapping;				nextPutAll: ': [';				nextPutAll: transformedCM jsHeader printString.				1 to: transformedCM numLiterals do: [:i | 					aStream nextPutAll: ', '.					(transformedCM literalAt: i) JSstoreOn: aStream visiting: aDict indent: level				].			aStream nextPutAll: '], '		].		aStream nextPut: $}].! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 12:41'!JSprintOn: aStream	aStream nextPutAll: self JSname! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 12:40'!JSstoreOn: aStream	aStream nextPutAll: self JSname! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 8/12/2021 19:08'!printJSClassOrganizerOn: aStream	organization notNil ifTrue: [		aStream nextPutAll: self JSname;			nextPutAll: '.pointers[4] = '.		organization JSprintOn: aStream.		aStream nextPut: $;;			cr; cr	]! !!ClassDescription methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 15:23'!printJSMethodDictionary: sourcesDict on: aStream	| target index |	aStream nextPutAll: 'var storage = (';		nextPutAll: self JSname;		nextPutAll: '.pointers[1] = ';		nextPutAll: MethodDictionary JSname;		nextPutAll: '.primitive_71_impl(';		nextPutAll: (methodDict basicSize) printString;		nextPutAll: ')[1]).pointers;';		cr;		nextPutAll: 'storage[0] = ';		nextPutAll: sourcesDict size printString;		nextPut: $;;		cr;		nextPutAll: 'storage[1] = ';		nextPutAll: Array JSname;		nextPutAll: '.primitive_71_impl(';		nextPutAll: methodDict basicSize printString;		nextPutAll: ')[1];';		cr.	sourcesDict isEmpty ifTrue: [		^self].	aStream		nextPutAll: 'var methods = storage[1].pointers;';		cr; cr.	index := -1.	target := self JSprotoypeName, '.'.	sourcesDict keys asSortedCollection do: [:sel | | assoc |		assoc := sourcesDict at: sel.		index := index + 1.		aStream nextPutAll: 'storage[';			nextPutAll: (index + 2) printString;			nextPutAll: '] = '.		sel JSstoreOn: aStream.		aStream nextPut: $;;			cr;			nextPutAll: 'methods[';			nextPutAll: index printString;			nextPutAll: '] = ';			nextPutAll: target;			nextPutAll: sel JSmapping;			nextPutAll: '.compiledMethod = '.		assoc key JSstoreOn: aStream.		aStream nextPut: $;;			cr;			nextPutAll: 'methods[';			nextPutAll: index printString;			nextPutAll: '].func = ';			nextPutAll: target;			nextPutAll: sel JSmapping;			nextPut: $;;			cr; cr].	! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/12/2021 19:04'!JSinstantiationOn: strm withArgs: args argsBlock: argsBlock	strm nextPutAll: self JSname.	self JSstorageType isNil ifTrue: [		strm nextPutAll: '.primitive_70_impl()[1]'.	] ifFalse: [		strm nextPutAll: '.from('.		self jsEncapsulateArgs: args on: strm argsBlock: argsBlock.		strm nextPut: $).	]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 23:49'!JSname	^JavaScriptTranspiler instance jsEnvironmentPrefix, name! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 12/22/2021 19:27'!JSprotoypeName	^self JSname, '.prototype'! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/27/2020 22:48'!JSstorageType	^self isVariable 		ifTrue: [			self isPointers 				ifTrue: ['pointers'] 				ifFalse: [self isWords 							ifTrue: ['words'] 							ifFalse: [								self isBytes 									ifTrue: ['bytes'] 									ifFalse: [self isLongs 												ifTrue: ['longs'] 												ifFalse: ['shorts']]]]]		ifFalse: [			self instSize > 0 				ifTrue: ['pointers'] ]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2022 20:08'!JSstorageTypeConstructor	^self isVariable 		ifTrue: [			self isPointers 				ifTrue: ['Array'] 				ifFalse: [self isWords 							ifTrue: ['Uint32Array'] 							ifFalse: [								self isBytes 									ifTrue: ['Uint8Array'] 									ifFalse: [self isLongs 												ifTrue: ['BigUint64Array'] 												ifFalse: ['Uint16Array']]]]]		ifFalse: [			self instSize > 0 				ifTrue: ['Array'] ]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 3/25/2022 16:59'!JSsuperConstructor	^self class superclass JSname! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2022 20:07'!JStypeOfStorageType	"only typed arrays"	^(self isVariable and: [self isPointers not]) ifTrue: [		self isWords 			ifTrue: ['Uint32Array'] 			ifFalse: [				self isBytes 					ifTrue: ['Uint8Array'] 					ifFalse: [self isLongs 								ifTrue: ['BigUint64Array'] 								ifFalse: ['Uint16Array']]]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/27/2020 22:49'!JStypedStorageTypeLimit	"only typed arrays"	^(self isVariable and: [self isPointers not]) ifTrue: [		self isWords 			ifTrue: ['4294967296'] 			ifFalse: [				self isBytes 					ifTrue: ['256'] 					ifFalse: [self isLongs 								ifTrue: ['18446744073709551616n'] 								ifFalse: ['65536']]]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/16/2020 21:58'!hasJsCachedStorage	^false! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 4/4/2021 23:43'!isBootstrapClass	^JavaScriptTranspiler instance jsBootstrapClasses includes: self! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 3/30/2022 23:44'!isCompiledMethodClass	^false! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 10:01'!isTransitioningFromNilStorageType	^self JSstorageType notNil and: [superclass isNil or: [superclass JSstorageType isNil]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 7/8/2021 21:06'!isTransitioningToInstvars	^self instSize > 0 and: [superclass isNil or: [superclass instSize = 0]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 2/11/2021 22:33'!isTransitioningToVariable	^self isVariable and: [superclass isNil or: [superclass isVariable not]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 2/11/2021 22:40'!isTransitioningToWeak	^self isWeak and: [superclass isNil or: [superclass isWeak not]]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 1/10/2022 22:23'!iterable	^'this.', self JSstorageType! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/3/2020 22:34'!jsCachedStorageOn: aStream! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/18/2020 15:49'!jsEncapsulateArgs: args on: strm argsBlock: argsBlock	| typedArrayType |	typedArrayType := self JStypeOfStorageType.	typedArrayType 		ifNil: [			strm nextPut: $[]		ifNotNil: [			strm nextPutAll: typedArrayType; 				nextPutAll: '.from(['].	args do: argsBlock separatedBy: [strm nextPutAll: ', '].	strm nextPut: $].	typedArrayType 		ifNotNil: [			strm nextPut: $)].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 02:00'!jsStaticFromOn: aStream	"Generic implementation"	"String streamContents: [:s | WeakArray jsStaticFromOn: s]"	(self isTransitioningFromNilStorageType or: [self isTransitioningToWeak]) ifFalse: [		^self].	self == Behavior ifTrue: [		"behaviors are functions, they cannot be constructed from their instvars"		^self].	aStream nextPutAll: self class JSprotoypeName;		nextPutAll: '.from = function from(aJsArray) {';		crtab.	self isPointers ifTrue: [		aStream nextPutAll: 'if (!!Array.isArray(aJsArray)) return undefined;'	] ifFalse: [		aStream nextPutAll: 'if (aJsArray.constructor !!== ';			nextPutAll: self JStypeOfStorageType;			nextPutAll: ') return undefined;'	].	aStream crtab;		nextPutAll: 'let result = this.primitive_70_impl();';		crtab;		nextPutAll: 'if (result[0] !!== true) return undefined;';		crtab;		nextPutAll: 'const result1 = result[1];';		crtab.	self isPointers ifTrue: [		aStream 			nextPutAll: 'const instSize = result1.pointers.length, length = aJsArray.length;';			crtab;			nextPutAll: 'if (instSize > length)';			crtab: 2;			nextPutAll: 'Object.assign(result1.pointers, aJsArray);';			crtab;			nextPutAll: 'else {';			crtab: 2].	aStream 		nextPutAll: 'result1.';		nextPutAll: self JSstorageType;		nextPutAll: ' = aJsArray;'.	self isWeak ifTrue: [		aStream crtab: 2;			nextPutAll: 'for(let i=instSize; i<length; i++) {const e = aJsArray[i]; if (e !!== nil) aJsArray[i] = new WeakRef(Object(e))}'	].	self isPointers ifTrue: [		aStream crtab: 2;			nextPutAll: 'Object.seal(aJsArray)}'].	aStream crtab;		nextPutAll: 'return result1;';		cr;		nextPutAll: '}';		cr! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/3/2020 21:23'!jsStaticHelpersOn: aStream! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 6/26/2023 22:24'!jsStorageTypeOn: aStream	self isTransitioningFromNilStorageType ifFalse: [		^self].	self primitiveJSmapping notNil ifTrue: [		^self].		self isBytes ifTrue: [		aStream nextPutAll: 'wordsOrBytes() {return this.uint32Array || (this.uint32Array = new Uint32Array(this.bytes.buffer, 0, this.bytes.length >>> 2))},';			cr.	] ifFalse: [		self JSstorageType = 'words' ifTrue: [			aStream nextPutAll: 'wordsOrBytes() {return this.words},';			crtab;			nextPutAll: 'wordsAsUint8Array() {return this.uint8Array || (this.uint8Array = new Uint8Array(this.words.buffer))},';			crtab;			nextPutAll: 'wordsAsUint16Array() {return this.uint16Array || (this.uint16Array = new Uint16Array(this.words.buffer))},';			crtab;			nextPutAll: 'wordsAsInt16Array() {return this.int16Array || (this.int16Array = new Int16Array(this.words.buffer))},';			crtab;			nextPutAll: 'wordsAsInt32Array() {return this.int32Array || (this.int32Array = new Int32Array(this.words.buffer))},';			crtab;			nextPutAll: 'wordsAsFloat32Array() {return this.float32Array || (this.float32Array = new Float32Array(this.words.buffer))},';			crtab;			nextPutAll: 'wordsAsFloat64Array() {return this.float64Array || (this.float64Array = new Float64Array(this.words.buffer))},';			cr.		] ifFalse: [			self JSstorageType = 'longs' ifTrue: [				aStream nextPutAll: 'longsAsUint8Array() {return this.uint8Array || (this.uint8Array = new Uint8Array(this.longs.buffer))},';				crtab;				nextPutAll: 'longsAsUint16Array() {return this.uint16Array || (this.uint16Array = new Uint16Array(this.longs.buffer))},';				crtab;				nextPutAll: 'longsAsInt16Array() {return this.int16Array || (this.int16Array = new Int16Array(this.longs.buffer))},';				crtab;				nextPutAll: 'longsAsInt32Array() {return this.int32Array || (this.int32Array = new Int32Array(this.longs.buffer))},';				crtab;				nextPutAll: 'longsAsFloat32Array() {return this.float32Array || (this.float32Array = new Float32Array(this.longs.buffer))},';				crtab;				nextPutAll: 'longsAsFloat64Array() {return this.float64Array || (this.float64Array = new Float64Array(this.longs.buffer))},';				cr.			]		]	]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/17/2020 12:06'!primitiveJSmapping	^(JavaScriptTranspiler instance primitiveJSmappings detect: [:m | m first includes: name] ifNone: []) ifNotNil: [:m | m last]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/6/2021 01:25'!printJSClassBindingOn: aStream	aStream nextPutAll: self JSname;		nextPutAll: '[2] = SmalltalkGlobals._ClassBinding.from([SmalltalkGlobals._ByteSymbol.from(`';		nextPutAll: name;		nextPutAll: '`), '; 		nextPutAll: self JSname;		nextPutAll: ']);'; 		cr; cr! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/2/2022 23:27'!printJSConstructorOn: aStream	self JSstorageType notNil ifTrue: [		aStream nextPutAll: '('.		self isVariable ifTrue: [			aStream nextPutAll: 'indexableSize = 0'].		aStream nextPutAll: ') {';			crtab.		self isPointers ifTrue: [			aStream nextPutAll: 'this.pointers = ';				nextPutAll: (self instSize = 0 ifTrue: ['indexableSize ? '] ifFalse: ['']);				nextPutAll: 'Object.seal(new Array(';				nextPutAll: (self instSize > 0 ifTrue: [self instSize printString] ifFalse: ['']);				nextPutAll: (self isVariable ifTrue: [self instSize > 0 ifTrue: [' + indexableSize'] ifFalse: ['indexableSize']] ifFalse: ['']);				nextPutAll: ').fill(nil))';				nextPutAll: (self instSize = 0 ifTrue: [' : Array.Empty;'] ifFalse: [';']).		] ifFalse: [			aStream nextPutAll: 'this.';				nextPutAll: self JSstorageType;				nextPutAll: ' =  indexableSize ? Object.seal(new ';				nextPutAll: self JStypeOfStorageType;				nextPutAll: '(indexableSize)) : ';				nextPutAll: self JStypeOfStorageType;				nextPutAll: '.Empty;'.			self hasJsCachedStorage ifTrue: [				aStream crtab;					nextPutAll: self initializeJsCachedStorageMessage].		].		aStream cr;			nextPut: $};			cr	] ifFalse: [		aStream nextPutAll: '() {}';			cr	]! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 10/6/2020 21:44'!printJSDefinitionOnlyOn: aStream	self printJSDefinitionWithMethods: nil on: aStream! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 2/3/2022 22:36'!printJSDefinitionWithMethods: sourcesDict on: aStream	aStream nextPutAll: self JSname;		nextPutAll: ' = function _';		nextPutAll: name.	self printJSConstructorOn: aStream.	self printJSStaticInitializerOn: aStream.	self printJSSupportMethodsOn: aStream.	self hasComment ifTrue: [		aStream nextPutAll: 'SmalltalkGlobals.classComments.set(';			nextPutAll: self JSname;			nextPutAll: ', '.		self comment asString JSprimitiveOn: aStream.		aStream nextPutAll: ');';			cr; cr	].	sourcesDict isNil ifTrue: [		^self].	sourcesDict isEmpty ifFalse: [		aStream nextPutAll: 'Object.assign(';			nextPutAll: self JSname;			nextPutAll: '.prototype, {'.		sourcesDict keys asSortedCollection do: [:sel | | assoc |			assoc := sourcesDict at: sel.			aStream cr; cr; nextPutAll: assoc value;				nextPut: $,			].		aStream nextPutAll: '})';			cr; cr.	].	self printJSClassBindingOn: aStream.	self printJSMethodDictionary: sourcesDict on: aStream.	self printJSClassOrganizerOn: aStream.! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 22:51'!printJSPrimitive105On: aStream	| storageType arg3storage |	(self isVariable not and: [superclass isNil]) ifTrue: [		aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {return [false]},';			crtab.		^self		].	(self instSize = 0 and: [self isTransitioningToVariable or: [self isTransitioningToWeak]]) ifTrue: [		(self inheritsFrom: Symbol) ifTrue: [			aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {return [false]},';				crtab.			^self		].		storageType := self JSstorageType.		arg3storage := 'arg3', storageType.		aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {';			crtab: 2;			nextPutAll: 'const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), arg4Val = arg4.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType;			nextPutAll: ', arg3proto = arg3._class().prototype, ';			nextPutAll: arg3storage;			nextPutAll: ' = arg3.';			nextPutAll: storageType;			nextPutAll: ';';			crtab: 2;			nextPutAll: 'if (arg1Val > 0 && arg2Val >= arg1Val && arg4Val > 0 && (arg1Val | 0) === arg1Val && (arg2Val | 0) === arg2Val && ';			nextPutAll: storageType;			nextPutAll: ' && arg2Val <= ';			nextPutAll: storageType;			nextPutAll: '.length && ';			crtab: 4;			nextPutAll: (self isPointers ifTrue: [' arg3proto.instSize === 0 && arg3proto.isVariable && '] ifFalse: ['']);			nextPutAll: (self isPointers ifTrue: [self isWeak ifTrue: ['arg3proto.isWeak && '] ifFalse: ['!!arg3proto.isWeak && ']] ifFalse: ['']);			nextPutAll: arg3storage;			nextPutAll: ' && (arg4Val | 0) === arg4Val && arg4Val + arg2Val - arg1Val <= ';			nextPutAll: arg3storage;			nextPutAll: '.length) {';			crtab: 3;			nextPutAll: 'const start = arg1Val - 1, replacementStart = arg4Val - 1; ';			crtab: 3;			nextPutAll: 'const replacement = ';			nextPutAll: arg3storage;			nextPutAll: '.slice(replacementStart, replacementStart + arg2Val - start); ';			crtab: 3.		self isPointers 			ifTrue: [				"fullS.splice(from - 1, to - from + 1, ...newS.slice(startingAt - 1, startingAt + to - from));"				aStream					nextPutAll: 'pointers.splice(start, arg2Val - start, ...replacement);']			ifFalse: [				"fullS.set(newS.slice(startingAt - 1, startingAt + to - from), from - 1);"				aStream					nextPutAll: storageType;					nextPutAll: '.set(replacement, start);';					nextPutAll: ((self hasJsCachedStorage and: [self requiresJsCacheSync]) ifTrue: [' this.dirty = true; '] ifFalse: [''])].		aStream			crtab: 3;			nextPutAll: 'return [true, this]}';			crtab: 2;			nextPutAll: 'else return [false]},';			crtab		].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 22:55'!printJSPrimitive132On: aStream	(superclass isNil and: [self isPointers not or: [self isVariable not and: [self instSize = 0]]]) ifTrue: [		aStream nextPutAll: 'primitive_132_impl(arg) {return [false]},';			crtab.		^self		].	((self isPointers and: [self isTransitioningFromNilStorageType or: [self isTransitioningToWeak]]) or: [self isCompiledMethodClass]) ifTrue: [		aStream nextPutAll: 'primitive_132_impl(arg) {';			nextPutAll: (self isWeak ifTrue: ['const instSize = this.instSize;'] ifFalse: ['']);			nextPutAll: 'return [true, this';			nextPutAll: (self isCompiledMethodClass ifTrue: ['.literals'] ifFalse: ['.pointers']);			nextPutAll: (self isWeak ifTrue: ['.some((x, i) => arg === (i > instSize ? (x.deref() || nil) : x))]},'] ifFalse: ['.some((x) => arg === x)]},']);			crtab.		].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/24/2022 22:51'!printJSPrimitive145On: aStream	((self isBits not or: [self isImmediateClass]) and: [superclass isNil]) ifTrue: [		aStream nextPutAll: 'primitive_145_impl(arg) {return [false]},';			crtab.		^self		].	((self isBits and: [self isImmediateClass not]) and: [superclass isNil or: [superclass isBits not]]) ifTrue: [		aStream nextPutAll: 'primitive_145_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(); if (';			nextPutAll: (self isLongs ifTrue: ['(typeof argVal === "number" && Number.isSafeInteger(argVal) || typeof argVal === "bigint") && argVal >= 0'] ifFalse: ['typeof argVal === "number" && (argVal >>> 0) === argVal']);			nextPutAll: ' && argVal < ';			nextPutAll: self JStypedStorageTypeLimit.		aStream			nextPutAll: ') {this.';			nextPutAll: self JSstorageType;			nextPutAll: '.fill(';			nextPutAll: (self isLongs ifTrue: ['BigInt(argVal)'] ifFalse: ['argVal']);			nextPutAll: '); return [true, this]} else return [false]},';			crtab.		].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 12/18/2022 00:41'!printJSPrimitive148On: aStream	| storageType |	(self primitiveJSmapping notNil) ifTrue: [		aStream nextPutAll: 'primitive_148_impl() {return [false]},';			crtab.		^self		].	storageType := self JSstorageType.	(superclass isNil or: [superclass JSstorageType ~= storageType or: [self isCompiledMethodClass]]) ifTrue: [		aStream nextPutAll: 'primitive_148_impl() {';			nextPutAll: 'const copy = this.constructor.primitive_70_impl()[1]; '.		(self inheritsFrom: String) ifTrue: [			aStream nextPutAll: 'if (!!this.dirty) {copy.string = this.string; copy.dirty = false} '		] ifFalse: [			self == LargePositiveInteger ifTrue: [				aStream nextPutAll: 'if (!!this.dirty) {copy.bigint = this.bigint; copy.dirty = false} '			] ifFalse: [				(self includesBehavior: Float) ifTrue: [					aStream nextPutAll: 'if (!!this.dirty) {copy.float = this.float; copy.dirty = false} '				] ifFalse: [					self isCompiledMethodClass ifTrue: [						aStream nextPutAll: 'copy.literals = Object.seal(this.literals.slice()); const func = this.func; copy.func = eval("(" + func.toString() + ")"); copy.func.compiledMethod = copy; copy.func.literals = copy.literals; '					]				]			]		].		storageType notNil ifTrue: [			(self includesBehavior: Behavior) ifTrue: [				aStream nextPutAll: 'Object.assign(copy.pointers, this.pointers); '			] ifFalse: [				aStream nextPutAll: 'copy.';					nextPutAll: storageType;					nextPutAll: ' = Object.seal(this.';					nextPutAll: storageType;					nextPutAll: '.slice()); '			]		].		aStream nextPutAll: 'return [true, copy]},';			crtab.		].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2022 20:31'!printJSPrimitive173On: aStream	| storageType |	(superclass isNil and: [self isVariable not and: [self instSize = 0]]) ifTrue: [		aStream nextPutAll: 'primitive_173_impl(arg) {return [false]},';			crtab.		^self		].	(self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_173_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType;			nextPutAll: '; const result = typeof argVal === "number" && ';			nextPutAll: storageType;			nextPutAll: ' ? ';			nextPutAll: storageType;			nextPutAll: '[argVal - 1] : undefined; ';			nextPutAll: (self isLongs ifTrue: ['let res; '] ifFalse: ['']);			nextPutAll: 'return [result !!== undefined, result';			nextPutAll: (self isWeak 				ifTrue: [self instSize > 0								ifTrue: [' !!== undefined && argVal > this.instSize ? (result.deref() || nil) : result]},']								ifFalse: [' !!== undefined ? (result.deref() || nil) : result]},']] 				ifFalse: [self isLongs ifTrue: [' !!== undefined && result == (res = Number(result)) ? res : result]},'] ifFalse: [']},']]);			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_173_impl(arg) {const argVal = arg.valueOf(); const result = typeof argVal === "number" ? this.bytes[argVal - this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				nextPutAll: ' - 1] : undefined; return [result !!== undefined, result]},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:38'!printJSPrimitive174On: aStream	| storageType element |	(superclass isNil and: [self isVariable not and: [self instSize = 0]]) ifTrue: [		aStream nextPutAll: 'primitive_174_impl(arg1, arg2) {return [false]},';			crtab.		^self		].	(self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_174_impl(arg1, arg2) {';			nextPutAll: 'const arg1Val = arg1.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType.		aStream			nextPutAll: '; if (arg1Val > 0 && (arg1Val | 0) === arg1Val && ';			nextPutAll: storageType;			nextPutAll: ' && arg1Val <= ';			nextPutAll: storageType;			nextPutAll: '.length ) {'.		self isPointers ifTrue: [			aStream				nextPutAll: 'pointers[arg1Val - 1] = arg2';				nextPutAll: (self isWeak ifTrue: [' === nil ? nil : (arg1Val > this.instSize ? new WeakRef(Object(arg2)) : arg2)'] ifFalse: ['']);				nextPutAll: '; return [true, arg2]'		] ifFalse: [			element := storageType , '[arg1Val - 1]'.			aStream				nextPutAll: 'const previous = ';				nextPutAll: element;				nextPutAll: '; ';				nextPutAll: element;				nextPutAll: (self isLongs ifTrue: [' = BigInt(arg2); return '] ifFalse: [' = arg2; return ']);				nextPutAll: element;				nextPutAll: ' === arg2 || ';				nextPutAll: element;				nextPutAll: ' == arg2.valueOf() ? [';				nextPutAll: ((self hasJsCachedStorage and: [self requiresJsCacheSync]) ifTrue: ['this.dirty = '] ifFalse: ['']);				nextPutAll: 'true, arg2] : [false, ';				nextPutAll: element;				nextPutAll: ' = previous]'		].		aStream			nextPutAll: '} else return [false]},';			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_174_impl(arg1, arg2) {';				crtab: 2;				nextPutAll: 'const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), bytes = this.bytes, litSize = this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				crtab: 2;				nextPutAll: 'if ((arg1Val | 0) === arg1Val && arg1Val > litSize && arg1Val <= bytes.length + litSize && (arg2Val >>> 0) === arg2Val && arg2Val < 256)';				crtab: 3;				nextPutAll: 'return [true, this.bytes[arg1Val - litSize - 1] = arg2Val];},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2022 20:26'!printJSPrimitive60On: aStream	| storageType |	(self isVariable not and: [superclass isNil]) ifTrue: [		aStream nextPutAll: 'primitive_60_impl(arg) {return [false]},';			crtab.		^self		].	(self isVariable and: [self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_60_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType;			nextPutAll: '; const result = typeof argVal === "number" && ';			nextPutAll: storageType;			nextPutAll: ' ? ';			nextPutAll: storageType;			nextPutAll: (self instSize > 0 ifTrue: ['[this.instSize + '] ifFalse: ['[']);			nextPutAll: 'argVal - 1] : undefined; ';			nextPutAll: (self isLongs ifTrue: ['let res; '] ifFalse: ['']);			nextPutAll: 'return [result !!== undefined, result';			nextPutAll: (self isWeak ifTrue: [' !!== undefined ? result.deref() || nil : result]},'] ifFalse: [self isLongs ifTrue: [' !!== undefined && result == (res = Number(result)) ? res : result]},'] ifFalse: [']},']]);			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_60_impl(arg) {const argVal = arg.valueOf(); const result = typeof argVal === "number" ? this.bytes[argVal - this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				nextPutAll: ' - 1] : undefined; return [result !!== undefined, result]},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:38'!printJSPrimitive61On: aStream	| storageType element |	(self isVariable not and: [superclass isNil]) ifTrue: [		aStream nextPutAll: 'primitive_61_impl(arg1, arg2) {return [false]},';			crtab.		^self		].	(self isVariable and: [self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_61_impl(arg1, arg2) {';			nextPutAll: 'const arg1Val = arg1.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType;			nextPutAll: (self instSize > 0 ifTrue: [', instSize = this.instSize; '] ifFalse: ['; ']).		aStream			nextPutAll: 'if (arg1Val > 0 && (arg1Val | 0) === arg1Val && ';			nextPutAll: storageType;			nextPutAll: ' && arg1Val <= ';			nextPutAll: storageType;			nextPutAll: (self instSize > 0 ifTrue: ['.length - instSize'] ifFalse: ['.length']);			nextPutAll: ') {'.		self isPointers ifTrue: [			aStream				nextPutAll: (self instSize > 0 ifTrue: ['pointers[arg1Val - 1 + instSize] = arg2'] ifFalse: ['pointers[arg1Val - 1] = arg2']);				nextPutAll: (self isWeak ifTrue: [' === nil ? nil : new WeakRef(Object(arg2))'] ifFalse: ['']);				nextPutAll: '; return [true, arg2]'		] ifFalse: [			element := storageType , '[arg1Val - 1]'.			aStream				nextPutAll: 'const previous = ';				nextPutAll: element;				nextPutAll: '; ';				nextPutAll: element;				nextPutAll: (self isLongs ifTrue: [' = BigInt(arg2); return '] ifFalse: [' = arg2; return ']);				nextPutAll: element;				nextPutAll: ' === arg2 || ';				nextPutAll: element;				nextPutAll: ' == arg2.valueOf() ? [';				nextPutAll: ((self hasJsCachedStorage and: [self requiresJsCacheSync]) ifTrue: ['this.dirty = '] ifFalse: ['']);				nextPutAll: 'true, arg2] : [false, ';				nextPutAll: element;				nextPutAll: ' = previous]'		].		aStream			nextPutAll: '} else return [false]},';			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_61_impl(arg1, arg2) {';				crtab: 2;				nextPutAll: 'const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), bytes = this.bytes, litSize = this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				crtab: 2;				nextPutAll: 'if ((arg1Val | 0) === arg1Val && arg1Val > litSize && arg1Val <= bytes.length + litSize && (arg2Val >>> 0) === arg2Val && arg2Val < 256)';				crtab: 3;				nextPutAll: 'return [true, this.bytes[arg1Val - litSize - 1] = arg2Val];},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 7/31/2022 17:10'!printJSPrimitive62On: aStream	(self isVariable not and: [superclass isNil]) ifTrue: [		aStream nextPutAll: 'primitive_62_impl() {return [false]},';			crtab.		^self	].	(self isVariable and: [self isTransitioningToInstvars or: [self isTransitioningToVariable]]) ifTrue: [		aStream nextPutAll: 'primitive_62_impl() {return [true, this.';			nextPutAll: self JSstorageType;			nextPutAll: (self instSize > 0 ifTrue: ['.length - this.instSize]},'] ifFalse: ['.length]},']);			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_62_impl() {return [true, this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				nextPutAll: ' + this.bytes.length]},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2022 20:33'!printJSPrimitive73On: aStream	| storageType |	(superclass isNil and: [self isVariable not and: [self instSize = 0]]) ifTrue: [		aStream nextPutAll: 'primitive_73_impl(arg) {return [false]},';			crtab.		^self		].	(self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_73_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType;			nextPutAll: '; const result = typeof argVal === "number" && ';			nextPutAll: storageType;			nextPutAll: ' ? ';			nextPutAll: storageType;			nextPutAll: '[argVal - 1] : undefined; ';			nextPutAll: (self isLongs ifTrue: ['let res; '] ifFalse: ['']);			nextPutAll: 'return [result !!== undefined, result';			nextPutAll: (self isWeak 				ifTrue: [self instSize > 0								ifTrue: [' !!== undefined && argVal > this.instSize ? (result.deref() || nil) : result]},']								ifFalse: [' !!== undefined ? (result.deref() || nil) : result]},']] 				ifFalse: [self isLongs ifTrue: [' !!== undefined && result == (res = Number(result)) ? res : result]},'] ifFalse: [']},']]);			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_73_impl(arg) {const argVal = arg.valueOf(); const result = typeof argVal === "number" ? this.bytes[argVal - this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				nextPutAll: ' - 1] : undefined; return [result !!== undefined, result]},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:37'!printJSPrimitive74On: aStream	| storageType element |	(superclass isNil and: [self isVariable not and: [self instSize = 0]]) ifTrue: [		aStream nextPutAll: 'primitive_74_impl(arg1, arg2) {return [false]},';			crtab.		^self		].	(self isTransitioningToInstvars or: [self isTransitioningToVariable or: [self isTransitioningToWeak]]) ifTrue: [		storageType := self JSstorageType.		aStream nextPutAll: 'primitive_74_impl(arg1, arg2) {';			nextPutAll: 'const arg1Val = arg1.valueOf(), ';			nextPutAll: storageType;			nextPutAll: ' = this.';			nextPutAll: storageType.		aStream			nextPutAll: '; if (arg1Val > 0 && (arg1Val | 0) === arg1Val && ';			nextPutAll: storageType;			nextPutAll: ' && arg1Val <= ';			nextPutAll: storageType;			nextPutAll: '.length ) {'.		self isPointers ifTrue: [			aStream				nextPutAll: 'pointers[arg1Val - 1] = arg2';				nextPutAll: (self isWeak ifTrue: [' === nil ? nil : (arg1Val > this.instSize ? new WeakRef(Object(arg2)) : arg2)'] ifFalse: ['']);				nextPutAll: '; return [true, arg2]'		] ifFalse: [			element := storageType , '[arg1Val - 1]'.			aStream				nextPutAll: 'const previous = ';				nextPutAll: element;				nextPutAll: '; ';				nextPutAll: element;				nextPutAll: (self isLongs ifTrue: [' = BigInt(arg2); return '] ifFalse: [' = arg2; return ']);				nextPutAll: element;				nextPutAll: ' === arg2 || ';				nextPutAll: element;				nextPutAll: ' == arg2.valueOf() ? [';				nextPutAll: ((self hasJsCachedStorage and: [self requiresJsCacheSync]) ifTrue: ['this.dirty = '] ifFalse: ['']);				nextPutAll: 'true, arg2] : [false, ';				nextPutAll: element;				nextPutAll: ' = previous]'		].		aStream			nextPutAll: '} else return [false]},';			crtab.	] ifFalse: [		self isCompiledMethodClass ifTrue: [			aStream nextPutAll: 'primitive_74_impl(arg1, arg2) {';				crtab: 2;				nextPutAll: 'const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), bytes = this.bytes, litSize = this.literals.length * ';				nextPutAll: Smalltalk wordSize printString;				crtab: 2;				nextPutAll: 'if ((arg1Val | 0) === arg1Val && arg1Val > litSize && arg1Val <= bytes.length + litSize && (arg2Val >>> 0) === arg2Val && arg2Val < 256)';				crtab: 3;				nextPutAll: 'return [true, this.bytes[arg1Val - litSize - 1] = arg2Val];},';				crtab.		]	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/6/2022 12:51'!printJSSpecializedIterationMethodsOn: aStream	| iterable recreateCacheFromStorage convertedToStorageType string storageType |	(self isVariable and: [(self inheritsFrom: Collection) and: [self instSize = 0 and: [superclass isVariable not or: [self isWeak and: [superclass isWeak not]]]]]) ifTrue: [		self isWeak			ifTrue: [				"mutation"				((self specializes: #at:put:) or: [self specializes: #atAllPut:]) ifFalse: [					aStream nextPutAll: '*_atAllPut_(arg) {this.pointers.fill(arg === nil ? nil : new WeakRef(Object(arg))); return this},'; crtab].				(self specializes: #at:) ifFalse: [					"iteration"					(self specializes: #allSatisfy:) ifFalse: [						aStream nextPutAll: '*_allSatisfy_(arg) {for (let e of this.pointers) if (!!(yield* arg._value_(e.deref() || nil)).booleanValueOf()) return false; return true},'; crtab].					(self specializes: #anySatisfy:) ifFalse: [						aStream nextPutAll: '*_anySatisfy_(arg) {for (let e of this.pointers) if ((yield* arg._value_(e.deref() || nil)).booleanValueOf()) return true; return false},'; crtab].					(self specializes: #detect:ifNone:) ifFalse: [						aStream nextPutAll: '*_detect_ifNone_(arg1, arg2) {for (let e of this.pointers) if ((yield* arg1._value_(e.deref() || nil)).booleanValueOf()) return (e.deref() || nil); return yield* arg2._value()},'; crtab].					(self specializes: #do:) ifFalse: [						aStream nextPutAll: '*_do_(arg) {for (let e of this.pointers) yield* arg._value_(e.deref() || nil); return this},'; crtab].					(self specializes: #do:separatedBy:) ifFalse: [						aStream nextPutAll: '*_do_separatedBy_(arg1, arg2) {let first = true; for (let e of this.pointers) {if (first) first = false; else yield* arg2._value(); yield* arg1._value_(e.deref() || nil)} return this},'; crtab].					(self specializes: #doWithIndex:) ifFalse: [						aStream nextPutAll: '*_doWithIndex_(arg) {let i = 1; for (let e of this.pointers) yield* arg._value_value_(e.deref() || nil, i++); return this},'; crtab].					(self specializes: #fold:) ifFalse: [						aStream nextPutAll: '*_fold_(arg) {let first = true, next; for (let e of this.pointers) if (first) {first = false; next = e.deref() || nil} else next = yield* arg._value_value_(next, e.deref() || nil); return next},'; crtab].					(self specializes: #inject:into:) ifFalse: [						aStream nextPutAll: '*_inject_into_(arg1, arg2) {let next = arg1; for (let e of this.pointers) next = yield* arg2._value_value_(next, e.deref() || nil); return next},'; crtab].					(self specializes: #noneSatisfy:) ifFalse: [						aStream nextPutAll: '*_noneSatisfy_(arg) {for (let e of this.pointers) if ((yield* arg._value_(e.deref() || nil)).booleanValueOf()) return false; return true},'; crtab].					(self specializes: #reduce:) ifFalse: [						aStream nextPutAll: '*_reduce_(arg) {let first = true, next; for (let e of this.pointers) if (first) {first = false; next = e.deref() || nil} else next = yield* arg._value_value_(next, e.deref() || nil); return next},'; crtab].					(self specializes: #reverseDo:) ifFalse: [						aStream nextPutAll: '*_reverseDo_(arg) {const pointers = this.pointers; for (let i = pointers.length - 1; i >= 0; i--) yield* arg._value_(pointers[i].deref() || nil); return this},'; crtab].					(self specializes: #withIndexDo:) ifFalse: [						aStream nextPutAll: '*_withIndexDo_(arg) {let i = 1; for (let e of this.pointers) yield* arg._value_value_(e.deref() || nil, i++); return this},'; crtab].					"search"					(self specializes: #includes:) ifFalse: [						aStream nextPutAll: '*_includes_(arg) {for (let e of this.pointers) if ((yield* (e.deref() || nil)._eq(arg)).booleanValueOf()) return true; return false},'; crtab].					(self specializes: #indexOf:) ifFalse: [						aStream nextPutAll: '*_indexOf_(arg) {let i = 0; for (let e of this.pointers) if ((yield* (e.deref() || nil)._eq(arg)).booleanValueOf()) return i + 1; else i++; return 0},'; crtab].					(self specializes: #indexOf:ifAbsent:) ifFalse: [						aStream nextPutAll: '*_indexOf_ifAbsent_(arg1, arg2) {let i = 0; for (let e of this.pointers) if ((yield* (e.deref() || nil)._eq(arg1)).booleanValueOf()) return i + 1; else i++; return yield* arg2._value()},'; crtab].					].				]			ifFalse: [				string := self inheritsFrom: String.				storageType := self JSstorageType.				(string not or: [storageType = 'bytes']) ifTrue: [					iterable := self iterable.					self == ByteSymbol ifFalse: [						"mutation"						(string or: [(self specializes: #at:put:) not]) ifTrue: [							recreateCacheFromStorage := self requiresJsCacheSync ifTrue: ['this.dirty = true; '] ifFalse: [''].							convertedToStorageType := storageType, (string ifTrue: ['.fill(arg.charCodeAt(0)'] ifFalse: ['.fill(arg']).							(self specializes: #atAllPut:) ifFalse: [								aStream nextPutAll: '*_atAllPut_(arg) {this.', convertedToStorageType, '); ', recreateCacheFromStorage, 'return this},'; crtab].							(self specializes: #from:to:put:) ifFalse: [								aStream nextPutAll: '*_from_to_put_(arg1, arg2, arg) {if (arg1 > arg2) return this; this.', convertedToStorageType, ', arg1.valueOf() - 1, arg2.valueOf()); ', recreateCacheFromStorage, 'return arg},'; crtab].							(self specializes: #reverseInPlace) ifFalse: [								aStream nextPutAll: '*_reverseInPlace() {this.', storageType, '.reverse(); ', recreateCacheFromStorage, 'return this},'; crtab].						].						"iteration"						(string or: [(self specializes: #at:) not]) ifTrue: [							(self specializes: #allSatisfy:) ifFalse: [								aStream nextPutAll: '*_allSatisfy_(arg) {for (let e of ', iterable, ') if (!!(yield* arg._value_(e)).booleanValueOf()) return false; return true},'; crtab].							(self specializes: #anySatisfy:) ifFalse: [								aStream nextPutAll: '*_anySatisfy_(arg) {for (let e of ', iterable, ') if ((yield* arg._value_(e)).booleanValueOf()) return true; return false},'; crtab].							(self specializes: #detect:ifNone:) ifFalse: [								aStream nextPutAll: '*_detect_ifNone_(arg1, arg2) {for (let e of ', iterable, ') if ((yield* arg1._value_(e)).booleanValueOf()) return e; return yield* arg2._value()},'; crtab].							(self specializes: #do:) ifFalse: [								aStream nextPutAll: '*_do_(arg) {for (let e of ', iterable, ') yield* arg._value_(e); return this},'; crtab].							(self specializes: #do:separatedBy:) ifFalse: [								aStream nextPutAll: '*_do_separatedBy_(arg1, arg2) {let first = true; for (let e of ', iterable, ') {if (first) first = false; else yield* arg2._value(); yield* arg1._value_(e)} return this},'; crtab].							(self specializes: #doWithIndex:) ifFalse: [								aStream nextPutAll: '*_doWithIndex_(arg) {let i = 1; for (let e of ', iterable, ') yield* arg._value_value_(e, i++); return this},'; crtab].							(self specializes: #findBinaryIndex:do:ifNone:) ifFalse: [								aStream nextPutAll: '*_findBinaryIndex_do_ifNone_(arg1, arg2, arg3) {const storage = ';									nextPutAll: iterable;									nextPutAll: '; let low = 1, high = storage.length, i, test; while(high >= low) {i = (high + low) / 2 | 0; if ((test = yield* arg1._value_(storage[i-1])) < 0) high = i - 1; else if (test > 0) low = i + 1; else return yield* arg2._value_(i)} return yield* arg3._cull_cull_(high, low)},'; 									crtab].							(self specializes: #fold:) ifFalse: [								aStream nextPutAll: '*_fold_(arg) {let first = true, next; for (let e of ', iterable, ') if (first) {first = false; next = e} else next = yield* arg._value_value_(next, e); return next},'; crtab].							(self specializes: #inject:into:) ifFalse: [								aStream nextPutAll: '*_inject_into_(arg1, arg2) {let next = arg1; for (let e of ', iterable, ') next = yield* arg2._value_value_(next, e); return next},'; crtab].							(self specializes: #noneSatisfy:) ifFalse: [								aStream nextPutAll: '*_noneSatisfy_(arg) {for (let e of ', iterable, ') if ((yield* arg._value_(e)).booleanValueOf()) return false; return true},'; crtab].							(self specializes: #reduce:) ifFalse: [								aStream nextPutAll: '*_reduce_(arg) {let first = true, next; for (let e of ', iterable, ') if (first) {first = false; next = e} else next = yield* arg._value_value_(next, e); return next},'; crtab].							(self specializes: #reverseDo:) ifFalse: [								aStream nextPutAll: '*_reverseDo_(arg) {const storage = ', iterable, '; for (let i = storage.length - 1; i >= 0; i--) yield* arg._value_(storage[i]); return this},'; crtab].							(self specializes: #withIndexDo:) ifFalse: [								aStream nextPutAll: '*_withIndexDo_(arg) {let i = 1; for (let e of ', iterable, ') yield* arg._value_value_(e, i++); return this},'; crtab].						].					].					"search"					storageType ~= 'pointers' ifTrue: ["pointers require Smalltalk's #= comparison"						(string or: [(self specializes: #at:) not]) ifTrue: [							(self specializes: #includes:) ifFalse: [								aStream nextPutAll: '*_includes_(arg) {return ', iterable, '.includes(arg)},'; crtab].							(self specializes: #indexOf:) ifFalse: [								aStream nextPutAll: '*_indexOf_(arg) {return ', iterable, '.indexOf(arg) + 1},'; crtab].							(self specializes: #indexOf:startingAt:) ifFalse: [								aStream nextPutAll: '*_indexOf_startingAt_(arg1, arg2) {return ', iterable, '.indexOf(arg1, arg2 - 1) + 1},'; crtab].							(self specializes: #indexOf:startingAt:ifAbsent:) ifFalse: [								aStream nextPutAll: '*_indexOf_startingAt_ifAbsent_(arg1, arg2, arg3) {return ', iterable, '.indexOf(arg1, arg2 - 1) + 1 || (yield* arg3._value())},'; crtab].							(self specializes: #lastIndexOf:startingAt:ifAbsent:) ifFalse: [								aStream nextPutAll: '*_lastIndexOf_startingAt_ifAbsent_(arg1, arg2, arg3) {return arg2 >= 1 && ', iterable, '.lastIndexOf(arg1, arg2) + 1 || (yield* arg3._value())},'; crtab].							string ifTrue: [								(self specializes: #beginsWith:) ifFalse: [									aStream nextPutAll: '*_beginsWith_(arg) {const argVal = arg.valueOf(); return argVal !!== "" && ', iterable, '.startsWith(argVal)},'; crtab].								(self specializes: #endsWith:) ifFalse: [									aStream nextPutAll: '*_endsWith_(arg) {const argVal = arg.valueOf(); return argVal !!== "" && ', iterable, '.endsWith(argVal)},'; crtab].								(self specializes: #findString:) ifFalse: [									aStream nextPutAll: '*_findString_(arg) {const argVal = arg.valueOf(); return argVal !!== "" ? ', iterable, '.indexOf(arg.valueOf()) + 1 : 0},'; crtab].								(self specializes: #findString:startingAt:) ifFalse: [									aStream nextPutAll: '*_findString_startingAt_(arg1, arg2) {const arg1Val = arg1.valueOf(); return arg1Val !!== "" ? ', iterable, '.indexOf(arg1.valueOf(), arg2 - 1) + 1 : 0},'; crtab].								(self specializes: #includesSubString:) ifFalse: [									aStream nextPutAll: '*_includesSubString_(arg) {const argVal = arg.valueOf(); return argVal !!== "" && ', iterable, '.includes(argVal)},'; crtab].								(self specializes: #includesSubstring:) ifFalse: [									aStream nextPutAll: '*_includesSubstring_(arg) {const argVal = arg.valueOf(); return argVal !!== "" && ', iterable, '.includes(argVal)},'; crtab].							] 						]					].				].			]		].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/22/2022 23:29'!printJSSpecializedPrimitivesOn: aStream	self printJSPrimitive60On: aStream.	self printJSPrimitive61On: aStream.	self printJSPrimitive62On: aStream.	self printJSPrimitive73On: aStream.	self printJSPrimitive74On: aStream.	self printJSPrimitive105On: aStream.	self printJSPrimitive132On: aStream.	self printJSPrimitive145On: aStream.	self printJSPrimitive148On: aStream.	self printJSPrimitive173On: aStream.	self printJSPrimitive174On: aStream.! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 1/21/2022 19:45'!printJSStaticInitializerForBootstrap: isBootstrap on: aStream	aStream nextPutAll: self JSsuperConstructor;		nextPutAll: (isBootstrap ifTrue: ['.initialize('] ifFalse: ['.fullInitialize(']);		nextPutAll: self JSname;		nextPutAll: ', ';		nextPutAll: format printString;		nextPutAll: ', ';		nextPutAll: self class format printString.	isBootstrap ifTrue: [		aStream nextPutAll: ');';			cr.		^self	].	aStream		nextPutAll: ', "';		nextPutAll: self category;		nextPutAll: '", ['.	self instVarNames do: [:i | aStream nextPut: $"; nextPutAll: i; nextPut: $"] separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: '], ['.	self class instVarNames do: [:i | aStream nextPut: $"; nextPutAll: i; nextPut: $"] separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ']'.	self class printJSPrimitive70On: aStream.	self class printJSPrimitive71On: aStream.	aStream nextPutAll: ');';		cr.! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 00:36'!printJSStaticInitializerOn: aStream	self printJSStaticInitializerForBootstrap: self isBootstrapClass on: aStream.	aStream cr! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 3/30/2022 23:50'!printJSStaticPostInitializerForBootstrapOn: aStream	aStream nextPutAll: self JSname;		nextPutAll: '.postInitialize("';		nextPutAll: self category;		nextPutAll: '", ['.	self instVarNames do: [:i | aStream nextPut: $"; nextPutAll: i; nextPut: $"] separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: '], ['.	self class instVarNames do: [:i | aStream nextPut: $"; nextPutAll: i; nextPut: $"] separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ']'.	self class printJSPrimitive70On: aStream.	self class printJSPrimitive71On: aStream.	aStream nextPutAll: ');';		cr.! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 09:35'!printJSStorageFieldsOn: aStream		self jsCachedStorageOn: aStream.	self jsStaticFromOn: aStream.	self jsStaticHelpersOn: aStream.! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 8/3/2022 20:17'!printJSSupportMethodsOn: aStream	| string |	self printJSStorageFieldsOn: aStream.	string := String streamContents: [:strm | self jsStorageTypeOn: strm].	string withBlanksTrimmed isEmpty ifTrue: [		string := String streamContents: [:strm | self printJSSpecializedIterationMethodsOn: strm].		string withBlanksTrimmed isEmpty ifTrue: [			string := String streamContents: [:strm | self printJSSpecializedPrimitivesOn: strm].			string withBlanksTrimmed isEmpty ifFalse: [				aStream nextPutAll: 'Object.assign(';					nextPutAll: self JSprotoypeName;					nextPutAll: ', {';					crtab;					nextPutAll: string;					cr;					nextPutAll: '});';					cr			].		] ifFalse: [			aStream nextPutAll: 'Object.assign(';				nextPutAll: self JSprotoypeName;				nextPutAll: ', {';				crtab;				nextPutAll: string.			self printJSSpecializedPrimitivesOn: aStream.			aStream cr;				nextPutAll: '});';				cr		].	] ifFalse: [		aStream nextPutAll: 'Object.assign(';			nextPutAll: self JSprotoypeName;			nextPutAll: ', {';			crtab;			nextPutAll: string.		self printJSSpecializedIterationMethodsOn: aStream.		self printJSSpecializedPrimitivesOn: aStream.		aStream cr;			nextPutAll: '});';			cr	].	self shouldKeepTrackOfInstances ifTrue: [		aStream nextPutAll: 'AllInstances.set(';			nextPutAll: self JSname;			nextPutAll: ', new Instances());'; 			cr	].! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 11/28/2021 15:11'!printJSmethodAddSubclassOn: aStream	aStream nextPutAll: 'addSubclass(subClass) {';		crtab: 2;		nextPutAll: 'if (this.pointers[5] === undefined || this.pointers[5] === nil)';		crtab: 3;		nextPutAll: 'this.pointers[5] = new ';		"we cannot use primitive_71 yet, since it may not have been added to _Array yet"		nextPutAll: Array JSname;		nextPutAll: '(1);';		crtab: 2;		nextPutAll: 'const subclasses = this.pointers[5].pointers;';		crtab: 2;		nextPutAll: 'if(subclasses === undefined)';		crtab: 3;		nextPutAll: 'throw "Should not happen";';		crtab: 2;		nextPutAll: 'if(Object.isSealed(subclasses)) {';		crtab: 3;		nextPutAll: 'this.pointers[5].pointers = [subClass];';		crtab: 2;		nextPutAll: '} else ';		crtab: 3;		nextPutAll: 'subclasses.push(subClass);';		crtab;		nextPut: $}! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:33'!requiresJsCacheSync	^false! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 11/28/2021 13:24'!shouldKeepTrackOfInstances	^JavaScriptTranspiler instance shouldKeepTrackOf: self! !!Class methodsFor: 'JavaScript generation' stamp: 'fm 9/6/2022 12:59'!specializes: aSelector	| implementor |	self withAllSubclassesDo: [:s |		(s methodDict includesKey: aSelector) ifTrue: [			^true]	].	implementor := self whichClassIncludesSelector: aSelector.	(implementor notNil and: [implementor superclass notNil]) ifTrue: [		^(implementor superclass whichClassIncludesSelector: aSelector) notNil	].	^false! !!Association class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:50'!jsStaticFromOn: aStream	name = 'Association' ifTrue: [		aStream nextPutAll: self class JSprotoypeName;			nextPutAll: '.from = function from(aJsArray) {';			crtab;			nextPutAll: 'if (!!Array.isArray(aJsArray)) return undefined;';			crtab;			nextPutAll: 'let result = this.primitive_70_impl();';			crtab;			nextPutAll: 'if (result[0] !!== true) return undefined;';			crtab;			nextPutAll: 'const result1 = result[1];';			crtab;			nextPutAll: 'const instSize = result1.pointers.length, length = aJsArray.length;';			crtab;			nextPutAll: 'if (instSize > length)';			crtab: 2;			nextPutAll: 'Object.assign(result1.pointers, aJsArray);';			crtab;			nextPutAll: 'else';			crtab: 2;			nextPutAll: 'result1.pointers = aJsArray;';			crtab;			nextPutAll: 'return result1;';			cr;			nextPutAll: '}';			cr	]! !!Association class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 15:04'!jsStorageTypeOn: aStream	name = 'Association' ifTrue: [		aStream nextPutAll: 'installAsUndeclared() {';			crtab: 2;			nextPutAll: 'SmalltalkGlobals["_" + this.pointers[0].string] = this.pointers;';			crtab: 2;			nextPutAll: 'this.pointers.push(this);';			crtab: 2;			nextPutAll: 'return this;';			crtab;			nextPutAll: '},';			cr; crtab	]! !!Association class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 16:24'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = new Array(2).fill(nil);';			cr;			nextPut: $};			cr! !!BalloonBuffer class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:56'!hasJsCachedStorage	^true! !!BalloonBuffer class methodsFor: 'JavaScript generation' stamp: 'fm 9/2/2022 00:00'!initializeJsCachedStorageMessage	^'this.float32Array = undefined; this.int32Array = undefined;'! !!Binding class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 16:58'!jsStorageTypeOn: aStream	name = 'Binding' ifTrue: [		aStream nextPutAll: 'installAsUndeclared() {';			crtab: 2;			nextPutAll: 'SmalltalkGlobals["_" + this.pointers[0].string] = this.pointers;';			crtab: 2;			nextPutAll: 'return this;';			crtab;			nextPutAll: '},';			cr; crtab	]! !!Binding class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 15:30'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = Object.seal(new Array(3).fill(nil));';			crtab;			nextPutAll: 'this.pointers[2] = this;';			cr;			nextPut: $};			cr! !!BlockClosure class methodsFor: 'JavaScript generation' stamp: 'fm 8/6/2022 23:27'!JSpartitioningTest	^'!!this.compiledMethod'! !!BlockClosure class methodsFor: 'JavaScript generation' stamp: 'fm 8/6/2022 23:27'!JsOptimizedPartitioningTest	^'!!this.compiledMethod'! !!BlockClosure class methodsFor: 'JavaScript generation' stamp: 'fm 11/5/2022 15:27'!printJSConstructorOn: aStream		aStream nextPutAll: '(indexableSize = 0) {';			crtab;			nextPutAll: 'this.pointers = Object.seal(new Array(';			nextPutAll: self instSize printString;			nextPutAll: ' + indexableSize).fill(nil));';			crtab;			nextPutAll: 'this.compiledMethod = undefined;';			cr;			nextPut: $};			cr! !!Character class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:46'!jsStaticFromOn: aStream		aStream nextPutAll: self class JSprotoypeName;			nextPutAll: '.from = function from(aJsArray) {';			crtab;			nextPutAll: 'if (!!Array.isArray(aJsArray) || aJsArray.length !!== 1) return undefined;';			crtab;			nextPutAll: 'let result = this.primitive_70_impl();';			crtab;			nextPutAll: 'if (result[0] !!== true) return undefined;';			crtab;			nextPutAll: 'const result1 = result[1];';			crtab;			nextPutAll: 'result1.pointers = aJsArray;';			crtab;			nextPutAll: 'return result1;';			cr;			nextPutAll: '}';			cr! !!Character class methodsFor: 'JavaScript generation' stamp: 'fm 7/16/2022 17:55'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = new Array(1).fill(nil);';			cr;			nextPut: $};			cr! !!Character class methodsFor: 'JavaScript generation' stamp: 'fm 7/16/2022 18:12'!printJSSpecializedPrimitivesOn: aStream	Model printJSSpecializedPrimitivesOn: aStream! !!Character class methodsFor: 'JavaScript generation' stamp: 'fm 7/16/2022 18:03'!printJSStaticInitializerForBootstrap: isBootstrap on: aStream	aStream nextPutAll: self JSsuperConstructor;		nextPutAll: (isBootstrap ifTrue: ['.initialize('] ifFalse: ['.fullInitialize(']);		nextPutAll: self JSname;		nextPutAll: ', ';		nextPutAll: Model format printString;		nextPutAll: ', ';		nextPutAll: Model class format printString.	isBootstrap ifTrue: [		aStream nextPutAll: ');';			cr.		^self	].	aStream		nextPutAll: ', "';		nextPutAll: self category;		nextPutAll: '", ["value"], ['.	self class instVarNames do: [:i | aStream nextPut: $"; nextPutAll: i; nextPut: $"] separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ']'.	self class printJSPrimitive70On: aStream.	self class printJSPrimitive71On: aStream.	aStream nextPutAll: ');';		cr.! !!Compiler methodsFor: 'public access' stamp: 'jr 1/15/2017 01:17'!compile: textOrStream in: aClass environment: anEnvironment notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	^self		compileCue: (CompilationCue			source: textOrStream			class: aClass			environment: anEnvironment			requestor: aRequestor)		noPattern: false		ifFail: failBlock! !!Environment methodsFor: 'accessing' stamp: 'fm 9/29/2020 10:00'!size	^declarations size! !!Environment methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 18:58'!JSdoStoreOn: aStream visiting: aDict indent: level	| globals notAlreadyConsidered sharedPoolDictionaries sharedPools classes |	self == Smalltalk globals ifTrue: [		aStream nextPutAll: ', "@path": ';			nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: 'Smalltalk[1].pointers[0]'.	] ifFalse: [self halt].	5 to: self class instSize do: [:i | 		(self instVarAt: i) ifNotNil: [:var |			aStream nextPutAll: ', ';				nextPutAll: (i - 1) printString;				nextPutAll: ': '.			var JSstoreOn: aStream visiting: aDict indent: level		].	].	sharedPoolDictionaries := IdentitySet new.	Smalltalk allClassesDo: [ :classOrTrait |		classOrTrait sharedPools do: [:pool | 			(pool class == Dictionary) ifTrue: [				sharedPoolDictionaries add: (classOrTrait environment keyAtIdentityValue: pool)]]].	globals := declarations array select: [:assoc | assoc class == Global].	sharedPools := globals select: [:assoc | sharedPoolDictionaries includes: assoc key].	aStream nextPutAll: ', "@pools": {'.	sharedPools do: [:assoc | 		aStream nextPut: $_;			nextPutAll: assoc key;			nextPutAll: ': '.		assoc value JSstoreOn: aStream visiting: aDict indent: level] separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $}.	notAlreadyConsidered := globals reject: [:assoc | (sharedPoolDictionaries includes: assoc key) or: [#(Smalltalk Undeclared) includes: assoc key]].	aStream nextPutAll: ', "@globals": {'.	notAlreadyConsidered do: [:assoc | 		(#(Smalltalk Undeclared) includes: assoc key) ifFalse: [			aStream nextPut: $_;				nextPutAll: assoc key;				nextPutAll: ': '.			assoc value JSstoreOn: aStream visiting: aDict indent: level]] separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $}.	classes := declarations array select: [:assoc | assoc class == ClassBinding].	aStream nextPutAll: ', "@classes": {'.	classes do: [:assoc | 		aStream nextPut: $_;			nextPutAll: assoc key;			nextPutAll: ': '.		assoc value JSstoreOn: aStream visiting: aDict indent: level] separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $}.! !!Exception class methodsFor: 'JavaScript generation' stamp: 'fm 10/2/2022 23:26'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = Object.seal(new Array(';			nextPutAll: self instSize printString;			nextPutAll: ').fill(nil));';			crtab;			nextPutAll: 'this.currentHandler = null;';			cr;			nextPut: $};			cr! !!False methodsFor: 'controlling' stamp: 'fm 10/25/2014 21:49'!questionMark: trueAlternative colon: falseAlternative	^falseAlternative! !!FullBlockClosure methodsFor: 'accessing' stamp: 'fm 1/17/2023 17:52'!startpcOrMethod	^startpcOrMethod! !!Global methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:54'!JSprintOn: aStream	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream].! !!Global methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:54'!JSprintOn: aStream indent: level	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSprintOn: aStream indent: level].! !!Global methodsFor: 'JavaScript generation' stamp: 'fm 11/19/2021 23:09'!JSprintValueOn: aStream	aStream nextPutAll: key; nextPutAll: '[1]'! !!Global methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:54'!JSstoreOn: aStream	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		super JSstoreOn: aStream].! !!Global methodsFor: 'JavaScript generation' stamp: 'fm 9/5/2021 17:55'!JSstoreOn: aStream visiting: aDict indent: level	((Smalltalk bindingOf: key) == self or:	[(Undeclared bindingOf: key) == self]) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: key;			nextPutAll: '[2]'	] ifFalse: [		self JSstoreWithIdOn: aStream visiting: aDict indent: level].! !!Global class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 13:53'!jsStorageTypeOn: aStream	aStream nextPutAll: 'install() {';		crtab: 2;		nextPutAll: 'SmalltalkGlobals["_" + this.pointers[0].string] = this.pointers;';		crtab: 2;		nextPutAll: 'return this;';		crtab;		nextPutAll: '},';		cr; crtab! !!InstructionStream methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 14:18'!JSstoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: 'nil'! !!Decompiler methodsFor: 'JavaScript generation' stamp: 'fm 1/18/2023 23:16'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreWithIdOn: aStream visiting: aDict indent: level! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 7/5/2022 00:35'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	1 to: self class instSize do: [:i | 		(self instVarAt: i) ifNotNil: [:var |			var ~~ behaviorsDict ifTrue: [				aStream nextPutAll: ', ';					nextPutAll: (i - 1) printString;					nextPutAll: ': '.				var JSstoreOn: aStream visiting: aDict indent: level			]		].	].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 7/5/2022 12:39'!behaviorsDict	^behaviorsDict ifNil: [behaviorsDict := Dictionary new]! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 12:41'!defaultJsEnvironment	^'SmalltalkGlobals'! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 7/3/2022 18:43'!exportAllClassesCode	| classesPath |	classesPath := 'classes', FileDirectory slash.	FileDirectory default assureExistenceOfPath: (FileDirectory default fullNameFor: generationPath, classesPath).	behaviorsDict associations do: [:assoc | 		(assoc key isMeta) ifFalse: [			self generateFile: classesPath, '_', assoc key, '.js' as: [:strm |				assoc key isBootstrapClass					ifTrue: [						assoc key JSname printJSExtensionFor: #() meta: false withMethods: assoc value on: strm]					ifFalse: [						assoc key printJSDefinitionWithMethods: assoc value on: strm].				strm cr; cr.				assoc key JSname printJSExtensionFor: #() meta: true withMethods: (behaviorsDict at: assoc key class) on: strm.				] insertComment: false			]		] displayingProgress: 'Generating JavaScript classes'.! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 3/30/2022 23:41'!exportBootstrapClassDefinitionsTo: jsSqueakRootPath for: imageName	"JavaScriptTranspiler newInstance exportBootstrapClassDefinitionsTo: 'C:\JsSqueak\' for: '4.5'"	| previousDefault |		previousDefault := FileDirectory default pathName.	FileDirectory setDefaultDirectory: jsSqueakRootPath, 'JavaScript'.	self setGenerationPathFor: imageName.[	self generateFile: 'bootstrap.js' as: [:strm | | core |		core := self jsCoreBootstrapClasses. 		core do: [:c |			strm nextPutAll: c JSname;				nextPutAll: '.setFormat(';				nextPutAll: c format printString; 				nextPutAll: ', ';				nextPutAll: c class format printString; 				nextPutAll: ');';				cr.			c printJSSupportMethodsOn: strm.			c hasComment ifTrue: [				strm nextPutAll: 'SmalltalkGlobals.classComments.set(';					nextPutAll: c JSname;					nextPutAll: ', '.				c comment asString JSprimitiveOn: strm.				strm nextPutAll: ');';					cr			].			strm cr		].		(self jsBootstrapClasses reject: [:c | core includes: c]) do: [:c |			c printJSDefinitionOnlyOn: strm.			strm cr; cr.		].		strm nextPutAll: 'var nil = new ';			nextPutAll: nil class JSname;			nextPutAll: '();';			cr; 			nextPutAll: 'nil.hash = 1;';			cr; 			nextPutAll: 'nil.deref = function deref() {return this};';			cr; 			nextPutAll: 'nil.toString = function toString() {return "nil"};';			cr; 			nextPutAll: 'Object.freeze(nil);';			cr; 			nextPutAll: 'AllInstances.get(SmalltalkGlobals._UndefinedObject).push(nil);';			cr; 			nextPutAll: 'globalThis.nil = nil;';			cr; cr.		strm nextPutAll: 'for (const b of ['.		self jsBootstrapClasses do: [:c | strm nextPutAll: c JSname] separatedBy: [strm nextPutAll: ', '].		strm nextPutAll: ']) {	let pointers = b.pointers;	for (let i = 0; i < pointers.length; i++)		if (pointers[i] === undefined)			pointers[i] = nil;	pointers = b.constructor.pointers;	for (let i = 0; i < pointers.length; i++)		if (pointers[i] === undefined)			pointers[i] = nil;}';			cr; cr.		self jsBootstrapClasses do: [:c |			c printJSStaticPostInitializerForBootstrapOn: strm			].	].] ensure: [FileDirectory setDefaultDirectory: previousDefault].																																								! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 7/13/2022 15:49'!exportGlobalBindingsOn: aStream	| globals |	aStream nextPutAll: 'const smalltalk = ';		nextPutAll: SmalltalkImage JSname;		nextPutAll: '.from([';			cr; space: 1;			nextPutAll: Environment JSname;				nextPutAll: '.from([';					cr; space: 2.					(globals := Smalltalk globals) info JSprintOn: aStream indent: 3.	"info"					aStream nextPut: $,;					cr; space: 2;					nextPutAll: IdentityDictionary JSname;	"declarations"					nextPutAll: '.from([';						cr; space: 3;						nextPutAll: (globals instVarAt: 2) size printString;						nextPut: $,;						cr; space: 3;						nextPutAll: Array JSname;						nextPutAll: '.from([';							cr; space: 4.							(globals instVarAt: 2) array								do: [:e | 									e class == ClassBinding ifTrue: [										e key == e value name ifTrue: [											e JSprintOn: aStream										] ifFalse: [											((globals instVarAt: 2) at: e value name) == e value ifTrue: [												aStream nextPutAll: ClassBinding JSname;													nextPutAll: '.from(['.												e key JSstoreOn: aStream.												aStream nextPutAll: ', ';													nextPutAll: e value JSname;													nextPutAll: ']).installAsUndeclared()'											] ifFalse: [												self halt											]										]									] ifFalse: [										e class == Global ifTrue: [											aStream nextPutAll: Global JSname;												nextPutAll: '.from(['.											e key JSstoreOn: aStream.											aStream nextPutAll: ', undefined]).install()'										] ifFalse: [											e isNil												ifTrue: [aStream nextPutAll: 'nil']												ifFalse: [self halt]]]]								separatedBy: [aStream nextPut: $,; cr; space: 4].							aStream nextPutAll: '])';									nextPutAll: ']),';					cr; space: 2.					(globals instVarAt: 3) JSprintOn: aStream indent: 3.	"bindings"					aStream nextPut: $,;					cr; space: 2;					nextPutAll: IdentityDictionary JSname;	"undeclared"					nextPutAll: '.from([';						cr; space: 3;						nextPutAll: (globals instVarAt: 4) size printString;						nextPut: $,;						cr; space: 3;						nextPutAll: Array JSname;						nextPutAll: '.from([';							cr; space: 4;							nextPutAll: (String streamContents: [:result |											(globals instVarAt: 4) associationsDo: [:e | 												result nextPutAll: e class JSname;													nextPutAll: '.from(['.												e key JSstoreOn: result.												result nextPutAll: ', nil]).installAsUndeclared(),';													cr; space: 5;													nextPutAll: 'nil,';													cr; space: 5]]);							nextPutAll: '])';									nextPutAll: '])'.			aStream nextPutAll: '])';		nextPutAll: ']);';		cr; cr;	nextPutAll: 'SmalltalkGlobals._Smalltalk[1] = smalltalk;';	cr;	nextPutAll: 'SmalltalkGlobals._Undeclared[1] = smalltalk.pointers[0].pointers[3];'! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 1/18/2023 23:48'!exportJavaScriptTo: jsSqueakRootPath for: imageName	"JavaScriptTranspiler newInstance exportJavaScriptTo: 'C:\JsSqueak\' for: '4.5'"	| previousDefault |		previousDefault := FileDirectory default containingDirectory pathName.	FileDirectory setDefaultDirectory: jsSqueakRootPath, 'JavaScript'.	self setGenerationPathFor: imageName.[	self exportBootstrapClassDefinitionsTo: jsSqueakRootPath for: imageName.	Smalltalk at: #Trait ifPresent: [ :aClass | 		Smalltalk at: #TraitsTestCase ifPresent: [ :aTestClass |			aTestClass subclasses do: [:aSubclass |  aSubclass removeFromSystem].			aTestClass removeFromSystem].		Smalltalk at: #TraitsResource ifPresent: [ :aResourceClass | aResourceClass removeFromSystem ].		aClass unloadTraits.		 ].	"revisit once/if we support traits"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk globals removeKey: #AA ifAbsent: [].	Smalltalk globals removeKey: #BB ifAbsent: [].	Smalltalk globals removeKey: #CC ifAbsent: [].	Smalltalk globals removeKey: #DD ifAbsent: [].	Smalltalk globals removeKey: #Temp ifAbsent: [].	ThumbnailMorph recursionReset.	ActiveWorld attemptCleanupReporting: false.	Player freeUnreferencedSubclasses; removeUninstantiatedSubclassesSilently.	Environment default declarations		select: [:binding | binding value isBehavior and: [binding value isUniClass and: [binding value isObsolete]]]		thenDo: [:binding |			SystemOrganization removeElement: binding key.			Environment default removeKey: binding key].	(Environment default instVarAt: 6)		select: [:e | 			e declarations allSatisfy: [:a | 				(#(Smalltalk Undeclared) includes: a key) or: 				[a value isBehavior and: [a value isUniClass and: [a value isObsolete]]]]]		thenDo: [:e | Environment default removeObserver: e].	(MCPackage named: 'Autogenerated') unload.	Smalltalk cleanUp: true.	Smalltalk fixObsoleteReferences.	self generateLoadAllModule.	self loadInlineablePrimitiveBodies.	self transpileAllToJavaScript.	self exportAllClassesCode.	self exportMappedTypesCode.	"self exportPluginsTo: jsSqueakRootPath for: imageName.	self exportStateTo: jsSqueakRootPath for: imageName"] ensure: [FileDirectory setDefaultDirectory: previousDefault].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 7/3/2022 18:43'!exportMappedTypesCode	| mappedTypesPath mappedTypesConflictPath moreGeneralMapping commonSuperclasses |	mappedTypesPath := 'mapped_types', FileDirectory slash.	FileDirectory default assureExistenceOfPath: (FileDirectory default fullNameFor: generationPath, mappedTypesPath).	mappedTypesConflictPath := mappedTypesPath, FileDirectory slash, 'methodConflicts', FileDirectory slash.	FileDirectory default assureExistenceOfPath: (FileDirectory default fullNameFor: generationPath, mappedTypesConflictPath).	self generateFile: 'mapped_types.mjs' as: [:strm |		strm nextPutAll: 'globalThis.Float = class Float extends Number {';			crtab;			nextPutAll: 'static ZERO = Object.freeze(new Float(0))';			crtab;			nextPutAll: 'static NEGATIVE_ZERO = Object.freeze(new Float(-0))';			crtab;			nextPutAll: 'static ONE = Object.freeze(new Float(1))';			crtab;			nextPutAll: 'constructor(number) {';			crtab: 2;			nextPutAll: 'const val = number.valueOf();';			crtab: 2;			nextPutAll: 'if (typeof val === "number")';			crtab: 3;			nextPutAll: 'super(val);';			crtab: 2;			nextPutAll: 'else';			crtab: 3;			nextPutAll: 'throw new TypeError("not a number");';			crtab;			nextPutAll: '}';			cr;			nextPutAll: '}';			cr; cr;			nextPutAll: 'await Promise.all(['. 		self primitiveJSmappings do: [:a | | mappingTargetName mappedClassNames conflicts common allSelectors allDescended mappedClasses other |			mappingTargetName := a last.			mappedClassNames := a first.			commonSuperclasses := #().			(mappedClassNames size = 1 and: [(moreGeneralMapping := self primitiveJSmappings detect: [:m | m first size > 1 and: [m first includes: mappedClassNames first]] ifNone: []) notNil]) ifTrue: [				self assert: moreGeneralMapping first size = 2.				other := Smalltalk classNamed: (moreGeneralMapping first first = mappedClassNames first ifTrue: [moreGeneralMapping first last] ifFalse: [moreGeneralMapping first first]).				commonSuperclasses := (Smalltalk classNamed: mappedClassNames first) withAllSuperclasses intersection: other withAllSuperclasses			].			conflicts := Dictionary new.			common := Dictionary new.			allSelectors := Set new.			mappedClasses := mappedClassNames collect: [:e | Smalltalk classNamed: e].			allDescended := mappedClasses collect: [:e | | descended |				descended := Dictionary new. 				e withAllSuperclasses reverseDo: [:c |					(commonSuperclasses includes: c) ifTrue: [						(behaviorsDict at: c) keysAndValuesDo: [:sel :assoc |							(commonSuperclasses includes: (other whichClassIncludesSelector: sel)) ifFalse: [								"although this implementation is provided by one of the common superclasses (to a common mapped super-type), 								 it is part of a conflict, so we still need it as a a specialization"								descended at: sel put: assoc]]					] ifFalse: [						(behaviorsDict at: c) keysAndValuesDo: [:sel :assoc |							descended at: sel put: assoc]					]				].				descended keysDo: [:sel | allSelectors add: sel]].			allSelectors do: [:sel | | sources sourcesDict | 				sources := Set new. 				sourcesDict := Dictionary new. 				allDescended with: mappedClasses do: [:descended :class | | assoc |					assoc := descended at: sel ifAbsent: ['DNU' -> 'DNU'].					sourcesDict at: class put: (sources add: assoc)].				sources size = 1					ifTrue: [						common at: sel put: sourcesDict values first]					ifFalse: [						conflicts at: sel put: sourcesDict]].			self generateFile: mappedTypesPath, mappingTargetName, '.js' as: [:str |				mappingTargetName printJSExtensionFor: mappedClasses meta: false withMethods: common on: str.				] insertComment: false.			strm crtab; 				nextPutAll: 'import("./mapped_types/';				nextPutAll: mappingTargetName;				nextPutAll: '.js"),'.			conflicts isEmpty ifFalse: [				self generateFile: mappedTypesConflictPath, mappingTargetName, '.js' as: [:str |					mappingTargetName printJSConflicts: conflicts for: mappedClasses on: str.				] insertComment: false.				strm crtab; 					nextPutAll: 'import("./mapped_types/methodConflicts/';					nextPutAll: mappingTargetName;					nextPutAll: '.js"),'.			]		] displayingProgress: 'Generating JavaScript primitive type mappings'.	strm nextPutAll: '])'].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 1/28/2022 17:54'!exportPluginsTo: jsSqueakRootPath for: imageName	"JavaScriptTranspiler newInstance exportPluginsTo: 'C:\JsSqueak\' for: '4.5'"	| previousDefault |		previousDefault := FileDirectory default containingDirectory pathName.	FileDirectory setDefaultDirectory: jsSqueakRootPath, 'JavaScript'.	self setGenerationPathFor: imageName.[	| pluginsDirectory pluginsPath |	pluginsPath := FileDirectory default fullNameFor: generationPath, 'plugins', FileDirectory slash.	FileDirectory default assureExistenceOfPath: pluginsPath.	pluginsDirectory := FileDirectory on: pluginsPath.	self generateFile: 'plugins.mjs' as: [:strm |		strm nextPutAll: 'await Promise.all(['. 		JSCodeGenerator beActiveDuring: [			#(	ADPCMCodecPlugin				BalloonEnginePlugin				BitBltSimulation				DSAPlugin				DeflatePlugin				FFTPlugin				FloatArrayPlugin				GeniePlugin				JPEGReaderPlugin				KedamaPlugin				KedamaPlugin2				KlattSynthesizerPlugin				LargeIntegersPlugin				Matrix2x3Plugin				MiscPrimitivePlugin				ScratchPlugin				SoundGenerationPlugin				StarSqueakPlugin			) do: [:pluginName |				(Smalltalk at: pluginName) translateInDirectory: pluginsDirectory doInlining: true.				strm crtab; 					nextPutAll: 'import("./plugins/';					nextPutAll: (Smalltalk at: pluginName) moduleName;					nextPutAll: '.js"),'.				]			displayingProgress: 'Generating JS plugins'.		].		strm nextPutAll: '])'. 	].] ensure: [FileDirectory setDefaultDirectory: previousDefault].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/2/2022 00:11'!exportStateTo: jsSqueakRootPath for: imageName	"JavaScriptTranspiler instance exportStateTo: 'C:\JsSqueak\' for: '6.0'"	| previousDefault currentJsEnvironmentPrefix |		"Make sure you don't have any inspectors or debuggers open when you run this, then quickly minimize Squeak!!"	(Delay forMilliseconds: 5000) wait.	Smalltalk unloadFonts.	SoundPlayer shutDown.	Display shutDown.	Smalltalk isMorphic ifTrue:		[World prepareToBeSaved].			MCWorkingCopy stubAllAncestry.	Smalltalk garbageCollect.	Environment allInstancesDo: [:environment | environment purgeUndeclared ].	Undeclared removeUnreferencedKeys.	Smalltalk processShutDownList: false.	HashedCollection compactAll.	Smalltalk garbageCollect.	Smalltalk at: #specialObjectsArray put: Smalltalk specialObjectsArray.	previousDefault := FileDirectory default pathName.	FileDirectory setDefaultDirectory: jsSqueakRootPath, 'JavaScript'.	self setGenerationPathFor: imageName.	currentJsEnvironmentPrefix := jsEnvironmentPrefix.[				.	self generateFile: 'imageFormat.js' as: [:strm | 		strm nextPutAll: 'SmalltalkGlobals.ImageFormat = '; 			nextPutAll: Smalltalk imageFormatVersion printString;			cr;			nextPutAll: 'SmalltalkGlobals.BytesPerWord = '; 			nextPutAll: Smalltalk wordSize printString;			cr;			nextPutAll: 'SmalltalkGlobals.MillisecondClockValue = ';			nextPutAll: Time eventMillisecondClock printString;			cr;			nextPutAll: 'SmalltalkGlobals.ProcessPreemptionYields = ';			nextPutAll: Smalltalk processPreemptionYields printString].	self generateFile: 'global_bindings.js' as: [:strm | self exportGlobalBindingsOn: strm].	jsEnvironmentPrefix := 'this._'.	self generateFile: 'serialized_Smalltalk_globals.js' as: [:strm | Smalltalk globals JSstoreOn: strm].] ensure: [	jsEnvironmentPrefix := currentJsEnvironmentPrefix.	FileDirectory setDefaultDirectory: previousDefault.	Smalltalk processStartUpList: false.	Project current wakeUpTopWindow].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/19/2020 17:09'!generateFile: fileName as: blockWithStream	FileStream forceNewFileNamed: generationPath, fileName do: [:all |		all nextPutAll: '/* Generated from ';			nextPutAll: Smalltalk version;"			nextPutAll: ' and VMMaker ';			nextPutAll: VMMaker versionString;"			nextPutAll: ' by (the Squeak portion of) JsSqueak, on '.		Time dateAndTimeNow do: [:e | all nextPutAll: e asString].		all nextPutAll: ' */'; cr; cr.		blockWithStream value: all].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 8/31/2021 22:01'!generateFile: fileName as: blockWithStream insertComment: aBool	FileStream forceNewFileNamed: generationPath, fileName do: [:all |		aBool ifTrue: [			all nextPutAll: '/* Generated from ';				nextPutAll: Smalltalk version;"				nextPutAll: ' and VMMaker ';				nextPutAll: VMMaker versionString;"				nextPutAll: ' by (the Squeak portion of) JsSqueak, on '.			Time dateAndTimeNow do: [:e | all nextPutAll: e asString].			all nextPutAll: ' */'; cr; cr.		].		blockWithStream value: all].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 3/12/2021 23:27'!generateLoadAllModule	self generateFile: 'classes.mjs' as: [:all |		all nextPutAll: 'await (Promise.all(['. 		Class subclasses do: [:e | | c previousLevel |			c := e soleInstance.			previousLevel := 0.			c allSubclassesWithLevelDo: [:subclass :level | | current peers |				level <= previousLevel					ifTrue: [all nextPutAll: ', '].				previousLevel := level.				self printImportOf: subclass indent: level on: all.				(subclass subclasses size > 0 and: [subclass ~~ Class])					ifTrue: [						all nextPutAll: '.then(value => '.						subclass subclasses size > 1							ifTrue: [all nextPutAll: 'Promise.all([']						]					ifFalse: [						current := subclass.						[current notNil and: [							peers := current superclass subclasses sort: [:a :b | a name <= b name].							peers last == current]						] whileTrue: [							(peers size > 1 or: [current superclass isNil]) ifTrue: [								all nextPutAll: '])'].							all nextPut: $).							current := current superclass]						]				] startingLevel: 1.			] separatedBy: [all nextPutAll: ', '].		].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 3/25/2022 15:42'!initBootstrapClasses	jsBootstrapClasses := self jsCoreBootstrapClasses.	{Array. CompiledMethod. MethodDictionary. ByteSymbol. ByteString. ClassOrganizer. Association. ClassBinding. UndefinedObject} 		do: [:e | | withSupers commonParent |			withSupers := e withAllSuperclasses.			commonParent := withSupers detect: [:s | jsBootstrapClasses includes: s].			(withSupers indexOf: commonParent) - 1 to: 1 by: -1 do: [:i |				jsBootstrapClasses addLast: (withSupers at: i)]].	jsBootstrapClasses := jsBootstrapClasses asArray! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 8/6/2022 20:57'!initPrimitiveJSmappings	"See the overrides folder for range redefinitions" 		primitiveJSmappings := Smalltalk environment at: #BoxedFloat64 "this way we only need to care about old float primitives"			ifPresent: [:floatClass |	#(				((True False) 'Boolean') 				((LargePositiveInteger LargeNegativeInteger) 'BigInt') 				((SmallInteger BoxedFloat64) 'Number') 				((BoxedFloat64) 'Float') 				((Character) 'String')				((BlockClosure FullBlockClosure) 'Function')			)]			ifAbsent: [	#(				((True False) 'Boolean') 				((LargePositiveInteger LargeNegativeInteger) 'BigInt') 				((SmallInteger Float) 'Number') 				((Float) 'Float') 				((Character) 'String')				((BlockClosure) 'Function')			)]! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 6/22/2022 20:39'!initialize	valueTypes := self class findValueTypes keys.	mirrorHandler := thisContext class basicNew: CompiledMethod smallFrameSize.	jsEnvironmentPrefix := self defaultJsEnvironment, '._'.	self initPrimitiveJSmappings.	self initBootstrapClasses.	Smalltalk globals 		at: #MISSING_MARKER put: Object new; 		at: #HANDLER_MARKER put: Object new. ! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 19:59'!inlineablePrimitiveBodies	^inlineablePrimitiveBodies! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 23:45'!jsBootstrapClasses	^jsBootstrapClasses! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 3/25/2022 15:42'!jsCoreBootstrapClasses	^Class withAllSuperclasses reversed add: Metaclass; yourself! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 23:46'!jsEnvironmentPrefix	^jsEnvironmentPrefix! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 23:47'!jsEnvironmentPrefix: aString	jsEnvironmentPrefix := aString! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 8/2/2022 23:29'!loadInlineablePrimitiveBodies	 | directory |	inlineablePrimitiveBodies := Array new: 600.	(directory := FileDirectory default directoryNamed: 'inlineablePrimitives') entries do: [:e | | name |		name := e name.		(e isDirectory not and: [(name beginsWith: 'primitive_') and: [name endsWith: '.js']]) ifTrue: [			(directory oldFileOrNoneNamed: name) ifNotNil: [:strm | | primitiveString primitiveNumber |				primitiveString := strm contents.				primitiveNumber := Integer readFrom: (name copyFrom: 11 to: name size).				inlineablePrimitiveBodies at: primitiveNumber put: primitiveString]		]	] ! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/17/2020 15:35'!mapPrimitives	"This is just a small in-image inspection debugging aid"	"JavaScriptTranspiler instance jmapPrimitives"	| primitives |		primitives := Dictionary new: 500.	Smalltalk allClassesDo: [ :classOrTrait | 		{classOrTrait. classOrTrait theMetaClass} do: [ :behavior | 			behavior selectorsAndMethodsDo: [:selector :method| | original |				original := method methodForDecompile.				(behavior isLocalMethod: original) ifTrue: [					(original primitive > 0 and: [(original primitive between: 255 and: 519) not])						ifTrue: [							(primitives at: original primitive ifAbsentPut: [OrderedCollection new]) add: behavior name , '>>#' , selector].					]				]			]		].	^primitives! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/28/2020 10:41'!nonPrimitiveJSmappings	"JavaScriptTranspiler instance nonPrimitiveJSmappings"	"	^nonPrimitiveJSmappings ifNil: [		nonPrimitiveJSmappings := #(				((IdentitySet) ('tally' 'size') 'Set')				((IdentityDictionary) ('tally' 'size') 'Map')			)]	"! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 01:03'!objJSprint: proxy on: aStream	"Assumes non-recursive structures"	proxy class JSinstantiationOn: aStream 		withArgs: ((1 to: proxy class instSize + (mirrorHandler objectSize: proxy)) collect: [:i | mirrorHandler object: proxy instVarAt: i]) 		argsBlock: [:arg | 			((arg class inheritsFrom: Object) and: [arg JSshouldBePrintedAsLiteral]) ifTrue: [				arg JSstoreOn: aStream			] ifFalse: [				(arg class inheritsFrom: Object) ifTrue: [					arg JSprintOn: aStream				] ifFalse: [					self objJSprint: arg on: aStream				].			]		].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 00:59'!objJSprint: proxy on: aStream indent: level	"Assumes non-recursive structures"	proxy class JSinstantiationOn: aStream 		withArgs: ((1 to: proxy class instSize + (mirrorHandler objectSize: proxy)) collect: [:i | mirrorHandler object: proxy instVarAt: i]) 		argsBlock: [:arg | 			((arg class inheritsFrom: Object) and: [arg JSshouldBePrintedAsLiteral]) ifTrue: [				arg JSstoreOn: aStream			] ifFalse: [				aStream cr; space: level.				(arg class inheritsFrom: Object) ifTrue: [					arg JSprintOn: aStream indent: level + 1				] ifFalse: [					self objJSprint: arg on: aStream indent: level + 1				].			]		].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 14:32'!objJSstore: proxy on: aStream visiting: aDict indent: level	| id size |	(proxy class inheritsFrom: ProtoObject) ifFalse: [self halt].	id := aDict at: proxy ifAbsent: [].	id isNil ifTrue: [		id := aDict at: proxy put: aDict size + 1.		aStream cr; space: level + 1;			nextPutAll: '{"@id": ';			nextPutAll: id printString.		id + 1 // 3000 ~= (id // 3000) ifTrue: [			aStream flush].		aStream nextPutAll: ', "@cls": ';			nextPutAll: proxy class JSname.		size := 0.		proxy class isPointers ifTrue: [			proxy class isVariable ifTrue: [				aStream nextPutAll: ', "@size": ';					nextPutAll: (size := mirrorHandler objectSize: proxy) printString.				].			1 to: proxy class instSize + size do: [:i | 				(mirrorHandler object: proxy instVarAt: i) ifNotNil: [:var |					aStream nextPutAll: ', ';						nextPutAll: (i - 1) printString;						nextPutAll: ': '.					(var class inheritsFrom: Object) ifTrue: [						var JSstoreOn: aStream visiting: aDict indent: level + 1					] ifFalse: [						self objJSstore: var on: aStream visiting: aDict indent: level + 1					].					].				].		] ifFalse: [			aStream nextPutAll: ', "@size": ';				nextPutAll: (size := mirrorHandler objectSize: proxy) printString.			1 to: size do: [:i | | var |				(var := mirrorHandler object: proxy basicAt: i) = 0 ifFalse: [					aStream nextPutAll: ', ';						nextPutAll: (i - 1) printString;						nextPutAll: ': '.					var JSstoreOn: aStream					].				].			].			aStream nextPut: $}.	] ifFalse: [		aStream nextPutAll: '{"@ref": ';			nextPutAll: id printString;			nextPut: $}.	].! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 1/18/2023 23:56'!prepareJavaScript	"a test method that does all the prep and translation work that #exportJavaScriptTo:for: does, without writing the files"	"JavaScriptTranspiler newInstance prepareJavaScript"	FileDirectory setDefaultDirectory: 'C:\JsSqueak\JavaScript'.	Smalltalk at: #Trait ifPresent: [ :aClass | 		Smalltalk at: #TraitsTestCase ifPresent: [ :aTestClass |			aTestClass subclasses do: [:aSubclass |  aSubclass removeFromSystem].			aTestClass removeFromSystem].		Smalltalk at: #TraitsResource ifPresent: [ :aResourceClass | aResourceClass removeFromSystem ].		aClass unloadTraits.		 ].	"revisit once/if we support traits"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk globals removeKey: #AA ifAbsent: [].	Smalltalk globals removeKey: #BB ifAbsent: [].	Smalltalk globals removeKey: #CC ifAbsent: [].	Smalltalk globals removeKey: #DD ifAbsent: [].	Smalltalk globals removeKey: #Temp ifAbsent: [].	ThumbnailMorph recursionReset.	ActiveWorld attemptCleanupReporting: false.	Player freeUnreferencedSubclasses; removeUninstantiatedSubclassesSilently.	Environment default declarations		select: [:binding | binding value isBehavior and: [binding value isUniClass and: [binding value isObsolete]]]		thenDo: [:binding |			SystemOrganization removeElement: binding key.			Environment default removeKey: binding key].	(Environment default instVarAt: 6)		select: [:e | 			e declarations allSatisfy: [:a | 				(#(Smalltalk Undeclared) includes: a key) or: 				[a value isBehavior and: [a value isUniClass and: [a value isObsolete]]]]]		thenDo: [:e | Environment default removeObserver: e].	(MCPackage named: 'Autogenerated') unload.	Smalltalk cleanUp: true.	Smalltalk fixObsoleteReferences.	self loadInlineablePrimitiveBodies.	self transpileAllToJavaScript.! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 23:42'!primitiveJSmappings	"JavaScriptTranspiler instance primitiveJSmappings"	^primitiveJSmappings! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 9/15/2020 02:18'!printImportOf: class indent: level on: aStream	aStream crtab: level; 		nextPutAll: 'import("./classes/_';		nextPutAll: class name;		nextPutAll: '.js")'.! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 10/19/2020 17:19'!setGenerationPathFor: imageName.		generationPath := 'generated', FileDirectory slash, imageName, FileDirectory slash.	FileDirectory default assureExistenceOfPath: (FileDirectory default fullNameFor: generationPath).! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 12/9/2021 23:26'!shouldKeepTrackOf: aClass	^(valueTypes includes: aClass) not and: 	[((aClass inheritsFrom: InstructionStream) not or: [aClass isContextClass not]) and:	[primitiveJSmappings noneSatisfy: [:m | m first includes: aClass name]]]! !!JavaScriptTranspiler methodsFor: 'JavaScript generation' stamp: 'fm 11/16/2022 22:53'!transpileAllToJavaScript	"JavaScriptTranspiler newInstance jsShouldWrap: false; transpileAllToJavaScript"	| exceptions undeclared previousDefault |		behaviorsDict := Dictionary new: 3000.	exceptions := OrderedCollection new.	undeclared := OrderedCollection new.	previousDefault := FileDirectory default pathName.	Smalltalk allClasses do: [ :classOrTrait | 		{classOrTrait. classOrTrait theMetaClass} do: [ :behavior |   | sources | 			sources := Dictionary new.			behavior selectorsAndMethodsDo: [:selector :method| | original source parsed |					selector isOptimizedSelector not ifTrue: [		"revisit once/if we support traits - (behavior isLocalMethod: original)"						original := method methodForDecompile.						source := original getSourceFor: selector in: behavior.						[							parsed := (Compiler new parse: source in: behavior notifying: nil).						] on: Notification do: [:e |							(e class name beginsWith: 'Undeclared') ifTrue: [								undeclared add: original reference -> (e instVarAt: Notification instSize + 1)].							e resume].						parsed notNil ifTrue: [							[sources at: selector put: parsed asJavaScript							] on: Error, Notification do: [:e | | assoc |								(e isResumable and: [e isKindOf: Notification]) ifTrue: [									(e class name beginsWith: 'Undeclared') ifTrue: [										assoc := original reference -> (e instVarAt: Notification instSize + 1).										(undeclared includes: assoc) ifFalse: [											exceptions halt add: assoc.										].									].									e resume								] ifFalse: [									exceptions halt add: original reference -> e printString]							]]						] 				].			behaviorsDict at: behavior put: sources.			].	] displayingProgress: 'Transpiling all methods'.	(exceptions isEmpty and: [undeclared isEmpty]) ifFalse: [		"This is just a small in-image inspection debugging aid"		Dictionary new			at: #exceptions put: exceptions;			at: #undeclared put: undeclared;			inspect.	].	^behaviorsDict! !!JavaScriptTranspiler class methodsFor: 'instance creation' stamp: 'fm 9/14/2020 20:21'!instance	^singleton ifNil: [singleton := self new]! !!JavaScriptTranspiler class methodsFor: 'instance creation' stamp: 'fm 9/17/2020 12:24'!newInstance	^singleton := self new! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 5/7/2021 10:13'!couldBeCompositeValueType: aClass		^aClass isPointers and: [aClass isVariable not and: [aClass instSize > 0 and: [aClass inheritsFrom: Object]]].! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 12/9/2021 22:32'!couldBeCompositeValueTypeInstvarClass: aClass	^(self isSimpleValueType: aClass)				or: [self couldBeCompositeValueType: aClass]! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 12/9/2021 22:32'!couldBeCompositeValueTypeInstvarType: aClassOrClasses using: candidatesDictionary	^aClassOrClasses isCollection ifTrue: [		aClassOrClasses allSatisfy: [:class | candidatesDictionary includesKey: class]	] ifFalse: [		candidatesDictionary includesKey: aClassOrClasses	]! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 12/9/2021 21:36'!findValueTypes	"JavaScriptTranspiler findValueTypes"	| valueTypeCandidates size toRemove |	valueTypeCandidates := IdentityDictionary new.	Smalltalk allClassesDo: [:c | | s inst next i cl types e count |		(self isKnownValueType: c) ifTrue: [			valueTypeCandidates at: c put: #()		] ifFalse: [			(self couldBeCompositeValueType: c) ifTrue: [					types := nil. "make it explicit"				s := c instSize.				inst := c someInstance.				count := 0.				[inst == nil] whileFalse: [					next := inst nextInstance.					count := count + 1.					i := s.					[i > 0] whileTrue: [						cl := (inst instVarAt: i) class.						(self couldBeCompositeValueTypeInstvarClass: cl) ifTrue: [							types == nil ifTrue: [								types := valueTypeCandidates at: c ifAbsentPut: [(Array new: s) at: i put: cl; yourself].							] ifFalse: [								(e := types at: i) == cl ifFalse: [									e isCollection ifTrue: [										(e includes: cl) ifFalse: [											e add: cl										]									] ifFalse: [										e isNil ifTrue: [											types at: i put: cl										] ifFalse: [											types at: i put: (OrderedCollection with: e with: cl)										].									]								]							].							i := i - 1						] ifFalse: [							next := nil.							valueTypeCandidates removeKey: c ifAbsent: [].							i := 0.						].					].					inst := next				].				count < 10 ifTrue: [					valueTypeCandidates removeKey: c ifAbsent: [].				]			]		]	].	size := 0.	[valueTypeCandidates size ~= size] whileTrue: [		toRemove := OrderedCollection new.		size := valueTypeCandidates size.		valueTypeCandidates keysAndValuesDo: [:c :types | | childrenSize children nextChildren |			(types allSatisfy: [:t | self couldBeCompositeValueTypeInstvarType: t using: valueTypeCandidates])				ifTrue: [					"check for recursive types"					childrenSize := 0.					children := types inject: IdentitySet new into: [:result :e | e isCollection ifTrue: [result addAll: e] ifFalse: [result add: e]. result].					[children size ~= childrenSize and: [(children includes: c) not]] whileTrue: [						childrenSize := children size.						nextChildren := IdentitySet new.						children do: [:ch | | nextTypes |							nextTypes := valueTypeCandidates at: ch ifAbsent: [#()].							nextChildren addAll: (nextTypes inject: IdentitySet new into: [:result :e | e isCollection ifTrue: [result addAll: e] ifFalse: [result add: e]. result])].						children addAll: nextChildren					].					(children includes: c) ifTrue: [						toRemove add: c					]				] ifFalse: [					toRemove add: c				]		].		toRemove do: [:c | valueTypeCandidates removeKey: c]	].	^valueTypeCandidates! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 12/11/2021 15:31'!isKnownValueType: aClass	^(self isSimpleValueType: aClass) or: 	[#(ByteArray Interval Point ThirtyTwoBitRegister Complex CompiledMethodTrailer	Bitmap Color TranslucentColor BitBlt GrafPort WarpBlt BitBltDisplayScanner Bezier2Segment EllipseMidpointTracer MorphicTransform	MorphicEventDispatcher KeyboardEvent MouseEvent MouseButtonEvent MouseMoveEvent	LayoutCell LayoutFrame TextLine RaisedBorder SimpleBorder TableLayout) includes: aClass name]! !!JavaScriptTranspiler class methodsFor: 'value types' stamp: 'fm 5/7/2021 10:10'!isSimpleValueType: aClass	^aClass == Character or: [(aClass inheritsFrom: Number) or: [aClass inheritsFrom: Boolean]] ! !!JavaScriptTranspiler class methodsFor: 'shared blocks' stamp: 'fm 7/9/2022 20:10'!emptyArrayBlockHolderMethod	"self class >> #emptyArrayBlockHolderMethod"	^[#()]! !!JavaScriptTranspiler class methodsFor: 'shared blocks' stamp: 'fm 7/9/2022 20:08'!emptyBlockHolderMethod	"self class >> #emptyBlockHolderMethod"	^[ ]! !!JavaScriptTranspiler class methodsFor: 'shared blocks' stamp: 'fm 7/9/2022 20:10'!falseBlockHolderMethod	"self class >> #falseBlockHolderMethod"	^[false]! !!JavaScriptTranspiler class methodsFor: 'shared blocks' stamp: 'fm 7/9/2022 20:09'!trueBlockHolderMethod	"self class >> #trueBlockHolderMethod"	^[true]! !!JavaScriptTranspiler class methodsFor: 'shared blocks' stamp: 'fm 7/9/2022 20:09'!zeroBlockHolderMethod	"self class >> #zeroBlockHolderMethod"	^[0]! !!MatrixTransform2x3 class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:58'!hasJsCachedStorage	^true! !!MatrixTransform2x3 class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:58'!initializeJsCachedStorageMessage	^'this.float32Array = undefined;'! !!Message methodsFor: 'printing' stamp: 'fm 1/12/2023 11:17'!printOn: stream	args isEmpty ifTrue: [^ stream nextPutAll: selector].	args with: selector keywords do: [:arg :word |		stream nextPutAll: word.		stream space.		(arg shouldBePrintedAsLiteral or: [arg = $ ]) ifTrue: [			arg printAsLiteralOn: stream		] ifFalse: [			arg printOn: stream].		stream space.	].	stream skip: -1.! !!Metaclass methodsFor: 'JavaScript generation' stamp: 'fm 8/25/2020 20:54'!JSname	^thisClass JSname, '.constructor'.! !!Metaclass methodsFor: 'JavaScript generation' stamp: 'fm 1/20/2022 18:15'!JSprotoypeName	^thisClass JSname, '.constructor.prototype'! !!Metaclass methodsFor: 'JavaScript generation' stamp: 'fm 2/14/2022 23:37'!printJSPrimitive70On: aStream	(thisClass isVariable not and: [(thisClass superclass notNil and: [thisClass superclass shouldKeepTrackOfInstances ~~ thisClass shouldKeepTrackOfInstances]) or: 	[thisClass superclass isNil and: [thisClass shouldKeepTrackOfInstances not]]]) ifTrue: [		aStream nextPut: $,; crtab; nextPutAll: 'function primitive_70_impl() {return [true, '.		thisClass shouldKeepTrackOfInstances ifTrue: [			aStream nextPutAll: 'AllInstances.get(this).addWeakly('].		aStream nextPutAll: 'new this'.		thisClass shouldKeepTrackOfInstances ifTrue: [			aStream nextPut: $)].		aStream nextPutAll: ']}'.		].	thisClass isTransitioningToVariable ifTrue: [		aStream nextPut: $,; crtab; nextPutAll: 'function primitive_70_impl() {return this.primitive_71_impl(0);}'.		].! !!Metaclass methodsFor: 'JavaScript generation' stamp: 'fm 6/20/2022 16:54'!printJSPrimitive71On: aStream	(thisClass isTransitioningToVariable or: [thisClass isVariable and: [(thisClass superclass notNil and: [thisClass superclass shouldKeepTrackOfInstances ~~ thisClass shouldKeepTrackOfInstances]) or: 	[thisClass superclass isNil and: [thisClass shouldKeepTrackOfInstances not]]]]) ifTrue: [		aStream nextPut: $,; crtab; nextPutAll: 'function primitive_71_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(); ';			nextPutAll: 'return (argVal >>> 0) === argVal ? [true, '.		thisClass shouldKeepTrackOfInstances ifTrue: [			aStream nextPutAll: 'AllInstances.get(this).addWeakly('].		aStream nextPutAll: 'new this(argVal)'.		thisClass shouldKeepTrackOfInstances ifTrue: [			aStream nextPut: $)].		aStream nextPutAll: '] : [false]}'.		].! !!Number methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:27'!JSprimitiveOn: aStream 	self JSstoreOn:  aStream.! !!Number methodsFor: 'JavaScript generation' stamp: 'fm 7/21/2020 10:59'!JSstoreOn: aStream 	self printOn: aStream! !!Number methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 14:44'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreOn: aStream! !!Number methodsFor: 'JavaScript generation' stamp: 'fm 3/25/2021 10:14'!isJSsafeInteger	^false! !!Float methodsFor: 'JavaScript generation' stamp: 'fm 10/4/2022 13:13'!JSstoreOn: aStream 	(self isFinite and: [self = self truncated]) ifTrue: [		self = 1.0 ifTrue: [			aStream nextPutAll: 'Float.ONE'.		] ifFalse: [			self = 0.0 ifTrue: [				aStream nextPutAll: (self == Float negativeZero ifTrue: ['Float.NEGATIVE_ZERO'] ifFalse: ['Float.ZERO']).			] ifFalse: [				aStream nextPutAll: 'new Float('.				self printOn: aStream.				aStream nextPut: $)			]		]	] ifFalse: [		self isFinite ifTrue: [			self < 0 ifTrue: [aStream nextPutAll: '(-'].			self abs absPrintExactlyOn: aStream base: 10.			self < 0 ifTrue: [aStream nextPutAll: ')'].		] ifFalse: [			self isNaN				ifTrue: [aStream nextPutAll: 'Number.NaN']				ifFalse: [					self > 0.0						ifTrue: [aStream nextPutAll: 'Number.POSITIVE_INFINITY']						ifFalse: [aStream nextPutAll: 'Number.NEGATIVE_INFINITY']]]	]! !!Float class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:38'!hasJsCachedStorage	^self isVariable! !!Float class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 13:08'!initializeJsCachedStorageMessage	^'this.float = 0; this.dirty = true;'	"while not strictly true, as a new, 'empty' float is equal to 0, they are clearly not meant to stay zero, so this is an exception 	and a very minor mis-optimization, better safe than sorry"! !!Float class methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 22:33'!jsCachedStorageOn: aStream	self isTransitioningFromNilStorageType ifTrue: [		"we still need Float, even though they are mapped to primitive numbers,		for the creation from bytes scenario"		aStream nextPutAll: self JSprotoypeName;			nextPutAll: '.valueOf = function valueOf() {if (this.dirty) {';			crtab;			nextPutAll: 'this.float = new DataView(this.words.buffer).getFloat64(0, false)';			crtab;			nextPutAll: 'this.dirty = false;}';			cr;			nextPutAll: 'return this.float;}	//mimic the native Number wrapper objects';			cr	].! !!Float class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:36'!requiresJsCacheSync	^true! !!Fraction methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2020 12:46'!JSstoreOn: aStream 		self class JSinstantiationOn: aStream withArgs: {numerator. denominator} argsBlock: [ :each | each JSstoreOn: aStream ]! !!LargePositiveInteger methodsFor: 'JavaScript generation' stamp: 'fm 9/30/2020 14:29'!JSstoreOn: aStream 	self < 4294967296 ifTrue: [		self JsHexWordOn: aStream.	] ifFalse: [		self JsHexOn: aStream.	].	self isJSsafeInteger ifFalse: [		aStream nextPut: $n		]	! !!LargePositiveInteger methodsFor: 'JavaScript generation' stamp: 'fm 9/30/2020 14:32'!JsHexOn: aStream	aStream nextPutAll: '0x'.	self asHexOn: aStream! !!LargePositiveInteger methodsFor: 'JavaScript generation' stamp: 'fm 9/30/2020 14:19'!JsHexWordOn: aStream	aStream nextPutAll: '0x'.	self asHexWordOn: aStream! !!LargePositiveInteger methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:24'!isJSsafeInteger	^self < 9007199254740992	"Number.MAX_SAFE_INTEGER + 1"! !!LargePositiveInteger methodsFor: 'printing' stamp: 'fm 9/30/2020 14:31'!asHexOn: aStream	self digitLength to: 1 by: -1 do: [:i |		aStream nextPutAll: (self digitAt: i) asHexByte]! !!LargePositiveInteger methodsFor: 'printing' stamp: 'fm 9/30/2020 12:35'!asHexWord	^String streamContents: [:s | 		s nextPutAll: (self digitAt: 4) asHexByte;			nextPutAll: (self digitAt: 3) asHexByte;			nextPutAll: (self digitAt: 2) asHexByte;			nextPutAll: (self digitAt: 1) asHexByte		]! !!LargePositiveInteger methodsFor: 'printing' stamp: 'fm 9/30/2020 12:34'!asHexWordOn: aStream	aStream nextPutAll: (self digitAt: 4) asHexByte;		nextPutAll: (self digitAt: 3) asHexByte;		nextPutAll: (self digitAt: 2) asHexByte;		nextPutAll: (self digitAt: 1) asHexByte.		! !!LargeNegativeInteger methodsFor: 'JavaScript generation' stamp: 'fm 8/25/2022 11:47'!JSstoreOn: aStream 	self JsHexOn: aStream.	self isJSsafeInteger ifFalse: [		aStream nextPut: $n		].! !!LargeNegativeInteger methodsFor: 'JavaScript generation' stamp: 'fm 10/3/2020 03:06'!JsHexOn: aStream	aStream nextPutAll: '-0x'.	self asHexOn: aStream! !!LargeNegativeInteger methodsFor: 'JavaScript generation' stamp: 'fm 10/3/2020 03:11'!JsHexWordOn: aStream	self halt: 'This should be a uint'! !!LargeNegativeInteger methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:23'!isJSsafeInteger	^self > -9007199254740992	"Number.MIN_SAFE_INTEGER - 1"! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 10/14/2020 23:13'!JSpartitioningTest	^'this >= 0'! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 12/22/2021 21:45'!JsOptimizedPartitioningTest	^'val >= 0'! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 11/7/2022 00:05'!hasJsCachedStorage	^true! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 13:04'!initializeJsCachedStorageMessage	^'this.bigint = 0n; this.dirty = true;'		"while not strictly true, as a new, 'empty' largeInteger is equal to 0, largeIntegers are manipulated in plugin primitives that are not aware of our dirty flag"		! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:45'!jsCachedStorageOn: aStream	"we still need LargePositiveInteger, even though they are mapped	 to the primitive bigint, for the creation from bytes scenario"	aStream nextPutAll: self JSprotoypeName;	nextPutAll: '.valueOf = function valueOf() {if (this.dirty) {';		crtab;		nextPutAll: 'const bytes = this.bytes;';		crtab;		nextPutAll: 'this.bigint = bytes.length > 0 ? ';		nextPutAll: (name = 'LargeNegativeInteger' ifTrue: ['-'] ifFalse: ['']);		nextPutAll: 'BigInt("0x" + Array.prototype.map.call(bytes, c => c.toString(16).padStart(2, "0")).reverse().join("")) : 0n';		crtab;		nextPutAll: 'this.dirty = false;}';		cr;		nextPutAll: 'return this.bigint;}	//mimic the native Number wrapper objects';		cr! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 11/7/2022 14:14'!printJSPrimitive105On: aStream	aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {		const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), arg4Val = arg4.valueOf(), bytes = this.bytes, arg3storageType = arg3._class().prototype.storageType;		if (arg1Val > 0 && arg2Val >= arg1Val && arg4Val > 0 && (arg1Val | 0) === arg1Val && (arg2Val | 0) === arg2Val && bytes && arg2Val <= bytes.length && arg3storageType === "bytes" && (arg4Val | 0) === arg4Val) {			const start = arg1Val - 1, replacementStart = arg4Val - 1, replacementEnd = replacementStart + arg2Val - start;			let replacement;			if (typeof arg3 === "bigint") {				let asString = (arg3 >= 0 ? arg3 : -arg3).toString(16);				const length = (asString.length + 1) >>> 1;				if (replacementEnd > length)					return [false];				const doubleLength = length << 1;				asString = asString.padStart(doubleLength, "0");				replacement = new Uint8Array(replacementEnd - replacementStart);				for (let i = replacementEnd - 1, j = 0; i >= replacementStart; i--) {					const j = doubleLength - (i << 1);					replacement[i - replacementStart] = parseInt(asString.slice(j - 2, j), 16);				}			} else {				const arg3bytes = arg3.bytes;				if (arg3bytes === undefined || replacementEnd > arg3bytes.length)					return [false];				replacement = arg3bytes.slice(replacementStart, replacementEnd);			}			bytes.set(replacement, start);			this.dirty = true;			return [true, this]}		else return [false]},';			crtab! !!LargePositiveInteger class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:37'!requiresJsCacheSync	^true! !!ParseNode methodsFor: 'JavaScript generation' stamp: 'fm 5/17/2022 02:10'!jsLiteralIndexUsing: parentCompiledCode	^nil! !!ParseNode methodsFor: 'JavaScript generation' stamp: 'fm 4/3/2022 00:16'!printJSCommentOn: aStream indent: indent 	self comment == nil ifTrue: [^ self].	1 to: self comment size do: [:index | | c |		index > 1 ifTrue: [aStream crtab: indent].		c := self comment at: index.		((c beginsWith: '<JS>') and: [c endsWith: '</JS>']) ifTrue: [			aStream nextPutAll: (c copyFrom: 5 to: c size - 5).		] ifFalse: [			aStream nextPutAll: '/*'.			(c findTokens: '/*') do: [:piece | aStream nextPutAll: piece] separatedBy: [aStream nextPutAll: '//'].			aStream nextPutAll: '*/'		].	]! !!ParseNode methodsFor: 'JavaScript generation' stamp: 'fm 7/20/2020 23:45'!printJSOn: aStream indent: level precedence: p properties: aDict	self printJSOn: aStream indent: level properties: aDict! !!ParseNode methodsFor: 'JavaScript generation' stamp: 'fm 7/20/2020 23:52'!printJSOn: aStream indent: anInteger properties: aDict	"If control gets here, avoid recursion loop."	super printOn: aStream! !!ParseNode methodsFor: 'printing' stamp: 'fm 10/2/2020 23:41'!printCommentOn: aStream indent: indent 	self comment == nil ifTrue: [^ self].	1 to: self comment size	   do: [:index |		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $";			nextPutAll: (self comment at: index);			nextPut: $"]! !!ParseNode methodsFor: 'testing' stamp: 'fm 7/6/2022 22:53'!isLiteralLike	^ false! !!ParseNode methodsFor: 'private' stamp: 'fm 3/23/2022 14:12'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.	Break the string at word breaks, given the widths in the default	font, at 450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |	readStream := ReadStream on: aString.	font := TextStyle default defaultFont.	tabWidth := TextStyle default tabWidth.	spaceWidth := font widthOf: Character space.	position := indent * tabWidth.	lineBreak := 450.	[readStream atEnd]		whileFalse: 			[word := self nextWordFrom: readStream setCharacter: [:lc | lastChar := lc].			wordWidth := word inject: 0 into: [:width :char | width + (font widthOf: char)].			position := position + wordWidth.			position > lineBreak				ifTrue: 					[(position > (indent * tabWidth + wordWidth)) ifTrue: [aStream skip: -1].					aStream crtab: indent.					position := indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					word isEmpty ifFalse: [aStream nextPutAll: word; space]]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position := position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream skip: -1; crtab: indent.							position := indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !!ParseNode methodsFor: 'transforming' stamp: 'fm 8/30/2014 16:20'!couldBeAffectedByReordering	^true! !!ParseNode methodsFor: 'transforming' stamp: 'fm 8/24/2014 23:31'!isCascade	^false! !!ParseNode methodsFor: 'transforming' stamp: 'fm 9/23/2020 18:05'!isFixedValue	^false! !!ParseNode methodsFor: 'transforming' stamp: 'fm 12/12/2020 01:01'!isLoopStatement	^false! !!ParseNode methodsFor: 'transforming' stamp: 'fm 12/27/2020 15:38'!isRealReturn	^false! !!ParseNode methodsFor: 'transforming' stamp: 'fm 9/23/2020 11:08'!nodesWithParentsDo: aBlock	self accept: (ParseNodeWithParentsEnumerator ofBlock: aBlock)! !!ParseNode methodsFor: 'transforming' stamp: 'fm 10/1/2020 01:39'!privateCopy	"There is (at least) a clash with MessageNode>>sizeCodeForValue:, which does a copy of special selectors, so we use our own method name to avoid conflict"	^self shallowCopy privatePostCopy! !!ParseNode methodsFor: 'transforming' stamp: 'fm 8/28/2014 00:13'!replace: childNode with: otherNode	^false! !!ParseNode methodsFor: 'transforming' stamp: 'fm 9/22/2020 12:57'!sameAs: aNode	^self = aNode! !!ParseNode methodsFor: '*Etoys-Squeakland-Tweak-Kedama' stamp: 'yo 10/12/2005 11:16'!isLeaf	^ false.! !!AssignmentNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 12:02'!isJSexpression	^true! !!AssignmentNode methodsFor: 'JavaScript generation' stamp: 'fm 7/20/2020 23:45'!printJSOn: aStream indent: level precedence: p properties: aDict	aStream nextPut: $(.	self printJSOn: aStream indent: level properties: aDict.	aStream nextPut: $)! !!AssignmentNode methodsFor: 'JavaScript generation' stamp: 'fm 11/18/2022 00:35'!printJSOn: aStream indent: level  properties: aDict	| tempStream seen |		((variable isKindOf: RemoteTempVectorNode) and: 	[(value isKindOf: NewArrayNode) or: [value isMessageNode and: [value selector key == #new:]]]) ifTrue: [			tempStream := (String new: 16) writeStream.		seen := aDict at: variable ifAbsent: [Set new].		variable remoteTemps do: [:tempVariableNode | 			(seen includes: tempVariableNode key) ifFalse: [				tempStream nextPut: $_;					nextPutAll: (seen add: tempVariableNode key);					nextPutAll: ' = nil, ']].		tempStream size > 0 ifTrue: [			aStream nextPutAll: 'let ';				nextPutAll: (tempStream contents copyFrom: 1 to: tempStream size - 2)].		^self	].	variable printJSOn: aStream indent: level properties: aDict.	aStream nextPutAll: ' = '.	value printJSOn: aStream indent: level + 2 properties: aDict! !!AssignmentNode methodsFor: 'transforming' stamp: 'fm 10/1/2020 01:39'!privatePostCopy	value := value privateCopy! !!AssignmentNode methodsFor: 'transforming' stamp: 'fm 8/28/2014 00:11'!replace: childNode with: otherNode	variable == childNode ifTrue: [		variable := otherNode.		^true].	value == childNode ifTrue: [		value := otherNode.		^true].	^false! !!AssignmentNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 10:41'!sameAs: aNode	^aNode isAssignmentNode and: [(variable sameAs: aNode variable) and: [value sameAs: aNode value]]! !!BlockNode methodsFor: 'accessing' stamp: 'fm 9/13/2020 11:45'!optimizedMessageNode: parentMessageNode	optimizedMessageNode := parentMessageNode! !!BlockNode methodsFor: 'equation translation' stamp: 'fm 6/30/2022 00:35'!statements: val	val isEmpty ifTrue: [		Transcript show: 'argument is ', val fullPrintString; cr.		self halt: 'empty argument'].	statements := val.	1 to: val size - 1 do: [:i | 		(val at: i) class == ReturnNode ifTrue: [			Transcript show: 'argument is ', val fullPrintString; cr.			self halt: 'found return node at index ', i, ' out of ', val size. 			"Maybe it's legit"			returns := true.			statements := statements copyFrom: 1 to: i.			^self		]. 		(val at: i)  == (val at: i + 1) ifTrue: [			Transcript show: 'argument is ', val fullPrintString; cr.			self halt: 'found duplicate (identical) statements at index ', i "should not happen"]].	(returns and: [statements last isReturningIf]) ifFalse: [		returns := statements last isKindOf: ReturnNode].! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 1/8/2022 21:02'!JSprintEntryPreemptionOn: aStream indent: level properties: propsDict.	aStream nextPutAll: 'if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("';		nextPutAll: (propsDict at: #methodClass) name;		nextPutAll: '>>';		nextPutAll: (propsDict at: #methodSelector);		nextPutAll: ', checking interrupts:", true, false);';		cr;		crtab: level! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 10/17/2020 23:59'!firstRealStatement	^remoteTempNode ~~ nil 		ifTrue: [statements at: 2]		ifFalse: [statements at: 1]	! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 09:51'!ignoresOwnLocalReturn	^(optimized and: 		[optimizedMessageNode selector key == #repeat or: 		[optimizedMessageNode isLoopStatement and: 			[self ~~ optimizedMessageNode receiver]]]) or: 	[optimizedMessageNode notNil and: 		[self ~~ optimizedMessageNode receiver and: 			[#(ensure: ifCurtailed: valueNoContextSwitch) includes: optimizedMessageNode selector key]]]! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:50'!isJSexpression	^true! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 00:16'!isJSoptimized	"The return value may be different for the same receiver depending of the transformation stage"	^optimized or: [optimizedMessageNode notNil and: [#(ensure: ifCurtailed: timesRepeat: valueNoContextSwitch) includes: optimizedMessageNode selector key]]	! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 09:52'!isJSoptimizedValueBlock	"The return value may be different for the same receiver depending of the transformation stage"	^optimizedMessageNode notNil and: 		[#ifTrue:ifFalse: == optimizedMessageNode selector key or: 		[((#(caseOf: caseOf:otherwise:) includes: optimizedMessageNode selector key) and: 			[optimizedMessageNode arguments last == self or: 				[optimizedMessageNode arguments first elements anySatisfy: [:a | a arguments first == self]]]) or: 		[self == optimizedMessageNode receiver and: 			[#(ensure: ifCurtailed: valueNoContextSwitch) includes: optimizedMessageNode selector key]]]]! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 11/18/2022 10:48'!printJSBodyOn: aStream indent: level properties: aDict	| tempDefinitions seen toRemove definedNames addedTempVectors temps |	(self isJust: NodeNil) ifTrue: [		^self].		tempDefinitions := #().	(temporaries isNil or: [temporaries isEmpty]) ifFalse: [		seen := Set new.		temps := temporaries reject: [:e | e isIndirectTempVector].		temps size < temporaries size ifTrue: [			temps := temps asOrderedCollection.			temporaries do: [:e | e isIndirectTempVector ifTrue: [temps addAll: e remoteTemps]]].		tempDefinitions := statements select: [:s | s isAssignmentNode and: [(temps includes: s variable) and: [(seen includes: s variable key) not and: [seen add: s variable key. true]]]].		toRemove := OrderedCollection new.		addedTempVectors := Set new.		tempDefinitions do: [:def | | referencedBeforeDef tempVector |			referencedBeforeDef := false.			1 to: (statements indexOf: def) do: [:i |				referencedBeforeDef ifFalse: [					(statements at: i) value nodesDo: [:e | 						(referencedBeforeDef not and: [e isVariableNode and: [e key = def variable key]]) ifTrue: 							[referencedBeforeDef := true]]]].			referencedBeforeDef ifTrue: [				toRemove add: def			] ifFalse: [				(temporaries includes: def variable) ifFalse: [					tempVector := temporaries detect: [:e | e isIndirectTempVector and: [e remoteTemps includes: def variable]].					(aDict at: tempVector ifAbsentPut: [Set new]) add: def variable key.					addedTempVectors add: tempVector				].			]].		toRemove do: [:def | tempDefinitions remove: def].	].	tempDefinitions isEmpty ifTrue: [		(self printJSTemporaries: temporaries on: aStream doPrior: []) ifTrue:			[aStream crtab: level].		self printJSStatementsOn: aStream indent: level properties: aDict.	] ifFalse: [		definedNames := (tempDefinitions collect: [:def | def variable key]) asSet.		(self printJSTemporaries: (temporaries reject: [:e | definedNames includes: e key]) on: aStream doPrior: []) ifTrue:			[aStream crtab: level].		self printJSStatementsOn: aStream indent: level properties: aDict definitions: tempDefinitions.		addedTempVectors do: [:e |			aDict removeKey: e]	].! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 7/22/2020 11:46'!printJSOn: aStream indent: level precedence: p properties: aDict	aStream nextPut: $(.	self printJSOn: aStream indent: level properties: aDict.	aStream nextPut: $)! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 12:37'!printJSOn: aStream indent: level properties: aDict	| actualStream parentBlocks compiledMethodOrFuncRef immediateParent compiledBlocksDict i parentBlock s shouldUseSelf index value compiledBlock compiledMethod persistentClosure |	actualStream := (persistentClosure := aDict at: #ThisBlock ifAbsent: []) == self ifTrue: [		aDict at: #ActualStream	] ifFalse: [		aStream].	parentBlocks := aDict at: #functions ifAbsent: [#()].	shouldUseSelf := persistentClosure notNil or: [parentBlocks anySatisfy: [:a | a isJSoptimized not]].	(shouldUseSelf and: [(aDict includesKey: #selfInsideBlock) not]) ifTrue: [self halt].	compiledMethodOrFuncRef := persistentClosure isNil ifTrue: [		(aDict at: #methodSelector) JSmapping	] ifFalse: [		'compiledMethod'	].	compiledBlocksDict := aDict at: #compiledBlocksDict ifAbsent: [].	compiledMethod := aDict at: #compiledMethod.	immediateParent := parentBlocks notEmpty ifTrue: [ | path parent |		i := s := parentBlocks size.		[i > 0 and: [(parentBlock := parentBlocks at: i) isJSoptimized]] whileTrue: [i := i - 1].		i = 0 ifTrue: [			path := compiledMethodOrFuncRef.			parent := compiledMethod.		] ifFalse: [			persistentClosure == self ifTrue: [				path := compiledMethodOrFuncRef.				parent := compiledMethod.				i := 0			] ifFalse: [				path := aDict at: parentBlock]].		compiledBlocksDict notNil ifTrue: [			parent isNil ifTrue: [				parent := compiledBlocksDict at: parentBlock].			i := i + 1.			[i <= s] whileTrue: [path := path, '.literals[', (parent indexOfLiteral: (parent := compiledBlocksDict at: (parentBlocks at: i))), ']'. i := i + 1].			compiledBlock := compiledBlocksDict at: self.			parent == compiledBlock outerCode ifFalse: [self halt].			index := parent indexOfLiteral: compiledBlock.			index = 0 ifTrue: [self halt]		].		path	] ifFalse: [		compiledBlocksDict notNil ifTrue: [			compiledBlock := compiledBlocksDict at: self.			compiledMethod == compiledBlock outerCode ifFalse: [self halt].			index := compiledMethod indexOfLiteral: compiledBlock .			index = 0 ifTrue: [self halt]		].		compiledMethodOrFuncRef	].	actualStream nextPutAll: '(function* ';		nextPutAll: (aDict at: self);		nextPutAll: '('.	arguments 		do: [:arg | 			actualStream nextPut: $_; 				nextPutAll: arg key] 		separatedBy: [actualStream nextPutAll: ', '].	actualStream nextPutAll: ') {'.	(self isMostlyEmptyBlock and: 	[((value := statements first) isLiteralLike and: [value isInlinedJsLiteral]) or: 		[value isVariableNode and: [value isArg or: [value isFixedValue or: [value isSelfPseudoVariable]]]]])	ifTrue: [			actualStream nextPutAll: 'return '.			value isSelfPseudoVariable ifTrue: [				(aDict includesKey: #selfInsideBlock) ifFalse: [self halt].				actualStream nextPutAll: 'self'.			] ifFalse: [				value printJSOn: actualStream indent: level properties: aDict.			].	] ifFalse: [		actualStream crtab: level.		self JSprintEntryPreemptionOn: actualStream indent: level properties: aDict.		(aDict at: #Instvars ifAbsent: []) == self ifTrue: [			actualStream nextPutAll: 'const instvars = self.pointers;';				crtab: level].		self printJsLiteralsAndBodyOn: actualStream indent: level properties: aDict. 		actualStream crtab: level	].	actualStream nextPutAll: '}).set'.	index notNil ifTrue: [		actualStream nextPutAll: 'Full'	].	actualStream nextPut: $(;		nextPutAll: (shouldUseSelf ifTrue: ['self, '] ifFalse: ['this, ']);		nextPutAll: self copiedValues size printString;		nextPutAll: ', ';		nextPutAll: immediateParent.	index notNil ifTrue: [		actualStream			nextPutAll: ', ';			nextPutAll: index printString	] ifFalse: [		(aDict at: #blockPCsOk) ifTrue: [			actualStream				nextPutAll: ', ';				nextPutAll: self pc printString		] ifFalse: [self halt].	].	actualStream		nextPutAll: ')'.! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 11/17/2022 18:07'!printJSStatementsOn: aStream indent: levelOrZero properties: aDict	| shown thisStatement level hasLocalReturn |	level := 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printJSCommentOn: aStream indent: level.			aStream crtab: level].	hasLocalReturn := self isJSoptimized not and: [(aDict at: #functions ifAbsent: [#()]) includes: self].	shown := statements size.	1 to: shown do: 		[:i | 		thisStatement := statements at: i.		(i = shown and: [hasLocalReturn and: [thisStatement isJSexpression]]) 			ifTrue: [aStream nextPutAll: 'return '].		thisStatement printJSOn: aStream indent: level properties: aDict.		(aStream peekLast = $} or: [aStream peekLast = $; or: [aStream peekLast isSeparator]]) ifFalse: [			aStream nextPut: $;].		i < shown 			ifTrue: [aStream crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printJSCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 11/17/2022 18:08'!printJSStatementsOn: aStream indent: levelOrZero properties: aDict definitions: tempDefinitions	| shown thisStatement level hasLocalReturn |	level := 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printJSCommentOn: aStream indent: level.			aStream crtab: level].	hasLocalReturn := self isJSoptimized not and: [(aDict at: #functions ifAbsent: [#()]) includes: self].	shown := statements size.	1 to: shown do: 		[:i | 		thisStatement := statements at: i.		(tempDefinitions includes: thisStatement) ifTrue: [			aStream nextPutAll: 'let '		] ifFalse: [			(i = shown and: [hasLocalReturn and: [thisStatement isJSexpression]]) ifTrue: [				aStream nextPutAll: 'return ']].		thisStatement printJSOn: aStream indent: level properties: aDict.		(aStream peekLast = $} or: [aStream peekLast = $; or: [aStream peekLast isSeparator]]) ifFalse: [			aStream nextPut: $;].		(i = shown and: [hasLocalReturn and: [thisStatement isJSexpression and: [tempDefinitions includes: thisStatement]]]) 			ifTrue: [				aStream nextPutAll: 'return '.				thisStatement variable printJSOn: aStream indent: level properties: aDict].		i < shown 			ifTrue: [aStream crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printJSCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 11/18/2022 10:30'!printJSTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	| tempStream seen |	(tempSequence isNil or: [tempSequence isEmpty]) ifTrue: 		[^false].	tempStream := (String new: 16) writeStream.	"This is for the decompiler which canmot work out which optimized block a particular temp is	 local to and hence may produce diplicates as in		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"	tempStream nextPutAll: 'let '.	seen := Set new.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifFalse:				[(tempNode scope >= -1				  and: ["This is for the decompiler which may create a block arg when converting						a while into a to:do: but won't remove it form temporaries"					   tempNode isBlockArg not				  and: [(seen includes: tempNode key) not]]) ifTrue:					[tempStream nextPut: $_; nextPutAll: (seen add: tempNode key); nextPutAll: ' = nil, ']]].	tempStream position = 4 ifTrue:		[^false].	aBlock value.	aStream nextPutAll: (tempStream contents copyFrom: 1 to: tempStream size - 2); nextPut: $;.	^true! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 7/28/2022 12:15'!printJsLiteralsAndBodyOn: aStream indent: level properties: aDict	| literalsDict literalRefs holderPath |	(self isJust: NodeNil) ifTrue: [		^self].		literalsDict := (aDict at: #literalsDict ifAbsent: []) ifNotNil: [:l | l at: self ifAbsent: []].	(literalsDict notNil and: [(literalRefs := literalsDict at: #thisMethodLiteralsRef ifAbsent: [#()]) notEmpty]) ifTrue: [		holderPath := literalsDict at: #holderPath.		(holderPath isEmpty or: [holderPath beginsWith: '.literals[']) ifTrue: [			holderPath := ((aDict includesKey: #ThisBlock) ifTrue: ['compiledMethod'] ifFalse: [(aDict at: #methodSelector) JSmapping]), holderPath.		].		literalRefs size > 1 ifTrue: [			aStream nextPutAll: 'const thisMethodLiterals = ';				nextPutAll: holderPath;				nextPutAll: '.literals;';				crtab: level.		].		(literalsDict at: #reusedLiterals ifAbsent: [#()]) do: [:litIx | 			aStream nextPutAll: 'const literal';				nextPutAll: litIx printString;				nextPutAll: (literalRefs size > 1 ifTrue: [' = thisMethodLiterals['] ifFalse: [' = ', holderPath, '.literals[']);				nextPutAll: litIx printString.			(((aDict at: #compiledBlocksDict) at: self) literalAt: litIx) isVariableBinding ifTrue: [				aStream nextPutAll: '].pointers;'			] ifFalse: [				aStream nextPutAll: '];'			].			aStream crtab: level.		]	].	(aDict at: #functions ifAbsentPut: [OrderedCollection new]) add: self.	self printJSBodyOn: aStream indent: level properties: aDict.	(aDict at: #functions) remove: self.! !!BlockNode methodsFor: 'JavaScript generation' stamp: 'fm 10/27/2022 00:51'!withoutImplicitReturns	| copy statementsCopy |	(self statements ifEmpty: [^ self]) last isImplicitReturn		ifFalse: [^ self].	copy := self copy.	"leave the empty check in BlockNode>>statements: as-is, just work around it"	statementsCopy := self statements asOrderedCollection.	copy statements: statementsCopy.	statementsCopy removeLast.	^copy! !!BlockNode methodsFor: 'printing' stamp: 'fm 10/6/2022 22:22'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level := 1 max: levelOrZero.	comment ifNotNil: 		[self printCommentOn: aStream indent: level.		aStream crtab: level].	len := shown := statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown := 1 max: shown - 1]		ifFalse: ["should a trailing nil be printed or not? Not if it is an implicit result, not if the last statement answers nil."				(len = 1 and: [(statements at: len) == NodeNil])					ifTrue: [shown := 0]].	1 to: shown do: 		[:i | 		thisStatement := statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'testing' stamp: 'fm 7/24/2022 22:06'!isMostlyEmptyBlock	^statements size = 1 and: [statements first isKindOf: LeafNode]! !!BlockNode methodsFor: 'transforming' stamp: 'fm 6/15/2021 21:46'!addStatement: s before: existing	| length newStatements |	statements isArray ifTrue: [		length := statements size.		newStatements := Array new: length + 1.		1 to: length do: [:index | 			(statements at: index) = existing ifTrue: [				newStatements					replaceFrom: 1 to: index - 1 with: statements startingAt: 1;					at: index put: s;					replaceFrom: index + 1 to: length + 1 with: statements startingAt: index.				statements := newStatements.				^self			]		].		self halt.	] ifFalse: [		statements add: s before: existing	]! !!BlockNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 12:37'!copiedValues	^copiedValues ifNil: [#()]! !!BlockNode methodsFor: 'transforming' stamp: 'fm 10/12/2020 15:18'!moved: someStatements to: anotherTempsHolder	| tempsToMove anotherKeys |	self returns: false.	self temporaries isEmpty 		ifTrue: [^self].	tempsToMove := OrderedCollection new.	self temporaries do: [:t | | referenced key i |		referenced := false.		key := t key.		i := 1.		[referenced or: [i > someStatements size]] whileFalse: [ 			(someStatements at: i) accept: (ParseNodeEnumerator								ofBlock: [:n| (n isTemp and: [n key = key]) ifTrue: [referenced := true]]								select: [:n| referenced not]).			i := i + 1].		referenced ifTrue: [tempsToMove add: t].	].	tempsToMove notEmpty ifTrue: [		self temporaries: (self temporaries copyWithoutAll: tempsToMove).		anotherKeys := anotherTempsHolder temporaries collect: [:t | t key].		anotherTempsHolder temporaries: anotherTempsHolder temporaries , (tempsToMove reject: [:t | anotherKeys includes: t key])]! !!BlockNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:26'!privatePostCopy	temporaries := temporaries copy.	statements := statements copy.	statements withIndexDo: [:statement :index|		statements at: index put: statement privateCopy].	copiedValues notNil ifTrue: [		copiedValues := copiedValues copy.		copiedValues withIndexDo: [:copiedValue :index|			copiedValues at: index put: copiedValue privateCopy]].! !!BlockNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:27'!replace: childNode with: otherNode	statements withIndexDo: [:statement :index|		statement == childNode ifTrue: [			((statement isKindOf: ReturnNode) and: [(otherNode isKindOf: ReturnNode) not])				ifTrue: [returns := false].			(otherNode isKindOf: ReturnNode)				ifTrue: [returns := true. index == statements size ifFalse: [self halt]].			statements at: index put: otherNode.			(childNode comment ~~ nil and: [childNode comment size > 0]) ifTrue: [				(otherNode comment ~~ nil and: [otherNode comment size > 0 and: [childNode comment ~= otherNode comment]]) ifTrue: [					self halt				] ifFalse: [					otherNode comment: childNode comment]				].			^true		]].	^false! !!BlockNode methodsFor: 'transforming' stamp: 'fm 12/27/2020 21:51'!returns: aBoolean	returns := aBoolean.(returns and: [(statements last isReturningIf or: [statements last class == ReturnNode]) not]) ifTrue: [self halt].(returns not and: [statements last class == ReturnNode]) ifTrue: [self halt].! !!BlockNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 12:37'!sameAs: aNode	^aNode isBlockNode and: 	[(arguments sameAs: aNode arguments) and: 	[(temporaries sameAs: aNode temporaries) and: 	[(statements sameAs: aNode statements) and: 	[self copiedValues sameAs: aNode copiedValues]]]]! !!BraceNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:27'!privatePostCopy	elements := elements copy.	elements withIndexDo: [:element :index|		elements at: index put: element privateCopy].! !!BraceNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:27'!replace: childNode with: otherNode	elements withIndexDo: [:statement :index|		statement == childNode ifTrue: [			elements at: index put: otherNode.			^true]].	^false! !!BraceNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 10:51'!sameAs: aNode	^aNode class == BraceNode and: [elements sameAs: aNode elements]! !!BraceNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 12:05'!isJSexpression	^true! !!BraceNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 12:18'!printJSOn: aStream indent: level properties: aDict	Array JSinstantiationOn: aStream withArgs: elements argsBlock: [:each | each printJSOn: aStream indent: level properties: aDict]! !!BytecodeEncoder methodsFor: 'testing' stamp: 'eem 1/10/2018 13:56'!supportsFullBlocks	"Answer if the instruction set supports full closures (closure creation from	 specfic methods instead of bytecodes embedded in an outer home method)."	^self subclassResponsibility! !!BytecodeEncoder methodsFor: 'method generation' stamp: 'fm 12/17/2022 23:53'!generateMethodOfClass: aCompiledMethodClass trailer: trailer from: methodNode	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.	 The argument, trailer, is arbitrary but is typically either the reference to the source code	 that is stored with every CompiledMethod, or an encoding of the method's temporary names."	| primErrNode blkSize nLits locals literals header method stack |	primErrNode := methodNode primitiveErrorVariableName ifNotNil:						[self fixTemp: methodNode primitiveErrorVariableName].	methodNode ensureClosureAnalysisDone.	self rootNode: methodNode. "this is for BlockNode>>sizeCodeForClosureValue:"	blkSize := (methodNode block sizeCodeForEvaluatedValue: self)				+ (methodNode primitive > 0					ifTrue: [self sizeCallPrimitive: methodNode primitive]					ifFalse: [0])				+ (primErrNode					ifNil: [0]					ifNotNil:						[primErrNode							index: methodNode arguments size + methodNode temporaries size;							sizeCodeForStore: self "The VM relies on storeIntoTemp: (129)"]).	locals := methodNode arguments, methodNode block temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).	self noteBlockExtent: methodNode block blockExtent hasLocals: locals.	header := self computeMethodHeaderForNumArgs: methodNode arguments size					numTemps: locals size					numLits: (nLits := (literals := self allLiterals) size)					primitive: methodNode primitive.	method := trailer					createMethod: blkSize					class: aCompiledMethodClass					header: header.	1 to: nLits do:		[:lit |		(method literalAt: lit put: (literals at: lit)) isCompiledCode ifTrue:			[(literals at: lit) outerCode: method]].	self streamToMethod: method.	stack := ParseStack new init.	methodNode primitive > 0 ifTrue:		[self genCallPrimitive: methodNode primitive].	primErrNode ifNotNil:		[primErrNode emitCodeForStore: stack encoder: self].	stack position: method numTemps.	[methodNode block emitCodeForEvaluatedValue: stack encoder: self]		on: Error "If an attempt is made to write too much code the method will be asked"		do: [:ex|  "to grow, and the grow attempt will fail in CompiledCode class>>#newMethodViaNewError"			ex signalerContext sender method = (CompiledCode class>>#newMethodViaNewError)				ifTrue: [^self error: 'Compiler code size discrepancy']				ifFalse: [ex pass]].	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	stream position ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	^method! !!CascadeNode methodsFor: 'accessing' stamp: 'fm 10/5/2020 15:49'!sameAs: aNode	^aNode isCascade and: [(receiver sameAs: aNode receiver) and: [messages sameAs: aNode messages]]! !!CascadeNode methodsFor: 'testing' stamp: 'fm 8/24/2014 23:31'!isCascade	^true! !!CascadeNode methodsFor: 'transforming' stamp: 'fm 10/1/2020 01:41'!privatePostCopy	receiver := receiver privateCopy.! !!CascadeNode methodsFor: 'transforming' stamp: 'fm 10/2/2014 19:26'!replace: childNode with: otherNode	receiver == childNode ifTrue: [		receiver := otherNode.		^true].	^false! !!CommentNode methodsFor: '*Etoys-Squeakland-Tweak-Kedama' stamp: 'yo 10/12/2005 11:30'!isLeaf	^ true.! !!EncoderForV3 methodsFor: 'testing' stamp: 'eem 4/6/2017 10:39'!supportsFullBlocks	"Answer if the instruction set supports full closures (closure creation from	 specfic methods instead of bytecodes embedded in an outer home method)."		^false! !!FutureNode methodsFor: 'JavaScript generation' stamp: 'fm 9/20/2020 20:26'!isJSexpression	^true! !!FutureNode methodsFor: 'JavaScript generation' stamp: 'fm 10/23/2022 22:23'!printJSOn: aStream indent: anInteger properties: aDict	(futureArgs isNil or: [futureSelector isNil]) 		ifTrue: [			aStream nextPutAll: FutureMaker JSname;				nextPutAll: '._new()._setDeltaMSecs_target_(';				nextPutAll: (futureDelta isNil ifTrue: ['0'] ifFalse: [futureDelta key printString]);				nextPutAll: ', '.			receiver printJSOn: aStream indent: anInteger + 1 properties: aDict.			]		ifFalse: [			receiver printJSOn: aStream indent: anInteger precedence: nil properties: aDict.			aStream nextPutAll: '._futureSend_at_args_('.			futureSelector JSstoreOn: aStream.			aStream nextPutAll: ', '.			aStream nextPutAll: (futureDelta isNil ifTrue: ['0'] ifFalse: [futureDelta key printString]);				nextPutAll: ', '.			Array JSinstantiationOn: aStream withArgs: futureArgs argsBlock: [:each | each printJSOn: aStream indent: anInteger + 1 properties: aDict]							].	aStream nextPut: $)	! !!LeafNode methodsFor: '*Etoys-Squeakland-Tweak-Kedama' stamp: 'yo 10/12/2005 11:29'!isLeaf	^ true.! !!LeafNode methodsFor: 'transforming' stamp: 'fm 10/1/2020 01:38'!privateCopy	^self! !!LeafNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 16:16'!sameAs: aNode	^self class == aNode class and: [key = aNode key]! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 5/28/2022 23:34'!isInlinedJsLiteral	^((key class == ClassBinding or: [key class == Global]) and: [(Smalltalk bindingOf: key key asSymbol) == key]) or: 	[(key class == Association and: [(Undeclared bindingOf: key key asSymbol) == key]) or: 	[((key isKindOf: ArrayedCollection) and: [key size = 0]) or:	[key isInteger or:	[key isFloat or:	[key isCharacter]]]]]	! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:51'!isJSexpression	^true! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 7/6/2022 17:30'!isLiteralLike	^ true! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 7/6/2022 19:08'!jsLiteralIndexUsing: parentCompiledCode	^parentCompiledCode indexOfEqualLiteral: key ifAbsent: [self halt. nil]	! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 8/25/2022 10:38'!printJSOn: aStream indent: level precedence: p properties: aDict	(key isInteger and: [key isJSsafeInteger or: [key < 0]])		ifTrue: [			aStream nextPut: $(.			self printJSOn: aStream indent: level properties: aDict.			aStream nextPut: $)]		ifFalse: [			self printJSOn: aStream indent: level properties: aDict].! !!LiteralNode methodsFor: 'JavaScript generation' stamp: 'fm 7/28/2022 12:17'!printJSOn: aStream indent: level properties: aDict	| litIndex parent ix literalsHolderNode literalsDict blocksStack holderPath |	(self isInlinedJsLiteral not and: 	[blocksStack := aDict at: #functions ifAbsent: [#()].	ix := blocksStack size.	parent := ix > 0 ifTrue: [		(aDict at: #compiledBlocksDict ifAbsent: []) 			ifNil: [aDict at: #compiledMethod] 			ifNotNil: [:c |				[ix > 0 and: [(c at: (blocksStack at: ix) ifAbsent: []) isNil]] whileTrue: [ix := ix - 1].				ix > 0 ifTrue: [c at: (literalsHolderNode := blocksStack at: ix)] ifFalse: [aDict at: #compiledMethod]].	] ifFalse: [		aDict at: #compiledMethod	].	literalsHolderNode isNil ifTrue: [literalsHolderNode := #method].	(litIndex := self jsLiteralIndexUsing: parent) notNil and:	[(aDict includesKey: #ThisBlock) not]]) ifTrue: [		literalsDict := (aDict at: #literalsDict) at: literalsHolderNode.		((literalsDict at: #reusedLiterals ifAbsent: [#()]) includes: litIndex) ifTrue: [			aStream nextPutAll: 'literal';				nextPutAll: litIndex printString		] ifFalse: [			((literalsDict at: #thisMethodLiteralsRef ifAbsent: [#()]) size = 1) ifTrue: [				holderPath := literalsDict at: #holderPath.				(holderPath isEmpty or: [holderPath beginsWith: '.literals[']) ifTrue: [					holderPath := (aDict at: #methodSelector) JSmapping, holderPath.				].				aStream nextPutAll: holderPath;					nextPutAll: '.literals'			] ifFalse: [				aStream nextPutAll: 'thisMethodLiterals'			].			aStream nextPut: $[;				nextPutAll: litIndex printString;				nextPut: $].			key isVariableBinding ifTrue: [				aStream nextPutAll: '.pointers'			].		].		key isVariableBinding ifTrue: [			aStream nextPutAll: '[1]/* ';				nextPutAll: key key;				nextPutAll: ' */'		] ifFalse: [			((key isKindOf: ArrayedCollection) and: 			[key isString not or: 				[(key findDelimiters: String crlf startingAt: 1) > key size and: [(key findString: '*/') = 0]]]) ifTrue: [						aStream nextPutAll: '/* ';							nextPutAll: (key printStringLimitedTo: 50);							nextPutAll: ' */']		].	] ifFalse: [		(key isVariableBinding and: [key key isNil or: 		[((key class == ClassBinding or: [key class == Global]) and: [(Smalltalk bindingOf: key key asSymbol) == key]) or:		[key class == Association and: [(Undeclared bindingOf: key key asSymbol) == key]]]]) ifTrue: [			aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix.			key JSprintValueOn: aStream		] ifFalse: [			(litIndex notNil and: [aDict includesKey: #ThisBlock]) ifTrue: [				literalsDict := (aDict at: #literalsDict) at: literalsHolderNode.				holderPath := literalsDict at: #holderPath.				(holderPath isEmpty or: [holderPath beginsWith: '.literals[']) ifTrue: [					holderPath := 'compiledMethod', holderPath.				].				aStream nextPutAll: holderPath;					nextPutAll: '.literals[';					nextPutAll: litIndex printString;					nextPut: $].				key isVariableBinding ifTrue: [					aStream nextPutAll: '.pointers[1]/* ';					nextPutAll: key key;					nextPutAll: ' */'				] ifFalse: [					((key isKindOf: ArrayedCollection) and: 					[key isString not or: 						[(key findDelimiters: String crlf startingAt: 1) > key size and: [(key findString: '*/') = 0]]]) ifTrue: [							aStream nextPutAll: '/* ';								nextPutAll: (key printStringLimitedTo: 50);								nextPutAll: ' */']				].			] ifFalse: [				key JSstoreOn: aStream			]		]	].! !!LiteralNode methodsFor: 'transforming' stamp: 'fm 7/8/2022 16:37'!couldBeAffectedByReordering	^key isVariableBinding and: [key canAssign]! !!LiteralNode methodsFor: 'transforming' stamp: 'fm 7/8/2022 16:35'!isFixedValue	^key isVariableBinding not or: [key canAssign not]! !!LiteralNode methodsFor: 'transforming' stamp: 'fm 9/28/2020 01:10'!literalValueString	^key storeString! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2022 14:14'!JSprintCaseOn: aStream indent: level  properties: aDict	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode |	braceNode := arguments first.	aStream nextPutAll: 'switch('.	receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.	aStream nextPutAll: '.valueOf()) {'; crtab: level + 1.	braceNode casesForwardDo:		[:keyNode :valueNode :last | | caseValue |		aStream nextPutAll: 'case '.		caseValue := keyNode statements first.		(caseValue isVariableNode and: [caseValue key = 'true' or: [caseValue key = 'false' or: [caseValue key = 'nil']]])			ifTrue: [				aStream nextPutAll: caseValue key]			ifFalse: [				caseValue isLiteralNode					ifTrue: [						caseValue key JSprimitiveOn: aStream]					ifFalse: [						caseValue printJSOn: aStream indent: level + 1 precedence: precedence properties: aDict.						aStream nextPutAll: '.valueOf()'.						]				].		aStream nextPutAll: ': {'; crtab: level + 2.		valueNode printJSBodyOn: aStream indent: level + 2 properties: aDict.		valueNode returns ifFalse: [			aStream crtab: level + 2; nextPutAll: 'break;'].		aStream crtab: level + 2; nextPut: $}.		last 			ifTrue: [				aStream crtab: level + 1; nextPutAll: 'default: {'; crtab: level + 2.				arguments size = 2 ifTrue: [					arguments last printJSBodyOn: aStream indent: level + 2 properties: aDict.				] ifFalse: [					aStream nextPutAll: 'yield* SmalltalkGlobals._Error._signal_(SmalltalkGlobals._ByteString.from("Case not found (" + (yield* '.					receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.					aStream nextPutAll: '._printString()).valueOf() + "), and no otherwise clause"))'				].				aStream crtab: level + 2; nextPut: $}.				aStream nextPut: $}]			ifFalse: [				aStream crtab: level + 1]].	! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:35'!JSprintIfNil: aStream indent: level properties: aDict	selector key == #ifTrue:ifFalse: 		ifTrue: [self JSprintIfOn: aStream indent: level properties: aDict]		ifFalse: [self halt]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:12'!JSprintIfNilNotNil: aStream indent: level properties: aDict	selector key == #ifTrue:ifFalse: 		ifTrue: [self JSprintIfOn: aStream indent: level properties: aDict]		ifFalse: [self halt]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 12/18/2021 14:12'!JSprintIfOn: aStream indent: level properties: aDict	(arguments last isJust: NodeNil) ifTrue:		[aStream nextPutAll: 'if ('.		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ') {'.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("ifTrue:")) {'.		].		aStream crtab: level + 1.		arguments first printJSBodyOn: aStream indent: level + 1 properties: aDict.		^aStream  crtab: level; nextPut: $}].	(arguments first isJust: NodeNil) ifTrue:		[aStream nextPutAll: 'if (!!'.		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ') {'.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("ifFalse:")) {'.		].		aStream crtab: level + 1.		arguments last printJSBodyOn: aStream indent: level + 1 properties: aDict.		^aStream  crtab: level; nextPut: $}].	selector key == #and: ifTrue:		[receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ' && '.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("and:") && '.		].		arguments first statements size = 1 ifFalse: [self halt]. 		^arguments first statements first printJSOn: aStream indent: level precedence: precedence properties: aDict].	selector key == #or: ifTrue:		[receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ' || '.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("or:") || '.		].		arguments last statements size = 1 ifFalse: [self halt]. 		^arguments last statements last printJSOn: aStream indent: level precedence: precedence properties: aDict].	aStream nextPutAll: 'if ('.		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ') {'.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("ifTrue:ifFalse:")) {'.		].		aStream crtab: level + 1.		arguments first printJSBodyOn: aStream indent: level + 1 properties: aDict.		aStream crtab: level; nextPutAll: '} else {'; crtab: level + 1.		arguments last printJSBodyOn: aStream indent: level + 1 properties: aDict.		^aStream  crtab: level; nextPut: $}! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 12:23'!JSprintLoopPreemptionOn: aStream indent: level properties: aDict	aStream crtab: level + 1; 		nextPutAll: 'if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("';		nextPutAll: (aDict at: #methodClass) name;		nextPutAll: '>>';		nextPutAll: (aDict at: #methodSelector);		nextPutAll: ', checking interrupts:", ';		nextPutAll: ((aDict at: #functions ifAbsent: [#()]) anySatisfy: [:a | a isJSoptimized not]) printString;		nextPutAll: ', true);';		crtab: level;		nextPut: $}! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 7/25/2020 23:13'!JSprintRepeatOn: aStream indent: level properties: aDict	aStream nextPutAll: 'while (true) {'; crtab: level + 1.	receiver printJSBodyOn: aStream indent: level + 1 properties: aDict.	self JSprintLoopPreemptionOn: aStream indent: level properties: aDict! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 11/4/2022 01:33'!JSprintToDoOn: aStream indent: level properties: aDict	| index increment limit block toDoLimitNameIncrement toDoVarNameIncrement initialValue limitValue inc maxIntMinusInc |	initialValue := (arguments at: 4) value.	(arguments last isMemberOf: AssignmentNode) 		ifTrue: [			((initialValue isLiteralLike and: [initialValue isInlinedJsLiteral]) or: 			[initialValue isVariableNode and: [initialValue isArg or: [initialValue isFixedValue]]]) ifFalse: [				toDoVarNameIncrement := aDict at: #toDoVarNameIncrement put: (aDict at: #toDoVarNameIncrement ifAbsent: [0]) + 1.				(arguments at: 4) variable name: (arguments at: 4) variable name, toDoVarNameIncrement.				aStream nextPutAll: 'let '.				(arguments at: 4) printJSOn: aStream indent: level properties: aDict.				aStream nextPut: $;; 					crtab: level].			toDoLimitNameIncrement := aDict at: #toDoLimitNameIncrement put: (aDict at: #toDoLimitNameIncrement ifAbsent: [0]) + 1.			arguments last variable name: arguments last variable name, toDoLimitNameIncrement.			aStream nextPutAll: 'const '.			arguments last printJSOn: aStream indent: level properties: aDict.			aStream nextPut: $;; 				crtab: level].	aStream nextPutAll: 'for ('.	((arguments last isMemberOf: AssignmentNode) not or:	[(initialValue isLiteralLike and: [initialValue isInlinedJsLiteral]) or: 	[initialValue isVariableNode and: [initialValue isArg or: [initialValue isFixedValue]]]]) ifTrue: [		aStream nextPutAll: 'let '.		(arguments at: 4) printJSOn: aStream indent: level properties: aDict.	].	index := '_', (arguments at: 4) variable name.	increment := arguments at: 2.	aStream 		nextPutAll: '; ';		nextPutAll: index;		nextPutAll: (increment key > 0 ifTrue: [' <= '] ifFalse: [' >= ']).	limit := (arguments last isMemberOf: AssignmentNode) 		ifTrue: [arguments last variable] 		ifFalse: [arguments first].	limit printJSOn: aStream indent: level properties: aDict.	aStream 		nextPutAll: '; ';		nextPutAll: index.	limitValue := (arguments last isMemberOf: AssignmentNode) 		ifTrue: [arguments last value isConstantNumber ifTrue: [arguments last value key]].		increment key > 0 ifTrue: [		(increment key isInteger and: 				[(initialValue isConstantNumber and: [initialValue key isInteger and: 					[initialValue key >= 9007199254740992 or: [initialValue key <= -9007199254740992 or: 					[(limitValue isNil and: [9007199254740991 - initialValue key / increment key < 4294967296]) or: 					[limitValue notNil and: [limitValue >= 9007199254740992]]]]]]) or:				[initialValue isConstantNumber not and: 					[limitValue isNil or:					[limitValue >= 9007199254740992 or: [limitValue <= -9007199254740992 or: 					[9007199254740991 + limitValue / increment key < 4294967296]]]]]]		) ifTrue: [			increment key = 1 ifTrue: [				aStream 					nextPutAll: ' === 9007199254740991 ? ';					nextPutAll: index;					nextPutAll: ' = 9007199254740992n : (';					nextPutAll: index;					nextPutAll: ' === -9007199254740992n ? ';					nextPutAll: index;					nextPutAll: ' = -9007199254740991 : ';					nextPutAll: index;					nextPutAll: '++)'			] ifFalse: [				maxIntMinusInc := (9007199254740992 - increment key) printString.				inc := increment key printString.				aStream 					nextPutAll: ' = ';					nextPutAll: index;					nextPutAll: ' < ';					nextPutAll: maxIntMinusInc;					nextPutAll: ' && ';					nextPutAll: index;					nextPutAll: ' >= -9007199254740991 ? ';					nextPutAll: index;					nextPutAll: ' + ';					nextPutAll: inc;					nextPutAll: ' : (';					nextPutAll: index;					nextPutAll: ' > 9007199254740991 || ';					nextPutAll: index;					nextPutAll: ' < ';					nextPutAll: (-9007199254740991 - increment key) printString;					nextPutAll: 'n ? ';					nextPutAll: index;					nextPutAll: ' + ';					nextPutAll: inc;					nextPutAll: 'n : (';					nextPutAll: index;					nextPutAll: ' <= 9007199254740991 && ';					nextPutAll: index;					nextPutAll: ' >= ';					nextPutAll: maxIntMinusInc;					nextPutAll: ' ? BigInt(';					nextPutAll: index;					nextPutAll: ') + ';					nextPutAll: inc;					nextPutAll: 'n : Number(';					nextPutAll: index;					nextPutAll: ' + ';					nextPutAll: inc;					nextPutAll: 'n)))'			].		] ifFalse: [			(increment key = 1 and: [increment key isInteger])				ifTrue: [					aStream nextPutAll: '++']				ifFalse: [					aStream nextPutAll: ' += ';					nextPutAll: increment key printString]		].	] ifFalse: [		(increment key isInteger and: 				[(initialValue isConstantNumber and: [initialValue key isInteger and: 					[initialValue key >= 9007199254740992 or: [initialValue key <= -9007199254740992 or: 					[(limitValue isNil and: [9007199254740991 + initialValue key / increment key negated < 4294967296]) or: 					[limitValue notNil and: [limitValue <= -9007199254740992]]]]]]) or:				[initialValue isConstantNumber not and: 					[limitValue isNil or:					[limitValue >= 9007199254740992 or: [limitValue <= -9007199254740992 or: 					[9007199254740991 - limitValue / increment key negated < 4294967296]]]]]]		) ifTrue: [			increment key = -1 ifTrue: [				aStream 					nextPutAll: ' === -9007199254740991 ? ';					nextPutAll: index;					nextPutAll: ' = -9007199254740992n : (';					nextPutAll: index;					nextPutAll: ' === 9007199254740992n ? ';					nextPutAll: index;					nextPutAll: ' = 9007199254740991 : ';					nextPutAll: index;					nextPutAll: '--)'			] ifFalse: [				maxIntMinusInc := (9007199254740992 + increment key) printString.				inc := increment key negated printString.				aStream 					nextPutAll: ' = ';					nextPutAll: index;					nextPutAll: ' > -';					nextPutAll: maxIntMinusInc;					nextPutAll: ' && ';					nextPutAll: index;					nextPutAll: ' <= 9007199254740991 ? ';					nextPutAll: index;					nextPutAll: ' - ';					nextPutAll: inc;					nextPutAll: ' : (';					nextPutAll: index;					nextPutAll: ' < -9007199254740991 || ';					nextPutAll: index;					nextPutAll: ' > ';					nextPutAll: (9007199254740991 - increment key) printString;					nextPutAll: 'n ? ';					nextPutAll: index;					nextPutAll: ' - ';					nextPutAll: inc;					nextPutAll: 'n : (';					nextPutAll: index;					nextPutAll: ' >= -9007199254740991 && ';					nextPutAll: index;					nextPutAll: ' <= -';					nextPutAll: maxIntMinusInc;					nextPutAll: ' ? BigInt(';					nextPutAll: index;					nextPutAll: ') - ';					nextPutAll: inc;					nextPutAll: 'n : Number(';					nextPutAll: index;					nextPutAll: ' - ';					nextPutAll: inc;					nextPutAll: 'n)))'			].		] ifFalse: [			(increment key = -1 and: [increment key isInteger])				ifTrue: [					aStream nextPutAll: '--']				ifFalse: [					aStream nextPutAll: ' -= ';					nextPutAll: increment key negated printString]		]		].	aStream nextPutAll: ') {';		crtab: level + 1.	block := arguments at: 3.	block printJSBodyOn: aStream indent: level + 1 properties: aDict.	self JSprintLoopPreemptionOn: aStream indent: level properties: aDict! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 11/22/2022 08:51'!JSprintWhileOn: aStream indent: level properties: aDict	| preamble booleanExpr isGuaranteedBoolean noArg temporaries tempDefinitions seen temps toRemove definedNames addedTempVectors |	booleanExpr := receiver statements last.	preamble := receiver statements allButLast.	noArg := originalArguments size = 0 or: [originalArguments first isJust: NodeNil].	temporaries := receiver temporaries.	(preamble notEmpty or: [temporaries notEmpty]) ifTrue: [		tempDefinitions := #().		addedTempVectors := Set new.		temporaries notEmpty ifTrue: [			seen := Set new.			temps := temporaries reject: [:e | e isIndirectTempVector].			temps size < temporaries size ifTrue: [				temps := temps asOrderedCollection.				temporaries do: [:e | e isIndirectTempVector ifTrue: [temps addAll: e remoteTemps]]].			tempDefinitions := preamble select: [:s | s isAssignmentNode and: [(temps includes: s variable) and: [(seen includes: s variable key) not and: [seen add: s variable key. true]]]].			toRemove := OrderedCollection new.			tempDefinitions do: [:def | | referencedBeforeDef tempVector |				referencedBeforeDef := false.				1 to: (preamble indexOf: def) do: [:i |					referencedBeforeDef ifFalse: [						(preamble at: i) value nodesDo: [:e | 							(referencedBeforeDef not and: [e isVariableNode and: [e key = def variable key]]) ifTrue: 								[referencedBeforeDef := true]]]].				referencedBeforeDef ifTrue: [					toRemove add: def				] ifFalse: [					(temporaries includes: def variable) ifFalse: [ 						tempVector := temporaries detect: [:e | e isIndirectTempVector and: [e remoteTemps includes: def variable]].						(aDict at: tempVector ifAbsentPut: [Set new]) add: def variable key.						addedTempVectors add: tempVector					].				]].			toRemove do: [:def | tempDefinitions remove: def].		].		noArg ifFalse: [			aStream nextPutAll: 'var firstTime = true;	//declared var just in case there are multiple while loops in the same method';				crtab: level].		aStream nextPutAll: 'do {';			crtab: level + 1.		tempDefinitions isEmpty ifTrue: [			(receiver printJSTemporaries: temporaries on: aStream doPrior: []) ifTrue:				[aStream crtab: level + 1].		] ifFalse: [			definedNames := (tempDefinitions collect: [:def | def variable key]) asSet.			(receiver printJSTemporaries: (temporaries reject: [:e | definedNames includes: e key]) on: aStream doPrior: []) ifTrue:				[aStream crtab: level + 1].		].		noArg ifFalse: [			aStream nextPutAll: 'if (firstTime) {';				crtab: level + 2;				nextPutAll: 'firstTime = false;';				crtab: level + 1;				nextPutAll: '} else {';				crtab: level + 2.			originalArguments first printJSBodyOn: aStream indent: level + 2 properties: aDict.			aStream crtab: level + 1;				nextPut: $};				crtab: level + 1].		preamble 			do: [:statement | 				(tempDefinitions includes: statement) ifTrue: [					aStream nextPutAll: 'let '].				statement printJSOn: aStream indent: level + 1 properties: aDict.				(aStream peekLast = $} or: [aStream peekLast = $; or: [aStream peekLast isSeparator]]) ifFalse: [					aStream nextPut: $;]]			separatedBy:				[aStream crtab: level + 1].		addedTempVectors do: [:e |			aDict removeKey: e].		self JSprintLoopPreemptionOn: aStream indent: level properties: aDict.		aStream nextPutAll: ' while ('.		isGuaranteedBoolean := booleanExpr isMessageNode and: [booleanExpr selector key isOptimizedSelector].		(originalSelector beginsWith: 'whileFalse') 			ifTrue: [				aStream nextPut: $!!.				booleanExpr printJSOn: aStream indent: level precedence: precedence properties: aDict.				isGuaranteedBoolean ifFalse: [					aStream nextPutAll: '.booleanValueOf("whileFalse'.				].			] ifFalse: [				booleanExpr printJSOn: aStream indent: level precedence: precedence properties: aDict.				isGuaranteedBoolean ifFalse: [					aStream nextPutAll: '.booleanValueOf("whileTrue'.				].			].		isGuaranteedBoolean ifFalse: [			noArg ifFalse: [				aStream nextPut: $:].			aStream nextPutAll: '")'].		^aStream nextPutAll: ');'	].	aStream nextPutAll: 'while ('.	isGuaranteedBoolean := booleanExpr isMessageNode and: [booleanExpr selector key isOptimizedSelector].	(originalSelector beginsWith: 'whileFalse') 		ifTrue: [			aStream nextPut: $!!.			booleanExpr printJSOn: aStream indent: level precedence: precedence properties: aDict.			isGuaranteedBoolean ifFalse: [				aStream nextPutAll: '.booleanValueOf("whileFalse'.			].		] ifFalse: [			booleanExpr printJSOn: aStream indent: level precedence: precedence properties: aDict.			isGuaranteedBoolean ifFalse: [				aStream nextPutAll: '.booleanValueOf("whileTrue'.			].		].	isGuaranteedBoolean ifFalse: [		noArg ifFalse: [			aStream nextPut: $:].		aStream nextPutAll: '")'].	aStream nextPutAll: ') {'.	noArg ifFalse: [		aStream crtab: level + 1.		originalArguments first printJSBodyOn: aStream indent: level + 1 properties: aDict].	self JSprintLoopPreemptionOn: aStream indent: level properties: aDict.! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 8/17/2014 16:01'!isBig	^arguments size > 2				or: [{receiver} , arguments anySatisfy:						[:thisArg |						thisArg notNil						and: [(thisArg isBlockNode and: [thisArg isQuick not])							 or: [thisArg isMessageNode and: [thisArg isBig]]]]].! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 12/12/2020 00:52'!isJSexpression	self isOptimized ifTrue: [^#(and: or:) includes: selector key].	^self isJsOptimized not! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 9/17/2020 15:37'!isJStryFinally	^receiver isBlockNode and: [receiver numberOfArguments = 0 and: 	[arguments size = 1 and: [arguments first isBlockNode and: [arguments first numberOfArguments = 0 and: 	[#(ensure: ifCurtailed:) includes: selector key]]]]]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 22:40'!isJsOptimized	^(arguments size = 0 or: [arguments first isBlockNode and: [arguments first numberOfArguments = 0]]) and: 	[(receiver isBlockNode and: [receiver numberOfArguments = 0 and: 	[#(ensure: ifCurtailed: valueNoContextSwitch) includes: selector key]]) or: [#timesRepeat: == selector key]]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 10/11/2014 10:52'!macroSelector	"special > 0 denotes specially treated (potentially inlined) messages. "	^special > 0 ifTrue: [MacroSelectors at: special]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 10/23/2022 20:35'!printJSOn: aStream indent: level precedence: p properties: aDict	selector key isOptimizedSelector ifFalse: [		aStream nextPut: $(].	self printJSOn: aStream indent: level properties: aDict.	selector key isOptimizedSelector ifFalse: [		aStream nextPut: $)]! !!MessageNode methodsFor: 'JavaScript generation' stamp: 'fm 6/26/2023 14:26'!printJSOn: aStream indent: level properties: aDict	| indent arg doCrTab r t maybeExceptionClass superclass |	special > 0 ifTrue:		[^self perform: ('JS', self macroPrinter, 'properties:') asSymbol with: aStream with: level with: aDict].	receiver isBlockNode 		ifTrue: [			receiver optimized ifTrue: [self halt]. 			self isJStryFinally ifTrue: [				aStream nextPutAll: 'try {';					crtab: level + 1.				receiver printJsLiteralsAndBodyOn: aStream indent: level + 1 properties: aDict.				aStream crtab: level.				selector key == #ensure: ifTrue: [					aStream nextPutAll: '} finally {';						crtab: level + 1.				] ifFalse: [					selector key == #ifCurtailed: ifTrue: [						t := aDict at: #catchVariable put: (aDict at: #catchVariable ifAbsent: [0]) + 1.						r := 'catchVariable', t.						aStream nextPutAll: '} catch(';							nextPutAll: r;							nextPutAll: ') {if (';							nextPutAll: r;							nextPutAll: '.isNonLocalReturn ||  '; 							nextPutAll: r;							nextPutAll: ' === "TERMINATE") {'; 							crtab: level + 1.					] ifFalse: [self halt]				].				arguments first printJsLiteralsAndBodyOn: aStream indent: level + 1 properties: aDict.				selector key == #ifCurtailed: ifTrue: [					arguments first returns ifFalse: [						aStream crtab: level + 1;							nextPutAll: 'throw ';							nextPutAll: r					].					aStream crtab: level + 1;						nextPutAll: '} else';						crtab: level + 2;						nextPutAll: 'yield* SmalltalkVM.debug();';						crtab: level + 1				].				aStream crtab: level;					nextPut: $}.				^self			] ifFalse: [				#valueNoContextSwitch = selector key ifTrue: [					aStream nextPutAll: 'GlobalActivationCounter = Number.MAX_SAFE_INTEGER;';						crtab: level;						nextPutAll: 'try {';						crtab: level + 1.					receiver printJsLiteralsAndBodyOn: aStream indent: level + 1 properties: aDict.					aStream crtab: level;						nextPutAll: '} finally {';						crtab: level + 1;						nextPutAll: 'GlobalActivationCounter = 0;';						crtab: level;						nextPut: $}.					^self				]			].		].	(#(signal signal:) includes: selector key) ifTrue: [		"This is just a best effort - we will miss cases when the exception or its class is retrieved via a message,		  let's just hope that the receiver won't be needed in those cases"		(((maybeExceptionClass := receiver) isVariableNode and: [maybeExceptionClass key class == ClassBinding and: 		[(maybeExceptionClass key value includesBehavior: Exception) and: 		[(maybeExceptionClass key value class whichClassIncludesSelector: selector key) == Exception class]]]) 		or: 		[receiver isMessageNode and: [receiver selector key = #new and: 		[(maybeExceptionClass := receiver receiver) isVariableNode and: [maybeExceptionClass key class == ClassBinding and: 		[maybeExceptionClass key value includesBehavior: Exception]]]]]) ifTrue: [			aStream nextPutAll: 'yield* (yield* ';				nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;				nextPutAll: maybeExceptionClass key key;				nextPutAll: '._new()).setReceiver(';				nextPutAll: (((aDict at: #functions ifAbsent: [#()]) anySatisfy: [:a | a isJSoptimized not]) ifTrue: [					'self, '] ifFalse: ['this, ']);				nextPutAll: (aDict at: #methodSelector) JSmapping;				nextPutAll: '.compiledMethod).';				nextPutAll: (selector key JSmapping);				nextPut: $(.			doCrTab := self isBig.			1 to: arguments size do: [:i |				arg := arguments at: i.				doCrTab					ifTrue: [aStream crtab: level+1. indent := 1]					ifFalse: [aStream space. indent := 0].				arg printJSOn: aStream indent: level + 1 + indent properties: aDict.				i < arguments size ifTrue: [					aStream nextPutAll: ', ']].			^aStream nextPut: $)		]	].	selector key == #questionMark:colon: ifTrue:		[receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		(receiver isMessageNode and: [receiver selector key isOptimizedSelector]) ifTrue: [			aStream nextPutAll: ' ? '.		] ifFalse: [			aStream nextPutAll: '.booleanValueOf("questionMark:colon:") ? '.		].		arguments first printJSOn: aStream indent: level precedence: precedence properties: aDict.		aStream nextPutAll: ' : '.		^arguments last printJSOn: aStream indent: level precedence: precedence properties: aDict].	selector key == #translated ifTrue:	"avoid thisContext sender method"		[aStream nextPutAll: 'yield* '.		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		^aStream nextPutAll: '._translatedFor_(';				nextPutAll: (aDict at: #methodSelector) JSmapping;				nextPutAll: '.compiledMethod)'].	(#(deprecated deprecated: backwardCompatibilityOnly:) includes: selector key) ifTrue:	"avoid thisContext sender method"		[			aStream nextPutAll: 'yield* ';				nextPutAll: Deprecation JSname;				nextPutAll: '._signal_(SmalltalkGlobals._ByteString.from("';				nextPutAll: (aDict at: #methodClass) name;				nextPutAll: '>>';				nextPutAll: (aDict at: #methodSelector);				nextPutAll: ' has been deprecated'.			selector key == #backwardCompatibilityOnly: ifTrue:	[				aStream nextPutAll: ' (but will be kept for compatibility). '			].			doCrTab := self isBig.			1 to: arguments size do: [:i |				arg := arguments at: i.				aStream nextPutAll: '" + '.				doCrTab					ifTrue: [aStream crtab: level+1. indent := 1]					ifFalse: [indent := 0].				arg printJSOn: aStream indent: level + 1 + indent precedence: precedence properties: aDict.				"There can be at most one argument"				^aStream nextPutAll: '.valueOf()))'				].			^aStream nextPutAll: '"))'		].	selector key == #primitiveFailed ifTrue:	"avoid thisContext sender selector"		[aStream nextPutAll: 'yield* '.		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.		aStream nextPutAll: '._primitiveFailed_('.		(aDict at: #methodSelector) JSstoreOn: aStream.		^aStream nextPut: $)].	self isTimesRepeat ifTrue: [		t := aDict at: #timesRepeatNameIncrement put: (aDict at: #timesRepeatNameIncrement ifAbsent: [0]) + 1.		r := 'timesRepeatReceiver', t.		aStream nextPutAll: 'for (let ';			nextPutAll: r;			nextPutAll: ' = '.		receiver printJSOn: aStream indent: level properties: aDict.		aStream nextPutAll: '; ';		nextPutAll: r;		nextPutAll: ' > 0; ';		nextPutAll: r;		nextPutAll: '--) {';		crtab: level + 1.		arguments first printJsLiteralsAndBodyOn: aStream indent: level + 1 properties: aDict.		^self JSprintLoopPreemptionOn: aStream indent: level properties: aDict].	selector key isOptimizedSelector ifFalse: 		[aStream nextPutAll: 'yield* '].	(receiver isVariableNode and: [receiver key = 'super']) ifTrue: [		(superclass := (aDict at: #methodClass) superclass) notNil ifTrue: [			aStream nextPutAll: superclass JSprotoypeName		] ifFalse: [			aStream nextPutAll: 'dnuProxy'		].	] ifFalse: [		receiver printJSOn: aStream indent: level precedence: precedence properties: aDict.	].	aStream		nextPut: $.;		nextPutAll: selector key JSmapping.	(receiver isVariableNode and: [receiver key = 'super']) ifTrue: [		aStream nextPutAll: '.call('.		((aDict at: #functions ifAbsent: [#()]) anySatisfy: [:a |a isJSoptimized not]) ifTrue: [			(aDict includesKey: #selfInsideBlock) not ifTrue: [self halt].			aStream nextPutAll: 'self'] ifFalse: [aStream nextPutAll: 'this'].		arguments size > 0 ifTrue: [			aStream nextPutAll: ', '.		]	] ifFalse: [		aStream nextPut: $(.	].	doCrTab := self isBig.	1 to: arguments size do: [:i |		arg := arguments at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent := 1] "newline after big args"			ifFalse: [aStream space. indent := 0].		arg printJSOn: aStream indent: level + 1 + indent properties: aDict.		i < arguments size ifTrue: [			aStream nextPutAll: ', ']].	aStream nextPut: $)! !!MessageNode methodsFor: 'transforming' stamp: 'fm 7/8/2022 16:56'!couldBeAffectedByReordering	^(receiver notNil and: [receiver couldBeAffectedByReordering]) or: [selector key ~~ #class and: [(#(== ~~ = ~= + - * / // \\ | &) includes: selector key) not or: [arguments first couldBeAffectedByReordering]]]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 9/20/2020 13:26'!hasOptimizedValueBlocks	^self mayHaveOptimizedValueBlocks and: [self optimizedValueBlocks notEmpty]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 11/1/2020 22:54'!isFullyReturningFromOptimizedValueBlocks	| valueBlocks |	^self mayHaveOptimizedValueBlocks and: 		[(valueBlocks := self optimizedValueBlocks) notEmpty and: [valueBlocks allSatisfy: [:a | a returns]]]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 6/14/2021 23:15'!loopReturnValue	^special > 0 ifTrue: [(MacroTransformers at: special)		caseOf: {			[#transformToDo:] -> [receiver].			[#transformRepeat:] -> [NodeNil].			[#transformWhile:] -> [NodeNil].			}	] ifFalse: [		selector key == #timesRepeat: ifTrue: [			receiver		] ifFalse: [			self error: self selector key, ' is not one of the recognized optimized loop selectors']]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 1/16/2023 09:49'!mayHaveOptimizedValueBlocks	^#(caseOf: caseOf:otherwise: ensure: ifCurtailed: ifTrue:ifFalse: valueNoContextSwitch) includes: self selector key ! !!MessageNode methodsFor: 'transforming' stamp: 'fm 1/16/2023 09:57'!optimizedValueBlocks	^self selector key 		caseOf: {			[#caseOf:] -> [self isOptimized ifTrue: [arguments first elements collect: [:e | e arguments first]] ifFalse: [#()]].			[#caseOf:otherwise:] -> [self isOptimized 										ifTrue: [arguments last isJustCaseError 											ifTrue: [arguments first elements collect: [:e | e arguments first]]											ifFalse: [(arguments first elements collect: [:e | e arguments first]) copyWith: arguments last]] 										ifFalse: [#()]].			[#ensure:] -> [self isJStryFinally ifTrue: [{receiver}] ifFalse: [#()]].			[#ifCurtailed:] -> [self isJStryFinally ifTrue: [{receiver}] ifFalse: [#()]].			[#ifTrue:ifFalse:] -> [self isOptimized ifTrue: [{arguments first. arguments last}] ifFalse: [#()]].			[#valueNoContextSwitch] -> [self isJsOptimized ifTrue: [{receiver}] ifFalse: [#()]].			}		otherwise: [self error: self selector key, ' is not one of the recognized optimized selectors']! !!MessageNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:27'!privatePostCopy	receiver := receiver privateCopy.	(receiver isBlockNode and: [receiver optimizedMessageNode notNil]) ifTrue: [receiver optimizedMessageNode: self].	arguments := arguments copy.	arguments withIndexDo: [:arg :index | | newArg |		arg notNil ifTrue: [			newArg := arguments at: index put: arg privateCopy.			(newArg isBlockNode and: [newArg optimizedMessageNode notNil]) 				ifTrue: [newArg optimizedMessageNode: self].			(index = 1 and: [#(13 14) includes: special]) ifTrue: [				 newArg elements do: [ :messageNode |					messageNode receiver noteOptimizedIn: self.					messageNode arguments first noteOptimizedIn: self ]]]].! !!MessageNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:28'!replace: childNode with: otherNode	receiver == childNode ifTrue: [		receiver := otherNode.		(special > 0 and: [(MacroTransformers at: special) == #transformToDo: and: [arguments size >= 7]]) ifTrue: [			^(arguments at: 4) replace: childNode with: otherNode		] ifFalse: [			(receiver isBlockNode and: [receiver optimizedMessageNode notNil]) ifTrue: [receiver optimizedMessageNode: self].			^true		].	].	arguments withIndexDo: [:arg :index|		arg == childNode ifTrue: [			arguments at: index put: otherNode.			(otherNode isBlockNode and: [otherNode optimizedMessageNode notNil]) 				ifTrue: [otherNode optimizedMessageNode: self].			(index = 1 and: [special > 0 and: [(MacroTransformers at: special) == #transformCase:]]) ifTrue: [				 otherNode elements do: [ :messageNode |					messageNode receiver noteOptimizedIn: self.					messageNode arguments first noteOptimizedIn: self ]].			^true]].	^false! !!MessageNode methodsFor: 'transforming' stamp: 'fm 10/17/2020 00:35'!sameAs: aNode	^aNode isMessageNode and: [(selector key = aNode selector key or: [^self withoutComments printString = aNode withoutComments printString]) and: [(receiver sameAs: aNode receiver) and: 		[arguments sameAs: aNode arguments]]]! !!MessageNode methodsFor: 'transforming' stamp: 'fm 10/17/2020 00:36'!withoutComments	self nodesDo: [:e | e comment notNil ifTrue: [e comment: nil]]! !!MethodNode methodsFor: 'code generation' stamp: 'fm 5/28/2022 15:36'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!MethodNode methodsFor: 'transforming' stamp: 'fm 9/20/2020 21:25'!addNewTempTo: aBlockNode		^self addTemp: (encoder reallyBind: (encoder uniqueNameStartingFrom: 'zzzTemp')) to: aBlockNode! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/2/2020 15:25'!addTemp: temp to: aBlockNode	aBlockNode addTempNode: temp.	aBlockNode == block ifTrue: [		temporaries := temporaries copyWith: temp.		aBlockNode temporaries: nil].	^temp! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 20:05'!ascendValueBlocksAssignments	| anyTransformed |	anyTransformed := false.	[self select: [:node | | var atLeastOne |			node isMessage and: 			[node mayHaveOptimizedValueBlocks and:			[(node optimizedValueBlocks allSatisfy: [:a | | last |					a returns or: 				[((last := a statements last) isVariableNode and: [(var isNil and: [var := last. true]) or: [var name = last name]]) or: 				[last isAssignmentNode and: [atLeastOne := true. (var isNil and: [var := last variable. true]) or: [var name = last variable name]]]]]) and:			[atLeastOne == true]]]]		withParentDo: [:node :parent | | var |			node optimizedValueBlocks do: [:valueBlock | | last |					(last := valueBlock statements last) isAssignmentNode ifTrue: [					var := last variable.					valueBlock replace: last with: last value]].			parent replace: node with: (AssignmentNode new variable: var value: node)]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 12/27/2020 21:17'!ascendValueBlocksReturrns	"This should only be called after all optimizedValueBlocks messages have been converted to statements or return expression"	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodePostOrderEnumerator ofBlock: [:parent | | size statements i node valueBlocks |		parent isBlockNode ifTrue: [			size := (statements := parent statements) size.			i := 1.			[i <= size] whileTrue: [				((node := statements at: i) isMessage and: 				[node mayHaveOptimizedValueBlocks and: 				[(valueBlocks := node optimizedValueBlocks) notEmpty and: 				[valueBlocks allSatisfy: [:a | a statements last isRealReturn]]]]) ifTrue: [					valueBlocks do: [:e | e replace: e statements last with: e statements last expr].					statements at: i put: node asReturnNode.					i < size ifTrue: [						parent statements: (statements copyFrom: 1 to: i).						i := size].					parent returns: true.					anyTransformed := true].				i := i + 1]		] ifFalse: [			(parent class == ReturnNode) ifTrue: [				((node := parent expr) isMessage and: 				[node mayHaveOptimizedValueBlocks and: 				[(valueBlocks := node optimizedValueBlocks) notEmpty and: 				[valueBlocks allSatisfy: [:a | a statements last isRealReturn]]]]) ifTrue: [					valueBlocks do: [:e | e replace: e statements last with: e statements last expr].					anyTransformed := true]]		]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/9/2022 11:58'!cacheCaseReceivers	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | | newTemps |			node isBlockNode ifTrue: [								node statements do: [:s | | receiver |					(s isMessageNode and: [s macroPrinter == #printCaseOn:indent: and: [s arguments size = 1]]) ifTrue: [						(((receiver := s receiver) isLiteralLike and: [receiver isInlinedJsLiteral]) or: 						[receiver isVariableNode and: [receiver isArg or: [receiver isFixedValue or: [receiver isSelfPseudoVariable]]]]) ifFalse: [							newTemps isNil ifTrue: [								newTemps := OrderedCollection new							].							newTemps add: (self addNewTempTo: node) -> s						]					]				].				newTemps notNil ifTrue: [					newTemps do: [:a | | newAssignment |						newAssignment := AssignmentNode new variable: a key value: a value receiver.						node addStatement: newAssignment before: a value.						a value replace: a value receiver with: a key.					].					anyTransformed := true				]			]		]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/9/2022 13:04'!cleanupOptimizedBlockWithArg	| anyTransformed |	anyTransformed := false.	[self select: [:node | | a |			node isMessage and: 			[((node selector key == #ifTrue:ifFalse: and: 			[node macroPrinter == #printIfNilNotNil:indent: and:			[(a := node receiver receiver) isAssignmentNode]]) or:				[node selector key == #caseOf:otherwise: and: 				[node macroPrinter == #printCaseOn:indent: and:				[(a := node receiver) isAssignmentNode]]]) and: 			[node arguments last arguments size = 1 and:			[a variable key = node arguments last arguments first key]]]] 		withBlockAndParentDo: [:node :enclosingBlock :parent | | oneArgBlock canRemove key temp a p originalKey noNameConflicts |			oneArgBlock := node arguments last.			key := oneArgBlock arguments first key.			a := (p := node receiver isMessageNode ifTrue: [node receiver] ifFalse: [node]) receiver.			canRemove := true.			oneArgBlock accept: (ParseNodeEnumerator									ofBlock: [:n| (n isTemp and: [n key = key]) ifTrue: [canRemove := false]]									select: [:n| canRemove]).			canRemove ifTrue: [				p replace: a with: a value.			] ifFalse: [				originalKey := key.				[noNameConflicts := true.				enclosingBlock accept: (ParseNodeEnumerator										ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [noNameConflicts := false]]										select: [:n| noNameConflicts and: [key ~= originalKey or: [n ~~ oneArgBlock and: [n ~~ a variable]]]]).				noNameConflicts] 					whileFalse: [key := encoder uniqueNameStartingFrom: key, '1'].									key = originalKey ifTrue: [					temp := self addTemp: oneArgBlock arguments first to: enclosingBlock.					temp clearArgType.				] ifFalse: [					temp := self addTemp: (encoder reallyBind: key) to: enclosingBlock.					a replace: a variable with: temp.					oneArgBlock accept: (ParseNodeWithParentsEnumerator 											ofBlock: [:n :parents | (n isTemp and: [n key = originalKey]) ifTrue: [parents last replace: n with: temp]])				].			].			oneArgBlock arguments: #().			node noteSpecialSelector: node selector key.			true]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 12/28/2020 21:18'!compactIfTrueIfFalse	"This should only be called after all ifTrue:ifFalse: messages have been converted to statements"	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodeEnumerator ofBlock: [:parent | 		| size statements i node args return nonReturn oldStatements oldSize newSize newStatements |		parent isBlockNode ifTrue: [			size := (statements := parent statements) size.			i := 1.			[i < size] whileTrue: [				((node := statements at: i) isMessage and: 				[node isOptimized and:				[node selector key == #ifTrue:ifFalse: and: 				[((return := (args := node arguments) first) returns and:					[(nonReturn := args last) returns not]) or:				[(nonReturn := return) returns not and:					[(return := args last) returns]]]]]) ifTrue: [						parent statements: (statements copyFrom: 1 to: i).						(nonReturn isJust: NodeNil)							ifTrue: [								nonReturn statements: (statements copyFrom: i + 1 to: size)]							ifFalse: [								oldStatements := nonReturn statements.								oldSize := oldStatements size.								(oldStatements last isKindOf: LeafNode) ifTrue: [oldSize := oldSize - 1].								newSize := oldSize + size - i.								newStatements := Array new: newSize.								newStatements replaceFrom: 1 to: oldSize with: oldStatements startingAt: 1.								newStatements replaceFrom: oldSize + 1 to: newSize with: statements startingAt: i + 1.								nonReturn statements: newStatements].						size := i.						anyTransformed := true					].			i := i + 1.			]		]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 4/13/2021 17:04'!deduplicateIfTrueIfFalseBranches	"This should only be called after all ifTrue:ifFalse: messages have been converted to statements"	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodeEnumerator ofBlock: [:parent | 		| size statements i node firstArg lastArg firstStatements lastStatements firstLast lastLast minSize count toMove additionalSize newSize newStatements lastMoved firstSize lastSize firstOffset lastOffset moveTargetNode |		parent isBlockNode ifTrue: [			size := (statements := parent statements) size.			i := 1.			[i <= size] whileTrue: [				((node := statements at: i) isMessage and: 				[node isOptimized and:				[node selector key == #ifTrue:ifFalse: and: 				[firstArg := node arguments first.				firstLast := (firstStatements := firstArg statements) last.				((firstSize := firstStatements size) ~= 1 or: [firstLast ~~ NodeNil]) and:				[lastArg := node arguments last.				lastLast := (lastStatements := lastArg statements) last.				((lastSize := lastStatements size) ~= 1 or: [lastLast ~~ NodeNil]) and:				[firstLast sameAs: lastLast]]]]]) ifTrue: [					firstSize > lastSize ifTrue: [						minSize := lastSize.						firstOffset := firstSize - lastSize.						lastOffset := 0.					] ifFalse: [						minSize := firstSize.						firstOffset := 0.						lastOffset := lastSize - firstSize.					].					minSize = 1 ifTrue: [						count := 1.					] ifFalse: [						count := minSize - ((minSize - 1 to: 1 by: -1) detect: [:j | ((firstStatements at: firstOffset + j) sameAs: (lastStatements at: lastOffset + j)) not] ifNone: [0]).					].					count = minSize ifTrue: [						count = firstSize ifTrue: [							toMove := firstStatements.						] ifFalse: [							toMove := lastStatements]					] ifFalse: [						toMove := firstStatements last: count].					moveTargetNode := parent == block ifTrue: [self] ifFalse: [parent].					firstArg statements: (firstSize > count ifTrue: [firstStatements allButLast: count] ifFalse: [Array with: NodeNil]);						moved: toMove to: moveTargetNode.					lastArg statements: (lastSize > count ifTrue: [lastStatements allButLast: count] ifFalse: [Array with: NodeNil]);						moved: toMove to: moveTargetNode.					additionalSize := toMove size.					((lastMoved := toMove last) class == ReturnNode or: [lastMoved isReturningIf]) ifTrue: [						size := i					] ifFalse: [						(i < size and: [lastMoved isBlockNode or: [lastMoved isKindOf: LeafNode]]) ifTrue: [							additionalSize := additionalSize - 1].					].					additionalSize > 0 ifTrue: [						newSize := additionalSize + size.						newStatements := Array new: newSize.						newStatements replaceFrom: 1 to: i with: statements startingAt: 1.						newStatements replaceFrom: i + 1 to: i + additionalSize with: toMove startingAt: 1.						i < size ifTrue: [							newStatements replaceFrom: i + additionalSize + 1 to: newSize with: statements startingAt: i + 1].						parent statements: newStatements.						statements := parent statements.						size := newSize].					anyTransformed := true				].			i := i + 1.			]		]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/14/2021 15:45'!descendAssignmentsIntoLoops	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | 			(node isAssignmentNode and: 			[node value isMessage and: 			[node value isLoopStatement]]) ifTrue: [self halt]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 23:28'!descendAssignmentsIntoValueBlocks	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:nodeWithParents || node |			node := nodeWithParents last.			node isAssignmentNode and: 			[node value isMessage and: 			[node value hasOptimizedValueBlocks]]]		preservingEvaluationOrderDo: [:nodeWithParents | | node parent var newVar blockNode newAssignment replacement |			blockNode := nodeWithParents first.			node := nodeWithParents removeLast.			parent := nodeWithParents last.			nodeWithParents addLast: node.			(parent isMessageNode and: [parent macroPrinter == #printToDoOn:indent: and: [parent arguments size >= 7]]) ifTrue: [				node = parent argumentsInEvaluationOrder first ifTrue: [					"this is a synthetic assignmentNode, initStmt, handle with care"					newVar := self addNewTempTo: blockNode.					newAssignment := AssignmentNode new variable: newVar value: node value.					blockNode addStatement: newAssignment before: (nodeWithParents at: 2).					parent receiver: newVar.					node replace: node value with: newVar.					node := newAssignment.					parent := blockNode.				] ifFalse: [					node = (parent arguments at: 7) ifTrue: [						"this is also a synthetic assignmentNode, limitInit"						newVar := self addNewTempTo: blockNode.						newAssignment := AssignmentNode new variable: newVar value: node value.						blockNode addStatement: newAssignment before: (nodeWithParents at: 2).						node replace: node value with: newVar.						node := newAssignment.						parent := blockNode.					]				]			].			replacement := node value.			var := node variable.			replacement optimizedValueBlocks do: [:valueBlock | | lastStatement written returnValue |				valueBlock statements isEmpty ifTrue: [					valueBlock statements: (Array with: (AssignmentNode new variable: var value: NodeNil)).				] ifFalse: [					lastStatement := valueBlock statements last.					(valueBlock returns or:					[(lastStatement isAssignmentNode and: [lastStatement variable name = var name]) or:					[lastStatement isVariableNode and: [lastStatement name = var name]]]) ifFalse: [						(lastStatement isMessage and: [lastStatement isLoopStatement]) ifTrue: [							returnValue := lastStatement loopReturnValue.							(returnValue isAssignmentNode and: [returnValue isTemp]) ifTrue: [								written := false. 								lastStatement arguments last nodesDo: [:n | (n isAssignmentNode and: [n variable key = returnValue variable key]) ifTrue: [written := true]]. 								written ifTrue: [returnValue := returnValue value] ifFalse: [returnValue := returnValue variable]].							(returnValue isLiteralNode or: 							[returnValue == NodeNil or: 							[returnValue isTemp and: [returnValue isArg or: [								written := false. 								lastStatement arguments last nodesDo: [:n | (n isAssignmentNode and: [n variable key = returnValue key]) ifTrue: [written := true]]. 								written not]]]]) ifTrue: [								valueBlock statements: (valueBlock statements copyWith: (AssignmentNode new variable: var value: returnValue))							] ifFalse: [								newVar := self addNewTempTo: valueBlock.								newAssignment := AssignmentNode new variable: newVar value: returnValue.								valueBlock addStatement: newAssignment before: lastStatement.								lastStatement replace: returnValue with: newVar.								valueBlock statements: (valueBlock statements copyWith: (AssignmentNode new variable: var value: newVar))							]						] ifFalse: [							valueBlock replace: lastStatement with: (AssignmentNode new variable: var value: lastStatement)]]]].			parent replace: node with: replacement]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 19:34'!descendReturnsIntoLoops	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | | returnNode loopExpr loopReturnValue newVar newAssignment |			(node isBlockNode and: 			[node returns and: 			[(returnNode := node statements last) isMessage not and: 			[(loopExpr := returnNode expr) isLoopStatement]]]) ifTrue: [				(loopReturnValue := loopExpr loopReturnValue) == NodeNil ifFalse: [					newVar := self addNewTempTo: node.					newAssignment := AssignmentNode new variable: newVar value: loopReturnValue.					node addStatement: newAssignment before: returnNode.					loopExpr replace: loopReturnValue with: newVar.					loopReturnValue := newVar].				node replace: returnNode with: loopExpr.				node statements: (node statements copyWith: loopReturnValue asReturnNode).				anyTransformed := true]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 23:24'!descendReturnsIntoValueBlocks	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | | returnNode replacement optimizedValueBlocks |			(node isBlockNode and: 			[node returns and: 			[(returnNode := node statements last) isMessage not and: 			[(replacement := returnNode expr) isMessage and: 			[replacement mayHaveOptimizedValueBlocks and:			[(optimizedValueBlocks := replacement optimizedValueBlocks) notEmpty]]]]]) ifTrue: [				optimizedValueBlocks do: [:valueBlock | | lastStatement written returnValue newVar newAssignment |					valueBlock statements isEmpty ifTrue: [						valueBlock statements: (Array with: (NodeNil asReturnNode)).					] ifFalse: [						lastStatement := valueBlock statements last.						(lastStatement isMessage and: [lastStatement isLoopStatement]) ifTrue: [							returnValue := lastStatement loopReturnValue.							(returnValue isAssignmentNode and: [returnValue isTemp]) ifTrue: [								written := false.								lastStatement arguments last nodesDo: [:n | (n isAssignmentNode and: [n variable key = returnValue variable key])																				ifTrue: [written := true]].								written									ifTrue: [returnValue := returnValue value]									ifFalse: [returnValue := returnValue variable]].							(returnValue isLiteralNode							or: [returnValue == NodeNil							or: [returnValue isTemp								and: [returnValue isArg									or: [written := false.										lastStatement arguments last nodesDo: [:n | (n isAssignmentNode and: [n variable key = returnValue key])																						ifTrue: [written := true]].										written not]]]])											ifTrue: [												valueBlock statements: (valueBlock statements copyWith: returnValue asReturnNode)]											ifFalse: [												newVar := self addNewTempTo: node.												newAssignment := AssignmentNode new variable: newVar value: lastStatement loopReturnValue.												lastStatement replace: lastStatement loopReturnValue with: newVar.												node addStatement: newAssignment before: returnNode.												valueBlock statements: newVar asReturnNode]						] ifFalse: [							valueBlock replace: lastStatement with: lastStatement asReturnNode]]].				(node replace: returnNode with: replacement) ifTrue: [anyTransformed := true]]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 10:34'!fixupMacroSelectors	block nodesDo: [:node |		(node isMessageNode and: [node isOptimized and: [node selector key ~~ node macroSelector]]) ifTrue: [			node noteSpecialSelector: node selector key]]! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/6/2022 23:34'!isLocalReturn: node withParents: parents	| i current parent gparent ggparent |	(parent := parents last) isBlockNode ifFalse: [		^false]. 	current := node.	i := parents size.	[parent == block or: 	[current ~~ parent statements last or: 	[parent ignoresOwnLocalReturn or: 	[(gparent := parents at: i - 1) isMessageNode and: 		[((#(streamContents: new:streamContents: do: reverseDo: do:separatedBy:) includes: gparent selector key) and: [parent arguments size = 1]) or: 		[((#(doWithIndex: withIndexDo: with:do:) includes: gparent selector key) and: [parent arguments size = 2]) or: 		[gparent selector key == #on:do: and: [(ggparent := parents at: i - 2) isBlockNode and: 			[ggparent == block or: 			[gparent ~~ ggparent statements last or: 			[ggparent ignoresOwnLocalReturn]]]]]]]	]]]] whileFalse: [		parent isJSoptimizedValueBlock ifTrue: [			i := (parents indexOf: (current := parent optimizedMessageNode)) - 1.			(parent := parents at: i) isBlockNode ifFalse: [				^true].					] ifFalse: [			^true] 	].	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/2/2014 17:10'!makeImplicitSelfReturnExplicit	block returns ifFalse:		[block statements add: (StdVariables at: 'self') asReturnNode.		block returns: true]! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/14/2021 15:38'!makeLoopExpressionsStatements	[self descendAssignmentsIntoLoops | 	self transformLoopReceivers | 	self transformLoopArguments |	self transformLoopLocalReturns] 		whileTrue.	self descendReturnsIntoLoops.! !!MethodNode methodsFor: 'transforming' stamp: 'fm 9/18/2020 12:47'!makeValueBlocksExpressionsStatements	[self descendAssignmentsIntoValueBlocks | 	self transformValueBlocksReceivers | 	self transformValueBlocksArguments |	self transformValueBlocksLocalReturns |	self removeComplexAnd | self removeComplexOr] 		whileTrue.	self descendReturnsIntoValueBlocks.! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/16/2023 10:09'!markJSoptimizedBlocks	block accept: 		(ParseNodeEnumerator ofBlock: [:node | 			(node isMessage and: 			[node isJsOptimized]) ifTrue: [				node arguments size > 0 ifTrue: [					node arguments first optimizedMessageNode: node].				node receiver isBlockNode ifTrue: [					node receiver optimizedMessageNode: node]]])! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/15/2021 21:37'!moveNonExpressionsOutOfBraces	| anyTransformed |	anyTransformed := false.	[self select: [:node | (node class == BraceNode) and: [node elements anySatisfy: [:a | a isJSexpression not]]] 		preservingEvaluationOrderDo: [:nodeWithParents | | node enclosingBlock enclosingStatement newVar nonExpression |			enclosingBlock := nodeWithParents first.			enclosingStatement := nodeWithParents at: 2.			node := nodeWithParents removeLast.			newVar := self addNewTempTo: enclosingBlock.			nonExpression := node elements detect: [:a | a isJSexpression not].			enclosingBlock addStatement: (AssignmentNode new variable: newVar value: nonExpression) before: enclosingStatement.			node replace: nonExpression with: newVar]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 11/18/2022 20:20'!moveReturnIntoPrecedingIfTrueIfFalse	"This should only be called after all ifTrue:ifFalse: messages have been converted to statements"	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodeEnumerator ofBlock: [:parent | | node statements return firstArg lastArg firstStatements lastStatements |		(parent isBlockNode and: 		[parent returns and: 		[(statements := parent statements) size > 1 and: 		[(return := statements last) isRealReturn and: 		[(node := statements at: statements size - 1) isMessage and: 		[node isOptimized and:		[node selector key == #ifTrue:ifFalse: and:		[(1 to: statements size - 1) anySatisfy: [:i | | hasReturns |				hasReturns := false.				(statements at: i) accept: (ParseNodeEnumerator 												ofBlock: [:n | hasReturns := n isRealReturn] 												select: [:n | hasReturns not and: [n isLoopStatement not]]).				hasReturns			]		]]]]]]]) ifTrue: [			firstArg := node arguments first.			lastArg := node arguments last.			firstArg returns ifTrue: [				lastArg returns ifFalse: [					lastStatements := lastArg statements.					(lastStatements size = 1 and: [lastStatements first == NodeNil]) ifTrue: [						lastArg statements: (Array with: return)					] ifFalse: [						(lastStatements last isKindOf: LeafNode) ifTrue: [lastStatements := lastStatements allButLast].						(lastStatements notEmpty and: [lastStatements last isAssignmentNode and: [return expr isVariableNode and: [lastStatements last variable key = return expr key]]]) ifTrue: [							lastArg statements: (lastStatements allButLast copyWith: (ReturnNode new expr: lastStatements last value))						] ifFalse: [							lastArg statements: (lastStatements copyWith: return)						]					]. 					lastArg returns: true.				]			] ifFalse: [				firstStatements := firstArg statements.				(firstStatements size = 1 and: [firstStatements first == NodeNil]) ifTrue: [					firstArg statements: (Array with: return)				] ifFalse: [					(firstStatements last isKindOf: LeafNode) ifTrue: [firstStatements := firstStatements allButLast].					(firstStatements notEmpty and: [firstStatements last isAssignmentNode and: [return expr isVariableNode and: [firstStatements last variable key = return expr key]]]) ifTrue: [						firstArg statements: (firstStatements allButLast copyWith: (ReturnNode new expr: firstStatements last value))					] ifFalse: [						firstArg statements: (firstStatements copyWith: return)					]				]. 				firstArg returns: true.				lastArg returns ifFalse: [					lastStatements := lastArg statements.					(lastStatements size = 1 and: [lastStatements first == NodeNil]) ifTrue: [						lastArg statements: (Array with: return privateCopy)					] ifFalse: [						(lastStatements last isKindOf: LeafNode) ifTrue: [lastStatements := lastStatements allButLast].						(lastStatements notEmpty and: [lastStatements last isAssignmentNode and: [return expr isVariableNode and: [lastStatements last variable key = return expr key]]]) ifTrue: [							lastArg statements: (lastStatements allButLast copyWith: (ReturnNode new expr: lastStatements last value privateCopy))						] ifFalse: [							lastArg statements: (lastStatements copyWith: return privateCopy)						]					]. 					lastArg returns: true.				]			].			parent statements: statements allButLast.			anyTransformed := true]		]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/2/2022 23:38'!moveTempsFrom: blocks to: outerBlock	| keys |	keys := Dictionary new.	blocks do: [:b | b temporaries do: [:t | keys at: t key put: t]].	keys keysAndValuesDo: [:originalKey :temp | | canRemove key allStatements newTemp |		key := originalKey.		[canRemove := true. 		"in some cases, the blocks have alread been replaced within the outerBlock, but their statements are still there"		allStatements := blocks inject: OrderedCollection new into: [:c :b | c addAll: b statements; yourself].		outerBlock accept: (ParseNodeEnumerator							ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [canRemove := false]]							select: [:n| canRemove and: [(allStatements includes: n) not]]).		canRemove] whileFalse: [key := encoder uniqueNameStartingFrom: key, '1'].			key = originalKey ifTrue: [			self addTemp: temp to: outerBlock.		] ifFalse: [			newTemp := self addTemp: (encoder reallyBind: key) to: outerBlock.			blocks do: [:b |				b accept: 					(ParseNodeWithParentsEnumerator ofBlock: [:n :parents | 						(n isVariableNode and: [n key = originalKey]) ifTrue: [parents last replace: n with: newTemp]])			].		]].	blocks do: [:b |		b temporaries: #()].! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/5/2023 22:59'!normalize: willInline	"(Compiler new parse: (ReturnNode>>#printJSOn:indent:properties:) getSource in: ReturnNode notifying: nil) preen normalize"	"(Compiler new parse: (TableLayout>>#layoutLeftToRight:in:) getSource in: TableLayout notifying: nil) preen normalize"	"(Compiler new parse: (ScratchPlugin>>#hueFromR:G:B:min:max:) getSource in: ScratchPlugin notifying: nil) preen normalize"	"(Compiler new parse: (ScratchPlugin>>#bitmap:at:putH:s:v:) getSource in: ScratchPlugin notifying: nil) preen normalize"	"(Compiler new parse: (PolygonMorph>>#mouseDown:) getSource in: PolygonMorph notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEnginePlugin>>#loadArrayPolygon:nPoints:fill:lineWidth:lineFill:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEnginePlugin>>#loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEnginePlugin>>#assureValue:between:and:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEnginePlugin>>#loadBitmapFill:colormap:tile:from:along:normal:xIndex:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEngineBase>>#proceedRenderingScanline) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEngineBase>>#wbStackPush:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BalloonEnginePlugin>>#fillRadialGradient:from:to:at:) getSource in: BalloonEnginePlugin notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#clipRange) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#primitiveCopyBits) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#warpBits) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#pickWarpPixelAtX:y:) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#loadColorMap) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#loadHalftoneForm) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#sourceSkewAndPointerInit) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (BitBltSimulation>>#ignoreSourceOrHalftone:) getSource in: BitBltSimulation notifying: nil) preen normalize"	"(Compiler new parse: (DeflatePlugin>>#loadZipEncoderFrom:) getSource in: DeflatePlugin notifying: nil) preen normalize"	"(Compiler new parse: (DeflatePlugin>>#nextZipBits:put:) getSource in: DeflatePlugin notifying: nil) preen normalize"	"(Compiler new parse: (KedamaPlugin>>#degreesFromX:y:) getSource in: KedamaPlugin notifying: nil) preen normalize"	"(Compiler new parse: (KlattSynthesizerPlugin>>#addAmplitudeDiplophonia) getSource in: KlattSynthesizerPlugin notifying: nil) preen normalize"	"(Compiler new parse: (LoopedSampledSound>>#mixSampleCount:into:startingAt:leftVol:rightVol:) getSource in: LoopedSampledSound notifying: nil) preen normalize"	"(Compiler new parse: (LargeIntegersPlugin>>#cDigitLshift:from:len:to:len:) getSource in: LargeIntegersPlugin notifying: nil) preen normalize"	"(Compiler new parse: (LargeIntegersPlugin>>#digitBitLogic:with:opIndex:) getSource in: LargeIntegersPlugin notifying: nil) preen normalize"	"(Compiler new parse: (LargeIntegersPlugin>>#cDigitMontgomery:len:times:len:modulo:len:mInvModB:into:) getSource in: LargeIntegersPlugin notifying: nil) preen normalize"	"(Compiler new parse: (MethodFinder>>#verify) getSource in: MethodFinder notifying: nil) preen normalize"	"(Compiler new parse: (BlockClosure>>#valueWithin:onTimeout:) getSource in: BlockClosure notifying: nil) preen normalize"	"(Compiler new parse: (ClassDescription>>#replaceSilently:to:) getSource in: ClassDescription notifying: nil) preen normalize"	"(Compiler new parse: (MCMczReader>>#loadDefinitions) getSource in: MCMczReader notifying: nil) preen normalize"	"(Compiler new parse: (MethodNode>>#removeIfNilIfNotNil) getSource in: MethodNode notifying: nil) preen normalize"	"(Compiler new parse: (Socket class>>#ping:) getSource in: Socket class notifying: nil) preen normalize"	"(Compiler new parse: (TTCFont class>>#newTextStyleFromTTStream:) getSource in: TTCFont class notifying: nil) preen normalize"	"(Compiler new parse: (ObjectMemory>>#allocate:headerSize:h1:h2:h3:doFill:with:) getSource in: ObjectMemory notifying: nil) preen normalize"	"(Compiler new parse: (NewObjectMemory>>#allocate:headerSize:h1:h2:h3:doFill:format:) getSource in: NewObjectMemory notifying: nil) preen normalize"	"(Compiler new parse: (CCodeGenerator>>#fileHeaderVersionStampForSourceClass:) getSource in: CCodeGenerator notifying: nil) preen normalize"	| prepareForInlining shouldConsiderInlining returnCount nodeCount hasReturningIf returnValue |	shouldConsiderInlining := (properties pragmas		detect: [:p | 			p keyword = #inline: and: 			[p arguments first == true]]		ifNone: [			block statements 				detect: [:s | 					s isMessageNode and: 					[s receiver isSelfPseudoVariable and:					[s selector key = #inline: and: 					[s arguments first isVariableNode and:					[s arguments first key = 'true']]]]]				ifNone: []]) notNil.	prepareForInlining := willInline & shouldConsiderInlining.	shouldConsiderInlining ifFalse: [		properties pragmas			detect: [:p | 				p keyword = #inline: and: 				[p arguments first == false]]			ifNone: [				block statements 					detect: [:s | 						s isMessageNode and: 						[s receiver isSelfPseudoVariable and:						[s selector key = #inline: and: 						[s arguments first isVariableNode and:						[s arguments first key = 'false']]]]]					ifNone: [shouldConsiderInlining := true]]].	shouldConsiderInlining ifTrue: [		((properties pragmas			detect: [:p | 				p keyword = #export: and: 				[p arguments first == true]]			ifNone: [				block statements 					detect: [:s | 						s isMessageNode and: 						[s receiver isSelfPseudoVariable and:						[s selector key = #export: and: 						[s arguments first isVariableNode and:						[s arguments first key = 'true']]]]]					ifNone: []]) notNil and: [self selector beginsWith: 'prim']) ifTrue: [shouldConsiderInlining := false]].	shouldConsiderInlining ifTrue: [		nodeCount := 0.		returnCount := 0.		hasReturningIf := false.		block nodesDo: [:n | 			nodeCount := nodeCount + 1.			n isRealReturn				ifTrue: [returnCount := returnCount + 1]				ifFalse: [n isReturningIf ifTrue: [hasReturningIf := true]]].		((returnCount < 2 or: [returnCount = 2 and: [hasReturningIf]]) or: [nodeCount > 400])			ifTrue: [shouldConsiderInlining := false]].	self renameTempsNamedLikeMySelector.	self replaceReusedVarNames.	self removeCascades.	self normalizeIfTrueIfFalse.		self markJSoptimizedBlocks.	self removeNonLocalReturns.	"This is not required, it is an optimization"	self moveNonExpressionsOutOfBraces."	Transcript cr; show: self printString size printString."	self makeValueBlocksExpressionsStatements. 	self cacheCaseReceivers. 	self makeLoopExpressionsStatements. 	self recoverCaseOfExpressions. "	Transcript cr; show: self printString size printString."	[(shouldConsiderInlining | prepareForInlining and: [self compactIfTrueIfFalse | self moveReturnIntoPrecedingIfTrueIfFalse]) 	| self ascendValueBlocksReturrns	] whileTrue."	Transcript cr; show: self printString size printString."	shouldConsiderInlining | prepareForInlining ifFalse: [			self descendReturnsIntoValueBlocks.			[self removeReturnsFromPrecedingIfTrueIfFalse			| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."			self ascendValueBlocksReturrns].	self removeDeadCodeFollowingAssignments."	Transcript cr; show: self printString size printString."	self ascendValueBlocksAssignments.	[self recoverConditionalExpressions] whileTrue."	Transcript cr; show: self printString size printString."	prepareForInlining ifTrue: [		[self descendAssignmentsIntoValueBlocks | 		self transformValueBlocksReceivers | 		self transformValueBlocksArguments |		self transformValueBlocksLocalReturns |		self removeComplexAnd | self removeComplexOr] 			whileTrue.	] ifFalse: [		self descendAssignmentsIntoValueBlocks.		self descendReturnsIntoValueBlocks.		self makeValueBlocksExpressionsStatements].	self removeRedundantAssignments."	Transcript cr; show: self printString size printString."	shouldConsiderInlining | prepareForInlining ifTrue: [		[self removeReturnsFromPrecedingIfTrueIfFalse 		| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	].	self replaceStatementConditionalExpressions.	[self removeNoOps | self removeWriteOnlyTemps] whileTrue."	Transcript cr; show: self printString size printString."	[self removeReturnsFromPrecedingIfTrueIfFalse 	| self deduplicateIfTrueIfFalseBranches] whileTrue."	Transcript cr; show: self printString size printString."	prepareForInlining ifTrue: [		returnCount := 0.		block nodesDo: [:n | 			n isRealReturn				ifTrue: [returnCount := returnCount + 1]].		(returnCount > 1 or: [(returnValue := block statements last expr) isMessageNode and: [returnValue selector key == #ifTrue:ifFalse:]])			ifTrue: [self normalize: false]].	self fixupMacroSelectors.! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/4/2022 01:34'!normalizeBranches	self select: [:node | 			node isMessage and: 			[node isOptimized and: 			[(node selector key == #ifTrue:ifFalse: or: 				[node selector key == #or: or: 				[node selector key == #and:]]) and: 			[node arguments anySatisfy: [:a | 					a isBlockNode and: 					[a statements size = 0]]]]]] 		withBlockAndParentDo: [:node :enclosingBlock :parent |			node arguments do: [:a |				a isBlockNode					ifTrue: [						a statements isEmpty ifTrue: [a statements: {NodeNil}]]				].			true]! !!MethodNode methodsFor: 'transforming' stamp: 'fm 12/17/2022 19:49'!normalizeIfTrueIfFalse"	self removeIfFalseIfTrue."	"done by transform"	self removeIfFalse.	self removeIfTrue.	self removeIfNil."	self removeIfNilIfNotNil."	"done by transform""	self removeIfNotNil."		"done by transform""	self removeIfNotNilIfNil."	"done by transform"	self cleanupOptimizedBlockWithArg.	self normalizeBranches.	self recoverBooleanExpressions.	[self removeComplexAnd | self removeComplexOr] whileTrue: [].! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/22/2022 23:59'!recoverBooleanExpressions	| anyTransformed |	anyTransformed := false.	[self select: [:node | | trueBlock falseBlock |			node isMessage and: [node selector key == #ifTrue:ifFalse: and: [			(	((trueBlock := node arguments first) isJust: NodeTrue) and: 				[(falseBlock := node arguments last) returns not and: 				[falseBlock statements size = 1 and: 				[falseBlock statements first isMessage not or:						"since we are traversing bottom-up, if an inner message is ifTrue:ifFalse,					it was already considered and it was not convertible to an and/or expression,					which also disqualifies the parent ifTrue:ifFalse:"					[falseBlock statements first selector key ~~ #ifTrue:ifFalse:]]]]			) or:			[	((falseBlock := node arguments last) isJust: NodeFalse) and: 				[trueBlock returns not and: 				[trueBlock statements size = 1 and:				[trueBlock statements first isMessage not or:					[trueBlock statements first selector key ~~ #ifTrue:ifFalse:]]]			]]]]]		withBlockAndParentDo: [:node :enclosingBlock :parent | | falseBlock replacement trueBlock messageSelector messageArguments |			(parent ~~ enclosingBlock or: [parent ~~ block and: [node == parent statements last]]) and: 			[trueBlock := node arguments first.			falseBlock := node arguments last.			(trueBlock isJust: NodeTrue) 				ifTrue: [					messageSelector := #or:.					messageArguments := {falseBlock}] 				ifFalse: [					messageSelector := #and:.					messageArguments := {trueBlock}].			replacement := MessageNode new								receiver: node receiver								selector: messageSelector								arguments: messageArguments								precedence: 3								from: encoder.			replacement noteSpecialSelector: messageSelector.			falseBlock noteOptimizedIn: replacement.			trueBlock noteOptimizedIn: replacement.			parent replace: node with: replacement.			]		]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 3/30/2022 23:37'!recoverCaseOfExpressions	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodePostOrderEnumerator ofBlock: [:node | | size i statement receiver temp key last cases newStatements |		(node isBlockNode and: [(node returns and: [node statements size > 2]) or: [node returns not and: [node statements size > 1]]]) ifTrue: [			size := node statements size.			i := 0.			[(i := i + 1) < size] whileTrue: [				statement := node statements at: i.				(statement isMessageNode and: [statement selector key == #ifTrue:ifFalse: and: 				[(statement arguments allSatisfy: [:a | a isBlockNode and: [a returns not]]) and: 				[(receiver := statement receiver) isMessageNode and: 				[(((statement arguments last isJust: NodeNil) and: [receiver selector key == #=]) or: 					[(statement arguments first isJust: NodeNil) and: [receiver selector key == #~=]]) and:				[(((temp := receiver receiver) isTemp and: [receiver arguments first isFixedValue]) or:					[(temp := receiver arguments first) isTemp and: [receiver receiver isFixedValue]]) and:				[temp isArg or: 					[| written | 					written := false. 					statement nodesDo: [:n | (n isAssignmentNode and: [n variable key = temp key]) ifTrue: [written := true]]. 					written not]]]]]]]) 				ifTrue: [					key := temp key.					last := ((i + 1 to: size) detect: [:j | | n r t |						n := node statements at: j.						(n isMessageNode and: [n selector key == #ifTrue:ifFalse: and: 						[(n arguments allSatisfy: [:a | a isBlockNode and: [a returns not]]) and: 						[(r := n receiver) isMessageNode and: 						[(((n arguments last isJust: NodeNil) and: [r selector key == #=]) or: 							[(n arguments first isJust: NodeNil) and: [r selector key == #~=]]) and:						[(((t := r receiver) isTemp and: [r arguments first isFixedValue]) or:							[(t := r arguments first) isTemp and: [r receiver isFixedValue]]) and:						[t key = key]]]]]]) not] ifNone: [size + 1]) - 1.					last > i ifTrue: [						anyTransformed := true.						(temp isArg not and: [i + 1 < last]) ifTrue: [							last := (i + 1 to: last - 1) detect: [:j | | written |								written := false. 								(node statements at: j) nodesDo: [:n | 									(n isAssignmentNode and: [n variable key = key]) ifTrue: [written := true]]. 								written] ifNone: [last]						].						cases := (node statements copyFrom: i to: last) collect: [:m | | rcvr args |							rcvr := m receiver.							args := m arguments.							MessageNode new									receiver: (BlockNode withJust: ((rcvr receiver isTemp) ifTrue: [rcvr arguments first] ifFalse: [rcvr receiver]))								selector: #->								arguments: {(args first isJust: NodeNil) ifTrue: [args last] ifFalse: [args first]}								precedence: 2								from: encoder].						newStatements := Array new: size - last + i.						newStatements replaceFrom: 1 to: i - 1 with: node statements startingAt: 1.						newStatements at: i put: (MessageNode new														receiver: temp													selector: #caseOf:otherwise:													arguments: {BraceNode new elements: cases sourceLocations: (Array new: last - i + 1). BlockNode withJust: NodeNil} 													precedence: 3													from: encoder).						newStatements replaceFrom: i + 1 to: size - last + i with: node statements startingAt: last + 1.						node statements: newStatements.						size := size - last + i.						i := last.						].					].				].			]		]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/5/2023 23:14'!recoverConditionalExpressions	| anyTransformed |	anyTransformed := false.	block accept: 		(ParseNodeWithParentsEnumerator ofBlock: [:node :parents |			| trueBlock falseBlock trueReturns falseReturns falseValue trueValue isLocalReturn parent parentStatements parentLast replacement |			(node isMessage and: 			[node isOptimized and: 			[node selector key == #ifTrue:ifFalse: and: 			[(trueBlock := node arguments first) statements size = 1 and:			[(falseBlock := node arguments last) statements size = 1]]]]) ifTrue: [				trueReturns := trueBlock returns.				falseReturns := falseBlock returns.				trueValue := trueBlock statements first.				falseValue := falseBlock statements first.				parent := parents last.				anyTransformed := trueReturns ifTrue: [					falseReturns ifTrue: [						falseValue class == ReturnNode and: 						[falseValue expr isJSexpression and: 						[trueValue class == ReturnNode and: 						[trueValue expr isJSexpression and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue expr. falseValue expr}								precedence: 3								from: encoder.							parent replace: node with: replacement asReturnNode]]]]					] ifFalse: [						(falseValue isKindOf: LeafNode) and: 						[trueValue class == ReturnNode and: 						[trueValue expr isJSexpression and: 						[parent isBlockNode and:						[parent returns and:						[((parentStatements := parent statements) indexOf: node) + 1 = parentStatements size and:						[(parentLast := parentStatements last) class == ReturnNode and:						[parentLast expr isJSexpression and:						[(self isLocalReturn: node withParents: parents) not and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue expr. parentLast expr}								precedence: 3								from: encoder.							parent statements: parentStatements allButLast;								replace: node with: replacement asReturnNode]]]]]]]]]]				] ifFalse: [					falseReturns ifTrue: [						(trueValue isKindOf: LeafNode) and: 						[falseValue class == ReturnNode and: 						[falseValue expr isJSexpression and: 						[parent isBlockNode and:						[parent returns and:						[((parentStatements := parent statements) indexOf: node) + 1 = parentStatements size and:						[(parentLast := parentStatements last) class == ReturnNode and:						[parentLast expr isJSexpression and:						[(self isLocalReturn: node withParents: parents) not and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {parentLast expr. falseValue expr}								precedence: 3								from: encoder.							parent statements: parentStatements allButLast;								replace: node with: replacement asReturnNode]]]]]]]]]					] ifFalse: [						(falseValue isJSexpression and:						[trueValue isJSexpression and: 						[(parent := parents last) isBlockNode not or: [isLocalReturn := self isLocalReturn: node withParents: parents]]]) and: 						[	replacement := MessageNode new								receiver: node receiver								selector: #questionMark:colon:								arguments: {trueValue. falseValue}								precedence: 3								from: encoder.							parent replace: node with: replacement]					]				].				(anyTransformed and: [node arguments anySatisfy: [:a | a temporaries notEmpty]]) ifTrue: [					self moveTempsFrom: node arguments to: (parents reversed detect: [:e | e isBlockNode])				]			]		]). 	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 11/18/2022 23:53'!removeCascades	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:nodeWithParents | | node |			node := nodeWithParents last.			node isCascade and: [nodeWithParents allSatisfy: [:a | a == node or: [a isCascade not]]]] 		preservingEvaluationOrderDo: [:nodeWithParents | | node enclosingBlock enclosingStatement newVar lastMessage canMove key success |			enclosingBlock := nodeWithParents first.			enclosingStatement := nodeWithParents at: 2.			node := nodeWithParents removeLast.			lastMessage := node messages last.			canMove := false. 			node receiver isVariableNode ifTrue: [				newVar := node receiver			] ifFalse: [				node receiver isAssignmentNode ifTrue: [					newVar := node receiver variable.					enclosingBlock addStatement: node receiver before: enclosingStatement				] ifFalse: [					(nodeWithParents last isAssignmentNode and: [lastMessage selector key == #yourself and: [						canMove := true. 						key := nodeWithParents last variable key.						node accept: (ParseNodeEnumerator							ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [canMove := false]]							select: [:n| canMove]).						canMove]]) ifTrue: [							newVar := nodeWithParents last variable					] ifFalse: [						newVar := self addNewTempTo: enclosingBlock.					].					enclosingBlock addStatement: (AssignmentNode new variable: newVar value: node receiver) before: enclosingStatement				].			].			node messages allButLast do: [:m |				enclosingBlock addStatement: (m receiver: newVar) before: enclosingStatement].			(node == enclosingStatement and: 			[node ~~ enclosingBlock statements last and: 			[lastMessage selector key == #yourself]]) ifTrue: [				enclosingBlock statements: (enclosingBlock statements copyWithout: node).				true			] ifFalse: [				(nodeWithParents last isAssignmentNode and: [lastMessage selector key == #yourself and: [canMove]]) ifTrue: [					(nodeWithParents last == enclosingStatement and: 					[nodeWithParents last ~~ enclosingBlock statements last]) ifTrue: [						enclosingBlock statements: (enclosingBlock statements copyWithout: nodeWithParents last).						true					] ifFalse: [						success := (nodeWithParents at: nodeWithParents size - 1) replace: nodeWithParents last with: newVar.						success or: [self halt. false]					]				] ifFalse: [					success := nodeWithParents last replace: node with: (lastMessage selector key == #yourself ifTrue: [newVar] ifFalse: [lastMessage receiver: newVar]).					success or: [self halt. false]				]			]		]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:00'!removeComplexAnd	| anyTransformed |	anyTransformed := false.	[self select: [:node | 			node isMessage and: 			[(node selector key == #and: or: [node macroSelector == #and:]) and:			[node arguments first isBlockNode and:			[node arguments first returns or:				[node arguments first statements size > 1 or:				[node arguments first statements first isJSexpression not				"This should be run after recoverBooleanExpressions, see also comment in that method"]]]]]] 		withParentDo: [:node :parent | | replacement |			replacement := MessageNode new								receiver: node receiver 								selector: #ifTrue:ifFalse:								arguments: {node arguments first. BlockNode withJust: NodeFalse}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first noteOptimizedIn: replacement.			replacement arguments last noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:00'!removeComplexOr	| anyTransformed |	anyTransformed := false.	[self select: [:node | 			node isMessage and: 			[(node selector key == #or: or: [node macroSelector == #or:]) and:			[node arguments last isBlockNode and:			[node arguments last returns or:			[node arguments last statements size > 1 or:				[node arguments last statements first isJSexpression not				"This should be run after recoverBooleanExpressions, see also comment in that method"]]]]]] 		withParentDo: [:node :parent | | replacement |			replacement := MessageNode new								receiver: node receiver 								selector: #ifTrue:ifFalse:								arguments: {BlockNode withJust: NodeTrue. node arguments last}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first noteOptimizedIn: replacement.			replacement arguments last noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/29/2022 22:28'!removeDeadCodeFollowingAssignments	| anyTransformed |	anyTransformed := false.	"Transcript cr; show: 'before: '; show: self printString size printString."	block		accept: (ParseNodePostOrderEnumerator				ofBlock: [:n | | statements replacements |					n isBlockNode ifTrue: [						(statements := n statements) size >= 2 ifTrue: [							statements withIndexDo: [:e :i | | next receiver comp comparisonResult |								(i < statements size and:								[e isAssignmentNode and: 								[(e value isKindOf: LeafNode) and: 								[(next := statements at: i + 1) isMessageNode and:								[next selector key = #ifTrue:ifFalse: and:								[(receiver := next receiver) isMessageNode and: 								[(#(= == ~= ~~) includes: receiver selector key) and: 								[((receiver receiver sameAs: e variable) and: [((comp := receiver arguments first) sameAs: e value) or: [comp isFixedValue and: [e value isFixedValue]]]) or:									[(receiver arguments first sameAs: e variable) and: [((comp := receiver receiver) sameAs: e value) or: [comp isFixedValue and: [e value isFixedValue]]]]]]]]]]]								) ifTrue: [									anyTransformed := true.									comparisonResult := e value isFixedValue ifTrue: [										Compiler evaluate: e value literalValueString, ' ', receiver selector key, ' ', comp literalValueString									] ifFalse: [										#(= ==) includes: receiver selector key].									replacements ifNil: [replacements := Array new: statements size].									comparisonResult ifTrue: [										replacements at: i put: next arguments first statements									] ifFalse: [										replacements at: i put: next arguments last statements									].									]].							replacements notNil ifTrue: [								replacements size to: 1 by: -1 do: [:i | | r |									r := replacements at: i.									r notNil ifTrue: [										statements := n statements.										n statements: (statements copyFrom: 1 to: i), r, (statements copyFrom: i + 2 to: statements size)		]]]]]]).	"Transcript cr; show: 'after: '; show: self printString size printString; cr."	^ anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:00'!removeIfFalse	| anyTransformed |	anyTransformed := false.	[self select: [:node | node isMessage and: [node isOptimized and: [node selector key == #ifFalse:]]] 		withParentDo: [:node :parent | | replacement |			replacement := MessageNode new								receiver: node receiver 								selector: #ifTrue:ifFalse:								arguments: {BlockNode withJust: NodeNil. node arguments last}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first noteOptimizedIn: replacement.			replacement arguments last noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:00'!removeIfFalseIfTrue	| anyTransformed |	anyTransformed := false.	[self select: [:node | node isMessage and: [node selector key == #ifFalse:ifTrue:]] 		withParentDo: [:node :parent | | replacement |			replacement := MessageNode new								receiver: node receiver 								selector: #ifTrue:ifFalse:								arguments: node arguments reversed								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first noteOptimizedIn: replacement.			replacement arguments last noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/19/2022 23:53'!removeIfNil	| anyTransformed |	anyTransformed := false.	[self select: [:node | node isMessage and: [node selector key == #ifNil: and: [node arguments first isBlockNode and: [node arguments first arguments isEmpty]]]] 		withBlockAndParentDo: [:node :enclosingBlock :parent | | replacement var receiver canReuse key |			(node receiver isVariableNode or: [node receiver isAssignmentNode])				ifTrue: [					var := node receiver isVariableNode									ifTrue: [node receiver]									ifFalse: [node receiver variable].					receiver := node receiver]				ifFalse: [					parent isAssignmentNode ifTrue: [ 						canReuse := true.						key := parent variable key.						node arguments first accept: (ParseNodeEnumerator									ofBlock: [:n| (n isTemp and: [n key = key]) ifTrue: [canReuse := false]]									select: [:n| canReuse]).						canReuse ifTrue: [							var := parent variable.						] ifFalse: [							var := self addNewTempTo: enclosingBlock.						]					] ifFalse: [						var := self addNewTempTo: enclosingBlock.					].					receiver := AssignmentNode new variable: var value: node receiver].			replacement := MessageNode new								receiver: (MessageNode new											receiver: receiver											selector: #==											arguments: (Array with: NodeNil)											precedence: 2											from: encoder)								selector: #ifTrue:ifFalse:								arguments: {node arguments first. BlockNode withJust: var}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments last noteOptimizedIn: replacement.			replacement arguments first noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:01'!removeIfTrue	| anyTransformed |	anyTransformed := false.	[self select: [:node | node isMessage and: [node isOptimized and: [node selector key == #ifTrue:]]] 		withParentDo: [:node :parent | | replacement |			replacement := MessageNode new								receiver: node receiver 								selector: #ifTrue:ifFalse:								arguments: {node arguments first. BlockNode withJust: NodeNil}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first isBlockNode ifTrue: [				replacement arguments first noteOptimizedIn: replacement].			replacement arguments last noteOptimizedIn: replacement.			parent replace: node with: replacement.			]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 9/24/2020 10:40'!removeNoOps	| anyTransformed |	anyTransformed := false.	self selectWithParents: [:node :parents | 			node isBlockNode and: [(node isJust: NodeNil) not]]		do: [:parent :parents | | size allParents toRemove |			size := parent statements size.			allParents := parents copyWith: parent.			toRemove := OrderedCollection new. 			1 to: size do: [:i | | node |				node := parent statements at: i.				((node isBlockNode or: [node isKindOf: LeafNode]) and: 				[i < size or: [(self isLocalReturn: node withParents: allParents) not]]) ifTrue: [					toRemove add: node..					anyTransformed := true]].			size = toRemove size				ifTrue: [parent statements: (Array with: NodeNil)]				ifFalse: [toRemove isEmpty ifFalse: [parent statements: (parent statements copyWithoutAll: toRemove)]].			anyTransformed].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/21/2020 17:00'!removeNonLocalReturns	self removeNonLocalReturnsFromIfMissingBlock.	self removeNonLocalReturnsFromHandlerBlock.! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/6/2022 18:58'!removeNonLocalReturnsFromHandlerBlock	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:nodeWithParents | | node |			node := nodeWithParents last.			node isMessage and: 			[node selector key == #on:do: and:			[node receiver isBlockNode and:			[node arguments last isBlockNode and:			[node arguments last returns and:			[nodeWithParents noneSatisfy: [:p | p isBlockNode and: [p ~~ block and: [p isJSoptimized not]]]]]]]]] 		preservingEvaluationOrderDo: [:nodeWithParents | | node parent enclosingBlock var assignment handlerBlock canRemove signalArg return returnedExpr marker replacement key returnVar |			enclosingBlock := nodeWithParents first.			node := nodeWithParents removeLast.			handlerBlock := node arguments last.			(return := handlerBlock statements last) isMessage ifTrue: [self halt "check if we need to handle returningIf"] ifFalse: [				returnedExpr := return expr.				(returnedExpr isMessage and: 				[returnedExpr receiver isVariableNode and: 				[#(return return: retry retryUsing: resume resume: resumeUnchecked: pass outer) includes: returnedExpr selector key]])					ifTrue: [						"just remove the return, which doesn't get to be evaluated"						handlerBlock replace: return with: returnedExpr]					ifFalse: [						canRemove := true.						handlerBlock arguments isEmpty 							ifTrue: [								signalArg := encoder bindBlockArg: (encoder uniqueNameStartingFrom: 'HANDLER_ARG') within: handlerBlock.								signalArg scope: 2.								handlerBlock arguments: (Array with: signalArg)]							ifFalse: [								signalArg := handlerBlock arguments first.								key := signalArg key.								returnedExpr accept: (ParseNodeWithParentsEnumerator									ofBlock: [:n :parents | 										(n isVariableNode and: [n key = key and: 										[parents last isMessageNode not or: 											[(#(messageText tag description receiver) includes: parents last selector key) not]]]) ifTrue: [canRemove := false]]									select: [:n :parents | canRemove]).							].						canRemove and: [							((returnedExpr isKindOf: LeafNode) and: [returnedExpr isTemp not]) ifTrue: [								returnVar := returnedExpr.							] ifFalse: [													returnVar := self addNewTempTo: enclosingBlock.								handlerBlock addStatement: (AssignmentNode new variable: returnVar value: returnedExpr) before: return.							].							marker := LiteralVariableNode new 										name: #'HANDLER_MARKER'										key: nil										index: nil										type: LdLitIndType.							handlerBlock replace: return with: (MessageNode new																receiver: signalArg																selector: #return:																arguments: {marker}																precedence: 3																from: encoder).							parent := nodeWithParents removeLast.							parent isAssignmentNode								ifTrue: [									var := nodeWithParents last == enclosingBlock ifTrue: [NodeNil] ifFalse: [parent variable].									assignment := parent.									parent := nodeWithParents removeLast.									node := assignment									]								ifFalse: [									var := self addNewTempTo: enclosingBlock.									assignment := AssignmentNode new variable: var value: node.									].							replacement := MessageNode new												receiver: (MessageNode new															receiver: assignment															selector: (StdSelectors at: #==)															arguments: {marker}															precedence: 2)												selector: #ifTrue:ifFalse:												arguments: {BlockNode withJust: (ReturnNode new expr: returnVar). BlockNode withJust: var}												precedence: 3												from: encoder.							replacement noteSpecialSelector: #ifTrue:ifFalse:.							replacement arguments first noteOptimizedIn: replacement.							replacement arguments last noteOptimizedIn: replacement.							parent replace: node with: replacement]]]]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/6/2022 22:59'!removeNonLocalReturnsFromIfMissingBlock	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:node :parents |			node isMessage and: 			[(node selector key == #detect:ifNone: or: 				[node selector key == #at:ifAbsent: or: 				[node selector key == #remove:ifAbsent: or: 				[node selector key == #removeKey:ifAbsent:]]]) and:			[node arguments last isBlockNode and:			[node arguments last returns and:			[parents noneSatisfy: [:p | p isBlockNode and: [p ~~ block and: [p isJSoptimized not]]]]]]]] 		do: [:node :parents | | parent enclosingBlock nextParent var assignment child ifMissingBlock marker replacement |			enclosingBlock := parents first.			ifMissingBlock := node arguments last.			marker := LiteralVariableNode new 									name: #'MISSING_MARKER'									key: nil									index: nil									type: LdLitIndType.			node replace: ifMissingBlock with: (BlockNode withJust: marker).			parent := parents last.			parent isAssignmentNode				ifTrue: [					nextParent := parents at: parents size - 1.					var := nextParent == enclosingBlock ifTrue: [NodeNil] ifFalse: [parent variable].					assignment := parent.					parent := nextParent.					child := assignment					]				ifFalse: [					var := self addNewTempTo: enclosingBlock.					assignment := AssignmentNode new variable: var value: node.					child := node					].			replacement := MessageNode new								receiver: (MessageNode new											receiver: assignment											selector: (StdSelectors at: #==)											arguments: {marker}											precedence: 2)								selector: #ifTrue:ifFalse:								arguments: {ifMissingBlock. BlockNode withJust: var}								precedence: 3								from: encoder.			replacement noteSpecialSelector: #ifTrue:ifFalse:.			replacement arguments first noteOptimizedIn: replacement.			replacement arguments last noteOptimizedIn: replacement.			parent replace: child with: replacement]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/15/2021 22:06'!removeRedundantAssignments	| anyTransformed |	anyTransformed := false.	block		accept: (ParseNodePostOrderEnumerator				ofBlock: [:n | 					n isBlockNode ifTrue: [						n statements do: [:e | 							(e isAssignmentNode and: 							[(e value isVariableNode and: 							[e variable name = e value name]) or: [								e value isAssignmentNode and:								[e variable name = e value variable name]]])									ifTrue: [										anyTransformed := true.										n replace: e with: e value]]]]).	^ anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/7/2022 22:35'!removeReturnsFromPrecedingIfTrueIfFalse	"This should only be called after all ifTrue:ifFalse: messages have been converted to statements"	| anyTransformed |	anyTransformed := false.	block accept: (ParseNodePostOrderEnumerator ofBlock: [:parent | 		| node statements firstArg lastArg firstStatements lastStatements last |		parent isBlockNode ifTrue: [ 			statements := parent statements.			((parent returns and: [statements size > 1 and: [statements last class == ReturnNode and:			[(node := statements at: statements size - 1) isMessage and: 			[node isOptimized and: [node selector key == #ifTrue:ifFalse: and:			[((firstArg := node arguments first) returns and: [(firstStatements := firstArg statements) last sameAs: statements last]) or: 				[(lastArg := node arguments last) returns and: [(lastStatements := lastArg statements) last sameAs: statements last]]]]]]]]) or:			[parent == block and:			[(node := statements last) isMessage and: 			[node isOptimized and: [node selector key == #ifTrue:ifFalse: and:			[((firstArg := node arguments first) returns and: [(last := (firstStatements := firstArg statements) last) isReturningIf not and: [last expr isSelfPseudoVariable]]) or: 				[(lastArg := node arguments last) returns and: [(last := (lastStatements := lastArg statements) last) isReturningIf not and: [last expr isSelfPseudoVariable]]]]]]]]			) ifTrue: [				lastArg isNil ifTrue: [					firstStatements size = 1 ifTrue: [						firstArg statements: (Array with: NodeNil)					] ifFalse: [						firstArg statements: firstStatements allButLast.					].					firstArg returns: false.				] ifFalse: [					lastStatements size = 1 ifTrue: [						lastArg statements: (Array with: NodeNil)					] ifFalse: [						lastArg statements: lastStatements allButLast.					].					lastArg returns: false.				].				node == statements last ifTrue: [					parent statements: (statements copyWith: last)				].				anyTransformed := true			].		]	]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/6/2022 23:00'!removeWriteOnlyTemps	| anyTransformed |	anyTransformed := false.	block nodesDo: [:node | | tempsHolder statements toRemove keys newStatements |		node isBlockNode ifTrue: [			tempsHolder := node == block ifTrue: [self] ifFalse: [node].			tempsHolder temporaries isEmpty ifFalse: [ 				statements := node statements.				toRemove := Dictionary new.				tempsHolder temporaries do: [:e | | refs writes key |					e isBlockArg ifFalse: [						refs := 0.						writes := 0.						key := e key.						(key beginsWith: 'zzzTemp') ifTrue: [	"only remove our synthetic temps"							node accept: (ParseNodeEnumerator											ofBlock: [:n | 												(n isAssignmentNode and: [n variable key = key]) ifTrue: [writes := writes + 1].												(n isTemp and: [n key = key]) ifTrue: [refs := refs + 1]]).							writes = refs ifTrue: [								toRemove at: key put: 0						] ifFalse: [							(writes = 1 and: [refs = 2 and: [statements size > 1]]) ifTrue: [								statements withIndexDo: [:previous :i | | first |									(i < statements size and: [previous isAssignmentNode and: [previous variable key = key]]) ifTrue: [										first := true.										(statements at: i + 1) accept: (ParseNodePostOrderEnumerator											ofBlock: [:n | (first and: [n isVariableNode and: [n key = key]]) ifTrue: [first := false. toRemove at: key put: i ]]											select: [:n | first])]]]]]]].				toRemove isEmpty ifFalse: [					anyTransformed := true.					keys := toRemove keys.					tempsHolder temporaries: (tempsHolder temporaries reject: [:each | keys includes: each key] ).					toRemove values asSortedCollection reverseDo: [:i | | key previous replaced |						i > 0 ifTrue: [							key := toRemove keyAtValue: i.							statements := node statements.							previous := statements at: i.							replaced := false.							(statements at: i + 1) accept: 								(ParseNodeWithParentsEnumerator									ofBlock: [:n :parents | | parent messageParent |										(replaced not and: [n isVariableNode and: [n key = key]]) ifTrue: [											replaced := true.											parent := parents isEmpty ifTrue: [node] ifFalse: [parents last].											(parent isAssignmentNode and: [parents size > 1]) ifTrue: [												((messageParent := parents at: parents size - 1) isMessageNode and: 												[messageParent macroPrinter == #printToDoOn:indent: and: 												[messageParent arguments size >= 7 and:												[parent = messageParent argumentsInEvaluationOrder first]]]) ifTrue: [													"this is a synthetic assignmentNode, handle with care"													messageParent receiver: previous value]].											parent replace: n with: previous value]]									select: [:n :parents | replaced not]).							newStatements := (Array new: (statements size - 1)) 													replaceFrom: 1 to: i - 1 with: statements startingAt: 1;													replaceFrom: i to: statements size - 1 with: statements startingAt: i + 1.							node statements: newStatements						] ifFalse: [							toRemove keysAndValuesDo: [:k :ix |								ix = 0 ifTrue: [									node accept: 										(ParseNodeWithParentsEnumerator 											ofBlock: [:n :parents |												(n isAssignmentNode and: [n variable key = k]) ifTrue: [													parents last replace: n with: n value]])]]]]]]]].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 1/5/2023 18:26'!renameTempsNamedLikeMySelector	"This has to be called before generation, when the temp maps are computed"	| selector |	self assert: block blockExtent isNil.	(selector := self selector) precedence = 1 ifFalse: [		^self].	temporaries do: [:temp |		temp name = selector ifTrue: [			encoder bindUniquedTemp: temp]].	block nodesDo: [:n |		n isBlockNode ifTrue: [			n arguments do: [:arg |				arg name = selector ifTrue: [					encoder bindUniquedTemp: arg]].			n temporaries do: [:temp |				temp name = selector ifTrue: [					encoder bindUniquedTemp: temp]]]].! !!MethodNode methodsFor: 'transforming' stamp: 'fm 7/23/2022 00:02'!replaceStatementConditionalExpressions	| anyTransformed |	anyTransformed := false.	self selectWithParents: [:node :parents | 			node isBlockNode and: [(node isJust: NodeNil) not]]		do: [:parent :parents | | size allParents |			size := parent statements size.			allParents := parents copyWith: parent.			1 to: size do: [:i | | node replacement |				node := parent statements at: i.				(node isMessage and: 				[node selector key == #questionMark:colon: and: 				[i < size or: [(self isLocalReturn: node withParents: allParents) not]]]) ifTrue: [					replacement := MessageNode new							receiver: node receiver							selector: #ifTrue:ifFalse:							arguments: {BlockNode withJust: node arguments first. BlockNode withJust: node arguments last}							precedence: 3							from: encoder.					replacement noteSpecialSelector: #ifTrue:ifFalse:.					replacement arguments first noteOptimizedIn: replacement.					replacement arguments last noteOptimizedIn: replacement.					parent statements at: i put: replacement.					anyTransformed := true].				].			anyTransformed].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/25/2014 18:22'!replaceTempsIn: aBlock withTempsIn: enclosingBlock	aBlock temporaries do: [:temp |		self addTemp: temp to: enclosingBlock].	aBlock temporaries: #().! !!MethodNode methodsFor: 'transforming' stamp: 'fm 11/18/2022 23:35'!select: aNodeSelectBlock preservingEvaluationOrderDo: aBlock	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode | | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement | | allPrecedingNodes withParents |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						allPrecedingNodes := OrderedCollection new.						withParents := OrderedCollection with: blockNode.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |  | myParents p |								(aNodeSelectBlock value: aNode)									ifTrue: [										(aNode == statement or: [allPrecedingNodes size <= 1]) ifFalse: [											myParents := withParents allButLast: 1.											p := myParents last.											allPrecedingNodes withIndexDo: [:e :ix |  | r newVar notReferenced key followingMovingNode |												r := e key.												(r ~~ aNode and: [e value = myParents]) ifTrue: [													(r isAssignmentNode and: [p isMessageNode and: 													[p macroPrinter == #printToDoOn:indent: and: [p arguments size >= 7 and:													[r = p argumentsInEvaluationOrder first]]]]) ifTrue: [														"this is a synthetic assignmentNode, initStmt, handle with care"														r value isLiteralNode ifFalse: [															newVar := self addNewTempTo: blockNode.															blockNode addStatement: (AssignmentNode new variable: newVar value: r value) before: statement.															p receiver: newVar.															r replace: r value with: newVar.														]													] ifFalse: [														"Try to avoid adding unnecessary new temps (e.g. for storing other unreferenced temps)"														(r isTemp and: [														notReferenced := true. 														key := r key.														aNode accept: (ParseNodeEnumerator																ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [notReferenced := false]]																select: [:n| notReferenced]).														notReferenced ifTrue: [															ix + 1 to: allPrecedingNodes size do: [:i | 																notReferenced ifTrue: [																	(followingMovingNode := (allPrecedingNodes at: i) key) isVariableNode ifFalse: [																		followingMovingNode accept: (ParseNodeEnumerator																			ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [notReferenced := false]]																			select: [:n| notReferenced]).																	]																]															].														].														notReferenced]) ifFalse: [															newVar := self addNewTempTo: blockNode.															blockNode addStatement: (AssignmentNode new variable: newVar value: r) before: statement.															p replace: r with: newVar.														]													].												]]].										^aBlock value: withParents]									ifFalse: [										withParents remove: aNode]]							select: [ :aNode |								(aNode isKindOf: SelectorNode) not and: [									(aNode ~~ statement and: [aNode couldBeAffectedByReordering]) ifTrue: [allPrecedingNodes add: aNode -> withParents copy].									aNode isLeaf not and: [aNode isBlockNode not and: [withParents add: aNode. true]].									]])]]]]).	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/13/2022 14:33'!select: aNodeSelectBlock withBlockAndParentDo: aBlock	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode |  | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement | | allPrecedingNodes |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						allPrecedingNodes := IdentitySet new.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |  | withParents |								(aNodeSelectBlock value: aNode)									ifTrue: [										withParents := OrderedCollection with: blockNode.										aNode == statement 											ifFalse:												[| aNodeReached |												aNodeReached := false.												statement accept: 													(ParseNodeEnumerator														ofBlock: [:node| 															((allPrecedingNodes includes: node) or: [node isKindOf: SelectorNode]) 																ifFalse: [																	node isLeaf ifTrue: [self halt].																	withParents add: node]]														select: [:node | 															node isBlockNode not and: 															[(aNodeReached := aNodeReached or: [node == aNode]) not]])].										^aBlock value: aNode value: blockNode value: withParents last]									ifFalse: [										(aNode isKindOf: SelectorNode) ifFalse: [											allPrecedingNodes add: aNode]]]							select: [ :aNode | aNode isBlockNode not])]]]]).	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 20:08'!select: aNodeSelectBlock withEnclosingBlockDo: aBlock	| anySatisfied |	anySatisfied := false.	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode |  | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |								(aNodeSelectBlock value: aNode value: blockNode) ifTrue: [									(aBlock value: aNode value: blockNode) ifTrue: [anySatisfied := true]]]							select: [ :aNode | aNode isBlockNode not])]]]]).	^anySatisfied! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/13/2022 14:35'!select: aNodeSelectBlock withParentDo: aBlock	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode |  | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement | | allPrecedingNodes |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						allPrecedingNodes := IdentitySet new.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |  | withParents |								(aNodeSelectBlock value: aNode)									ifTrue: [										withParents := OrderedCollection with: blockNode.										aNode == statement 											ifFalse:												[| aNodeReached |												aNodeReached := false.												statement accept: 													(ParseNodeEnumerator														ofBlock: [:node| 															((allPrecedingNodes includes: node) or: [node isKindOf: SelectorNode]) 																ifFalse: [																	node isLeaf ifTrue: [self halt].																	withParents add: node]]														select: [:node | 															node isBlockNode not and: 															[(aNodeReached := aNodeReached or: [node == aNode]) not]])].										^aBlock value: aNode value: withParents last]									ifFalse: [										(aNode isKindOf: SelectorNode) ifFalse: [											allPrecedingNodes add: aNode]]]							select: [ :aNode | aNode isBlockNode not])]]]]).	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/13/2022 14:35'!select: aNodeSelectBlock withParentsDo: aBlock	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode |  | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement | | allPrecedingNodes |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						allPrecedingNodes := IdentitySet new.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |  | withParents |								(aNodeSelectBlock value: aNode)									ifTrue: [										withParents := OrderedCollection with: blockNode.										aNode == statement 											ifFalse:												[| aNodeReached |												aNodeReached := false.												statement accept: 													(ParseNodeEnumerator														ofBlock: [:node| 															((allPrecedingNodes includes: node) or: [node isKindOf: SelectorNode]) 																ifFalse: [																	node isLeaf ifTrue: [self halt].																	withParents add: node]]														select: [:node | 															node isBlockNode not and: 															[(aNodeReached := aNodeReached or: [node == aNode]) not]])].										^aBlock value: aNode value: withParents]									ifFalse: [										(aNode isKindOf: SelectorNode) ifFalse: [											allPrecedingNodes add: aNode]]]							select: [ :aNode | aNode isBlockNode not])]]]]).	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 9/24/2020 23:01'!selectWithParents: aNodeSelectBlock do: aBlock	| anySatisfied |	anySatisfied := false.	block accept: 		(ParseNodeWithParentsEnumerator 			ofBlock: [:node :parents | ((aNodeSelectBlock value: node value: parents) and: [aBlock value: node value: parents]) ifTrue: [anySatisfied := true]]).	^anySatisfied! !!MethodNode methodsFor: 'transforming' stamp: 'fm 11/18/2022 23:27'!selectWithParents: aNodeSelectBlock preservingEvaluationOrderDo: aBlock	block accept: 		(ParseNodePostOrderEnumerator ofBlock: [:blockNode | | visitedStatements |			blockNode isBlockNode ifTrue: [				visitedStatements := IdentitySet new.				blockNode statements do: [:statement | | allPrecedingNodes withParents |					((blockNode statements includes: statement) and:					[(visitedStatements includes: statement) not]) ifTrue: [						visitedStatements add: statement.						allPrecedingNodes := OrderedCollection new.						withParents := OrderedCollection with: blockNode.						statement accept: (ParseNodePostOrderEnumerator							ofBlock: [ :aNode |  | myParents p |								(aNodeSelectBlock value: withParents)									ifTrue: [										(aNode == statement or: [allPrecedingNodes size <= 1]) ifFalse: [											myParents := withParents allButLast: 1.											p := myParents last.											allPrecedingNodes withIndexDo: [:e :ix |  | r newVar notReferenced key followingMovingNode |												r := e key.												(r ~~ aNode and: [e value = myParents]) ifTrue: [													(r isAssignmentNode and: [p isMessageNode and: 													[p macroPrinter == #printToDoOn:indent: and: [p arguments size >= 7 and:													[r = p argumentsInEvaluationOrder first]]]]) ifTrue: [														"this is a synthetic assignmentNode, initStmt, handle with care"														r value isLiteralNode ifFalse: [															newVar := self addNewTempTo: blockNode.															blockNode addStatement: (AssignmentNode new variable: newVar value: r value) before: statement.															p receiver: newVar.															r replace: r value with: newVar.														]													] ifFalse: [														"Try to avoid adding unnecessary new temps (e.g. for storing other unreferenced temps)"														(r isTemp and: [														notReferenced := true. 														key := r key.														aNode accept: (ParseNodeEnumerator																ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [notReferenced := false]]																select: [:n| notReferenced]).														notReferenced ifTrue: [															ix + 1 to: allPrecedingNodes size do: [:i | 																notReferenced ifTrue: [																	(followingMovingNode := (allPrecedingNodes at: i) key) isVariableNode ifFalse: [																		followingMovingNode accept: (ParseNodeEnumerator																			ofBlock: [:n| (n isVariableNode and: [n key = key]) ifTrue: [notReferenced := false]]																			select: [:n| notReferenced]).																	]																]															].														].														notReferenced]) ifFalse: [															newVar := self addNewTempTo: blockNode.															blockNode addStatement: (AssignmentNode new variable: newVar value: r) before: statement.															p replace: r with: newVar.														]													].												]]].										^aBlock value: withParents]									ifFalse: [										withParents remove: aNode]]							select: [ :aNode |								(aNode isKindOf: SelectorNode) not and: [									(aNode ~~ statement and: [aNode couldBeAffectedByReordering]) ifTrue: [allPrecedingNodes add: aNode -> withParents copy].									aNode isLeaf not and: [aNode isBlockNode not and: [withParents add: aNode. true]].									]])]]]]).	^false! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 19:43'!transformLoopArguments	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | 			(node isMessage and: 			[node argumentsInEvaluationOrder anySatisfy: [:a | 				a isMessage and: 				[a isLoopStatement]]]) ifTrue: [			self halt]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 10/6/2022 22:30'!transformLoopLocalReturns	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:node :parents | | lastStatement |			node isBlockNode and: [(lastStatement := node statements last) isMessage and: [lastStatement isLoopStatement and: [				self isLocalReturn: lastStatement withParents: (parents copyWith: node)]]]]		do: [:node :parents | | lastStatement var returnValue |			lastStatement := node statements last.			returnValue := lastStatement loopReturnValue.			(returnValue isLiteralNode or: [returnValue == NodeNil]) ifTrue: [				node statements: (node statements copyWith: returnValue).			] ifFalse: [				var := self addNewTempTo: node.				node addStatement: (AssignmentNode new variable: var value: returnValue) before: lastStatement.				lastStatement replace: returnValue with: var.				node statements: (node statements copyWith: var).			].			true]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/17/2021 19:41'!transformLoopReceivers	| anyTransformed |	anyTransformed := false.	self accept: 		(ParseNodeEnumerator ofBlock: [:node | 			(node isMessage and: 			[node receiver notNil and: 			[node receiver isMessage and: 			[node receiver isLoopStatement]]]) ifTrue: [				self halt]]).	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/15/2021 21:41'!transformValueBlocksArguments	| anyTransformed |	anyTransformed := false.	[self select: [:node | 			node isMessage and: 			[node argumentsInEvaluationOrder anySatisfy: [:a | 				a isMessage and: 				[a hasOptimizedValueBlocks]]]] 		preservingEvaluationOrderDo: [:nodeWithParents | | node enclosingBlock enclosingStatement lastToBeReplaced |			enclosingBlock := nodeWithParents first.			enclosingStatement := nodeWithParents at: 2.			node := nodeWithParents removeLast.			node receiver couldBeAffectedByReordering ifTrue: [ | newVar |				newVar := self addNewTempTo: enclosingBlock.				enclosingBlock addStatement: (AssignmentNode new variable: newVar value: node receiver) before: enclosingStatement.				node replace: node receiver with: newVar].			lastToBeReplaced := (node argumentsInEvaluationOrder select: [:a | 										a isMessage and: 										[a hasOptimizedValueBlocks]]									) last.			node argumentsInEvaluationOrder anySatisfy: [:a | | newVar |				a couldBeAffectedByReordering and: [					newVar := self addNewTempTo: enclosingBlock.					enclosingBlock addStatement: (AssignmentNode new variable: newVar value: a) before: enclosingStatement.					node replace: a with: newVar.					a == lastToBeReplaced]]]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/6/2021 23:46'!transformValueBlocksLocalReturns	| anyTransformed |	anyTransformed := false.	[self selectWithParents: [:node :parents | 			node isMessage and: [node hasOptimizedValueBlocks and: [				node isFullyReturningFromOptimizedValueBlocks not and:				[self isLocalReturn: node withParents: parents]]]]		do: [:node :parents | | var parent nonReturningValueBlocks |			parent := parents last.			nonReturningValueBlocks := node optimizedValueBlocks reject: [:a | a returns].			(nonReturningValueBlocks allSatisfy: [:a | | last |						(((last := a statements last) isVariableNode or: [last isLiteralNode]) and: [(var isNil and: [var := last. true]) or: [var key = last key]]) or: 					[last isAssignmentNode and: [(var isNil and: [var := last variable. true]) or: [var key = last variable key]]]]			) ifFalse: [				var := self addNewTempTo: parent.				parent replace: node with: (AssignmentNode new variable: var value: node).				].			parent statements: (parent statements copyWith: var).			true]	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'transforming' stamp: 'fm 6/15/2021 21:41'!transformValueBlocksReceivers	| anyTransformed |	anyTransformed := false.	[self select: [:node | 			node isMessage and: 			[node receiver notNil and: 			[node receiver isMessage and: 			[node receiver hasOptimizedValueBlocks]]]] 		preservingEvaluationOrderDo: [:nodeWithParents | | nonReturningValueBlocks nonReturningValueBlock nonReturningValueBlockLocalReturn node enclosingBlock enclosingStatement newVar |			enclosingBlock := nodeWithParents first.			enclosingStatement := nodeWithParents at: 2.			node := nodeWithParents removeLast.			nonReturningValueBlocks := node receiver optimizedValueBlocks reject: [:a | a returns].			nonReturningValueBlocks size = 1 ifTrue: [				nonReturningValueBlock := nonReturningValueBlocks first.				nonReturningValueBlockLocalReturn := nonReturningValueBlock statements last.				nodeWithParents last replace: node with: node receiver.				node replace: node receiver with: nonReturningValueBlockLocalReturn.				nonReturningValueBlock replace: nonReturningValueBlockLocalReturn with: node.			] ifFalse: [				newVar := self addNewTempTo: enclosingBlock.				enclosingBlock addStatement: (AssignmentNode new variable: newVar value: node receiver) before: enclosingStatement.				node replace: node receiver with: newVar]			].	] whileTrue: [anyTransformed := true].	^anyTransformed! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 00:17'!JSPropertiesFor: aCompiledMethod	| propsDict loopsStack nonStOptimizedBlockNodesStack nonJsOptimizedBlockNodesStack counter compiledBlocks compiledBlocksDict decompiledMethodNode dBlock translatedBlocks blockPCsOk |	"SyntaxMorph >>| #mouseMove:"	"DynamicVariable class >>| #value:during:"	loopsStack := OrderedCollection new.	nonStOptimizedBlockNodesStack := OrderedCollection new.	nonJsOptimizedBlockNodesStack := OrderedCollection new.	propsDict := Dictionary new		at: #methodClass put: self methodClass;		at: #methodSelector put: self selector;		at: #compiledMethod put: aCompiledMethod;		yourself.	counter := 0.	compiledBlocks := encoder supportsFullBlocks ifTrue: [		aCompiledMethod allCompiledBlockLiterals	] ifFalse: [#()].	compiledBlocksDict := Dictionary new.	block accept: 		(ParseNodePostOrderEnumerator 			ofBlock: [:node |  				(node isBlockNode and: [node ~~ block]) ifTrue: [					node isJSoptimized ifTrue: [						node optimizedMessageNode isLoopStatement ifTrue: [							loopsStack remove: node]					] ifFalse: [						nonJsOptimizedBlockNodesStack remove: node					].					node optimized ifFalse: [						nonStOptimizedBlockNodesStack remove: node.					]				].			] 			select: [:node | | litIndex literalRefs triplet parentCompiledCode literalsHolderCompiledCode literalsDict allLiteralsDict index holderPath compiledBlock literalsHolderNode nonStOptimizedBlockNode | 				(node isBlockNode and: [node ~~ block]) ifTrue: [					node isJSoptimized ifTrue: [						node optimizedMessageNode isLoopStatement ifTrue: [							loopsStack add: node]					] ifFalse: [						nonJsOptimizedBlockNodesStack notEmpty ifTrue: [							propsDict at: #selfInsideBlock put: nil].						nonJsOptimizedBlockNodesStack add: node					].					node optimized ifFalse: [						propsDict at: node put: 'zzzBlock', (counter := counter + 1).						translatedBlocks isNil ifTrue: [							translatedBlocks := Dictionary new.						].						translatedBlocks at: 'zzzBlock', counter put: node.						compiledBlocks isEmpty ifFalse: [							triplet := compiledBlocks at: counter.							parentCompiledCode := triplet first.							parentCompiledCode == (nonStOptimizedBlockNodesStack isEmpty ifTrue: [aCompiledMethod] ifFalse: [compiledBlocksDict at: nonStOptimizedBlockNodesStack last]) ifFalse: [self halt].							compiledBlock := triplet at: 2.							node numberOfArguments = compiledBlock numArgs ifFalse: [self halt].							compiledBlocksDict at: node put: compiledBlock.							propsDict at: #compiledBlocksDict ifAbsentPut: [compiledBlocksDict].						].						nonStOptimizedBlockNodesStack add: node.					]				] ifFalse: [					(node isKindOf: InstanceVariableNode) ifTrue: [						propsDict at: #instvarRef  put: nil					] ifFalse: [						(node isLiteralLike and: [node isInlinedJsLiteral not and:						[index := nonStOptimizedBlockNodesStack size.						[index > 0 and: [(compiledBlocksDict at: (literalsHolderNode := nonStOptimizedBlockNodesStack at: index) ifAbsent: []) isNil]] whileTrue: [index := index - 1].						index > 0 ifTrue: [							literalsHolderCompiledCode := compiledBlocksDict at: literalsHolderNode						] ifFalse: [							literalsHolderCompiledCode := aCompiledMethod.							literalsHolderNode := #method].						"Now exclude (recursively) leaf jsOptimized blocks and build a path for the compiledCode holding the literal"						holderPath := ''.						[index > 0 and: [(nonStOptimizedBlockNode := nonStOptimizedBlockNodesStack at: index) isJSoptimized]] whileTrue: [							compiledBlock := compiledBlocksDict at: nonStOptimizedBlockNode.							parentCompiledCode := index > 1 ifTrue: [compiledBlocksDict at: (nonStOptimizedBlockNodesStack at: index - 1)] ifFalse: [aCompiledMethod].							holderPath := '.literals[', (parentCompiledCode indexOfLiteral: compiledBlock), ']', holderPath.							index := index - 1].						index > 0 ifTrue: [							holderPath := (propsDict at: nonStOptimizedBlockNode), holderPath].						(litIndex := node jsLiteralIndexUsing: literalsHolderCompiledCode) notNil]]) ifTrue: [							allLiteralsDict := propsDict at: #literalsDict ifAbsentPut: [Dictionary new].							literalsDict := allLiteralsDict at: literalsHolderNode ifAbsentPut: [Dictionary new].							literalsDict at: #holderPath ifAbsentPut: [holderPath].							literalRefs := literalsDict at: #thisMethodLiteralsRef ifAbsentPut: [Set new].							((literalRefs includes: litIndex) or: [(encoder supportsFullBlocks not and: [nonJsOptimizedBlockNodesStack notEmpty]) or: [loopsStack notEmpty]]) ifTrue: [								(literalsDict at: #reusedLiterals ifAbsentPut: [Set new]) add: litIndex].							literalRefs add: litIndex						] ifFalse: [							node isMessageNode ifTrue: [								node isJsOptimized ifTrue: [									node arguments size > 0 ifTrue: [										node arguments first optimizedMessageNode: node].									node receiver isBlockNode ifTrue: [										node receiver optimizedMessageNode: node]								] ifFalse: [									nonJsOptimizedBlockNodesStack isEmpty ifFalse: [										(node receiver isVariableNode and: [node receiver key = 'super']) ifTrue: [											propsDict at: #selfInsideBlock put: nil										]									]								].							] ifFalse: [								nonJsOptimizedBlockNodesStack isEmpty ifFalse: [									(node isKindOf: ReturnNode) ifTrue: [										(propsDict at: #nonLocalReturns ifAbsentPut: [OrderedCollection new]) add: node									] ifFalse: [										(node isVariableNode and: 											[node isSelfPseudoVariable or: 											[node key = 'thisContext']]) ifTrue: [												propsDict at: #selfInsideBlock put: nil										]									]								]							].						].					].				].				true			]).	blockPCsOk := false.	translatedBlocks notNil ifTrue: [		counter := 0.		decompiledMethodNode := [aCompiledMethod decompileWithTemps] on: Error do: [:e | aCompiledMethod decompile].		(dBlock := decompiledMethodNode block) accept: 			(ParseNodePostOrderEnumerator 				ofBlock: [:n | | caseNode |					n isMessageNode ifTrue: [						(n isOptimized or: [#(to:do: to:by:do:) includes: n selector key "if this were a transformed while loop, it would be optimized"]) ifFalse: [							n noteSpecialSelector: n selector key].						n isOptimized ifTrue: [							decompiledMethodNode encoder noteSourceRange: (1 to: 0) forNode: n.	"bogus range, we don't care about it, but transform blows up without it"							n macroPrinter == #printCaseOn:indent: ifTrue: [								caseNode := n arguments first.								((caseNode isMemberOf: BraceNode) and: [caseNode elements size > 0]) ifTrue: [									caseNode elements: caseNode elements sourceLocations: (Array new: caseNode elements size).									(n transform: decompiledMethodNode encoder) ifFalse: [self halt]								].							] ifFalse: [								n transform: decompiledMethodNode encoder							]]]]).		dBlock nodesDo: [:node | | translatedBlock compiledBlockPC |			(node isBlockNode and: [node ~~ dBlock]) ifTrue: [				node optimized ifFalse: [					translatedBlock := translatedBlocks at: 'zzzBlock', (counter := counter + 1).					(translatedBlock returns = node returns and: [translatedBlock numberOfArguments = node numberOfArguments]) ifFalse: [self halt].					compiledBlocks isEmpty ifTrue: [						node pc ~= 0 ifTrue: [							compiledBlockPC := node pc value						] ifFalse: [self halt].					] ifFalse: [						compiledBlockPC := (compiledBlocks at: counter) at: 3.						(node pc ~= 0 and: [node pc value ~= compiledBlockPC]) ifTrue: [self halt].					].					translatedBlock pc: compiledBlockPC.				]]].		counter = translatedBlocks size ifTrue: [			blockPCsOk := true		] ifFalse: [self halt]	].	propsDict at: #blockPCsOk put: blockPCsOk.	^propsDict! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 11/4/2022 00:02'!JSprepare: willInline	| compiler |	self normalize: willInline. 	compiler := Compiler new.	compiler parser encoderClass: encoder class.				   	^compiler compile: self fullPrintString in: self methodClass environment: encoder environment notifying: nil ifFail: [].! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 1/8/2022 21:01'!JSprintEntryPreemptionOn: aStream properties: propsDict.	aStream nextPutAll: 'if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("';		nextPutAll: (propsDict at: #methodClass) name;		nextPutAll: '>>';		nextPutAll: (propsDict at: #methodSelector);		nextPutAll: ', checking interrupts:", false, false);';		cr;		crtab: 1! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 6/16/2023 16:20'!asJavaScript	| prepared cm props |	prepared := self JSprepare: false.	cm := prepared generateWithTempNames.	"check viability of decompiled sources"	Compiler new compile: cm decompileWithTemps fullPrintString in: self methodClass environment: encoder environment notifying: nil ifFail: [self halt].	prepared removeIfNil.	props := prepared JSPropertiesFor: cm.	^cm -> (String streamContents: [:s | prepared printJSOn: s properties: props])! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 12:42'!inlineBodyOf: primitiveNumber on: aStream properties: propsDict	| name primitiveString actualArguments errorVarName |		name := primitiveNumber printString.	(primitiveString := JavaScriptTranspiler instance inlineablePrimitiveBodies at: primitiveNumber ifAbsent: []) isNil 		ifTrue: [			aStream tab; 				nextPutAll: 'console.log("Primitive ';				nextPutAll: name;				nextPutAll: ' is not implemented yet");';				crtab;				nextPutAll: 'yield* SmalltalkVM.debug();'			]		ifFalse: [			(((propsDict at: #methodClass) inheritsFrom: InstructionStream)					and: [(propsDict at: #methodClass) isContextClass							and: [self selector beginsWith: 'object']]) ifTrue: [				"mirror primitives"				primitiveString := (self selector 					caseOf: {						[#objectClass:] -> ['if (true) return _' , arguments first name , '._class();'].						[#object:eqeq:] -> ['if (true) return _' , arguments first name , '._eqEq(_' , arguments last name , ');'].					} otherwise: [						actualArguments := arguments allButFirst.						actualArguments withIndexDo: [:a :i | | token |							token := actualArguments size > 1 ifTrue: ['arg', i] ifFalse: ['arg'].							primitiveString := primitiveString copyReplaceTokens: token with: '_', a name].						primitiveString := primitiveString copyReplaceTokens: 'this' with: '_', arguments first name					])			] ifFalse: [				arguments withIndexDo: [:a :i | | token |					token := arguments size > 1 ifTrue: ['arg', i] ifFalse: ['arg'].					primitiveString := primitiveString copyReplaceTokens: token with: '_', a name].			].			(errorVarName := self primitiveErrorVariableName) notNil ifTrue: [				aStream crtab;					nextPutAll: 'let _';							nextPutAll: errorVarName;					nextPutAll: ' = nil;';					crtab			].			"This is for the sake of test methods which call primitives without arguments, as well as for primitives that set an error code.			But we want to idenitify the test methods scenario while avoiding false positives in primitives that refer to the function's special variable 'arguments'.			In particular we have to avoid adding adding a try/catch to the (full)blockclosure primitives, which are not at a barrier from the VM to the image,			they bridge image-side to image-side, and part of the exceptions handling implementation needs exclusivity on the image side, 			as it uses JavaScript throw/catch - see e.g. the primitive 199 implementation"			((arguments isEmpty and: [((primitiveString copyReplaceTokens: 'arguments' with: 'rguments') indexOfSubCollection: 'arg' startingAt: 1) > 0]) or:			[errorVarName notNil]) ifTrue: [				primitiveString := 'try {	', primitiveString, '	} catch (catchVar) {		'.				errorVarName notNil ifTrue: [						primitiveString := primitiveString, 'if (!!catchVar.isPrimitiveFailed) {			'.					(#(87 88 188 578) includes: primitiveNumber) ifTrue: [						primitiveString := primitiveString, 'if ('.						(#(87 188) includes: primitiveNumber) ifTrue: [							primitiveString := primitiveString, '!!catchVar.isNonLocalReturn && '.						].						primitiveString := primitiveString, 'catchVar !!== "TERMINATE")	'.					].					primitiveString := primitiveString, '			yield* SmalltalkVM.debug();			throw catchVar;		}		_', errorVarName, ' = catchVar.payload;	}'				] ifFalse: [					primitiveString := primitiveString, 'if (!!(catchVar instanceof ReferenceError) || !!catchVar.message.startsWith("arg")) yield* SmalltalkVM.debug()	}'				]			].			aStream nextPutAll: '//Start inlined primitive ';				nextPutAll: name;				crtab;				nextPutAll: primitiveString;				cr;				nextPutAll: '//End inlined primitive ';				nextPutAll: name;				cr			]! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 6/18/2023 12:31'!printJSOn: aStream properties: propsDict	| selector indent returnExpr literalRefs literalsDict index definedNames seen statements tempDefinitions toRemove temps |	selector := self selector.	precedence = 1		ifTrue:			[aStream nextPutAll: '_';				nextPutAll: selector;				nextPutAll: ': function *_';				nextPutAll: selector;				nextPutAll: '() {']		ifFalse:			[precedence = 2				ifTrue: [					aStream nextPutAll: selector JSmappingForBinary;							nextPutAll: ': function *';							nextPutAll: selector JSmappingForBinary;							nextPutAll: '(_';							nextPutAll: arguments first name;							nextPutAll: ') {']				ifFalse: [					aStream nextPutAll: '_'.					selector keywords do: [:kwd |						aStream nextPutAll: (kwd copyFrom: 1 to: kwd size - 1); nextPut: $_].					aStream nextPutAll: ': function *_'.					selector keywords do: [:kwd |						aStream nextPutAll: (kwd copyFrom: 1 to: kwd size - 1); nextPut: $_].					aStream nextPut: $(.					arguments 						do: [:arg | aStream nextPut: $_; nextPutAll: arg name]						separatedBy: [							aStream								nextPut: $,;								 space].					aStream nextPutAll: ') {']]..	comment == nil ifFalse:		[aStream crtab.		 self printJSCommentOn: aStream indent: 1].	tempDefinitions := #().	(temporaries isNil or: [temporaries isEmpty]) ifFalse: [		seen := Set new.		statements := block statements.		temps := temporaries reject: [:e | e isIndirectTempVector].		temps size < temporaries size ifTrue: [			temps := temps asOrderedCollection.			temporaries do: [:e | e isIndirectTempVector ifTrue: [temps addAll: e remoteTemps]]].		tempDefinitions := statements select: [:s | s isAssignmentNode and: [(temps includes: s variable) and: [(seen includes: s variable key) not and: [seen add: s variable key. true]]]].		toRemove := OrderedCollection new.		tempDefinitions do: [:def | | referencedBeforeDef tempVector |			referencedBeforeDef := false.			1 to: (statements indexOf: def) do: [:i |				referencedBeforeDef ifFalse: [					(statements at: i) value nodesDo: [:e | 						(referencedBeforeDef not and: [e isVariableNode and: [e key = def variable key]]) ifTrue: 							[referencedBeforeDef := true]]]].			referencedBeforeDef ifTrue: [				toRemove add: def			] ifFalse: [				(temporaries includes: def variable) ifFalse: [ 					tempVector := temporaries detect: [:e | e isIndirectTempVector and: [e remoteTemps includes: def variable]].					(propsDict at: tempVector ifAbsentPut: [Set new]) add: def variable key				].			]].		toRemove do: [:def | tempDefinitions remove: def].	].	tempDefinitions isEmpty ifTrue: [		block printJSTemporaries: temporaries on: aStream doPrior: [aStream crtab]	] ifFalse: [		definedNames := (tempDefinitions collect: [:def | def variable key]) asSet.		block printJSTemporaries: (temporaries reject: [:e | definedNames includes: e key]) on: aStream doPrior: [aStream crtab]	].	aStream crtab.		((primitive = 0 or: [primitive between: 255 and: 519]) and: [block statements size = 1 and: 	[(block statements first class == ReturnNode) and: 	[(returnExpr := block statements first expr) isKindOf: LeafNode]]]) 		ifTrue: ["more general than quick prims"			aStream nextPutAll: 'return '.			(returnExpr isKindOf: InstanceVariableNode) ifTrue: [				index := block statements first expr index.				(self methodClass == BlockClosure and: [index = 1]) ifTrue: [					aStream nextPutAll: 'this.pointers ? this.pointers[1] : this.compiledMethod || this.startpc;'				] ifFalse: [					(self methodClass includesBehavior: BlockClosure) ifTrue: [						index = 0 ifTrue: [							aStream nextPutAll: 'this.pointers ? this.pointers[0] : nil'							] ifFalse: [							index = 1 ifTrue: [								aStream nextPutAll: 'this.pointers ? this.pointers[1] : this.compiledMethod;'							] ifFalse: [								index = 2 ifTrue: [									aStream nextPutAll: 'this.pointers ? this.pointers[2] : this.length;'								] ifFalse: [									aStream nextPutAll: 'this.pointers ? this.pointers[3] : this.receiver;'								]							]						]					] ifFalse: [						aStream nextPutAll: 'this.pointers[';							nextPutAll: index printString;							nextPut: $]					]				]			] ifFalse: [				returnExpr printJSOn: aStream indent: 1 properties: propsDict.			].			aStream cr;				nextPut: $}.			^self].	primitive > 0 ifTrue: [		aStream cr.		self printJSPrimitive: primitive on: aStream properties: propsDict.		aStream crtab].	self JSprintEntryPreemptionOn: aStream properties: propsDict.	(propsDict includesKey: #instvarRef) ifTrue: [		aStream nextPutAll: 'const instvars = this.pointers;';			crtab.		self methodClass == BlockClosure ifTrue: [			aStream nextPutAll: 'const length = instvars ? instvars[2] : this.length, startpc = instvars ? instvars[1] : this.compiledMethod || this.startpc, receiver = instvars ? instvars[3] : this.receiver, outerContext = instvars ? instvars[0] : nil;';				crtab.		] ifFalse: [			(self methodClass includesBehavior: BlockClosure) ifTrue: [				aStream nextPutAll: 'const length = instvars ? instvars[2] : this.length, startpcOrMethod = instvars ? instvars[1] : this.compiledMethod, receiver = instvars ? instvars[3] : this.receiver, outerContext = instvars ? instvars[0] : nil;';					crtab.			].		].	].	literalsDict := (propsDict at: #literalsDict ifAbsent: []) ifNotNil: [:l | l at: #method ifAbsent: []].	(literalsDict notNil and: [(literalRefs := literalsDict at: #thisMethodLiteralsRef ifAbsent: [#()]) notEmpty]) ifTrue: [		literalRefs size > 1 ifTrue: [			aStream nextPutAll: 'const thisMethodLiterals = ';				nextPutAll: selector JSmapping;				nextPutAll: '.literals;';				crtab.		].		(literalsDict at: #reusedLiterals ifAbsent: [#()]) do: [:litIx | 			aStream nextPutAll: 'const literal';				nextPutAll: litIx printString;				nextPutAll: (literalRefs size > 1 ifTrue: [' = thisMethodLiterals['] ifFalse: [' = ', selector JSmapping, '.literals[']);				nextPutAll: litIx printString.			((propsDict at: #compiledMethod) literalAt: litIx) isVariableBinding ifTrue: [				aStream nextPutAll: '].pointers;'			] ifFalse: [				aStream nextPutAll: '];'			].			aStream crtab.		]	].	(propsDict includesKey: #selfInsideBlock) ifTrue: [		aStream nextPutAll: 'const self = this;';			crtab			].	indent := 1.	(propsDict includesKey: #nonLocalReturns) ifTrue: [		aStream nextPutAll: 'const nonLocalReturnException = Object.create(NonLocalReturn);';			crtab;			nextPutAll: 'try {';			crtab: 2.		indent := 2.		].	tempDefinitions isEmpty ifTrue: [		block printJSStatementsOn: aStream indent: indent properties: propsDict	] ifFalse: [		block printJSStatementsOn: aStream indent: indent properties: propsDict definitions: tempDefinitions	].	(propsDict includesKey: #nonLocalReturns) ifTrue: [		aStream crtab: 1;			nextPutAll: '} catch(aJavaScriptException) {';			crtab: 2;			nextPutAll: 'if (aJavaScriptException === nonLocalReturnException)';			crtab: 3;			nextPutAll: 'return nonLocalReturnException.payload;';			crtab: 2;			nextPutAll: 'else if (aJavaScriptException.isNonLocalReturn || aJavaScriptException === "TERMINATE")'; 			crtab: 3;			nextPutAll: 'throw aJavaScriptException;';			crtab: 2;			nextPutAll: 'else'; 			crtab: 3;			nextPutAll: 'yield* SmalltalkVM.debug();';			crtab;			nextPut: $}		].	aStream cr; nextPut: $}! !!MethodNode methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 12:44'!printJSPrimitive: primitive on: aStream   properties: propsDict	| name |	primitive = 117 ifTrue: [ | primDecl primitiveString |		primDecl := (propsDict at: #compiledMethod) literalAt: 1.		name := primDecl at: 2.		(name isNil or: [name isEmpty or: [name endsWith: '_']])			ifTrue: [^self "not a real primitive"].		primDecl first ifNil: [			name = 'primitiveImageFormatVersion' ifTrue: [				aStream nextPutAll: '//Start inlined primitive primitiveImageFormatVersion';					crtab;					nextPutAll: 'if (true) return ';					nextPutAll: Smalltalk imageFormatVersion printString;					crtab;					nextPutAll: '//End inlined primitive primitiveImageFormatVersion'.				^self			].			name = 'primitiveInterpreterSourceVersion' ifTrue: [				aStream nextPutAll: '//Start inlined primitive primitiveInterpreterSourceVersion';					crtab;					nextPutAll: 'if (true) return SmalltalkGlobals._ByteString.from("4.8.0");';		"indicate support for mirror primitives"					crtab;					nextPutAll: '//End inlined primitive primitiveInterpreterSourceVersion'.				^self			].			name = 'primitiveMillisecondClockMask' ifTrue: [				aStream nextPutAll: '//Start inlined primitive primitiveMillisecondClockMask';					crtab;					nextPutAll: 'if (true) return Number.MAX_SAFE_INTEGER';					crtab;					nextPutAll: '//End inlined primitive primitiveMillisecondClockMask'.				^self			].			name = 'primitivePluginBrowserReady' ifTrue: [				aStream nextPutAll: '//Start inlined primitive primitivePluginBrowserReady';					crtab;					nextPutAll: '// Just fail';					crtab;					nextPutAll: '//End inlined primitive primitivePluginBrowserReady'.				^self			].			name = 'primitiveScreenScaleFactor' ifTrue: [				aStream nextPutAll: '//Start inlined primitive primitiveScreenScaleFactor';					crtab;					nextPutAll: '// Just fail';					crtab;					nextPutAll: '//End inlined primitive primitiveScreenScaleFactor'.				^self			].			name = 'primitiveUtcWithOffset' ifTrue: [				primitiveString := 'const argVal = arg.valueOf();    const instvars = argVal.pointers;    if (instvars && instvars.length === 2) {        const d = new Date();        const posixMicroseconds = d.getTime() * 1000;        const offsetSeconds = -60 * d.getTimezoneOffset();        instvars[0] = posixMicroseconds;        instvars[1] = offsetSeconds;        return arg;    }'.				arguments withIndexDo: [:a :i | | token |					token := arguments size > 1 ifTrue: ['arg', i] ifFalse: ['arg'].					primitiveString := primitiveString copyReplaceTokens: token with: '_', a name].				aStream nextPutAll: '//Start inlined primitive primitiveUtcWithOffset';					crtab;					nextPutAll: primitiveString;					cr;					nextPutAll: '//End inlined primitive primitiveUtcWithOffset';					cr.				^self			].			aStream tab; 				nextPutAll: 'console.log("Primitive ';				nextPutAll: name;				nextPutAll: ' is not implemented yet");';				crtab;				nextPutAll: 'yield* SmalltalkVM.debug();'.			^self			].		self primitiveErrorVariableName ifNotNil: [:errorVarName | 			aStream crtab;				nextPutAll: 'let _';						nextPutAll: errorVarName;				nextPutAll: ' = nil;';				crtab		].		(primDecl first = 'FilePlugin' and: [name = 'primitiveDirectorySetMacTypeAndCreator']) ifTrue: [			aStream nextPutAll: '//Start inlined primitive primitiveDirectorySetMacTypeAndCreator';				crtab;				nextPutAll: 'if (true) return this';				crtab;				nextPutAll: '//End inlined primitive primitiveDirectorySetMacTypeAndCreator'.			^self		].		aStream nextPutAll: '//Calling named primitive ';			crtab;			nextPutAll: 'try {';			crtab: 2;			nextPutAll: 'const result = ';			nextPutAll: primDecl first;			nextPut: $.;			nextPutAll: name;			nextPutAll: '.apply(this, arguments);';			crtab: 2;			nextPutAll: 'if (result === undefined) return this';			crtab: 2;			nextPutAll: 'if (result !!== null) return result';			crtab;			nextPutAll: '} catch(catchVar) {';			crtab: 2;			nextPutAll: 'if (catchVar.isPrimitiveReturn) return catchVar.payload;';			crtab: 2.		(primDecl = 'SecurityPlugin' and: [name = 'primitiveCanWriteImage' or: [name = 'primitiveHasSocketAccess']]) ifTrue: [			aStream				nextPutAll: 'if (catchVar instanceof ReferenceError && catchVar.message.startsWith("SecurityPlugin")) {';				crtab: 3;				nextPutAll: 'console.log("Missing plugin SecurityPlugin");';				crtab: 3;				nextPutAll: 'return false;'		] ifFalse: [			aStream				nextPutAll: 'if (catchVar.isPrimitiveYield) {';				crtab: 3;				nextPutAll: 'while (!!catchVar.payloadHolder.completed) {yield "relinquishing Processor for 5"}';				crtab: 3;				nextPutAll: 'return catchVar.payloadHolder.value}';				crtab: 2;				nextPutAll: 'if (catchVar instanceof ReferenceError && catchVar.message.startsWith("';				nextPutAll: primDecl first;				nextPutAll: '")) {';				crtab: 3;				nextPutAll: 'console.log("Missing plugin ';				nextPutAll: primDecl first;				nextPutAll: '");';				crtab: 2;				nextPutAll: '} else if (catchVar instanceof TypeError && catchVar.message == "Cannot read properties of undefined (reading ''apply'')") {';				crtab: 3;				nextPutAll: 'console.log("Primitive ';				nextPutAll: primDecl first;				nextPut: $.;				nextPutAll: name;				nextPutAll: ' is not implemented yet");';				crtab: 3;				nextPutAll: 'yield* SmalltalkVM.debug();'.		].		aStream			crtab: 2;			nextPutAll: '} else if (!!catchVar.isPrimitiveFailed) {';			crtab: 3;			nextPutAll: 'console.log("JavaScript error during ';			nextPutAll: primDecl first;			nextPut: $.;			nextPutAll: name;			nextPutAll: ': " + catchVar + "\n" + catchVar.stack);';			crtab: 3;			nextPutAll: 'yield* SmalltalkVM.debug();';			crtab: 2;			nextPut: $}.		self primitiveErrorVariableName ifNotNil: [:errorVarName | 			aStream crtab: 2;				nextPut: $_;				nextPutAll: errorVarName;				nextPutAll: ' = catchVar.payload;'						].		aStream crtab;			nextPut: $}.	] ifFalse: [		self inlineBodyOf: primitive on: aStream properties: propsDict.	].! !!ParseNode class methodsFor: 'accessing' stamp: 'fm 10/17/2020 01:47'!tempSortBlockWithoutBlockExtents	"Answer a block that can sort a set of temporaries into a stable	 order so that different compilations produce the same results."	^[:t1 :t2| 	   t1 index < t2 index "simple sort by index."	   or: [t1 index = t2 index "complex tie break" 		  and: [t1 isRemote ~= t2 isRemote				ifTrue: [t2 isRemote] "put direct temps before indirect temps"				ifFalse: 					[t1 name < t2 name]]]] "only have the name left to go on"! !!BlockNode class methodsFor: 'instance creation' stamp: 'fm 9/15/2020 22:59'!withJust: aNode	^ self new statements: (Array with: aNode) returns: (aNode isKindOf: ReturnNode)! !!BytecodeEncoder class methodsFor: 'bytecode decoding' stamp: 'fm 6/15/2022 00:37'!pcAfterBlockPushForBlockStartingAt: startpc in: method	"This is actually the implementation for the Sista encoder, it is here for the changeset's compatibility with older images that lack the Sista encoder class"	"Answer the pc of the push closure bytecode whose block starts at startpc in method.	 May need to back up to include extension bytecodes."	"*	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)	 *	225		11100001	bbbbbbbb			Extend B (Ext B = Ext B prev * 256 + Ext B)	 **	250		11111010 	eeiiikkk		jjjjjjjj	Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"	| numExtensions |	self assert: (method at: startpc - 3) = 250.	numExtensions := (method at: startpc - 2) >> 6.	^startpc - (numExtensions * 2)! !!BytecodeEncoder class methodsFor: 'testing' stamp: 'eem 1/10/2018 13:58'!supportsFullBlocks	"Answer if the instruction set supports full closures (closure creation from	 specfic methods instead of bytecodes embedded in an outer home method)."	^self basicNew supportsFullBlocks! !!ParseNodeWithParentsEnumerator methodsFor: 'initialize-release' stamp: 'fm 9/20/2020 19:34'!ofBlock: aBlock	theBlock := aBlock.	parents := OrderedCollection new! !!ParseNodeWithParentsEnumerator methodsFor: 'initialize-release' stamp: 'fm 9/20/2020 19:34'!ofBlock: aBlock select: aSelectBlock	theBlock := aBlock.	theSelectBlock := aSelectBlock.	parents := OrderedCollection new! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:14'!visitAssignmentNode: anAssignmentNode	(theSelectBlock isNil or: [theSelectBlock value: anAssignmentNode value: parents]) ifFalse:		[^nil].	theBlock value: anAssignmentNode value: parents.	parents add: anAssignmentNode.	super visitAssignmentNode: anAssignmentNode.	parents remove: anAssignmentNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:14'!visitBlockNode: aBlockNode	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode value: parents]) ifFalse:		[^nil].	theBlock value: aBlockNode value: parents.	parents add: aBlockNode.	super visitBlockNode: aBlockNode.	parents remove: aBlockNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:14'!visitBraceNode: aBraceNode	(theSelectBlock isNil or: [theSelectBlock value: aBraceNode value: parents]) ifFalse:		[^nil].	theBlock value: aBraceNode value: parents.	parents add: aBraceNode.	super visitBraceNode: aBraceNode.	parents remove: aBraceNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:14'!visitCascadeNode: aCascadeNode	(theSelectBlock isNil or: [theSelectBlock value: aCascadeNode value: parents]) ifFalse:		[^nil].	theBlock value: aCascadeNode value: parents.	parents add: aCascadeNode.	super visitCascadeNode: aCascadeNode.	parents remove: aCascadeNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:34'!visitCommentNode: aCommentNode	(theSelectBlock isNil or: [theSelectBlock value: aCommentNode value: parents]) ifFalse:		[^nil].	theBlock value: aCommentNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:34'!visitFieldNode: aFieldNode	(theSelectBlock isNil or: [theSelectBlock value: aFieldNode value: parents]) ifFalse:		[^nil].	theBlock value: aFieldNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:13'!visitFutureNode: aFutureNode	(theSelectBlock isNil or: [theSelectBlock value: aFutureNode value: parents]) ifFalse:		[^nil].	theBlock value: aFutureNode value: parents.	parents add: aFutureNode.	super visitFutureNode: aFutureNode.	parents remove: aFutureNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:34'!visitInstanceVariableNode: anInstanceVariableNode	(theSelectBlock isNil or: [theSelectBlock value: anInstanceVariableNode value: parents]) ifFalse:		[^nil].	theBlock value: anInstanceVariableNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:35'!visitLiteralNode: aLiteralNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralNode value: parents]) ifFalse:		[^nil].	theBlock value: aLiteralNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:35'!visitLiteralVariableNode: aLiteralVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralVariableNode value: parents]) ifFalse:		[^nil].	theBlock value: aLiteralVariableNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:12'!visitMessageNode: aMessageNode	(theSelectBlock isNil or: [theSelectBlock value: aMessageNode value: parents]) ifFalse:		[^nil].	theBlock value: aMessageNode value: parents.	parents add: aMessageNode.	super visitMessageNode: aMessageNode.	parents remove: aMessageNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:13'!visitMessageNodeInCascade: aMessageNodeInCascade	(theSelectBlock isNil or: [theSelectBlock value: aMessageNodeInCascade value: parents]) ifFalse:		[^nil].	theBlock value: aMessageNodeInCascade value: parents.	parents add: aMessageNodeInCascade.	super visitMessageNodeInCascade: aMessageNodeInCascade.	parents remove: aMessageNodeInCascade ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:38'!visitMethodNode: aMethodNode	(theSelectBlock isNil or: [theSelectBlock value: aMethodNode value: #()]) ifFalse:		[^nil].	theBlock value: aMethodNode value: #().	^super visitMethodNode: aMethodNode! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:39'!visitNewArrayNode: aNewArrayNode	(theSelectBlock isNil or: [theSelectBlock value: aNewArrayNode value: parents]) ifFalse:		[^nil].	theBlock value: aNewArrayNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:39'!visitRemoteTempVectorNode: aRemoteTempVectorNode	(theSelectBlock isNil or: [theSelectBlock value: aRemoteTempVectorNode value: parents]) ifFalse:		[^nil].	theBlock value: aRemoteTempVectorNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 10/11/2020 22:13'!visitReturnNode: aReturnNode	(theSelectBlock isNil or: [theSelectBlock value: aReturnNode value: parents]) ifFalse:		[^nil].	theBlock value: aReturnNode value: parents.	parents add: aReturnNode.	super visitReturnNode: aReturnNode.	parents remove: aReturnNode ifAbsent: []! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:41'!visitSelectorNode: aSelectorNode	(theSelectBlock isNil or: [theSelectBlock value: aSelectorNode value: parents]) ifFalse:		[^nil].	theBlock value: aSelectorNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:41'!visitTempVariableNode: aTempVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aTempVariableNode value: parents]) ifFalse:		[^nil].	theBlock value: aTempVariableNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:42'!visitUndeclaredVariableNode: aVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aVariableNode value: parents]) ifFalse:		[^nil].	theBlock value: aVariableNode value: parents.! !!ParseNodeWithParentsEnumerator methodsFor: 'visiting' stamp: 'fm 9/20/2020 15:41'!visitVariableNode: aVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aVariableNode value: parents]) ifFalse:		[^nil].	theBlock value: aVariableNode value: parents.! !!ParseNodeWithParentsEnumerator class methodsFor: 'instance creation' stamp: 'fm 9/20/2020 15:08'!ofBlock: aBlock	^self new ofBlock: aBlock! !!ParseNodeWithParentsEnumerator class methodsFor: 'instance creation' stamp: 'fm 9/20/2020 15:08'!ofBlock: aBlock select: selectBlock	^self new ofBlock: aBlock select: selectBlock! !!Parser methodsFor: 'private' stamp: 'fm 1/13/2023 00:00'!addComment	(parseNode ~~ nil and: [currentComment ~~ nil])		ifTrue: 			[parseNode comment: currentComment.			(currentComment detect: [:c | (c beginsWith: '<JS>') and: [c endsWith: '</JS>']] ifNone: []) 				ifNotNil: [					(self properties includesProperty: #source) ifFalse: [						properties := properties copyWith: (Association										key: #source										value: source originalContents)]				].			currentComment := nil]! !!Process methodsFor: 'JavaScript generation' stamp: 'fm 11/24/2022 00:12'!JSstoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: 'nil'! !!Process class methodsFor: 'JavaScript generation' stamp: 'fm 10/5/2022 00:34'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = Object.seal(new Array(';			nextPutAll: self instSize printString;			nextPutAll: ').fill(nil));';			crtab;			nextPutAll: 'this.exceptionHandlers = [];';			crtab;			nextPutAll: 'this.exception = null;';			crtab;			nextPutAll: 'this.name = "defined";';			cr;			nextPut: $};			cr! !!ReadStream methodsFor: 'file stream compatibility' stamp: 'fm 1/31/2022 22:33'!isReadOnly	^true! !!ReadStream methodsFor: 'file stream compatibility' stamp: 'fm 1/31/2022 22:34'!setConverterForCode! !!ReadWriteStream methodsFor: 'accessing' stamp: 'fm 1/31/2022 22:35'!readOnlyCopy	readLimit := readLimit max: position.	^ ReadStream		on: collection		from: 1		to: readLimit! !!ReadWriteStream methodsFor: 'file status' stamp: 'fm 7/9/2022 16:08'!fullName	^nil! !!ReadWriteStream methodsFor: 'file status' stamp: 'fm 1/31/2022 22:35'!isReadOnly	^false! !!RemoteString methodsFor: 'JavaScript generation' stamp: 'fm 2/1/2022 00:34'!JSprintOn: aStream 	aStream nextPutAll: 'nil'! !!ReturnNode methodsFor: 'transforming' stamp: 'fm 12/27/2020 15:38'!isRealReturn	"primitiveFail and primitiveFailFor: will be transformed in throw statements"	^expr isMessageNode not or: [(#(primitiveFail primitiveFailFor:) includes: expr selector key) not]! !!ReturnNode methodsFor: 'transforming' stamp: 'fm 10/1/2020 01:42'!privatePostCopy	expr := expr privateCopy! !!ReturnNode methodsFor: 'transforming' stamp: 'fm 9/6/2014 14:15'!replace: childNode with: otherNode	expr == childNode ifTrue: [		expr := otherNode.		^true].	^false! !!ReturnNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 10:53'!sameAs: aNode	^aNode class == ReturnNode and: [expr sameAs: aNode expr]! !!ReturnNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:52'!isJSexpression	^false! !!ReturnNode methodsFor: 'JavaScript generation' stamp: 'fm 11/29/2020 14:57'!printJSOn: aStream indent: level properties: aDict	((aDict at: #nonLocalReturns ifAbsent: [#()]) includes: self) 		ifTrue: [			aStream nextPutAll: 'throw nonLocalReturnException.setPayload('. 			expr printJSOn: aStream indent: level properties: aDict.			aStream nextPutAll: '); '.			expr printJSCommentOn: aStream indent: level]		ifFalse: [			expr isJSexpression ifTrue: [aStream nextPutAll: 'return ']. 			expr printJSOn: aStream indent: level properties: aDict.			expr printJSCommentOn: aStream indent: level]! !!ScaledDecimal methodsFor: 'JavaScript generation' stamp: 'fm 8/23/2020 12:47'!JSstoreOn: aStream 		self class JSinstantiationOn: aStream withArgs: {fraction. scale} argsBlock: [ :each | each JSstoreOn: aStream ]! !!SelectorNode methodsFor: 'transforming' stamp: 'fm 10/2/2014 22:59'!couldBeAffectedByReordering	^false! !!SequenceableCollection methodsFor: 'comparing' stamp: 'fm 10/5/2020 10:45'!sameAs: otherCollection 	| size |	self == otherCollection ifTrue: [^ true].	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size := self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		((self at: index) sameAs: (otherCollection at: index)) ifFalse: [^ false]].	^ true! !!Array methodsFor: 'testing' stamp: 'fm 9/29/2020 19:35'!shouldBePrintedAsLiteralVisiting: aSet	self class == Array ifFalse:		[^false].	(aSet includes: self) ifTrue:		[^false].	aSet add: self.	^self allSatisfy: [:each | (each class inheritsFrom: Object) and: [each shouldBePrintedAsLiteralVisiting: aSet]]! !!Array methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 19:50'!JSdoStoreOn: aStream visiting: aDict indent: level	| size count |	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	count := 0.	1 to: (size := self size) do: [:i |		(self at: i) == nil ifFalse: [			count := count + 1			].		].	count * 2 < size ifTrue: [		aStream nextPutAll: ', "@size": ';			nextPutAll: size printString.		count = 0 ifFalse: [			1 to: size do: [:i | | var |				(var := self at: i) == nil ifFalse: [					aStream nextPutAll: ', ';						nextPutAll: (i - 1) printString;						nextPutAll: ': '.					(var class inheritsFrom: Object) ifTrue: [						var JSstoreOn: aStream visiting: aDict indent: level					] ifFalse: [						JavaScriptTranspiler instance objJSstore: var on: aStream visiting: aDict indent: level					].					].				]			]	] ifFalse: [		aStream nextPutAll: ', "@pointers": '.		self class jsEncapsulateArgs: self					on: aStream					argsBlock: [:arg | (arg class inheritsFrom: Object) ifTrue: [										arg JSstoreOn: aStream visiting: aDict indent: level									] ifFalse: [										JavaScriptTranspiler instance objJSstore: arg on: aStream visiting: aDict indent: level				]].	].	! !!Array methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 10:17'!JSshouldBePrintedAsLiteral	^self class == Array	  and: [self JSshouldBePrintedAsLiteralVisiting: (IdentitySet new: 8)]! !!Array methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 10:16'!JSshouldBePrintedAsLiteralVisiting: aSet	self class == Array ifFalse:		[^false].	(aSet includes: self) ifTrue:		[^false].	aSet add: self.	^self allSatisfy: [:each | (each class inheritsFrom: Object) and: [each JSshouldBePrintedAsLiteralVisiting: aSet]]! !!Array methodsFor: 'JavaScript generation' stamp: 'fm 4/9/2021 09:36'!JSstoreOn: aStream 	| count |	self JSshouldBePrintedAsLiteral ifTrue: [		self isEmpty ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.Empty'.			^self		].		count := 0.		1 to: self size do: [:i |			(self at: i) isNil ifFalse: [				count := count + 1				].			].		count = 0 ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.primitive_71_impl(';	"This also takes care of wrapping, as opposed to directly invoking new"				nextPutAll: self basicSize printString;				nextPutAll: ')[1]'.			^self].		self class JSinstantiationOn: aStream withArgs: self argsBlock: [:each | each JSstoreOn: aStream].	] ifFalse: [		self halt.		super JSstoreOn: aStream	].! !!Array methodsFor: 'JavaScript generation' stamp: 'fm 7/14/2022 00:08'!JSstoreOn: aStream visiting: aDict indent: level	| count |		self JSshouldBePrintedAsLiteral ifTrue: [		self isEmpty ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.Empty'.			^self		].		count := 0.		1 to: self size do: [:i |			(self at: i) isNil ifFalse: [				count := count + 1				].			].		count = 0 ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.primitive_71_impl(';	"This also takes care of wrapping, as opposed to directly invoking new"				nextPutAll: self basicSize printString;				nextPutAll: ')[1]'.			^self].		self class JSinstantiationOn: aStream withArgs: self argsBlock: [:each | each JSstoreOn: aStream].	] ifFalse: [		super JSstoreOn: aStream visiting: aDict indent: level	].! !!Array class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 01:24'!jsStaticHelpersOn: aStream	(name = #Array) ifTrue: [		aStream nextPutAll: self JSname;			nextPutAll: '.Empty = Object.freeze(Object.assign(new ';			nextPutAll: self JSname;			nextPutAll: '(0), {hash: 1000}));';			cr.		.].! !!Bitmap methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 16:03'!JSdoStoreOn: aStream visiting: aDict indent: level	| size count |	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	count := 0.	1 to: (size := self basicSize) do: [:i |		(self basicAt: i) = 0 ifFalse: [			count := count + 1			].		].	count * 2 < size ifTrue: [		aStream nextPutAll: ', "@size": ';			nextPutAll: size printString.		count = 0 ifFalse: [			1 to: size do: [:i | | var |				(var := self basicAt: i) = 0 ifFalse: [					aStream nextPutAll: ', ';						nextPutAll: (i - 1) printString;						nextPutAll: ': '.					var JsHexWordOn: aStream					].				]			]	] ifFalse: [		aStream nextPutAll: ', "@words": '.		self class jsEncapsulateArgs: self					on: aStream					argsBlock: [:arg | arg JsHexWordOn: aStream].	].	! !!Bitmap class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:56'!hasJsCachedStorage	^true! !!Bitmap class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:59'!initializeJsCachedStorageMessage	^'this.int32Array = undefined;'! !!ByteArray methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 15:42'!JSdoStoreOn: aStream visiting: aDict indent: level	| size count |	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	count := 0.	1 to: (size := self basicSize) do: [:i |		(self basicAt: i) = 0 ifFalse: [			count := count + 1			].		].	count * 2 < size ifTrue: [		aStream nextPutAll: ', "@size": ';			nextPutAll: size printString.		count = 0 ifFalse: [			1 to: size do: [:i | | var |				(var := self basicAt: i) = 0 ifFalse: [					aStream nextPutAll: ', ';						nextPutAll: (i - 1) printString;						nextPutAll: ': ';						nextPutAll: var printString					].				]			]	] ifFalse: [		aStream nextPutAll: ', "@bytes": '.		self class jsEncapsulateArgs: self					on: aStream					argsBlock: [:arg | arg printOn: aStream].	].	! !!ByteArray methodsFor: 'JavaScript generation' stamp: 'fm 4/9/2021 09:56'!JSstoreOn: aStream	| count |	"Although not a literal in JavaScript, we still get a more compact representation this way"	(self class == ByteArray and: [self isEmpty]) ifTrue: [		aStream nextPutAll: self class JSname;			nextPutAll: '.Empty'.		^self	].	count := 0.	1 to: self basicSize do: [:i |		(self basicAt: i) = 0 ifFalse: [			count := count + 1			].		].	count = 0 ifTrue: [		aStream nextPutAll: self class JSname;			nextPutAll: '.primitive_71_impl(';			nextPutAll: self basicSize printString;			nextPutAll: ')[1]'.		^self].	self class JSinstantiationOn: aStream withArgs: self argsBlock: [:each | each printOn: aStream].! !!ByteArray methodsFor: 'JavaScript generation' stamp: 'fm 7/14/2022 00:32'!JSstoreOn: aStream visiting: aDict indent: level	| count |	"Although not a literal in JavaScript, we still get a more compact representation this way"	self JSshouldBePrintedAsLiteral ifTrue: [		self isEmpty ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.Empty'.			^self		].		count := 0.		1 to: self basicSize do: [:i |			(self basicAt: i) = 0 ifFalse: [				count := count + 1				].			].		count = 0 ifTrue: [			aStream nextPutAll: self class JSname;				nextPutAll: '.primitive_71_impl(';				nextPutAll: self basicSize printString;				nextPutAll: ')[1]'.			^self].		self class JSinstantiationOn: aStream withArgs: self argsBlock: [:each | each printOn: aStream].	] ifFalse: [		super JSstoreOn: aStream visiting: aDict indent: level	].! !!ByteArray methodsFor: 'JavaScript generation' stamp: 'fm 7/5/2022 21:03'!encoderClass	^EncoderForV3PlusClosures! !!ByteArray methodsFor: 'JavaScript generation' stamp: 'fm 7/5/2022 20:47'!isCompiledBlock	^false! !!ByteArray class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:57'!hasJsCachedStorage	^name == #ByteArray! !!ByteArray class methodsFor: 'JavaScript generation' stamp: 'fm 9/2/2022 00:02'!initializeJsCachedStorageMessage	^'this.uint32Array = undefined;'! !!ByteArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/22/2022 01:25'!jsStaticHelpersOn: aStream	(name = #ByteArray) ifTrue: [		aStream nextPutAll: self JSname;			nextPutAll: '.Empty = Object.freeze(Object.assign(new ';			nextPutAll: self JSname;			nextPutAll: '(0), {hash: 2000}));';			cr.		.].! !!CompiledCode methodsFor: 'accessing' stamp: 'fm 7/30/2022 23:03'!jsHeader	"The sign flag bit uses SmallInteger minVal, but that value is different in JavaScript.	It also uses the assumption that SmallInteger minVal is a power of two.	To make the bit logic on the header work in JavaScript, we have to add not	Number.MIN_SAFE_INTEGER, which is SmallInteger minVal in JavaScript,	but Number.MIN_SAFE_INTEGER - 1"	^self header < 0 ifTrue: [		self header - SmallInteger minVal - 9007199254740992	] ifFalse: [		self header	]! !!CompiledCode methodsFor: 'literals' stamp: 'fm 6/23/2022 15:28'!allCompiledBlockLiterals	^ Array streamContents: [:result |		self compiledBlockLiteralsDo: [:literal | result nextPut: literal]]		! !!CompiledCode methodsFor: 'literals' stamp: 'fm 5/29/2022 01:20'!compiledBlockLiteralsDo: aBlock	| sortedCompiledBlocks |			sortedCompiledBlocks := SortedCollection sortBlock: [:a :b | a last <= b last].	1 to: self numLiterals - 1 do: [:index | | literal |		(literal := self literalAt: index) isCompiledCode ifTrue: [			sortedCompiledBlocks add: {self. literal. literal pcAfterBlockPush}.			].		].	sortedCompiledBlocks do: [:e | 		aBlock value: e.		(e at: 2) compiledBlockLiteralsDo: aBlock.		].! !!CompiledBlock methodsFor: 'literals' stamp: 'fm 6/23/2022 15:37'!indexOfEqualLiteral: literal ifAbsent: absentBlock	"Answer the literal index of the argument, literal, or zero if none."	2 to: self numLiterals  "exclude header and outer code"	   do:		[:index |		(literal literalEqual: (self objectAt: index)) ifTrue: [^index - 1]].	^absentBlock value! !!CompiledBlock methodsFor: 'literals' stamp: 'fm 7/19/2022 23:36'!indexOfLiteral: literal	"Answer the literal index of the argument, literal, or zero if none."	2 to: self numLiterals  "exclude outer code"	   do:		[:index |		literal == (self objectAt: index) ifTrue: [^index - 1]].	^0! !!CompiledBlock methodsFor: 'JavaScript generation' stamp: 'fm 7/30/2022 23:04'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	aStream nextPutAll: ', "@bytes": '.		self class jsEncapsulateArgs: ((self initialPC to: self size) collect: [:i | self at: i])				on: aStream				argsBlock: [:arg | arg printOn: aStream].	aStream nextPutAll: ', "@lits": '.	Array jsEncapsulateArgs: {self jsHeader}, ((1 to: self numLiterals) collect: [:i | self literalAt: i])			on: aStream			argsBlock: [:arg | arg JSstoreOn: aStream visiting: aDict indent: level].! !!CompiledBlock methodsFor: 'JavaScript generation' stamp: 'fm 5/14/2022 16:35'!JSstoreOn: aStream	self halt! !!CompiledBlock methodsFor: 'JavaScript generation' stamp: 'fm 5/21/2022 00:41'!pcAfterBlockPush	"self allInstances do: [:e | e pcAfterBlockPush]"	| method encoderClass end byte pc extA byte2 |	method := self outerCode.	pc := method initialPC.	end := method endPC.	encoderClass := method encoderClass.	[pc <= end] whileTrue: 		[extA := 0.		[byte := method at: pc.		 pc := pc + 1.		 byte >= 224 and: [byte <= 225]] whileTrue:			[| extByte |			 extByte := method at: pc.			 pc := pc + 1.			 byte = 224				ifTrue:					[extA := extByte]].		 byte = 249 ifTrue:			[byte2 := method at: pc.			(method literalAt: (extA bitShift: 8) + byte2 + 1) == self ifTrue: 				[^pc + 2]].		 pc := pc + (encoderClass bytecodeSize: byte) - 1].	^self halt! !!CompiledBlock class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:58'!hasJsCachedStorage	^true! !!CompiledBlock class methodsFor: 'JavaScript generation' stamp: 'fm 11/5/2022 22:04'!initializeJsCachedStorageMessage	^'this.literals = undefined; this.func = undefined, this.compiledMethod = undefined;'! !!CompiledBlock class methodsFor: 'JavaScript generation' stamp: 'fm 7/18/2022 16:32'!isCompiledMethodClass	"future compatibility"	^true! !!CompiledBlock class methodsFor: 'JavaScript generation' stamp: 'fm 7/18/2022 16:33'!jsStorageTypeOn: aStream	aStream nextPutAll: 'setLiterals(anArray) {this.literals = Object.seal(anArray); return this;},';		cr! !!CompiledMethod methodsFor: 'decompiling' stamp: 'fm 4/23/2023 17:35'!copyWithTemps	| class tempNames source |	self isQuick ifTrue: [		"a quick method has no temps"		^self].	self holdsTempNames		ifTrue: [tempNames := self tempNamesString]		ifFalse:			[			((self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil])			or: [(source := self getSourceFromFile) isNil]) ifTrue: [				"No source file or no source (e.g. doits) and no temp names"				^self ].			class := self methodClass ifNil: [Object].			tempNames := (class newParser								encoderClass: self encoderClass;								parse: source class: class)										generate: CompiledMethodTrailer empty;										schematicTempNamesString].	^self copyWithTrailerBytes: (CompiledMethodTrailer new tempNames: tempNames)! !!CompiledMethod methodsFor: 'decompiling' stamp: 'fm 3/14/2023 13:10'!jsHeader	"The sign flag bit uses SmallInteger minVal, but that value is different in JavaScript.	It also uses the assumption that SmallInteger minVal is a power of two.	To make the bit logic on the header work in JavaScript, we have to add not	Number.MIN_SAFE_INTEGER, which is SmallInteger minVal in JavaScript,	but Number.MIN_SAFE_INTEGER - 1"	^self header < 0 ifTrue: [		self header - SmallInteger minVal - 9007199254740992	] ifFalse: [		self header	]! !!CompiledMethod methodsFor: 'literals' stamp: 'fm 6/23/2022 15:38'!indexOfEqualLiteral: literal ifAbsent: absentBlock	"Answer the literal index of the argument, literal, or zero if none."	2 to: self numLiterals - 1 "exclude header, superclass and selector/properties"	   do:		[:index |		(literal literalEqual: (self objectAt: index)) ifTrue: [^index - 1]].	^absentBlock value! !!CompiledMethod methodsFor: 'JavaScript generation' stamp: 'fm 7/30/2022 23:04'!JSdoStoreOn: aStream visiting: aDict indent: level	"This is only for the storage of uninstalled compiled methods"	| wihTemps props |	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname.	aStream nextPutAll: ', "@bytes": '.		wihTemps := (self holdsTempNames or: [(props := self penultimateLiteral) isMethodProperties and: [props includesKey: #source]]) ifTrue: [self] ifFalse: [self copyWithTemps].	self class jsEncapsulateArgs: ((wihTemps initialPC to: wihTemps size) collect: [:i | wihTemps at: i])				on: aStream				argsBlock: [:arg | arg printOn: aStream].	aStream nextPutAll: ', "@lits": '.	Array jsEncapsulateArgs: {self jsHeader}, ((1 to: self numLiterals) collect: [:i | self literalAt: i])			on: aStream			argsBlock: [:arg | arg JSstoreOn: aStream visiting: aDict indent: level].! !!CompiledMethod methodsFor: 'JavaScript generation' stamp: 'fm 5/14/2022 16:11'!JSprintOn: aStream	aStream nextPutAll: self methodClass JSprotoypeName;		nextPut: $.;		nextPutAll: self selector JSmapping;		nextPutAll: '.compiledMethod'! !!CompiledMethod methodsFor: 'JavaScript generation' stamp: 'fm 7/19/2022 21:41'!JSstoreOn: aStream	"This version is for the early, code-only (together with the class definitions) export, and it does not include storing the literals, 	which are stored later as part of the image state export (together with the state part of the classes), 	see ClassDescription>>#JSdoStoreOn:visiting:indent:"	| wihTemps props |			wihTemps := (self holdsTempNames or: [(props := self penultimateLiteral) isMethodProperties and: [props includesKey: #source]]) 					ifTrue: [self] ifFalse: [self copyWithTemps].	self class JSinstantiationOn: aStream 				withArgs: ((wihTemps initialPC to: wihTemps size) collect: [:i | wihTemps at: i]) 				argsBlock: [:arg | arg printOn: aStream].! !!CompiledMethod methodsFor: 'JavaScript generation' stamp: 'fm 7/4/2022 11:23'!JSstoreOn: aStream visiting: aDict indent: level	self isJsInstalled ifTrue: [		self JSprintOn: aStream.	] ifFalse: [		super JSstoreOn: aStream visiting: aDict indent: level].! !!CompiledMethod methodsFor: 'JavaScript generation' stamp: 'fm 7/5/2022 20:48'!isCompiledCode	^true! !!CompiledMethod methodsFor: 'testing' stamp: 'fm 11/3/2022 13:31'!isJsInstalled	"This should work both as the original isInstalled, for when we are running it in JavaScript,	and as 'installed in the translation dictionary' for when we are running the export from Smalltalk"	self methodClass ifNotNil:		[:class|		self selector ifNotNil:			[:selector|			selector isDoIt ifTrue: [^false].			self == (class methodDict at: selector ifAbsent: []) ifTrue: [^true].			^((JavaScriptTranspiler instance behaviorsDict at: class ifAbsent: [^false]) at: selector ifAbsent: []) key == self]].	^false! !!CompiledMethod class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:58'!hasJsCachedStorage	^true! !!CompiledMethod class methodsFor: 'JavaScript generation' stamp: 'fm 11/5/2022 22:04'!initializeJsCachedStorageMessage	^'this.literals = undefined; this.func = undefined, this.compiledMethod = undefined;'! !!CompiledMethod class methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 22:50'!isCompiledMethodClass	"future compatibility"	^true! !!CompiledMethod class methodsFor: 'JavaScript generation' stamp: 'fm 2/11/2022 10:55'!jsStorageTypeOn: aStream	aStream nextPutAll: 'setLiterals(anArray) {this.literals = Object.seal(anArray); return this;},';		cr! !!FloatArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/17/2023 18:14'!hasJsCachedStorage	^true! !!FloatArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/17/2023 18:15'!initializeJsCachedStorageMessage	^'this.float32Array = undefined;'! !!FloatArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/17/2023 18:15'!iterable	^'this.wordsAsFloat32Array()'! !!Float32Array class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:54'!hasJsCachedStorage	^true! !!Float32Array class methodsFor: 'JavaScript generation' stamp: 'fm 9/1/2022 23:53'!initializeJsCachedStorageMessage	^'this.float32Array = undefined;'! !!Float32Array class methodsFor: 'JavaScript generation' stamp: 'fm 9/3/2022 01:26'!iterable	^'this.wordsAsFloat32Array()'! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 13:09'!JSstorageType		^'float64Array'! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 12:54'!JSstorageTypeConstructor	^'Float64Array'! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 14:23'!JStypeOfStorageType	^'Float64Array'! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 15:12'!hasJsCachedStorage	^false! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 13:07'!iterable	^'this.float64Array'! !!Float64Array class methodsFor: 'JavaScript generation' stamp: 'fm 6/29/2023 22:48'!printJSPrimitive145On: aStream		aStream nextPutAll: 'primitive_145_impl(arg) {';			nextPutAll: 'const argVal = arg.valueOf(); if (typeof argVal === "number" || typeof argVal === "bigint") {this.';			nextPutAll: self JSstorageType;			nextPutAll: '.fill(Number(argVal)); return [true, this]} else return [false]},';			crtab.! !!IntegerArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/10/2022 22:49'!iterable	^'this.wordsAsInt32Array()'! !!MemorySourceFileArray methodsFor: 'accessing' stamp: 'fm 3/31/2021 18:24'!at: index	^files at: index! !!MemorySourceFileArray methodsFor: 'accessing' stamp: 'fm 3/31/2021 18:24'!at: index put: aFile	^files at: index put: aFile! !!MemorySourceFileArray methodsFor: 'accessing' stamp: 'fm 3/31/2021 18:24'!size	^files size! !!MemorySourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'fm 3/31/2021 18:24'!checkOKToAdd: size at: filePosition	"No check is required"	^ self! !!MemorySourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'fm 1/31/2022 22:38'!fileIndexFromSourcePointer: anInteger	"Return the index of the source file which contains the source chunk addressed by anInteger"	(anInteger bitAnd: 16r1000000) ~= 0		ifTrue: [^0 "sources file"]		ifFalse: [anInteger >= 16r1000000			ifTrue: [^2 "changes file"]			ifFalse: [^0 "compatibility with StandardSourceFileArray"]]! !!MemorySourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'fm 1/31/2022 22:39'!filePositionFromSourcePointer: anInteger 	"Return the position of the source chunk addressed by anInteger"	| hi lo |	hi := anInteger // 33554432.	lo := anInteger \\ 16777216.	((anInteger bitAnd: 16777216) ~= 0			or: [anInteger < 16777216 "compatibility with StandardSourceFileArray"])		ifTrue: [^ 0"sources file"]		ifFalse: [^ hi - 1 * 16777216 + lo"changes file"]! !!MemorySourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'fm 1/31/2022 22:40'!sourcePointerFromFileIndex: index andPosition: position	"Return a sourcePointer encoding the given file index and position"	| hi lo |	(index = 1 or: [index = 2])		ifFalse: [self error: 'invalid source file index'].	index = 1 ifTrue: [		^0].	position < 0 ifTrue: [self error: 'invalid source code pointer'].	hi := position // 16r1000000 *2 + index.	lo := position \\ 16r1000000.	^ hi * 16r1000000 + lo! !!MemorySourceFileArray methodsFor: 'initialize-release' stamp: 'fm 2/4/2022 14:19'!initialize	files := Array new: 2.	files at: 1 put: nil.	files at: 2 put: (ReadWriteStream on: (WideString new: 2000))! !!MemorySourceFileArray class methodsFor: 'initialize-release' stamp: 'fm 4/5/2021 17:50'!new: nFiles	nFiles = 2 ifFalse: [		self error: 'Wrong argument'].	^self new initialize! !!Semaphore class methodsFor: 'JavaScript generation' stamp: 'fm 10/5/2022 00:34'!printJSConstructorOn: aStream		aStream nextPutAll: '() {';			crtab;			nextPutAll: 'this.pointers = Object.seal(new Array(';			nextPutAll: self instSize printString;			nextPutAll: ').fill(nil));';			crtab;			nextPutAll: 'this.name = "no-name semaphore created";';			crtab;			nextPutAll: 'this.stack = " before this image was started";';			cr;			nextPut: $};			cr! !!ShortIntegerArray class methodsFor: 'JavaScript generation' stamp: 'fm 1/10/2022 22:47'!iterable	^'this.wordsAsInt16Array()'! !!SmallInteger methodsFor: 'printing' stamp: 'fm 9/30/2020 12:22'!asHexByte	"(0 to: 255) collect: [:i | '', (i bitShift: -4) asHexDigit, (i bitAnd: 15) asHexDigit]"	^#('00' '01' '02' '03' '04' '05' '06' '07' '08' '09' '0A' '0B' '0C' '0D' '0E' '0F' '10' '11' '12' '13' '14' '15' '16' '17' '18' '19' '1A' '1B' '1C' '1D' '1E' '1F' '20' '21' '22' '23' '24' '25' '26' '27' '28' '29' '2A' '2B' '2C' '2D' '2E' '2F' '30' '31' '32' '33' '34' '35' '36' '37' '38' '39' '3A' '3B' '3C' '3D' '3E' '3F' '40' '41' '42' '43' '44' '45' '46' '47' '48' '49' '4A' '4B' '4C' '4D' '4E' '4F' '50' '51' '52' '53' '54' '55' '56' '57' '58' '59' '5A' '5B' '5C' '5D' '5E' '5F' '60' '61' '62' '63' '64' '65' '66' '67' '68' '69' '6A' '6B' '6C' '6D' '6E' '6F' '70' '71' '72' '73' '74' '75' '76' '77' '78' '79' '7A' '7B' '7C' '7D' '7E' '7F' '80' '81' '82' '83' '84' '85' '86' '87' '88' '89' '8A' '8B' '8C' '8D' '8E' '8F' '90' '91' '92' '93' '94' '95' '96' '97' '98' '99' '9A' '9B' '9C' '9D' '9E' '9F' 'A0' 'A1' 'A2' 'A3' 'A4' 'A5' 'A6' 'A7' 'A8' 'A9' 'AA' 'AB' 'AC' 'AD' 'AE' 'AF' 'B0' 'B1' 'B2' 'B3' 'B4' 'B5' 'B6' 'B7' 'B8' 'B9' 'BA' 'BB' 'BC' 'BD' 'BE' 'BF' 'C0' 'C1' 'C2' 'C3' 'C4' 'C5' 'C6' 'C7' 'C8' 'C9' 'CA' 'CB' 'CC' 'CD' 'CE' 'CF' 'D0' 'D1' 'D2' 'D3' 'D4' 'D5' 'D6' 'D7' 'D8' 'D9' 'DA' 'DB' 'DC' 'DD' 'DE' 'DF' 'E0' 'E1' 'E2' 'E3' 'E4' 'E5' 'E6' 'E7' 'E8' 'E9' 'EA' 'EB' 'EC' 'ED' 'EE' 'EF' 'F0' 'F1' 'F2' 'F3' 'F4' 'F5' 'F6' 'F7' 'F8' 'F9' 'FA' 'FB' 'FC' 'FD' 'FE' 'FF') at: self + 1! !!SmallInteger methodsFor: 'printing' stamp: 'fm 10/4/2020 01:05'!asHexWordOn: aStream padded: padded prefix: prefix	| abs n msb ms2b |	self < 0 ifTrue: [		self halt: 'This should be a uint' 	] ifFalse: [		aStream nextPutAll: prefix.		abs := self].	padded ifTrue: [		aStream nextPutAll: (abs bitShift: -24) asHexByte;			nextPutAll: ((abs bitShift: -16) bitAnd: 16rFF) asHexByte;			nextPutAll: ((abs bitShift: -8) bitAnd: 16rFF) asHexByte;			nextPutAll: (abs bitAnd: 16rFF) asHexByte.	] ifFalse: [		(n := abs highBit + 3 quo: 4) <= 4 ifTrue: [			n <= 2 ifTrue: [				n == 1 					ifTrue: [aStream nextPut: abs asHexDigit] 					ifFalse: [aStream nextPutAll: abs asHexByte]			] ifFalse: [				msb := abs bitShift: -8.				n == 3 					ifTrue: [aStream nextPut: msb asHexDigit] 					ifFalse: [aStream nextPutAll: msb asHexByte].				aStream nextPutAll: (abs bitAnd: 16rFF) asHexByte			]		] ifFalse: [			ms2b := abs bitShift: -16.			n <= 6 ifTrue: [				n == 5 					ifTrue: [aStream nextPut: ms2b asHexDigit] 					ifFalse: [aStream nextPutAll: ms2b asHexByte]			] ifFalse: [				msb := ms2b bitShift: -8.				n == 7 					ifTrue: [aStream nextPut: msb asHexDigit] 					ifFalse: [aStream nextPutAll: msb asHexByte].				aStream nextPutAll: (ms2b bitAnd: 16rFF) asHexByte			].			aStream nextPutAll: ((abs bitShift: -8) bitAnd: 16rFF) asHexByte;				nextPutAll: (abs bitAnd: 16rFF) asHexByte.		]	].		! !!SmallInteger methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 14:27'!JSstoreOn: aStream 	self printOn: aStream.	self isJSsafeInteger ifFalse: [		aStream nextPut: $n		]	! !!SmallInteger methodsFor: 'JavaScript generation' stamp: 'fm 10/3/2020 02:52'!JsHexWordOn: aStream	self asHexWordOn: aStream padded: false prefix: '0x'! !!SmallInteger methodsFor: 'JavaScript generation' stamp: 'fm 3/23/2022 14:34'!isJSsafeInteger	^(self <= 107374183 and: [self >= -107374184]) or:	[9007199254740992 > self and: [-9007199254740992 < self]]! !!SmallInteger class methodsFor: 'JavaScript generation' stamp: 'fm 9/10/2020 16:32'!JSpartitioningTest	^'Number.isSafeInteger(this.valueOf())'! !!SmallInteger class methodsFor: 'JavaScript generation' stamp: 'fm 12/22/2021 21:44'!JsOptimizedPartitioningTest	^'(val | 0) === val || Number.isSafeInteger(val)'! !!SoundBuffer class methodsFor: 'JavaScript generation' stamp: 'fm 1/10/2022 22:48'!iterable	^'this.wordsAsInt16Array()'! !!String methodsFor: 'accessing' stamp: 'fm 11/15/2020 21:13'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector. It is intended mostly for the assistance of spelling correction."	| numColons index size c |	(size := self size) = 0 ifTrue: [ ^-1 ].	index := 1.	(self at: index) isSpecial ifTrue: [		2 to: size do: [ :i | (self at: i) isSpecial ifFalse: [ ^-1 ] ].		^1 ].	self canBeToken ifFalse: [ ^-1 ].	"Fast colon count"	numColons := 0.	[ 		((c := self at: index) isLetter		 or: [ c = $_ and: [ Scanner prefAllowUnderscoreSelectors ] ]) ifFalse:			[ ^-1 ].		(index := (self indexOf: $: startingAt: index) + 1) > 1 ifFalse:			[ numColons = 0 ifTrue: [ ^0 ].			 ^-1 ].		numColons := numColons + 1.		index <= size ] whileTrue.	^numColons! !!String methodsFor: '*System-Localization' stamp: 'fm 3/19/2021 18:38'!translatedFor: aCompiledMethod	"answer the receiver translated to the default language"	| translator translation |	NaturalLanguageTranslator translators isEmpty ifTrue: [		^self].	translator := NaturalLanguageTranslator translators		at: LocaleID current		ifAbsent: [LocaleID current hasParent				ifTrue: [NaturalLanguageTranslator translators						at: LocaleID current parent						ifAbsent: []]].	translator isNil ifTrue: [		^self].	translation := translator translate: self 							inDomain: (TextDomainManager domainOfMethod: aCompiledMethod).	self == translation ifTrue: [		TextDomainManager allKnownDomains do: [:domain |			translation := translator translate: self inDomain: domain.			self = translation ifFalse: [^translation]		]	].	^translation! !!String methodsFor: 'JavaScript generation' stamp: 'fm 10/7/2020 17:40'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname;		nextPutAll: ', "@str": '.	self class jsEncapsulateArgs: self				on: aStream				argsBlock: [:arg | arg JSprintOn: aStream].! !!String methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:39'!JSprimitiveOn: aStream 	aStream nextPut: $`.	self do: [:x | x JSprintOn: aStream].	aStream nextPut: $`.! !!String methodsFor: 'JavaScript generation' stamp: 'fm 4/11/2021 17:06'!JSstoreOn: aStream 	((self class == ByteString or: [self class == WideString]) and: [self isEmpty]) ifTrue: [		aStream nextPutAll: self class JSname;			nextPutAll: '.Empty'.		^self	].	self class JSinstantiationOn: aStream withArgs: self argsBlock: [:each | each JSprintOn: aStream].! !!String methodsFor: 'JavaScript generation' stamp: 'fm 7/13/2022 23:08'!JSstoreOn: aStream visiting: aDict indent: level	self JSstoreOn: aStream! !!ByteString methodsFor: 'JavaScript generation' stamp: 'fm 9/23/2022 15:31'!printJSConflict: sel with: sourcesDict for: mappedClasses on: aStream	| bodies args jsSelector argsVariations comments argsSize argsStream argsSet signature |	bodies := OrderedCollection new.	jsSelector := sel JSmapping.	argsVariations := OrderedCollection new.	comments := OrderedCollection new.	mappedClasses do: [:class | | jsSource comment |		jsSource := (sourcesDict at: class) value.		jsSource = 'DNU' 			ifTrue: [				argsVariations add: nil.				bodies add: 'return yield* ', class JSprotoypeName, '.', jsSelector, '.call(this'.				comment := '// No implementation for #', sel, ' in ', class name, ' hierarchy, trigger a DNU']			ifFalse: [				args := (jsSource readStream nextLine findTokens: '(,)') removeLast; removeFirst; yourself.				argsVariations add: args.				bodies add: 'return yield* ', class JSprotoypeName, '.', jsSelector, '.call(this'.				comment := '// Call implementation for #', sel, ' in ', class name].		comments add: comment		].	aStream nextPutAll: jsSelector;		nextPutAll: ': function *'.	argsStream := (String new: 50) writeStream.	argsSet := argsVariations asSet remove: nil ifAbsent: []; yourself.	argsSize := argsSet anyOne size.	argsSet size = 1 		ifTrue: [			argsSet anyOne do: [:arg | argsStream nextPutAll: arg] separatedBy: [argsStream nextPutAll: ','].			]		ifFalse: [			1 to: argsSize do: [:i | argsStream nextPutAll: 'arg', i. i = argsSize ifFalse: [argsStream nextPutAll: ', ']]			].	argsStream nextPut: $).	signature := argsStream contents.	aStream nextPutAll: jsSelector;		nextPut: $(;		nextPutAll: signature;		nextPutAll: ' {';		crtab;		nextPutAll: 'const val = this.valueOf();';		crtab;		nextPutAll: 'if (';		nextPutAll: mappedClasses first JsOptimizedPartitioningTest;		nextPutAll: ') { ';		nextPutAll: comments first.	aStream crtab: 2;		nextPutAll: bodies first;		nextPutAll: ((argsSize > 0 and: [bodies first endsWith: '.call(this']) ifTrue: [', '] ifFalse: ['']);		nextPutAll: signature;		cr;		nextPutAll: '	}';		nextPutAll: ' else { ';		nextPutAll: comments last.	aStream crtab: 2;		nextPutAll: bodies last;		nextPutAll: ((argsSize > 0 and: [bodies last endsWith: '.call(this']) ifTrue: [', '] ifFalse: ['']);		nextPutAll: signature;		cr;		nextPutAll: '	}';		cr;		nextPutAll: '},';		cr; cr! !!ByteString methodsFor: 'JavaScript generation' stamp: 'fm 7/18/2021 14:15'!printJSConflicts: conflicts for: mappedClasses on: aStream	aStream nextPutAll: 'Object.assign(';		nextPutAll: self;		nextPutAll: '.prototype, {';		cr.	conflicts keys asSortedCollection do: [:sel | | sourcesDict |		sourcesDict := conflicts at: sel.		self printJSConflict: sel with: sourcesDict for: mappedClasses on: aStream		].	aStream nextPutAll: '})' ! !!ByteString methodsFor: 'JavaScript generation' stamp: 'fm 9/7/2022 12:36'!printJSExtensionFor: classes meta: isMeta withMethods: sourcesDict on: aStream	| target class nonPrimitiveType |	nonPrimitiveType := self beginsWith: JavaScriptTranspiler instance jsEnvironmentPrefix.	sourcesDict isEmpty ifFalse: [		target := self.		isMeta ifTrue: [			target := target, '.constructor.prototype'		] ifFalse: [			target := target, '.prototype'].		aStream nextPutAll: 'Object.assign(';			nextPutAll: target;			nextPutAll: ', {'.		nonPrimitiveType ifFalse: [			aStream cr.			"Number and BigInt need the _impl primitive definitions"			self printJSSpecializedPrimitivesFor: classes on: aStream		].		sourcesDict keys asSortedCollection do: [:sel | | assoc jsSource jsSelector |			assoc := sourcesDict at: sel.			jsSource := assoc value.			nonPrimitiveType ifFalse: [				jsSelector := sel JSmapping.				jsSource := jsSelector, ': ', assoc key methodClass JSprotoypeName, '.', jsSelector.			].			aStream cr; cr; nextPutAll: jsSource;				nextPut: $,			].		aStream nextPutAll: '})';			cr; cr.	].	nonPrimitiveType ifTrue: [		class := Smalltalk at: (self allButFirst: JavaScriptTranspiler instance jsEnvironmentPrefix size) asSymbol.		isMeta ifTrue: [class := class class].		class printJSMethodDictionary: sourcesDict on: aStream.		class printJSClassOrganizerOn: aStream].	(classes isEmpty and: [isMeta not]) ifTrue: [		(Smalltalk at: (self allButFirst: JavaScriptTranspiler instance jsEnvironmentPrefix size) asSymbol) printJSClassBindingOn: aStream	].	classes isEmpty ifTrue: [^self].	aStream cr;		nextPutAll: self;		nextPutAll: '.prototype._class = function _class() {';		nextPutAll: 'return '.	classes size = 1 ifTrue: [		aStream nextPutAll: classes first JSname;			nextPutAll: '}'	] ifFalse: [		aStream nextPutAll: classes first JSpartitioningTest;			nextPutAll: ' ? ';			nextPutAll: classes first JSname;			nextPutAll: ' : ';			nextPutAll: classes last JSname;			nextPutAll: '}'	].	aStream cr;		nextPutAll: self;		nextPutAll: '.prototype._eqEq = function _eqEq(arg) {return this._class() === arg._class() && this.valueOf() === arg.valueOf()}';		cr;		nextPutAll: self;		nextPutAll: '.prototype._notEqEq = function _notEqEq(arg) {return this._class() !!== arg._class() || this.valueOf() !!== arg.valueOf()}'.	"self = 'Boolean' ifTrue: [		aStream nextPutAll: 'this.valueOf() ? SmalltalkGlobals._True : SmalltalkGlobals._False;'		] ifFalse: [	self = 'Number' ifTrue: [		aStream 			nextPutAll: 'Number.isSafeInteger(this.valueOf())  ? SmalltalkGlobals._SmallInteger : ';			nextPutAll: (classes size = 2 						ifTrue: ['SmalltalkGlobals._Float'] 						ifFalse: ['(Math.abs(this) < 1.157920892373162e+77 ? SmalltalkGlobals._SmallFloat64 : SmalltalkGlobals._BoxedFloat64);'])						] ifFalse: [	self = 'String' ifTrue: [		aStream nextPutAll: 'SmalltalkGlobals._Character;'		] ifFalse: [	self = 'Function' ifTrue: [		aStream nextPutAll: 'SmalltalkGlobals._BlockClosure'		] ifFalse: [	self = 'BigInt' ifTrue: [		aStream nextPutAll: 'this > 0 ? SmalltalkGlobals._LargePositiveInteger : SmalltalkGlobals._LargeNegativeInteger;'		]]]]].	aStream cr;		nextPut: $}"! !!ByteString methodsFor: 'JavaScript generation' stamp: 'fm 9/7/2022 14:00'!printJSSpecializedPrimitivesFor: classes on: aStream	classes size = 1 ifTrue: [		classes first printJSSpecializedPrimitivesOn: aStream	] ifFalse: [		#(printJSPrimitive60On: printJSPrimitive61On: printJSPrimitive62On: printJSPrimitive73On: printJSPrimitive74On: printJSPrimitive105On: printJSPrimitive132On: printJSPrimitive145On: printJSPrimitive148On: printJSPrimitive173On: printJSPrimitive174On:) do: [:sel | | c source firstSource sourcesDict |			c := classes first.			[c notNil and: [(source := String new: 200 streamContents: [:s | c perform: sel with: s]) isEmpty]] whileTrue: [c := c superclass].			firstSource := source.			c := classes last.			[c notNil and: [(source := String new: 200 streamContents: [:s | c perform: sel with: s]) isEmpty]] whileTrue: [c := c superclass].			firstSource = source ifTrue: [				aStream nextPutAll: source			] ifFalse: [				sourcesDict := Dictionary new.				sourcesDict 					at: classes first put: firstSource;					at: classes last put: source.				self printPrimitiveJSConflict: 'primitive_', sel asInteger, '_impl' with: sourcesDict for: classes on: aStream.			]		].	].! !!ByteString methodsFor: 'JavaScript generation' stamp: 'fm 9/7/2022 12:34'!printPrimitiveJSConflict: sel with: sourcesDict for: mappedClasses on: aStream	| bodies args jsSelector argsVariations comments argsSize argsStream argsSet signature |	bodies := OrderedCollection new.	jsSelector := sel.	argsVariations := OrderedCollection new.	comments := OrderedCollection new.	mappedClasses do: [:class | | jsSource comment |		jsSource := (sourcesDict at: class) value.		jsSource = '' 			ifTrue: [				argsVariations add: nil.				bodies add: 'debugger;'.				comment := '// No implementation for #', sel, ' in ', class name, ' hierarchy, trigger a DNU']			ifFalse: [				args := (jsSource readStream nextLine findTokens: '(,)') removeLast; removeFirst; yourself.				argsVariations add: args.				bodies add: 'return ', class JSprotoypeName, '.', jsSelector, '.call(this'.				comment := '// Call implementation for #', sel, ' in ', class name].		comments add: comment		].	aStream nextPutAll: jsSelector;		nextPutAll: ': function '.	argsStream := (String new: 50) writeStream.	argsSet := argsVariations asSet remove: nil ifAbsent: []; yourself.	argsSize := argsSet anyOne size.	argsSet size = 1 		ifTrue: [			argsSet anyOne do: [:arg | argsStream nextPutAll: arg] separatedBy: [argsStream nextPutAll: ','].			]		ifFalse: [			1 to: argsSize do: [:i | argsStream nextPutAll: 'arg', i. i = argsSize ifFalse: [argsStream nextPutAll: ', ']]			].	argsStream nextPut: $).	signature := argsStream contents.	aStream nextPutAll: jsSelector;		nextPut: $(;		nextPutAll: signature;		nextPutAll: ' {';		crtab;		nextPutAll: 'const val = this.valueOf();';		crtab;		nextPutAll: 'if (';		nextPutAll: mappedClasses first JsOptimizedPartitioningTest;		nextPutAll: ') { ';		nextPutAll: comments first.	aStream crtab: 2;		nextPutAll: bodies first;		nextPutAll: ((argsSize > 0 and: [bodies first endsWith: '.call(this']) ifTrue: [', '] ifFalse: ['']);		nextPutAll: signature;		cr;		nextPutAll: '	}';		nextPutAll: ' else { ';		nextPutAll: comments last.	aStream crtab: 2;		nextPutAll: bodies last;		nextPutAll: ((argsSize > 0 and: [bodies last endsWith: '.call(this']) ifTrue: [', '] ifFalse: ['']);		nextPutAll: signature;		cr;		nextPutAll: '	}';		cr;		nextPutAll: '},';		cr; cr! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:38'!hasJsCachedStorage	^self isVariable! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 2/12/2022 16:31'!initializeJsCachedStorageMessage	^'this.dirty = true;'! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 2/12/2022 16:28'!iterable	^'this.valueOf()'! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 9/8/2022 23:33'!jsCachedStorageOn: aStream	self isTransitioningFromNilStorageType ifTrue: [		aStream nextPutAll: self JSprotoypeName;			nextPutAll: '.valueOf = function valueOf() {';			nextPutAll: 'if (this.dirty) {'.		self isBytes ifTrue: [			aStream nextPutAll: '	const bytes = this.bytes, length = bytes.length;		if (length > 0) {		if (length > 100000) {// empirically observed 100000 limit in Chrome, 500000 in Firefox			let chunk = String.fromCharCode(...bytes.subarray(0, 100000));			let remaining = length - 100000;			while (remaining > 100000) {				chunk += String.fromCharCode(...bytes.subarray(length - remaining, length - remaining + 100000));				remaining -= 100000}			if (remaining)				chunk += String.fromCharCode(...bytes.subarray(length - remaining, length));			this.string = chunk;		} else			this.string = String.fromCharCode(...bytes);'		] ifFalse: [			aStream nextPutAll: '	const words = this.words, length = words.length;		if (length > 0) {		if (length > 100000) {// empirically observed 100000 limit in Chrome, 500000 in Firefox			let chunk = String.fromCodePoint(...words.subarray(0, 100000).map(e => e & 0x10FFFF));			let remaining = length - 100000;			while (remaining > 100000) {				chunk += String.fromCodePoint(...words.subarray(length - remaining, length - remaining + 100000).map(e => e & 0x10FFFF));				remaining -= 100000}			if (remaining)				chunk += String.fromCodePoint(...words.subarray(length - remaining, length).map(e => e & 0x10FFFF));			this.string = chunk;		} else			this.string = String.fromCodePoint(...words.map(e => e & 0x10FFFF));'		].		aStream			crtab;			nextPutAll: '} else';			crtab: 2;			nextPutAll: 'this.string = "";';			crtab;			nextPutAll: 'this.dirty = false;}';			cr;			nextPutAll: 'return this.string;}	//mimic the native String wrapper objects';			cr; cr].! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 2/13/2022 00:22'!jsCreateAs: varName fromPrimitive: argName on: aStream	self JSstorageType = 'bytes' ifTrue: [		aStream nextPutAll: 'const bytes = new Uint8Array(';			nextPutAll: argName;			nextPutAll: '.length);';			crtab;			nextPutAll: 'let p = 0;';			crtab;			nextPutAll: 'for (const c of ';			nextPutAll: argName;			nextPutAll: ') {';			crtab: 2;			nextPutAll: 'const codePoint = c.codePointAt(0);';			crtab: 2;			nextPutAll: 'if (codePoint >= 256)';			crtab: 3;			nextPutAll: 'return SmalltalkGlobals._Wide';			nextPutAll: (name copyFrom: 5 to: name size);			nextPutAll: '.from(';			nextPutAll: argName;			nextPutAll: ');';			crtab: 2;			nextPutAll: 'bytes[p++] = codePoint;';			crtab;			nextPut: $};			crtab;			nextPutAll: 'const ';			nextPutAll: varName;			nextPutAll: ' = this.primitive_70_impl()[1];';			crtab;			nextPutAll: varName;			nextPutAll: '.bytes = bytes;'.	 ] ifFalse: [		aStream nextPutAll: 'const out = [];';			crtab;			nextPutAll: 'for (const c of ';			nextPutAll: argName;			nextPut: $);			crtab: 2;			nextPutAll: 'out.push(c.codePointAt(0));';			crtab;			nextPutAll: 'const ';			nextPutAll: varName;			nextPutAll: ' = this.primitive_70_impl()[1];';			crtab;			nextPutAll: varName;			nextPutAll: '.words = Uint32Array.from(out);'.	].! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 10/1/2020 01:14'!jsEncapsulateArgs: args on: strm argsBlock: argsBlock	strm nextPut: $`.	args do: argsBlock.	strm nextPut: $`.! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 2/13/2022 13:35'!jsStaticFromOn: aStream	self isTransitioningFromNilStorageType ifFalse: [		^self].		aStream nextPutAll: self class JSprotoypeName;		nextPutAll: '.from = function from(aString) {';		crtab;		nextPutAll: 'const primitiveString = aString.valueOf();';		crtab;		nextPutAll: 'if (primitiveString === "")';		crtab: 2;		nextPutAll: 'return ';		nextPutAll: self JSname;		nextPutAll: '.Empty;';		crtab.	self jsCreateAs: 'result' fromPrimitive: 'primitiveString' on: aStream.	aStream crtab;		nextPutAll: 'result.string = primitiveString;';		crtab;		nextPutAll: 'result.dirty = false;';		crtab;		nextPutAll: 'return result;';		cr;		nextPut: $};		cr; cr! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 2/14/2022 15:01'!jsStaticHelpersOn: aStream	self isTransitioningFromNilStorageType ifFalse: [		^self].		name = #WideSymbol ifFalse: [		aStream nextPutAll: self JSname;			nextPutAll: '.Empty = Object.freeze(Object.assign(new ';			nextPutAll: self JSname;			nextPutAll: '(0), {hash: 4000, string: "", dirty: false}));';			cr].	name = #ByteSymbol ifTrue: [		aStream nextPutAll: Symbol JSname;			nextPutAll: '.allSymbols[""] = new WeakRef(';			nextPutAll: self JSname;			nextPutAll: '.Empty);';			cr].! !!String class methodsFor: 'JavaScript generation' stamp: 'fm 9/4/2022 11:37'!requiresJsCacheSync	^true! !!ByteString class methodsFor: 'JavaScript generation' stamp: 'fm 11/7/2022 14:14'!printJSPrimitive105On: aStream	aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {		const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), arg4Val = arg4.valueOf(), bytes = this.bytes, arg3bytes = arg3.bytes;		if (arg1Val > 0 && arg2Val >= arg1Val && arg4Val > 0 && (arg1Val | 0) === arg1Val && (arg2Val | 0) === arg2Val && arg2Val <= bytes.length && (arg4Val | 0) === arg4Val) {			const start = arg1Val - 1, replacementStart = arg4Val - 1, replacementEnd = replacementStart + arg2Val - start;			if (arg3bytes && replacementEnd <= arg3bytes.length) {				const replacement = arg3bytes.slice(replacementStart, replacementEnd);				bytes.set(replacement, start);				this.dirty = true;				return [true, this];			} else if (arg3._class() === SmalltalkGlobals._WideString && replacementEnd <= arg3.words.length) {				const words = new Uint32Array(bytes.length);				if (start > 0) words.set(bytes.slice(0, start), 0);				const replacement = arg3.words.slice(replacementStart, replacementEnd);				words.set(replacement, start);				if (arg2Val < words.length) words.set(bytes.slice(arg2Val), arg2Val);				Object.setPrototypeOf(this, SmalltalkGlobals._WideString.prototype);				this.words = words;				delete this.bytes;				this.dirty = true; 				return [true, this];			} else return [false];		} else return [false]},';			crtab! !!Symbol methodsFor: 'JavaScript generation' stamp: 'fm 10/2/2020 13:37'!JSmapping	 | mappedSelector |	^self first canBeIdentifierInitial		ifTrue: [			self last = $:				ifTrue: [					mappedSelector := '_'.					self keywords do: [:kwd |						mappedSelector := mappedSelector, (kwd copyFrom: 1 to: kwd size - 1), '_'].					mappedSelector]				ifFalse: [					'_', self]]		ifFalse: [self JSmappingForBinary].! !!Symbol methodsFor: 'JavaScript generation' stamp: 'fm 10/23/2022 20:36'!JSmappingForBinary	^self caseOf: {					[#==] -> ['_eqEq'].					[#~~] -> ['_notEqEq'].					[#=] -> ['_eq']. 					[#~=] -> ['_notEq']. 					[#|] -> ['_or']. 					[#&] -> ['_and']. 					[#*] -> ['_mul']. 					[#+] -> ['_add']. 					[#-] -> ['_sub']. 					[#/] -> ['_div']. 					[#>] -> ['_gt']. 					[#<] -> ['_lt']. 					[#>=] -> ['_ge']. 					[#<=] -> ['_le']. 					[#->] -> ['_assoc']. 					[#,] -> ['_concat']. 					[#@] -> ['_at']. 					[#//] -> ['_quo']. 					[#\\] -> ['_mod']. 					[#<<] -> ['_lshift']. 					[#>>] -> ['_rshift']. 					[#=>] -> ['_bind']. 					[#\\\] -> ['_modulo']. 					[#*=] -> ['_mulArray']. 					[#==>] -> ['_implies']. 					[#<=>] -> ['_spaceship']. 					[#+*] -> ['_preMul']. 					[#,,] -> ['_matrixConcat']. 					[#+=] -> ['_plusEq']. 					[#-=] -> ['_minusEq']. 					[#\\=] -> ['_modEq']. 					[#/=] -> ['_divEq']. 					[#**] -> ['_raisedTo']. 					[#>>=] -> ['_then']. 					[#>>|] -> ['_asJavaScript']. 					[#>><] -> ['_asPluginJavaScript']. 			} otherwise: 					[ | unmapped |					unmapped := Smalltalk at: #UnmappedBinarySelectors ifAbsentPut: [SortedCollection new].					(unmapped includes: self) ifFalse: [						self halt. 						unmapped add: self].					 '_unmappedBinarySelector', (unmapped indexOf: self)]! !!Symbol methodsFor: 'JavaScript generation' stamp: 'fm 10/19/2020 13:17'!isOptimizedSelector	^#(class == ~~) includes: self! !!Symbol class methodsFor: 'JavaScript generation' stamp: 'fm 2/13/2022 00:26'!jsCreateAs: varName fromPrimitive: argName on: aStream	aStream nextPutAll: 'if (';		nextPutAll: argName;		nextPutAll: ' in this.allSymbols) {';		crtab: 2;		nextPutAll: 'const result = this.allSymbols[';		nextPutAll: argName;		nextPutAll: '].deref();';		crtab: 2;		nextPutAll: 'if(result !!== undefined) return result;';		crtab;		nextPut: $};		crtab.	super jsCreateAs: varName fromPrimitive: argName on: aStream.	aStream crtab;		nextPutAll: 'this.allSymbols[';		nextPutAll: argName;		nextPutAll: '] = new WeakRef(result);'! !!Symbol class methodsFor: 'JavaScript generation' stamp: 'fm 2/13/2022 13:42'!jsStaticHelpersOn: aStream	(name = #Symbol) ifTrue: [		aStream nextPutAll: self JSname;			nextPutAll: '.constructor.prototype.allSymbols = Object.create(null);';			cr.		.].	super jsStaticHelpersOn: aStream! !!Symbol class methodsFor: 'JavaScript generation' stamp: 'fm 10/9/2020 11:12'!printJSClassVariablesOn: aStream	"replaced SymbolTable and its companion NewSymbols by the static allSymbols, see #jsStaticHelpersOn:"! !!SystemNavigationTest methodsFor: 'running' stamp: 'fm 10/21/2022 13:29'!setUp	| g p t |	env := Environment named: 'test'.	g := self createClass: #Griffle.	p := self createClass: #Plonk.	g compileSilently: 'foo ^ 1'.	g class compileSilently: 'classFoo ^ 1'.	g compileSilently: 'bar ^ 1'.	p compileSilently: 'foo ^ 2'.	t := self createClass: #TGriffle.	t compileSilently: 'baz ^ Griffle new foo + Plonk new bar'.	self createClass: #Unused.	sysNav := SystemNavigation for: env.! !!SystemOrganizer methodsFor: 'JavaScript generation' stamp: 'fm 1/30/2022 23:58'!JSstoreOn: aStream visiting: aDict indent: level	(self == Smalltalk organization) ifTrue: [		aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix;			nextPutAll: 'SystemOrganization[1]'			"also 'Smalltalk[1].pointers[0].pointers[0].pointers[1]'"	] ifFalse: [		self JSstoreWithIdOn: aStream visiting: aDict indent: level].! !!Time class methodsFor: 'clock' stamp: 'tpr 1/11/2016 14:18'!eventMillisecondClock	"In order to make certain event handling code work (cf MouseEvent>asMouseMove) we need access	to the tick kept by ioMSecs() "	"Time eventMillisecondClock"	<primitive: 135>	^0! !!True methodsFor: 'controlling' stamp: 'fm 10/25/2014 21:49'!questionMark: trueAlternative colon: falseAlternative	^trueAlternative! !!True class methodsFor: 'JavaScript generation' stamp: 'fm 9/10/2020 16:29'!JSpartitioningTest	^'this.valueOf()'! !!True class methodsFor: 'JavaScript generation' stamp: 'fm 12/22/2021 21:45'!JsOptimizedPartitioningTest	^'val'! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 3/25/2022 17:13'!JSname	^'undefined'! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 9/29/2020 11:28'!JSprimitiveOn: aStream 	self JSstoreOn:  aStream.! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 8/12/2021 19:05'!JSprintOn: aStream 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 8/12/2021 19:05'!JSprintOn: aStream  indent: level	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 7/21/2020 16:19'!JSstoreOn: aStream 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'JavaScript generation' stamp: 'fm 10/6/2020 13:29'!JSstoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'transforming' stamp: 'fm 9/24/2020 14:07'!sameAs: aNode	^aNode isNil! !!VariableNode methodsFor: 'accessing' stamp: 'fm 9/14/2014 21:06'!key: aString	key := aString! !!VariableNode methodsFor: 'transforming' stamp: 'fm 6/15/2022 23:58'!couldBeAffectedByReordering	^(self isArg or: [self isSelfPseudoVariable or: [self isFixedValue or: [key = 'super']]]) not! !!VariableNode methodsFor: 'transforming' stamp: 'fm 9/28/2020 15:50'!isFixedValue	^key = 'true' or: [key = 'false' or: [key = 'nil']]! !!VariableNode methodsFor: 'transforming' stamp: 'fm 9/28/2020 01:10'!literalValueString	^key! !!VariableNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 16:15'!sameAs: aNode	^aNode isVariableNode and: [aNode class ~~ RemoteTempVectorNode and: [key = aNode key]]! !!VariableNode methodsFor: 'JavaScript generation' stamp: 'fm 9/14/2020 11:51'!isJSexpression	^true! !!VariableNode methodsFor: 'JavaScript generation' stamp: 'fm 1/16/2023 12:24'!printJSOn: aStream indent: level properties: aDict	| insideBlock compiledMethod |	self isSelfPseudoVariable 		ifTrue: [			((aDict at: #functions ifAbsent: [#()]) anySatisfy: [:a | a isJSoptimized not]) ifTrue: [				(aDict includesKey: #selfInsideBlock) not ifTrue: [self halt].				aStream nextPutAll: 'self'] ifFalse: [aStream nextPutAll: 'this']]		ifFalse: [			self isFixedValue				ifTrue: [					aStream nextPutAll: key]				ifFalse: [					key = 'thisContext' 						ifTrue: [							compiledMethod := (aDict at: #ThisBlock ifAbsent: []) == nil ifTrue: [								(aDict at: #methodSelector) JSmapping, '.compiledMethod || nil, '							] ifFalse: [								'compiledMethod, '							].							insideBlock := (aDict at: #functions ifAbsent: [#()]) anySatisfy: [:a | a isJSoptimized not].							aStream nextPutAll: thisContext class JSname;								nextPutAll: '.from([nil, 0, 0, ';								nextPutAll: compiledMethod;								nextPutAll: (insideBlock ifTrue: [aDict at: ((aDict at: #functions ifAbsent: [#()]) select: [:a | a isJSoptimized not]) last] ifFalse: ['nil']);								nextPutAll: (insideBlock ifTrue: [', self'] ifFalse: [', this']);								nextPutAll: '])']						ifFalse: [							aStream nextPut: $_; 								nextPutAll: name]]]! !!InstanceVariableNode methodsFor: 'JavaScript generation' stamp: 'fm 8/7/2022 00:56'!printJSOn: aStream indent: level properties: aDict	((aDict at: #methodClass) == BlockClosure and: [index = 1]) ifTrue: [			aStream nextPutAll: 'startpc'	] ifFalse: [		((aDict at: #methodClass) includesBehavior: BlockClosure) ifTrue: [			index = 0 ifTrue: [				aStream nextPutAll: 'outerContext'				] ifFalse: [				index = 1 ifTrue: [					aStream nextPutAll: 'startpcOrMethod'				] ifFalse: [					index = 2 ifTrue: [						aStream nextPutAll: 'length'					] ifFalse: [						aStream nextPutAll: 'receiver'					]				]			]		] ifFalse: [			aStream nextPutAll: 'instvars['; 				nextPutAll: index printString; 				nextPutAll: ']/* ';				nextPutAll: name;				nextPutAll: ' */'		]	]! !!LiteralVariableNode methodsFor: 'JavaScript generation' stamp: 'fm 12/30/2022 11:36'!isInlinedJsLiteral		^((#(MISSING_MARKER HANDLER_MARKER) includes: name) or: [key isVariableBinding and: 	[((key class == ClassBinding or: [key class == Global]) and: [(Smalltalk bindingOf: key key asSymbol) == key]) or: 	[key class == Association and: [(Undeclared bindingOf: key key asSymbol) == key]]]]) ! !!LiteralVariableNode methodsFor: 'JavaScript generation' stamp: 'fm 7/6/2022 17:31'!isLiteralLike	^ true! !!LiteralVariableNode methodsFor: 'JavaScript generation' stamp: 'fm 12/30/2022 11:33'!jsLiteralIndexUsing: parentCompiledCode		^key notNil ifTrue: [parentCompiledCode indexOfEqualLiteral: key ifAbsent: [self halt. nil]]! !!LiteralVariableNode methodsFor: 'JavaScript generation' stamp: 'fm 7/28/2022 12:18'!printJSOn: aStream indent: level properties: aDict	| litIndex parent ix literalsHolderNode literalsDict blocksStack holderPath |	(self isInlinedJsLiteral not and: 	[blocksStack := aDict at: #functions ifAbsent: [#()].	ix := blocksStack size.	parent := ix > 0 ifTrue: [		(aDict at: #compiledBlocksDict ifAbsent: []) 			ifNil: [aDict at: #compiledMethod] 			ifNotNil: [:c |				[ix > 0 and: [(c at: (blocksStack at: ix) ifAbsent: []) isNil]] whileTrue: [ix := ix - 1].				ix > 0 ifTrue: [c at: (literalsHolderNode := blocksStack at: ix)] ifFalse: [aDict at: #compiledMethod]].	] ifFalse: [		aDict at: #compiledMethod	].	literalsHolderNode isNil ifTrue: [literalsHolderNode := #method].	(litIndex := self jsLiteralIndexUsing: parent) notNil and:	[(aDict includesKey: #ThisBlock) not]]) ifTrue: [		literalsDict := (aDict at: #literalsDict) at: literalsHolderNode.		((literalsDict at: #reusedLiterals ifAbsent: [#()]) includes: litIndex) ifTrue: [			aStream nextPutAll: 'literal';				nextPutAll: litIndex printString;				nextPutAll: '[1]/* '		] ifFalse: [			((literalsDict at: #thisMethodLiteralsRef ifAbsent: [#()]) size = 1) ifTrue: [				holderPath := literalsDict at: #holderPath.				(holderPath isEmpty or: [holderPath beginsWith: '.literals[']) ifTrue: [					holderPath := (aDict at: #methodSelector) JSmapping, holderPath.				].				aStream nextPutAll: holderPath;					nextPutAll: '.literals'			] ifFalse: [				aStream nextPutAll: 'thisMethodLiterals'			].			aStream nextPut: $[;				nextPutAll: litIndex printString;				nextPutAll: '].pointers[1]/* '		].		aStream nextPutAll: key key;			nextPutAll: ' */'	] ifFalse: [		(#(MISSING_MARKER HANDLER_MARKER) includes: name) ifTrue: [			aStream nextPut: $_; 				nextPutAll: name		] ifFalse: [			(key isVariableBinding and: [key key isNil or: 			[((key class == ClassBinding or: [key class == Global]) and: [(Smalltalk bindingOf: key key asSymbol) == key]) or:			[key class == Association and: [(Undeclared bindingOf: key key asSymbol) == key]]]]) ifTrue: [				aStream nextPutAll: JavaScriptTranspiler instance jsEnvironmentPrefix.				key JSprintValueOn: aStream			] ifFalse: [				(litIndex notNil and: [aDict includesKey: #ThisBlock]) ifTrue: [					literalsDict := (aDict at: #literalsDict) at: literalsHolderNode.					holderPath := literalsDict at: #holderPath.					(holderPath isEmpty or: [holderPath beginsWith: '.literals[']) ifTrue: [						holderPath := 'compiledMethod', holderPath.					].					aStream nextPutAll: holderPath;						nextPutAll: '.literals[';						nextPutAll: litIndex printString;						nextPutAll: '].pointers[1]/* ';						nextPutAll: key key;						nextPutAll: ' */'				] ifFalse: [self halt]			]		]	]! !!LiteralVariableNode methodsFor: 'transforming' stamp: 'fm 12/30/2022 11:34'!couldBeAffectedByReordering	^(#(MISSING_MARKER HANDLER_MARKER) includes: name) not and: [key isVariableBinding and: [key canAssign]]! !!TempVariableNode methodsFor: 'transforming' stamp: 'fm 10/5/2014 11:03'!clearArgType	argType := nil! !!RemoteTempVectorNode methodsFor: 'transforming' stamp: 'fm 10/5/2020 20:41'!sameAs: aNode	^(self class == aNode class) and: [remoteTemps sameAs: aNode remoteTemps]! !!WeakArray methodsFor: 'JavaScript generation' stamp: 'fm 3/28/2021 14:10'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname;		nextPutAll: ', "@pointers": '.	self class jsEncapsulateArgs: self			on: aStream			argsBlock: [:arg | (arg class inheritsFrom: Object) ifTrue: [								arg JSstoreOn: aStream visiting: aDict indent: level							] ifFalse: [								JavaScriptTranspiler instance objJSstore: arg on: aStream visiting: aDict indent: level			]].! !!WideString methodsFor: 'JavaScript generation' stamp: 'fm 11/22/2021 08:29'!JSdoStoreOn: aStream visiting: aDict indent: level	aStream nextPutAll: ', "@cls": ';		nextPutAll: self class JSname;		nextPutAll: ', "@str": ['.	self do: [:each | aStream nextPutAll: each asInteger printString] separatedBy: [aStream nextPutAll: ', ']..	aStream nextPutAll: ']'.! !!WideString methodsFor: 'JavaScript generation' stamp: 'fm 7/14/2022 23:19'!JSstoreOn: aStream 	self isEmpty ifTrue: [		aStream nextPutAll: self class JSname;			nextPutAll: '.Empty'.		^self	].	aStream nextPutAll: self class JSname;		nextPutAll: '.fromWords(['.	self do: [:each | aStream nextPutAll: each asInteger printString] separatedBy: [aStream nextPutAll: ', ']..	aStream nextPutAll: '])'.! !!WideString class methodsFor: 'JavaScript generation' stamp: 'fm 2/12/2022 23:00'!jsStaticFromOn: aStream	super jsStaticFromOn: aStream.	aStream nextPutAll: self class JSprotoypeName;		nextPutAll: '.fromWords = function fromWords(aJsArray) {';		crtab;		nextPutAll: 'const result = this.primitive_70_impl()[1];';		crtab;		nextPutAll: 'result.words = aJsArray instanceof Uint32Array ? aJsArray : Uint32Array.from(aJsArray);';		crtab;		nextPutAll: 'Object.seal(result.words);';		crtab;		nextPutAll: 'return result;';		cr;		nextPut: $};		cr! !!WideString class methodsFor: 'JavaScript generation' stamp: 'fm 11/7/2022 14:14'!printJSPrimitive105On: aStream	aStream nextPutAll: 'primitive_105_impl(arg1, arg2, arg3, arg4) {		const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), arg4Val = arg4.valueOf(), words = this.words, arg3storageType = arg3.storageType;		if (arg1Val > 0 && arg2Val >= arg1Val && arg4Val > 0 && (arg1Val | 0) === arg1Val && (arg2Val | 0) === arg2Val && arg2Val <= words.length &&		(arg3storageType === "words" || arg3storageType === "bytes") && (arg4Val | 0) === arg4Val && arg4Val + arg2Val - arg1Val <= arg3[arg3storageType].length) {			const start = arg1Val - 1, replacementStart = arg4Val - 1;			const replacement = arg3[arg3storageType].slice(replacementStart, replacementStart + arg2Val - start);			words.set(replacement, start);			this.dirty = true; 			return [true, this];		} else return [false]},';			crtab! !!LiteralVariableNode reorganize!('code generation' emitCodeForLoad:forValue:encoder: emitCodeForStore:encoder: emitCodeForStorePop:encoder: emitCodeForValue:encoder: sizeCodeForLoad:forValue: sizeCodeForStore: sizeCodeForStorePop: sizeCodeForValue:)('visiting' accept:)('JavaScript generation' isInlinedJsLiteral isLiteralLike jsLiteralIndexUsing: printJSOn:indent:properties:)('testing' assignmentCheck:at:)('transforming' couldBeAffectedByReordering)!!String reorganize!('accessing' byteAt: byteAt:put: byteSize do:toFieldNumber: findAnySubStr:startingAt: findBetweenSubStrs: findCloseParenthesisFor: findDelimiters:startingAt: findLastOccurrenceOfString:startingAt: findString: findString:startingAt: findString:startingAt:caseSensitive: findSubstring:in:startingAt:matchTable: findTokens: findTokens:escapedBy: findTokens:includes: findTokens:keep: findWordStart:startingAt: indexOf: indexOf:startingAt: indexOf:startingAt:ifAbsent: indexOfSubCollection: indexOfSubCollection:startingAt:ifAbsent: lastSpacePosition leadingCharRunLengthAt: lineCorrespondingToIndex: lineCount lineIndicesDo: lineNumber: lines linesDo: numArgs skipAnySubStr:startingAt: skipDelimiters:startingAt: tabDelimitedFieldsDo:)('arithmetic' * + - / // \\)('comparing' < <= = > >= alike: caseInsensitiveLessOrEqual: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: compare:caseSensitive: compare:with:collated: crc16 hash hashWithInitialHash: howManyMatch: match: sameAs: startingAt:match:startingAt:)('converting' , adaptToCollection:andSend: adaptToNumber:andSend: adaptToPoint:andSend: adaptToString:andSend: asAscii asByteArray asByteString asCamelCase asCharacter asDate asDateAndTime asDecomposedUnicode asDisplayText asDuration asFileName asFourCode asHex asHtml asIdentifier: asInteger asLegalSelector asLowercase asNumber asOctetString asPacked asPluralBasedOn: asPrecomposedUnicode asSignedInteger asSmalltalkComment asSqueakPathName asString asStringOrText asSymbol asText asTime asTimeStamp asUnHtml asUnsignedInteger asUppercase asVmPathName asWideString askIfAddStyle:req: base64Decoded base64Encoded capitalized compressWithTable: contractTo: convertFromEncoding: convertFromSuperSwikiServerString convertFromWithConverter: convertToEncoding: convertToSuperSwikiServerString convertToSystemString convertToWithConverter: correctAgainst: correctAgainst:continuedFrom: correctAgainstDictionary:continuedFrom: encodeForHTTP encodeForHTTPWithTextEncoding: encodeForHTTPWithTextEncoding:conditionBlock: findSelector initialIntegerOrNil keywords numericSuffix onlyLetters romanNumber sansPeriodSuffix splitInteger squeakToUtf8 stemAndNumericSuffix string subStrings subStrings: substrings surroundedBySingleQuotes translateFrom:to:table: translateToLowercase translateToUppercase translateWith: truncateTo: truncateWithElipsisTo: unescapePercents unescapePercentsRaw unescapePercentsWithTextConverter: unescapePercentsWithTextEncoding: unparenthetically utf8ToSqueak withBlanksCondensed withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutJustTrailingDigits withoutLeadingBlanks withoutLeadingDigits withoutTrailingBlanks withoutTrailingDigits)('copying' copyReplaceTokens:with: deepCopy padded:to:with:)('displaying' displayAt: displayOn: displayOn:at: displayOn:at:textColor:)('encoding' writeLeadingCharRunsOn:)('filter streaming' byteEncode: putOn:)('formatting' expandMacros expandMacrosWith: expandMacrosWith:with: expandMacrosWith:with:with: expandMacrosWith:with:with:with: expandMacrosWithArguments: format: withCRs)('internet' decodeMimeHeader decodeQuotedPrintable isoToSqueak isoToUtf8 macToSqueak squeakToIso squeakToMac utf8ToIso withInternetLineEndings withLineEndings: withSqueakLineEndings withUnixLineEndings withoutQuoting)('paragraph support' indentationIfBlank:)('printing' encodeDoublingQuoteOn: printAsLiteralOn: printOn: storeOn: stringRepresentation)('testing' beginsWith: canBeToken endsWith: endsWithAColon endsWithAnyOf: endsWithDigit includesSubString: includesSubstring:caseSensitive: includesUnifiedCharacter isAllDigits isAllSeparators isAsciiString isByteString isLiteral isOctetString isString isWideString startsWithDigit)('user interface' asExplorerString)('*Morphic' asMorph asStringMorph)('*MorphicExtras-*morphic-Postscript Canvases' asPostscript)('*Morphic-converting' openAsMorph)('*monticello' withLoadedPackageVersions)('*network-uri' asURI)('*packageinfo-base' escapeEntities)('*services-base' service serviceOrNil)('*versionnumber' asVersion)('private' correctAgainstEnumerator:continuedFrom: evaluateExpression:parameters: replaceFrom:to:with:startingAt: stringhash)('*Morphic-Explorer' hasContentsInExplorer)('*xml-parser' applyLanguageInfomation:)('*ST80-Support' asParagraph)('*system' suggestedTypeNames)('*Etoys-tiles' basicType newTileMorphRepresentative)('*sound-synthesis' asSound)('*network-uuid' asAlphaNumeric:extraChars:mergeUID:)('*network-url' asUrl asUrlRelativeTo: urlEncoded)('*toolbuilder-kernel' displayProgressAt:from:to:during: displayProgressFrom:to:during:)('enumerating' combinations:atATimeDo:)('*Tools-Debugger' canonicalArgumentName)('*System-Localization' literalStringsDo: translated translatedFor: translatedIfCorresponds translatedInAllDomains translatedInAnyDomain translatedInDomain: translatedInDomain:or: translatedNoop translatedTo: translatedTo:inDomain:)('*Compression-Streams' unzipped zipped)('*collections' compareSafely:)('*Multilingual' encodedCharSetAt:)('*Etoys-support' asGetterSelector asSetterSelector inherentSelector)('*files' asDirectoryEntry)('JavaScript generation' JSdoStoreOn:visiting:indent: JSprimitiveOn: JSstoreOn: JSstoreOn:visiting:indent:)('*universes-model' uversionEqual: uversionLessThan:)('*Universes' asUVersion)('deprecated-3.10' findLastOccuranceOfString:startingAt:)('*Rome-PluginCanvas')('*VMMaker-Translation to C')('*Regex-Core')('*printf')('*FFI-Kernel-external data')('*Etoys-Squeakland-Camp Smalltalk')('*Etoys-Squeakland-encoding')('accessing - tokens')('*VMMaker-translation support')('*Etoys-internet')('*System-Support')('*Multilingual-converting')('*Etoys-Squeakland-converting')('*FFI-Kernel-accessing')('accessing - features')('*Etoys-Squeakland-testing')('sorting')('*Alien-Core')('*60Deprecated-user interface')('*Etoys-Squeakland-pango')('*Cog-script support')('*Etoys-Squeakland-network-mime')('*Etoys-Squeakland-password compatibility')('*JSON')('*JSON-writing')!!CompiledMethod class reorganize!('constants' abstractMarkers disabledMarker subclassResponsibilityMarker)('instance creation' basicNew basicNew: new new: newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive: newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:flag: newFrom: newInstanceFrom:variable:size:map: newMethod:header: primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer: toReturnConstant:trailerBytes: toReturnField:trailerBytes: toReturnSelf toReturnSelfTrailerBytes:)('evaluating' receiver:withArguments:executeMethod:)('accessing class hierarchy' methodPropertiesClass)('JavaScript generation' hasJsCachedStorage initializeJsCachedStorageMessage isCompiledMethodClass jsStorageTypeOn:)('class initialization' fullFrameSize initialize smallFrameSize)('*Traits-constants' conflictMarker explicitRequirementMarker implicitRequirementMarker)('full block bootstrap')('*Tests-Compiler-support')!!CompiledMethod reorganize!('accessing' clearFlag clearSignFlag defaultSelector dragLabel endPC flag flushCache frameSize initialPC methodClass methodClass: methodClassAssociation methodClassAssociation: methodHome numArgs numLiterals numTemps primitive properties properties: referredInstVars returnField scanner searchForClass searchForSelector selector selector: setSignFlag signFlag trailer)('closures' containsBlockClosures embeddedBlockClosures)('comparing' = equivalentTo: hasSameLiteralsAs: hasSameLiteralsExceptPropertiesAs: hash sameWithoutTrailerAs:)('decompiling' compilerClass copyWithTemps decompile decompileWithTemps decompilerClass encoderClass jsHeader methodForDecompile methodNode methodNodeFormattedAndDecorated: parserClass)('evaluating' valueWithReceiver:arguments:)('file in/out' objectForDataStream: readDataFrom:size: storeDataOn: veryDeepCopyWith: zapSourcePointer)('literals' allLiterals hasLiteral: hasLiteralSuchThat: hasLiteralThorough: header headerDescription indexOfEqualLiteral:ifAbsent: indexOfLiteral: literalAt: literalAt:put: literalStrings literals literalsDo: objectAt: objectAt:put: refersToLiteral: sendsSelector:)('JavaScript generation' JSdoStoreOn:visiting:indent: JSprintOn: JSstoreOn: JSstoreOn:visiting:indent: isCompiledCode)('printing' abstractSymbolic dateMethodLastSubmitted decompileString longPrintOn: longPrintOn:indent: longPrintRelativeOn:indent: preamble primitiveErrorVariableName printOn: printPrimitiveOn: printReferenceOn: printSignatureOn: reference storeLiteralsOn:forClass: storeOn: symbolic symbolicLinesDo: timeStamp)('scanning' abstractBytecodeMessageAt: abstractBytecodeMessagesDo: abstractBytecodeMessagesFrom:to:do: hasInstVarRef messages messagesDo: messagesSequence readsField: readsRef: scanFor: scanLongLoad: scanLongStore: scanVeryLongLoad:offset: scanVeryLongStore:offset: sendsToSuper writesField: writesRef:)('source code management' checkOKToAdd:at: copyWithTempNames: copyWithTempsFromMethodNode: dropSourcePointer fileIndex filePosition getPreambleFrom:at: getSource getSourceFor:in: getSourceFromFile getSourceFromFileAt: holdsTempNames linesOfCode putSource:fromParseNode:class:category:inFile:priorMethod: putSource:fromParseNode:class:category:withStamp:inFile:priorMethod: putSource:fromParseNode:inFile:withPreamble: setSourcePointer: setSourcePosition:inFile: sourceClass sourceFileStream sourcePointer sourceSelector tempNamesString)('testing' hasNewPropertyFormat hasReportableSlip isAbstract isBlueBookCompiled isClosureCompiled isCompiledMethod isDisabled isDisabled: isImplicitlyRequired isInstalled isJsInstalled isQuick isReturnField isReturnSelf isReturnSpecial isSubclassResponsibility isSubclassResponsibility: usesClosureBytecodes)('*Tools-Inspector' inspectorClass)('private' markerOrNil penultimateLiteral penultimateLiteral: replace:with:in:)('accessing-pragmas & properties' pragmaAt: pragmas propertyKeysAndValuesDo: propertyValueAt: propertyValueAt:ifAbsent: propertyValueAt:put: removeProperty: removeProperty:ifAbsent:)('converting' asString)('copying' copyWithTrailerBytes: postCopy)('*System-Tools-debugger support' hasBreakpoint)('*Tools-Debugger-support' abstractPCForConcretePC: blockExtentsInto:from:to:scanner:numberer: blockExtentsToTempsMap debuggerMap mapFromBlockKeys:toSchematicTemps: pcPreviousTo: startpcsToBlockExtents tempsSubSequenceFrom:)('*45Deprecated' setMySourcePointer:)('initialize-release' needsFrameSize:)('tracing' outboundPointersDo:)('*Morphic-Explorer' explorerContents)('*System-Support' methodReference)('*VMMaker-translation')('*Traits-testing' isConflict isExplicitlyRequired isExplicitlyRequired: isImplicitlyRequired: isProvided isProvided: isRequired isRequired:)('*Traits-NanoKernel' originalTraitMethod originalTraitMethod: originalTraitOrClass sameTraitCodeAs:)('*Tools-Debugger')('*VMMaker-C translation')('*CogTools-method introspection')('*Etoys-Squeakland-decompiling')('*FFI-Kernel')('*Tools-Browsing')('*MethodMassage-debugging')('*Etoys-Squeakland-printing')('*MethodMassage-disassembly')('*VMMaker-support')('*Compiler-private')('*ast-core')!!Array class reorganize!('brace support' braceStream: braceWith: braceWith:with: braceWith:with:with: braceWith:with:with:with: braceWithNone)('instance creation' empty new:)('*VMMaker-plugin generation')('*vmmakerjs')('JavaScript generation' jsStaticHelpersOn:)!!SequenceableCollection reorganize!('accessing' after: after:ifAbsent: allButFirst allButFirst: allButLast allButLast: anyOne at:ifAbsent: at:incrementBy: atAll: atAll:put: atAll:putAll: atAllPut: atLast: atLast:ifAbsent: atLast:put: atPin: atRandom: atWrap: atWrap:put: before: before:ifAbsent: eighth fifth first first: fourth from:to:put: identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt: indexOf:startingAt:ifAbsent: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: integerAt: integerAt:put: last last: lastIndexOf: lastIndexOf:ifAbsent: lastIndexOf:startingAt:ifAbsent: lastIndexOfAnyOf:startingAt:ifAbsent: middle ninth replaceAll:with: replaceFrom:to:with: replaceFrom:to:with:startingAt: second seventh sixth size swap:with: third)('comparing' = hasEqualElements: hash sameAs:)('converting' @ asArray asByteArray asColorArray asFloatArray asIntegerArray asStringWithCr asWordArray concatenation readStream reverse reverseInPlace reversed writeStream)('copying' , copyAfter: copyAfterLast: copyEmpty copyFrom:to: copyLast: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpThrough: copyUpTo: copyUpToLast: copyWith: copyWithFirst: copyWithoutFirst copyWithoutIndex: forceTo:paddingStartWith: forceTo:paddingWith: grownBy: shuffled sortBy:)('enumerating' allButFirstDo: allButLastDo: asDigitsToPower:do: collect: collect:from:to: collectWithIndex: combinations:atATimeDo: do: do:separatedBy: do:without: doWithIndex: findBinary: findBinary:do:ifNone: findBinary:ifNone: findBinaryIndex: findBinaryIndex:do:ifNone: findBinaryIndex:ifNone: findFirst: findLast: findNearbyBinaryIndex: from:to:do: groupsOf:atATimeCollect: groupsOf:atATimeDo: keysAndValuesDo: nextToLast overlappingPairsCollect: overlappingPairsDo: overlappingPairsWithIndexDo: paddedWith:do: pairsCollect: pairsDo: permutationsDo: piecesCutWhere: piecesCutWhere:do: polynomialEval: replace: reverseDo: reverseWith:do: select: splitBy: splitBy:do: upTo: with:collect: with:do: withIndexCollect: withIndexDo:)('removing' remove:ifAbsent:)('testing' beginsWith: beginsWithAnyOf: endsWith: endsWithAnyOf: includes: isSequenceable)('*services-base' startsWith:)('private' asDigitsAt:in:do: checkedAt: combinationsAt:in:after:do: copyReplaceAll:with:asTokens: errorFirstObject: errorLastObject: errorOutOfBounds permutationsStartingAt:do:)('*Morphic-NewCurves-cubic support' asCubic assertSlopesWith:from:to: changeInSlopes: changeOfChangesInSlopes: closedCubicSlopes closedCubicSlopes: closedFillinList cubicPointPolynomialAt: naturalCubicSlopes naturalCubicSlopes: naturalFillinList nilTransitions segmentedSlopes slopesWith:from:to: transitions transitions:)('*Morphic-fliprotate' flipRotated:)('*Morphic-Explorer' explorerContents)('filter streaming' putOn:)('shuffling' shuffle shuffleBy: shuffledBy:)('*Balloon' asPointArray)('*Traits' asTraitComposition)('*VMMaker-translation support')('printing')('*Etoys-Squeakland-accessing')('adding')!!ScaledDecimal reorganize!('arithmetic' * + - / negated reciprocal)('comparing' < <= = > >= hash isZero literalEqual:)('converting' adaptToFraction:andSend: adaptToInteger:andSend: asFloat asFraction asScaledDecimal: asSpecies:)('mathematical functions' ln log nthRoot: raisedToInteger: sqrt squared)('JavaScript generation' JSstoreOn:)('printing' printAsLiteralOn: printFractionAsDecimalOn: printOn: printOn:showingDecimalPlaces: printScaleOn: printString storeOn:)('testing' isLiteral isScaledDecimal negative)('truncation and round off' fractionPart integerPart truncated)('private' denominator numerator scale setFraction:scale:)('*JSON-writing')!!ReturnNode reorganize!('code generation' code emitCodeForReturn:encoder: emitCodeForValue:encoder: sizeCodeForReturn: sizeCodeForValue:)('converting' asReturnNode)('initialize-release' expr: expr:encoder:sourceRange:)('printing' expr printOn:indent: printWithClosureAnalysisOn:indent:)('testing' isReturnSelf isSpecialConstant isVariableReference)('visiting' accept:)('code generation (closures)' analyseTempsWithin:rootNode:assignmentPools:)('*Etoys-tiles' explanation)('transforming' isRealReturn privatePostCopy replace:with: sameAs:)('JavaScript generation' isJSexpression printJSOn:indent:properties:)('*VMMaker-C translation')('*Etoys-Squeakland-Tweak-Kedama')!!MethodNode reorganize!('code generation' encoder generate generate: generate:ifQuick: generate:using: generate:using:ifQuick: generateWithTempNames isQuick parserClass properties selector selectorNode)('initialize-release' block selector: selector:arguments:precedence:temporaries:block:encoder:primitive: selector:arguments:precedence:temporaries:block:encoder:primitive:properties: sourceText:)('printing' methodClass printOn: printPragmasOn: printPrimitiveOn: printPropertiesOn: printWithClosureAnalysisOn: sourceText tempNames)('transforming' addNewTempTo: addTemp:to: ascendValueBlocksAssignments ascendValueBlocksReturrns cacheCaseReceivers cleanupOptimizedBlockWithArg compactIfTrueIfFalse deduplicateIfTrueIfFalseBranches descendAssignmentsIntoLoops descendAssignmentsIntoValueBlocks descendReturnsIntoLoops descendReturnsIntoValueBlocks fixupMacroSelectors isLocalReturn:withParents: makeImplicitSelfReturnExplicit makeLoopExpressionsStatements makeValueBlocksExpressionsStatements markJSoptimizedBlocks moveNonExpressionsOutOfBraces moveReturnIntoPrecedingIfTrueIfFalse moveTempsFrom:to: normalize: normalizeBranches normalizeIfTrueIfFalse recoverBooleanExpressions recoverCaseOfExpressions recoverConditionalExpressions removeCascades removeComplexAnd removeComplexOr removeDeadCodeFollowingAssignments removeIfFalse removeIfFalseIfTrue removeIfNil removeIfTrue removeNoOps removeNonLocalReturns removeNonLocalReturnsFromHandlerBlock removeNonLocalReturnsFromIfMissingBlock removeRedundantAssignments removeReturnsFromPrecedingIfTrueIfFalse removeWriteOnlyTemps renameTempsNamedLikeMySelector replaceReusedVarNames replaceStatementConditionalExpressions replaceTempsIn:withTempsIn: select:preservingEvaluationOrderDo: select:withBlockAndParentDo: select:withEnclosingBlockDo: select:withParentDo: select:withParentsDo: selectWithParents:do: selectWithParents:preservingEvaluationOrderDo: transformLoopArguments transformLoopLocalReturns transformLoopReceivers transformValueBlocksArguments transformValueBlocksLocalReturns transformValueBlocksReceivers)('accessing' arguments arguments: body primitiveErrorVariableName removeProperty: temporaries temporaries:)('visiting' accept:)('converting' asColorizedSmalltalk80Text decompileString decompileText ensureNotQuick preen preenIfValue preenLocalIfNotNilArg preenWhileLoopValue)('source mapping' rawSourceRanges rawSourceRangesAndMethodDo:)('primitive error codes' removeAndRenameLastTempIfErrorCode)('code generation (closures)' addLocalsToPool: ensureClosureAnalysisDone locationCounter noteBlockEntry: noteBlockExit: referencedValuesWithinBlockExtent:)('JavaScript generation' JSPropertiesFor: JSprepare: JSprintEntryPreemptionOn:properties: asJavaScript inlineBodyOf:on:properties: printJSOn:properties: printJSPrimitive:on:properties:)('debugger support' blockExtentsToTempsMap hasGeneratedMethod schematicTempNamesString)('*VMMaker-C translation')('*Etoys-tiles')('*Etoys-Squeakland-Tweak-Kedama')('converting-private')('*Etoys-Squeakland-code generation')!!MessageNode reorganize!('cascading' cascadeReceiver)('code generation' emitCodeForCase:encoder:value: emitCodeForEffect:encoder: emitCodeForIf:encoder:value: emitCodeForIfNil:encoder:value: emitCodeForRepeat:encoder:value: emitCodeForToDo:encoder:value: emitCodeForValue:encoder: emitCodeForWhile:encoder:value: sizeCodeForCase:value: sizeCodeForEffect: sizeCodeForIf:value: sizeCodeForIfNil:value: sizeCodeForRepeat:value: sizeCodeForToDo:value: sizeCodeForValue: sizeCodeForWhile:value:)('equation translation' arguments arguments: eval originalArguments receiver receiver: selector)('initialize-release' receiver:selector:arguments:precedence: receiver:selector:arguments:precedence:from: receiver:selector:arguments:precedence:from:sourceRange: selector:)('macro transformations' noteSpecialSelector: toDoFromWhileWithInit: transform: transformAnd: transformBoolean: transformCase: transformIfFalse: transformIfFalseIfTrue: transformIfNil: transformIfNilIfNotNil: transformIfNotNilIfNil: transformIfTrue: transformIfTrueIfFalse: transformOr: transformRepeat: transformToDo: transformWhile:)('JavaScript generation' JSprintCaseOn:indent:properties: JSprintIfNil:indent:properties: JSprintIfNilNotNil:indent:properties: JSprintIfOn:indent:properties: JSprintLoopPreemptionOn:indent:properties: JSprintRepeatOn:indent:properties: JSprintToDoOn:indent:properties: JSprintWhileOn:indent:properties: isBig isJSexpression isJStryFinally isJsOptimized isTimesRepeat macroSelector printJSOn:indent:precedence:properties: printJSOn:indent:properties:)('printing' asMorphicCaseOn:indent: macroPrinter precedence printCaseOn:indent: printIfNil:indent: printIfNilNotNil:indent: printIfOn:indent: printKeywords:arguments:on:indent: printOn:indent: printOn:indent:precedence: printParenReceiver:on:indent: printReceiver:on:indent: printRepeatOn:indent: printToDoOn:indent: printWhileOn:indent: printWithClosureAnalysisCaseOn:indent: printWithClosureAnalysisIfNil:indent: printWithClosureAnalysisIfNilNotNil:indent: printWithClosureAnalysisIfOn:indent: printWithClosureAnalysisKeywords:arguments:on:indent: printWithClosureAnalysisOn:indent: printWithClosureAnalysisOn:indent:precedence: printWithClosureAnalysisParenReceiver:on:indent: printWithClosureAnalysisReceiver:on:indent: printWithClosureAnalysisToDoOn:indent: printWithClosureAnalysisWhileOn:indent: test)('testing' canCascade ensureCanCascade: isComplex isMessage isMessage:receiver:arguments: isMessageNode isNilIf isOptimized isOptimizedLoop isReturningIf toDoIncrement: toDoLimit:)('tiles' morphFromKeywords:arguments:on:indent:)('private' checkBlock:as:from: checkBlock:as:from:maxArgs: ifNilReceiver pvtCheckForPvtSelector: receiver:arguments:precedence:)('visiting' accept: argumentsInEvaluationOrder receiverInEvaluationOrder)('code generation (closures)' analyseTempsWithin:rootNode:assignmentPools:)('transforming' couldBeAffectedByReordering hasOptimizedValueBlocks isFullyReturningFromOptimizedValueBlocks isLoopStatement loopReturnValue mayHaveOptimizedValueBlocks optimizedValueBlocks privatePostCopy replace:with: sameAs: withoutComments)('*VMMaker-C translation')('decompiling')('*Etoys-tiles')('*Etoys-Squeakland-Tweak-Kedama')('*Cog-Explorations-testing')('*Etoys-Squeakland-etoys-transform')('*Etoys-Squeakland-accessing')!!LiteralNode reorganize!('code generation' emitCodeForValue:encoder: reserve: sizeCodeForValue:)('evaluation' eval)('JavaScript generation' isInlinedJsLiteral isJSexpression isLiteralLike jsLiteralIndexUsing: printJSOn:indent:precedence:properties: printJSOn:indent:properties:)('printing' printOn:indent: printWithClosureAnalysisOn:indent:)('testing' isConstantNumber isLiteralNode isSpecialConstant literalValue)('visiting' accept:)('initialize-release' name:key:index:type:)('*Etoys-tiles' explanation)('transforming' couldBeAffectedByReordering isFixedValue literalValueString)('*VMMaker-C translation')('*Etoys-Squeakland-code generation')!!BlockNode reorganize!('accessing' addArgument: arguments arguments: block closureCreationNode firstArgument nArgsSlot nArgsSlot: numberOfArguments optimized optimizedMessageNode optimizedMessageNode: returnLast returnNilIfNoOther returnSelfIfNoOther: startOfLastStatement startOfLastStatement: temporaries temporaries: tempsMark tempsMark:)('code generation' code emitCodeExceptLast:encoder: emitCodeForEvaluatedEffect:encoder: emitCodeForEvaluatedValue:encoder: emitCodeForValue:encoder: sizeCodeExceptLast: sizeCodeForEvaluatedEffect: sizeCodeForEvaluatedValue: sizeCodeForValue:)('equation translation' statements statements:)('initialize-release' arguments:statements:returns:from: noteSourceRangeStart:end:encoder: statements:returns:)('JavaScript generation' JSprintEntryPreemptionOn:indent:properties: firstRealStatement ignoresOwnLocalReturn isJSexpression isJSoptimized isJSoptimizedValueBlock printJSBodyOn:indent:properties: printJSOn:indent:precedence:properties: printJSOn:indent:properties: printJSStatementsOn:indent:properties: printJSStatementsOn:indent:properties:definitions: printJSTemporaries:on:doPrior: printJsLiteralsAndBodyOn:indent:properties: withoutImplicitReturns)('printing' decompileString decompileText printArgumentsOn:indent: printOn:indent: printStatementsOn:indent: printTemporaries:on:doPrior: printWithClosureAnalysisArgumentsOn:indent: printWithClosureAnalysisOn:indent: printWithClosureAnalysisStatementsOn:indent: printWithClosureAnalysisTemporariesOn:indent:)('testing' generateAsClosure isBlockNode isComplex isJust: isJustCaseError isMostlyEmptyBlock isQuick returns)('visiting' accept:)('code generation (closures)' actualScope addHoistedTemps: addRemoteTemp:rootNode: addTempNode: analyseArguments:temporaries:rootNode: analyseTempsWithin:rootNode:assignmentPools: blockExtent constructClosureCreationNode: deoptimize emitCodeForClosureValue:encoder: emitCodeForEvaluatedClosureValue:encoder: ifHasRemoteTempNodeEnsureInitializationStatementExists: makeTemporariesRemovable nilReadBeforeWrittenTemps noteOptimizedIn: optimizedBlockHoistTempsInto: postNumberingProcessTempsWithin:rootNode: reindexingLocalsDo:encoder: remoteTempNodeName removeTempNode:ifAbsent: sizeCodeForClosureValue: sizeCodeForEvaluatedClosureValue:)('converting' ensureNotQuick:)('transforming' addStatement:before: copiedValues moved:to: privatePostCopy replace:with: returns: sameAs:)('*VMMaker-C translation')('*Etoys-Squeakland-testing')('*Etoys-Squeakland-Tweak-Kedama')('*Etoys-tiles')('*Etoys-Squeakland-accessing')('closure analysis' computeCopiedValues:)!!AssignmentNode reorganize!('code generation' emitCodeForEffect:encoder: emitCodeForValue:encoder: sizeCodeForEffect: sizeCodeForValue:)('equation translation' variable)('initialize-release' toDoIncrement: value variable:value: variable:value:from: variable:value:from:sourceRange:)('JavaScript generation' isJSexpression printJSOn:indent:precedence:properties: printJSOn:indent:properties:)('printing' printOn:indent: printOn:indent:precedence: printWithClosureAnalysisOn:indent: printWithClosureAnalysisOn:indent:precedence:)('transforming' privatePostCopy replace:with: sameAs:)('visiting' accept:)('code generation (closures)' analyseTempsWithin:rootNode:assignmentPools:)('testing' isAssignmentNode)('*Etoys-tiles' explanation)('*VMMaker-C translation')('private')('*Etoys-Squeakland-Tweak-Kedama')!!ParseNode reorganize!('code generation' emitCodeForBlockValue:encoder: emitCodeForBranchOn:dist:pop:encoder: emitCodeForEffect:encoder: emitCodeForJump:encoder: emitCodeForReturn:encoder: pc pc: sizeCode:forBranchOn:dist: sizeCode:forJump: sizeCodeForBlockValue: sizeCodeForEffect: sizeCodeForReturn:)('comment' comment comment:)('converting' asReturnNode)('encoding' encodeSelector:)('JavaScript generation' jsLiteralIndexUsing: printJSCommentOn:indent: printJSOn:indent:precedence:properties: printJSOn:indent:properties:)('printing' nodePrintOn:indent: printCommentOn:indent: printOn: printOn:indent: printOn:indent:precedence: printWithClosureAnalysis printWithClosureAnalysisOn: printWithClosureAnalysisOn:indent: printWithClosureAnalysisOn:indent:precedence: shortPrintOn:)('testing' assignmentCheck:at: canCascade ensureCanCascade: isArg isAssignmentNode isBlockNode isComplex isConstantNumber isDoIt isFutureNode isJust: isLiteralLike isLiteralNode isMessage isMessage:receiver:arguments: isMessageNode isOnlySubnodeOf:in: isReturnSelf isReturningIf isSelfPseudoVariable isSpecialConstant isTemp isUndefTemp isUnusedTemp isVariableNode isVariableReference nowHasDef nowHasRef toDoIncrement:)('private' ifNilReceiver nextWordFrom:setCharacter: printSingleComment:on:indent:)('visiting' accept: nodesDo:)('*Etoys-tiles' addCommentToMorph: currentValueIn: explanation)('transforming' couldBeAffectedByReordering isCascade isFixedValue isLoopStatement isParentOf: isRealReturn nodesWithParentsDo: privateCopy replace:with: sameAs:)('*VMMaker-C translation')('*Etoys-Squeakland-testing')('*Etoys-Squeakland-Tweak-Kedama' isLeaf)('*Etoys-Squeakland-accessing')!!LargePositiveInteger reorganize!('arithmetic' * + - / // \\ \\\ abs negated quo: rem:)('bit manipulation' bitAt: bitReverse: hashMultiply highBit highBitOfMagnitude)('comparing' < <= > >= hash)('converting' as31BitSmallInt asFloat normalize withAtLeastNDigits:)('system primitives' digitAt: digitAt:put: digitLength replaceFrom:to:with:startingAt:)('testing' isLarge isPowerOfTwo isPrime negative positive sign strictlyPositive)('JavaScript generation' JSstoreOn: JsHexOn: JsHexWordOn: isJSsafeInteger)('printing' asHexOn: asHexWord asHexWordOn: printOn:base: printOn:base:nDigits: printStringBase:)('mathematical functions' ln log mightBeASquare sqrt)('*VMMaker-Tests')('private')('truncation and round off')('objects from disk')!!Fraction reorganize!('arithmetic' * + - / negated)('comparing' < <= = > >= hash)('converting' adaptToInteger:andSend: adaptToScaledDecimal:andSend: asFloat asFraction asNonFraction asScaledDecimal isFraction)('mathematical functions' ln log nthRoot: raisedToInteger: sqrt squared)('JavaScript generation' JSstoreOn:)('printing' printAsLiteralOn: printOn: printOn:base: printOn:showingDecimalPlaces: printTruncatedOn:showingDecimalPlaces: storeOn:base:)('truncation and round off' truncated)('private' denominator numerator reciprocal reduced setNumerator:denominator:)('testing' negative)!!Number reorganize!('arithmetic' * + - / // \\ abs arg negated quo: reciprocal rem:)('comparing' closeTo:)('converting' adaptToCollection:andSend: adaptToComplex:andSend: adaptToFloat:andCompare: adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: adaptToPoint:andSend: adaptToScaledDecimal:andSend: adaptToString:andSend: asB3DVector3 asComplex asDuration asFloatD asFloatE asFloatQ asInteger asNonFraction asNumber asPoint asScaledDecimal asScaledDecimal: asSmallAngleDegrees asSmallPositiveDegrees day days degreesToRadians hour hours i milliSecond milliSeconds minute minutes nanoSecond nanoSeconds radiansToDegrees second seconds week weeks withNegativeSign)('filter streaming' byteEncode:)('intervals' to: to:by: to:by:do: to:do:)('mathematical functions' arCosh arSinh arTanh arcCos arcSin arcTan arcTan: copySignTo: cos cosh degreeCos degreeSin exp floorLog: interpolateTo:at: ln log log: nthRoot: raisedTo: raisedToInteger: sign sign: sin sinh sqrt squared tan tanh)('JavaScript generation' JSprimitiveOn: JSstoreOn: JSstoreOn:visiting:indent: isJSsafeInteger)('printing' defaultLabelForInspector isOrAreStringWith: printOn: printOn:base: printOn:maxDecimalPlaces: printOn:showingDecimalPlaces: printShowingDecimalPlaces: printShowingMaxDecimalPlaces: printString printStringBase: storeOn: storeOn:base: storeStringBase: stringForReadout)('testing' even isDivisibleBy: isInfinite isNaN isNumber isZero negative odd positive strictlyPositive)('truncation and round off' ceiling detentBy:atMultiplesOf:snap: floor fractionPart integerPart reduce roundDownTo: roundTo: roundUpTo: rounded truncateTo: truncated)('*Etoys-tiles' basicType newTileMorphRepresentative)('*Etoys-vocabulary' vocabularyDemanded)('*Tools-Debugger' canonicalArgumentName)('*Graphics-converting' @)('*45Deprecated' isInf)('*collections' compareSafely:)('private' veryDeepCopy)('*Etoys-Squeakland-mathematical functions')('*chronology-core')('*Etoys-Squeakland-truncation and round off')('*Etoys-Squeakland-enumerating')('*Etoys-Squeakland-arithmetic')('*JSON-writing')('*Graphics-scale factor')!!Environment reorganize!('classes and traits' allClasses allClassesAndTraits allClassesAndTraitsDo: allClassesDo: allTraits allTraitsDo: classAndTraitNames classNamed: classNames classOrTraitNamed: flushClassNameCache forgetClass:logged: hasClassNamed: removeClassNamed: renameClass:as: renameClass:from: renameClass:from:to: renameClassNamed:as: traitNames)('accessing' info organization size undeclared)('binding' bind:to: bindingOf: bindingOf:ifAbsent: declarationOf: hasBindingOf: hideBinding: showBinding: unbind: valueOf: valueOf:ifAbsent:)('initialize-release' destroy initialize initializeWithName: initializeWithSystemDictionary:)('configuring' export: exportAddingPrefix: exportRemovingPrefix: exportSelf from:import: import: import:addingPrefix: import:removingPrefix: importSelf)('operations' fileIn:announcing: recompileAll)('printing' printOn:)('emulating' associationAt: associationAt:ifAbsent: associationOrUndeclaredAt: associationsDo: at: at:ifAbsent: at:ifAbsentPut: at:ifPresent: at:ifPresent:ifAbsent: at:ifPresentAndInMemory: at:put: do: environment includes: includesKey: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keys keysAndValuesDo: keysDo: objectForDataStream: poolUsers removeKey: removeKey:ifAbsent: scopeFor:from:envtAndPathIfFound: select: storeDataOn: valuesDo: veryDeepCopyWith:)('private' errorKeyNotFound: remove:from:readdAfter:)('*ShoutCore' hasBindingThatBeginsWith:)('updating' addAllBindings binding:addedTo: binding:removedFrom: notifyObserversOfBindingAdded: notifyObserversOfBindingRemoved:)('observing' addObserver: removeObserver: stopObserving:)('declaring' declarations isUndeclared: purgeUndeclared undeclare: undeclare:from:)('JavaScript generation' JSdoStoreOn:visiting:indent:)('evaluating')('*Tools-Browsing')('*PackageInfo-Base')('*Monticello-Loading')!!ClassDescription reorganize!('initialize-release' forgetDoIts obsolete superclass:methodDictionary:format: updateInstances:from:isMeta: updateInstancesFrom: updateMethodBindingsTo:)('accessing' classVersion version)('accessing class hierarchy' classesThatImplementAllOf: commentInventory printSubclassesOn:level: removeUninstantiatedSubclassesSilently subclasses subclassesDo:)('accessing comment' classCommentBlank comment comment: comment:stamp: hasComment)('accessing method dictionary' addAndClassifySelector:withMethod:inProtocol:notifying: addSelector:withMethod:notifying: addSelectorSilently:withMethod: allMethodCategoriesIntegratedThrough: allMethodsInCategory: induceMDFault isUniClass methodsInCategory: noteAddedSelector:meta: recoverFromMDFault recoverFromMDFaultWithTrace removeCategory: removeSelector:)('accessing parallel hierarchy' classSide instanceSide isClassSide isInstanceSide theMetaClass theNonMetaClass)('compiling' acceptsLoggingOfCompilation compile:classified: compile:classified:notifying: compile:classified:withStamp:notifying: compile:classified:withStamp:notifying:logSource: compile:environment:classified:withStamp:notifying: compile:environment:classified:withStamp:notifying:logSource: compile:notifying: compileSilently: compileSilently:classified: compileSilently:classified:notifying: doneCompiling instVarNamesAndOffsetsDo: moveInstVarNamed:to:after: noteCompilationOf:meta: reformatAll reformatMethodAt: wantsChangeSetLogging wantsRecompilationProgressReported)('copying' copy:from: copy:from:classified: copyAll:from: copyAll:from:classified: copyAllCategoriesFrom: copyAllCategoriesUnobtrusivelyFrom: copyAllUnobtrusively:from:classified: copyCategory:from: copyCategory:from:classified: copyCategoryUnobtrusively:from: copyMethodDictionaryFrom: copyUnobtrusively:from:classified: copyUnobtrusivelyCategory:from:classified:)('fileIn/Out' classComment: classComment:stamp: commentFollows commentStamp: commentStamp:prior: definition fileOutCategory: fileOutCategory:asHtml: fileOutCategory:on:moveSource:toFile: fileOutChangedMessages:on: fileOutChangedMessages:on:moveSource:toFile: fileOutChangedMessagesHistorically:on:moveSource:toFile: fileOutInitializerOn: fileOutMethod: fileOutMethod:asHtml: fileOutOn: fileOutOn:moveSource:toFile: fileOutOn:moveSource:toFile:initializing: fileOutOrganizationOn: methods methodsFor: methodsFor:priorSource:inFile: methodsFor:stamp: methodsFor:stamp:prior: moveChangesTo: moveClassCommentTo:fileIndex: printCategoryChunk:on: printCategoryChunk:on:priorMethod: printCategoryChunk:on:withStamp:priorMethod: printCategoryChunk:withStamp:on: printMethodChunk:withPreamble:on:moveSource:toFile: printMethodChunkHistorically:on:moveSource:toFile: putClassCommentToCondensedChangesFile:)('instance variables' addInstVarName: allInstVarNamesEverywhere checkForInstVarsOK: chooseInstVarAlphabeticallyThenDo: chooseVarThenDo: classThatDefinesClassVariable: classThatDefinesInstanceVariable: forceNewFrom: instVarIndexFor:ifAbsent: instVarNameForIndex: instVarNames removeInstVarName: renameInstVar:to: renameSilentlyInstVar:to: replaceSilently:to:)('organization' notifyOfRecategorizedSelector:from:to: organization organization: reorganize whichCategoryIncludesSelector: zapOrganization)('printing' classVariablesString instanceVariablesString printOn: printWithClosureAnalysisOn: sharedPoolsString storeOn:)('private' errorCategoryName instVarMappingFrom: linesOfCode logMethodSource:forMethodWithNode:inCategory:withStamp:notifying: newInstanceFrom:variable:size:map: setInstVarNames:)('*system-support' allUnreferencedClassVariables)('*Etoys-accessing method dictionary' namedTileScriptSelectors)('filein/out' moveChangesWithVersionsTo:)('*System' methodReferencesInCategory:)('*Protocols-Tools' chooseClassVarName)('JavaScript generation' >>| JSdoStoreOn:visiting:indent: JSprintOn: JSstoreOn: printJSClassOrganizerOn: printJSMethodDictionary:on:)('*Traits-NanoKernel' allTraits assembleTraitMethodsFrom: basicRemoveSelector: classify:under:from:trait: hasTraitComposition includesLocalSelector: includesTrait: installTraitMethodDict: installTraitsFrom: isAliasSelector: isLocalAliasSelector: isLocalMethod: localSelectors recompile:from: replaceSelector:withAlias:in: resolveTraitsConflict:from:to: setTraitComposition: setTraitCompositionFrom: traitAddSelector:withMethod: traitComposition traitComposition: traitCompositionString traitRemoveSelector: traits updateTraits updateTraitsFrom: users uses:)('testing')('*Etoys-Squeakland-compiling')('*monticello')('*Etoys-Squeakland-accessing')('*refactoring-squeak-platform')('*System-Tools')('*refactoring-core-fixes')('*VMMaker-accessing')!!Character reorganize!('accessing' asciiValue charCode codePoint digitValue leadingChar)('comparing' < = > hash sameAs:)('converting' asCharacter asInteger asLowercase asString asSymbol asText asUnicode asUppercase basicSqueakToIso isoToSqueak macToSqueak squeakToIso squeakToMac to:)('copying' clone copy deepCopy shallowCopy veryDeepCopyWith:)('object fileIn' comeFullyUpOnReload: objectForDataStream:)('printing' hex printAsLiteralOn: printOn: storeBinaryOn: storeOn:)('testing' canBeGlobalVarInitial canBeIdentifierInitial canBeNonGlobalVarInitial isAlphaNumeric isAscii isCharacter isDigit isLetter isLiteral isLowercase isOctetCharacter isSafeForHTTP isSeparator isSpecial isTraditionalDomestic isUppercase isVowel shouldBePrintedAsLiteral shouldBePrintedAsLiteralVisiting: tokenish)('*packageinfo-base' escapeEntities)('JavaScript generation' JSprimitiveOn: JSprintOn: JSshouldBePrintedAsLiteral JSshouldBePrintedAsLiteralVisiting: JSstoreOn: JSstoreOn:visiting:indent:)('private' setValue:)('*Tools-Inspecting-label')('system primitives')!!Object reorganize!('accessing' addInstanceVarNamed:withValue: at: at:modify: at:put: basicAddInstanceVarNamed:withValue: basicAt: basicAt:put: basicSize bindWithTemp: enclosedSetElement ifNil:ifNotNilDo: ifNotNilDo: ifNotNilDo:ifNil: in: presenter readFromString: size yourself)('associating' ->)('binding' bindingOf:)('casing' caseOf: caseOf:otherwise:)('class membership' class inheritsFromAnyIn: isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass)('comparing' = closeTo: hash identityHashPrintString literalEqual: ~=)('converting' adaptToFloat:andCompare: adaptToFloat:andSend: adaptToFraction:andCompare: adaptToFraction:andSend: adaptToInteger:andCompare: adaptToInteger:andSend: adaptToScaledDecimal:andCompare: as: asOrderedCollection asSetElement asString asStringOrText complexContents mustBeBoolean mustBeBooleanIn: printDirectlyToDisplay withoutListWrapper)('copying' clone copy copyAddedStateFrom: copyFrom: copySameFrom: copyTwoLevel deepCopy initialDeepCopierSize postCopy shallowCopy veryDeepCopy veryDeepCopySibling veryDeepCopyUsing: veryDeepCopyWith: veryDeepFixupWith: veryDeepInner:)('debugging' haltIf: needsWork)('debugging-haltOnce' checkHaltCountExpired clearHaltOnce decrementAndCheckHaltCount decrementHaltCount doExpiredHaltCount doExpiredHaltCount: doExpiredInspectCount halt:onCount: haltOnCount: haltOnce haltOnce: haltOnceEnabled hasHaltCount inspectOnCount: inspectOnce inspectUntilCount: removeHaltCount setHaltCountTo: setHaltOnce toggleHaltOnce)('dependents access' addDependent: breakDependents canDiscardEdits dependents evaluate:wheneverChangeIn: hasUnacceptedEdits myDependents myDependents: release removeDependent:)('drag and drop' acceptDroppingMorph:event:inMorph: dragAnimationFor:transferMorph: dragPassengerFor:inMorph: dragTransferType dragTransferTypeForMorph: wantsDroppedMorph:event:inMorph:)('error handling' assert: assert:description: assert:descriptionBlock: backwardCompatibilityOnly: caseError deprecated: deprecated:block: doesNotUnderstand: dpsTrace: dpsTrace:levels: dpsTrace:levels:withContext: error error: halt halt: handles: notify: notify:at: primitiveFailed primitiveFailed: shouldBeImplemented shouldNotImplement subclassResponsibility traitConflict)('evaluating' value valueWithArguments:)('filter streaming' byteEncode: drawOnCanvas: elementSeparator encodePostscriptOn: flattenOnStream: fullDrawPostscriptOn: putOn: writeOnFilterStream:)('flagging' isThisEverCalled isThisEverCalled: logEntry logExecution logExit)('graph model' addModelYellowButtonMenuItemsTo:forMorph:hand: hasModelYellowButtonMenuItems)('macpal' codeStrippedOut: contentsChanged currentEvent currentHand currentWorld flash instanceVariableValues isUniversalTiles objectRepresented refusesToAcceptCode scriptPerformer slotInfo)('message handling' executeMethod: perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:with:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: perform:withEnoughArguments: with:executeMethod: with:with:executeMethod: with:with:with:executeMethod: with:with:with:with:executeMethod: withArgs:executeMethod:)('objects from disk' comeFullyUpOnReload: convertToCurrentVersion:refStream: fixUponLoad:seg: indexIfCompact objectForDataStream: readDataFrom:size: saveOnFile saveOnFileNamed: storeDataOn:)('printing' fullPrintString isLiteral longPrintOn: longPrintOn:limitedTo:indent: longPrintString longPrintStringLimitedTo: nominallyUnsent: printOn: printString printStringLimitedTo: printWithClosureAnalysisOn: reportableSize storeOn: storeString stringForReadout stringRepresentation)('scripting' adaptedToWorld: defaultFloatPrecisionFor: evaluateUnloggedForSelf: methodInterfacesForCategory:inVocabulary:limitClass: methodInterfacesForInstanceVariablesCategoryIn: methodInterfacesForScriptsCategoryIn: selfWrittenAsIll selfWrittenAsIm selfWrittenAsMe selfWrittenAsMy selfWrittenAsThis)('system primitives' asOop className creationStamp instVarAt: instVarAt:put: instVarNamed: instVarNamed:put: oopString primitiveChangeClassTo: rootStubInImageSegment: someObject)('testing' JSshouldBePrintedAsLiteral JSshouldBePrintedAsLiteralVisiting: beViewed belongsToUniClass costumes haltIfNil hasLiteralSuchThat: isArray isBehavior isBlock isCharacter isClosure isCollection isColor isColorForm isCompiledCode isCompiledMethod isComplex isContext isDictionary isFloat isForm isFraction isHeap isInteger isInterval isMessageSend isMethodContext isMethodProperties isMorph isMorphicEvent isMorphicModel isNumber isPlayer isPoint isPrimitiveCostume isPseudoContext isRectangle isScriptEditorMorph isSketchMorph isStream isString isSymbol isSystemWindow isText isTextView isTrait isTransparent isVariableBinding isWebBrowser isWindowForModel: knownName name nameForViewer renameInternal: renameTo: shouldBePrintedAsLiteral shouldBePrintedAsLiteralVisiting: showDiffs stepAt:in: stepIn: stepTime stepTimeIn: vocabularyDemanded wantsDiffFeedback wantsSteps wantsStepsIn:)('updating' changed changed: changed:with: handledListVerification noteSelectionIndex:for: okToChange okToClose update: update:with: updateListsAndCodeIn: windowIsClosing)('user interface' addModelItemsToWindowMenu: addModelMenuItemsTo:forMorph:hand: asExplorerString defaultBackgroundColor defaultLabelForInspector launchPartVia: launchPartVia:label: launchTileToRefer modelSleep modelWakeUp modelWakeUpIn: mouseUpBalk: notYetImplemented windowActiveOnFirstClick windowReqNewLabel:)('*monticello' isConflict)('*services-base' requestor)('*system-support' oopAge oopTimestamp systemNavigation)('*Tools-Explorer' explore exploreAndYourself exploreWithLabel:)('*tools-browser' browseHierarchy)('private' errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: species storeAt:inTempFrame:)('thumbnail' iconOrThumbnailOfSize:)('*Morphic-Explorer' hasContentsInExplorer)('futures' future future: futureDo:at:args: futureSend:at:args:)('*Etoys-viewer' assureUniClass browseOwnClassSubProtocol categoriesForViewer: categoriesForVocabulary:limitClass: chooseNewNameForReference defaultLimitClassForVocabulary: defaultNameStemForInstances elementTypeFor:vocabulary: externalName graphicForViewerTab hasUserDefinedSlots infoFor:inViewer: initialTypeForSlotNamed: isPlayerLike methodInterfacesInPresentationOrderFrom:forCategory: newScriptorAround: newTileMorphRepresentative offerViewerMenuFor:event: offerViewerMenuForEvt:morph: renameScript: tilePhrasesForCategory:inViewer: tilePhrasesForMethodInterfaces:inViewer: tilePhrasesForSelectorList:inViewer: tileToRefer uniqueInstanceVariableNameLike:excluding: uniqueNameForReference uniqueNameForReferenceFrom: uniqueNameForReferenceOrNil updateThresholdForGraphicInViewerTab usableMethodInterfacesIn:)('*Protocols' currentVocabulary haveFullProtocolBrowsed haveFullProtocolBrowsedShowingSelector:)('*Etoys-tiles' basicType)('*Tools-MessageSets' browseAllCallsOn: browseAllImplementorsOf:)('*Tools-multi-window support' canHaveUnacceptedEdits)('*morphic' asDraggableMorph asMorph asStringMorph asTextMorph isPluggableListMorph openAsMorph)('*MorphicExtras-Undo' capturedState commandHistory purgeAllCommands redoFromCapturedState: refineRedoTarget:selector:arguments:in: refineUndoTarget:selector:arguments:in: rememberCommand: rememberUndoableAction:named: undoFromCapturedState:)('*MorphicExtras-PartsBin' descriptionForPartsBin)('tracing' inboundPointers inboundPointersExcluding: outboundPointers outboundPointersDo:)('*Tools-Debugger' canonicalArgumentName chasePointers explorePointers shouldFollowOutboundPointers)('*System-Object Events-accessing' actionForEvent: actionForEvent:ifAbsent: actionMap actionSequenceForEvent: actionsDo: createActionMap hasActionForEvent: setActionSequence:forEvent: updateableActionMap)('*System-Change Notification-events' actionsWithReceiver:forEvent: renameActionsWithReceiver:forEvent:toEvent:)('*System-Change Notification-converting' asActionSequence asActionSequenceTrappingErrors)('*System-Tools-breakpoint' break)('*ToolBuilder-Kernel-error handling' confirm: confirm:orCancel:)('*EToys-user interface' eToyStreamedRepresentationNotifying:)('*ToolBuilder-Kernel-user interface' inform:)('*System-Support-user interface' initialExtent)('*System-Localization-locales' localeChanged localeChangedGently)('*System-Object Events-accessing-removing' releaseActionMap removeAction:forEvent: removeActionsForEvent: removeActionsSatisfying: removeActionsSatisfying:forEvent: removeActionsWithReceiver: removeActionsWithReceiver:forEvent:)('*System-Object Events-accessing-triggering' triggerEvent: triggerEvent:ifNotHandled: triggerEvent:with: triggerEvent:with:ifNotHandled: triggerEvent:withArguments: triggerEvent:withArguments:ifNotHandled:)('*System-Object Events-accessing-registering' when:evaluate: when:send:to: when:send:to:with: when:send:to:withArguments:)('*Tools-inspecting' basicInspect inspect inspectWithLabel: inspectorClass jsInspect)('*Graphics-KernelExtensions' fullScreenSize)('*System-Finalization' actAsExecutor executor finalizationRegistry finalize hasMultipleExecutors retryWithGC:until: toFinalizeSend:to:with:)('*collections' compareSafely:)('*Tools-Browsing' browse)('*System-Recovery-error handling' primitiveError:)('*Tools-error handling' notifyWithLabel:)('JavaScript generation' JSdoStoreOn:visiting:indent: JSprimitiveOn: JSprintOn: JSprintOn:indent: JSstoreOn: JSstoreOn:visiting:indent: JSstoreWithIdOn:visiting:indent: checkFor53Changes:)('*universes' isUPackage isUPackageCategory)('*VMMaker-translation support')('*Traits' explicitRequirement requirement)('literals')('*FFI-Kernel')('write barrier')('*VMMaker-message handling')('*VMMakerUI-testing')('*Etoys-Squeakland-comparing')('*printf')('*Etoys-Squeakland-translation support')('*Etoys-Squeakland-testing')('*System-Preferences')('*VMMaker-testing')('*VMMaker-abbreviations')('*Monticello-Patching-testing')('pinning')('*Etoys-Squeakland-Tweak-Kedama')('*Etoys-Squeakland-Etoys-viewer')('*Morphic-Events-Filtering')('*SUnit-testing')('*Etoys-Squeakland-translating')('*Etoys-Squeakland-user interface')('*Etoys-Squeakland-error handling')('*Etoys-Squeakland-accessing')('*Tools')('*JSON')!