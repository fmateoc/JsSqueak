'From Squeak4.5 of 10 April 2015 [latest update: #13712] on 28 June 2023 at 7:39:38 pm'!BasicInspector subclass: #JsInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!JsInspector commentStamp: 'fm 12/18/2021 18:28' prior: 0!I show the internal representation of a JavaScript object, which may or may not also be the representation of a mapped Squeak object!!Object methodsFor: '*Tools-inspecting' stamp: 'fm 12/16/2021 19:58'!jsInspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	JsInspector openOn:  self! !!CodeHolder methodsFor: 'annotation' stamp: 'fm 5/4/2023 23:56'!annotation	"self >>| #annotation"	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."	|  aSelector aClass compiledMethod message |	((aSelector := self selectedMessageName) == nil or: [(aClass := self selectedClassOrMetaClass) == nil]) ifTrue: [^ ''].	compiledMethod := aClass compiledMethodAt: aSelector ifAbsent: [^ ''].	message := 'OVERRIDEN IN JAVASCRIPT' , (self showingJavaScript ifTrue: [''] ifFalse: [' - switch the code pane view to "JavaScript" to see the actual source']).	"<JS>if (_compiledMethod.orig) return _message;</JS>"	^ self annotationForSelector: aSelector ofClass: aClass! !!CodeHolder methodsFor: 'contents' stamp: 'fm 11/28/2021 22:58'!contents	"Answer the source code or documentation for the selected method"	self showingByteCodes ifTrue:		[^ self selectedBytecodes].	self showingJavaScript ifTrue:		[^ self selectedJavaScript].	self showingDocumentation ifTrue:		[^ self commentContents].	^ self selectedMessage! !!CodeHolder methodsFor: 'message list' stamp: 'fm 3/25/2022 23:14'!selectedJavaScript	"Answer text to show in a code pane when in showing-JavaScript mode"	| compiledMethod |	compiledMethod := self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName ifAbsent: [^ '' asText]. "<JS>_compiledMethod = SmalltalkGlobals._ByteString.from(_compiledMethod.func.toString());</JS>"	^ compiledMethod isString ifTrue: [compiledMethod asText] ifFalse: [(self selectedClassOrMetaClass >>| self selectedMessageName) asText]! !!CodeHolder methodsFor: 'what to show' stamp: 'fm 1/12/2023 21:16'!showJavaScript: aBoolean	"Set the JavaScript toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#JavaScript]).	super changed: #annotation! !!CodeHolder methodsFor: 'what to show' stamp: 'fm 12/16/2021 00:18'!showingJavaScript	"Answer whether the receiver should show JavaScript rather than, say, source code"	^ contentsSymbol == #JavaScript! !!CodeHolder methodsFor: 'what to show' stamp: 'fm 11/28/2021 22:12'!showingJavaScriptString	"Answer a string characerizing whether JavaScript is showing"	^ (self showingJavaScript		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'JavaScript'! !!CodeHolder methodsFor: 'what to show' stamp: 'fm 11/28/2021 22:13'!toggleJavaScript	"Toggle the setting of the showingJavaScript flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing := self showingJavaScript.		self restoreTextualCodingPane.		self showJavaScript: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!Browser methodsFor: 'annotation' stamp: 'fm 5/4/2023 23:55'!annotation	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."	|  aSelector aClass compiledMethod message |	(aClass := self selectedClassOrMetaClass) == nil ifTrue: [^ ''].	self editSelection == #editComment ifTrue:		[^ self annotationForSelector: #Comment ofClass: aClass].	self editSelection == #editClass ifTrue:		[^ self annotationForSelector: #Definition ofClass: aClass].	(aSelector := self selectedMessageName) ifNil: [^ ''].	compiledMethod := aClass compiledMethodAt: aSelector ifAbsent: [^ ''].	message := 'OVERRIDEN IN JAVASCRIPT' , (self showingJavaScript ifTrue: [''] ifFalse: [' - switch the code pane view to "JavaScript" to see the actual source']).	"<JS>if (_compiledMethod.orig) return _message;</JS>"	^ self annotationForSelector: aSelector ofClass: aClass! !!Inspector methodsFor: 'menu commands' stamp: 'fm 12/29/2021 11:09'!fieldListMenu: aMenu	"<JS>yield* _aMenu._addList_( SmalltalkGlobals._Array.from([SmalltalkGlobals._Array.from([SmalltalkGlobals._ByteString.from('inspect underlying JS representation'), SmalltalkGlobals._ByteSymbol.from('jsInspectSelection')])]));</JS>"	aMenu addStayUpItemSpecial.	aMenu addList: #(		('inspect (i)'						inspectSelection)		('explore (I)'						exploreSelection)).	self addCollectionItemsTo: aMenu.	aMenu addList: #(		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		('chase pointers'					chasePointers)		('explore pointers'				explorePointers)		-		('browse full (b)'					browseMethodFull)		('browse class'						browseClass)		('browse hierarchy (h)'					classHierarchy)		('browse protocol (p)'				browseFullProtocol)		-		('references... (r)'					browseVariableReferences)		('assignments... (a)'					browseVariableAssignments)		('class refs (N)'						browseClassRefs)		-		('copy name (c)'					copyName)				('basic inspect'						inspectBasic)).	Smalltalk isMorphic ifTrue:		[aMenu addList: #(			-			('tile for this value	(t)'			tearOffTile)			('viewer for this value (v)'		viewerForValue))].	^ aMenu"			-			('alias for this value'			aliasForValue)			('watcher for this slot'			watcherForSlot)"! !!Inspector methodsFor: 'menu commands' stamp: 'fm 12/29/2021 13:01'!jsInspectSelection	"Create and schedule an Inspector on the receiver's model's currently selected object."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	JsInspector openOn: self selection.	^ self selection! !!JsInspector methodsFor: 'accessing' stamp: 'fm 4/23/2023 19:41'!buildFieldListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fieldList; 		getIndex: #selectionIndex; 		setIndex: #toggleIndex:; 		menu: #fieldListMenu:.	^listSpec! !!JsInspector methodsFor: 'accessing' stamp: 'fm 11/10/2022 23:54'!fieldList	"<JS>if (true) {		const object = this.pointers[2];		let propertyNames = object !!= null ? Object.getOwnPropertyNames(object) : [];		if (propertyNames.length > 0 && propertyNames[propertyNames.length - 1] == 'length' && object.length > 1000)			propertyNames = ['length'].concat(propertyNames.slice(0, 1000));		return SmalltalkGlobals._Array.from([			SmalltalkGlobals._ByteString.from('this'), 			SmalltalkGlobals._ByteString.from('own properties'), 			...propertyNames.map(e => SmalltalkGlobals._ByteString.from(e))]);		}</JS>"	^#()! !!JsInspector methodsFor: 'accessing' stamp: 'fm 4/23/2023 20:05'!fieldListMenu: aMenu	"<JS>yield* _aMenu._addList_( SmalltalkGlobals._Array.from([SmalltalkGlobals._Array.from([SmalltalkGlobals._ByteString.from('inspect underlying JS representation'), SmalltalkGlobals._ByteSymbol.from('jsInspectSelection')])]));</JS>"	aMenu addList: #(		('inspect (i)'						inspectSelection)).	^ aMenu! !!JsInspector methodsFor: 'accessing' stamp: 'fm 4/25/2023 00:21'!inspectSelection	"Create and schedule an Inspector on the receiver's model's currently selected object."	| selection |	(self selectionIndex = 0 or: [self selectionIndex = 2]) ifTrue: [^ self changed: #flash].	selection := self selection.	"<JS>if (_selection !!= null && typeof _selection._class === 'function' && _selection._class() instanceof SmalltalkGlobals._ClassDescription) {		if (_selection.constructor instanceof SmalltalkGlobals._ClassDescription)			yield* _selection._inspect();		else switch (_selection.constructor.name) {			case 'Function':				if (_selection.receiver || _selection.pointers)					yield* _selection._inspect();				else					yield* SmalltalkGlobals._ByteString.from('Not a Smalltalk object')._inspect();				break;			case 'BigInt':			case 'Boolean':			case 'Number':				yield* _selection._inspect();				break;			case 'String':				let l = 0;				for (const c of _selection) {					l++;					if (l > 1) break;				}							if (l === 1)					yield* _selection._inspect();				else					yield* SmalltalkGlobals._ByteString.from('Not a Smalltalk object')._inspect();				break;			default:				yield* SmalltalkGlobals._ByteString.from('Not a Smalltalk object')._inspect();		}	} else		yield* SmalltalkGlobals._ByteString.from('Not a Smalltalk object')._inspect();</JS>"	^selection! !!JsInspector methodsFor: 'accessing' stamp: 'fm 4/23/2023 23:09'!selection	| temp |		temp := selectionIndex.	"<JS>if (true) {		const object = this.pointers[2], selectionIndex = _temp.valueOf();		let propertyNames = selectionIndex > 1 && object !!= null ? Object.getOwnPropertyNames(object) : [];		if (propertyNames.length > 0 && propertyNames[propertyNames.length - 1] == 'length' && object.length > 1000) {			propertyNames = ['length'].concat(propertyNames.slice(0, 1000));			selectionIndex++;		}		switch (selectionIndex) {			case 0: return SmalltalkGlobals._ByteString.Empty;			case 1: return object;			case 2: return object == null ? SmalltalkGlobals._ByteString.Empty : SmalltalkGlobals._ByteString.from(propertyNames.map(e => e + ': ' + object[e]).join(', '));			default: return object[propertyNames[selectionIndex - 3]]}}</JS>"	^''! !!JsInspector methodsFor: 'accessing' stamp: 'fm 4/23/2023 22:34'!selectionPrintString	| text temp |	text := ''.	temp := 0.	"<JS>const t = Date.now();	let selection = yield* this._selection();	if (selection == null)		selection = selection === null ? 'null' : 'undefined';	_text = SmalltalkGlobals._ByteString.from(selection.toString());	_temp = Math.round((Date.now - t) / 1000);	</JS>"	selectionUpdateTime := temp.	^ text ! !!JsInspector methodsFor: 'selecting' stamp: 'fm 6/17/2023 15:12'!accept: aString 	| rcvr result keyIndex |	rcvr := self doItReceiver.	result := nil.	"<JS>try {			const GeneratorFunction = _accept_.constructor;			_result = yield* (new GeneratorFunction(aString.valueOf())).call(_rcvr);		} catch(e) {			if (e !!== 'TERMINATE')				yield* SmalltalkVM.debug();			throw e;		}</JS>"	selectionIndex <= 2 ifTrue: [		selectionIndex ~= 1			ifTrue: [contents := self selection]			ifFalse: [contents := self selectionPrintString].		self changed: #selection.		self changed: #contents.		self changed: #selectionIndex.		^ object].	keyIndex := selectionIndex - 3.	"<JS>const object = this.pointers[2];		let propertyNames = object !!= null ? Object.getOwnPropertyNames(object) : [];		if (propertyNames.length > 0 && propertyNames[propertyNames.length - 1] == 'length' && object.length > 1000)			propertyNames = ['length'].concat(propertyNames.slice(0, 1000));		object[propertyNames[_keyIndex]] = _result;</JS>"	self changed: #contents.	^ true! !!JsInspector methodsFor: '*morphic' stamp: 'fm 4/23/2023 19:14'!representsSameBrowseeAs: anotherInspector	"<JS>if (true) {		return this.pointers[2] === (yield* _anotherInspector._object());		}</JS>"	^false! !!ParagraphEditor methodsFor: 'do-its' stamp: 'fm 10/28/2022 23:39'!jsDebugIt	self jsEvaluateSelectionAndDo: [:result | ] debugging: true! !!ParagraphEditor methodsFor: 'do-its' stamp: 'fm 12/16/2021 16:56'!jsDoIt	self jsEvaluateSelectionAndDo: [:result | ] debugging: false! !!ParagraphEditor methodsFor: 'do-its' stamp: 'fm 6/17/2023 15:13'!jsEvaluateSelectionAndDo: aBlock debugging: aBoolean	"Treat the current selection as an expression; evaluate it and invoke aBlock with the result."	| result rcvr contents |	self lineSelectAndEmptyCheck: [^ nil].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver]		ifFalse: [rcvr := nil].	contents := paragraph string		copyFrom: self startIndex		to: self stopIndex - 1.	aBoolean ifTrue: [		contents := 'yield* SmalltalkVM.debug();', contents].	result := nil.	"<JS>try {			const GeneratorFunction = _jsEvaluateSelectionAndDo_debugging_.constructor;			_result = yield* (new GeneratorFunction(_contents.valueOf())).call(_rcvr);		} catch(e) {			if (e !!== 'TERMINATE')				yield* SmalltalkVM.debug();			throw e;		}</JS>"	^aBlock value: result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'fm 12/16/2021 16:56'!jsInspectIt	self jsEvaluateSelectionAndDo: [:result | JsInspector openOn: result] debugging: false! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'fm 10/10/2022 16:44'!yellowButtonExpertMenu	^ SelectionMenu fromArray: StringHolder jsMenuItems, StringHolder yellowButtonMenuItems.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'fm 12/16/2021 16:57'!jsDebugIt		textMorph editor jsEvaluateSelectionAndDo: [:result | ] debugging: true! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'fm 12/16/2021 16:57'!jsDoIt		textMorph editor jsEvaluateSelectionAndDo: [:result | ] debugging: false! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'fm 12/16/2021 16:55'!jsInspectIt		textMorph editor jsEvaluateSelectionAndDo: [:result | JsInspector openOn: result] debugging: false! !!StandardToolSet class methodsFor: 'menu' stamp: 'fm 5/6/2023 00:39'!fileInFromLocalFS	| source announce |	source := announce := ''.	"<JS>const a = [];	Squeak.readFromLocalFS(a);	while (a[0] === undefined) {yield 'relinquishing Processor for 5'}	if (a[0] === null)		return this;	_announce = SmalltalkGlobals._ByteString.from('Filing in ' + a[1]);	_source = SmalltalkGlobals._ByteString.from(a[0]);</JS>"	source readStream fileInAnnouncing: announce! !!StringHolder class methodsFor: 'yellow button menu' stamp: 'fm 5/5/2023 19:48'!jsMenuItems	"Returns the additional yellow button menu items - only when running in JavaScript"	"<JS>if (true)		return SmalltalkGlobals._Array.from([SmalltalkGlobals._Array.from([yield* SmalltalkGlobals._ByteString.from('Js do it')._translatedFor_(_jsMenuItems.compiledMethod), SmalltalkGlobals._ByteSymbol.from('jsDoIt')]), SmalltalkGlobals._Array.from([yield* SmalltalkGlobals._ByteString.from('Js debug it')._translatedFor_(_jsMenuItems.compiledMethod), SmalltalkGlobals._ByteSymbol.from('jsDebugIt')]), SmalltalkGlobals._Array.from([yield* SmalltalkGlobals._ByteString.from('Js inspect it - no completion semantics (explicit return keyword(s) needed)')._translatedFor_(_jsMenuItems.compiledMethod), SmalltalkGlobals._ByteSymbol.from('jsInspectIt')]), SmalltalkGlobals._ByteSymbol.from('-')]);</JS>"	"the above is the JavaScript translation for:	true ifTrue: [		^{			{'Js do it - evaluate JavaScript snippet' translated.					#jsDoIt}.			{'Js debug it - debug JavaScript snippet' translated.					#jsDebugIt}.			{'Js inspect it - inspect JavaScript snippet (explicit return keyword(s) needed)' translated.					#jsInspectIt}.			#-.		}]"	^ #()! !!StringHolder class methodsFor: '*Tools-yellow button menu' stamp: 'fm 10/10/2022 16:44'!codePaneMenu: aMenu shifted: shifted	"Utility method for the 'standard' codePane menu"	aMenu addList: (shifted 		ifTrue:[self shiftedYellowButtonMenuItems]		ifFalse:[self jsMenuItems, self yellowButtonMenuItems]).	^aMenu! !!CodeHolder class methodsFor: 'controls' stamp: 'fm 11/28/2021 22:09'!defaultContentsSymbolQuints	"Default list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ {		{#source			. #togglePlainSource 			. #showingPlainSourceString 			. 'source'			. 'the textual source code as written' translated} .		{#documentation			. #toggleShowDocumentation			. #showingDocumentationString			. 'documentation'			. 'the first comment in the method' translated} .		#- .		{#prettyPrint			. #togglePrettyPrint			. #prettyPrintString			. 'prettyPrint'			. 'the method source presented in a standard text format' translated} .		#- .		{#showDiffs			. #toggleRegularDiffing			. #showingRegularDiffsString			. 'showDiffs'			. 'the textual source diffed from its prior version' translated} .		#- .		{#decompile			. #toggleDecompile			. #showingDecompileString			. 'decompile'			. 'source code decompiled from byteCodes' translated} .		{#byteCodes			. #toggleShowingByteCodes			. #showingByteCodesString			. 'byteCodes'				. 'the bytecodes that comprise the compiled method' translated} .		#- .		{#JavaScript			. #toggleJavaScript			. #showingJavaScriptString			. 'JavaScript'			. 'JavaScript source code of the method' translated} .	}! !!CodeHolder class methodsFor: 'controls' stamp: 'fm 11/28/2021 22:57'!defaultEditContentsOptions	"An array of associations of current display mode symbol to selector	that creates the edit contents for that display mode. The default selector	is #selectedMessage; this is a list of alternative to the default."	^ {		#byteCodes -> #selectedBytecodes .		#JavaScript -> #selectedJavaScript 	}! !!JsInspector class methodsFor: 'instance creation' stamp: 'fm 6/18/2023 12:14'!openOn: anObject withEvalPane: withEval 	"Create and schedule an instance of me on the model, anInspector. "	| title |	title := 'The JsInspector is not (really) available when running in Smalltalk'.	"<JS>let constrName;	if (_anObject === null) constrName = 'null';	else if (_anObject === undefined) constrName = 'undefined';	else if (typeof _anObject === 'object') constrName = _anObject.constructor.name;	else constrName = 'a primitive ' + (typeof _anObject);	if (constrName.startsWith('_')) constrName = 'SmalltalkGlobals.' + constrName; 	if (_anObject !!= null && typeof _anObject === 'object') constrName = 'an instance of ' + constrName;	_title = SmalltalkGlobals._ByteString.from(constrName);</JS>"	^ self openOn: anObject withEvalPane: withEval withLabel: title! !!TestCase methodsFor: 'accessing' stamp: 'fm 11/26/2021 09:45'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first * 20].	^self defaultTimeout * 20! !!TestCase methodsFor: 'accessing' stamp: 'fm 11/26/2021 09:45'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first * 20].	^(timeout ifNil: [self defaultTimeout]) * 20! !!TestResult methodsFor: 'printing' stamp: 'fm 6/28/2023 19:39'!inspectResultsStringElapsed: elapsed initialMemory: initialMemory afterMemory: afterMemory	| runCount failedOrErrored failedExpected failedShouldPass passedUnxpected passedShouldPass resultString |      failedOrErrored := Set new.      failures do: [:t |          failedOrErrored add: t].      errors do: [:t |          failedOrErrored add: t].      failedExpected := OrderedCollection new.      failedShouldPass := OrderedCollection new.      failedOrErrored do: [:t | | p |          t shouldPass ifTrue: [              failedShouldPass add: (p := t printString), '  -  ', (failureCauses at: p) asArray          ] ifFalse: [              failedExpected add: t printString		]].      passedUnxpected := OrderedCollection new.      passedShouldPass := OrderedCollection new.      passed do: [:t |          t shouldPass ifTrue: [              passedShouldPass add: t printString          ] ifFalse: [              passedUnxpected add: t printString		]].	runCount := failedExpected size + failedShouldPass size + passedShouldPass size + passedUnxpected size.	resultString := String new: 10000 streamContents: [:s |		s	cr; 			nextPutAll: 'Ran ';			nextPutAll: runCount printString;			nextPutAll: ' tests in ';			nextPutAll: elapsed printString;			nextPutAll: 's - ';			nextPutAll: passedShouldPass size printString;			nextPutAll: ' passed, ';			nextPutAll: failedExpected size printString;			nextPutAll: ' failed but expected, ';			nextPutAll: passedUnxpected size printString;			nextPutAll: ' passed unexpectedly, ';			nextPutAll: failedShouldPass size printString;			nextPutAll: ' failed or errored out';			cr;			nextPutAll: 'Memory (used/allocated), in MB: before ';			nextPutAll: initialMemory;			nextPutAll: ', after ';			nextPutAll: afterMemory;			cr.		passedUnxpected isEmpty ifFalse: [			s	cr; 				nextPutAll: 'passed unexpectedly:';				cr.			passedUnxpected sort do: [:t |				s cr; 				nextPutAll: t].			s cr		].		failedShouldPass isEmpty ifFalse: [			s	cr; 				nextPutAll: 'failed or errored out:'; 				cr.			failedShouldPass sort do: [:t | 				s	cr; 					nextPutAll: t]		]	].	"<JS>	const jsResult = _resultString.valueOf();	yield* SmalltalkGlobals._JsInspector._openOn_(jsResult);	</JS>"	^resultString! !!TestRunner methodsFor: 'accessing-classes' stamp: 'ct 5/31/2019 13:30'!filterClassesBy: aPattern	classesSelected := ((classPattern := aPattern) subStrings: ';')							inject: Set new							into: [:matches :subPattern|								matches									addAll: (classes select: [ :each | subPattern match: each name]);									yourself].	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'actions' stamp: 'fm 6/18/2023 12:31'!runAll	| totalHeap usedHeap initialMilliseconds elapsed initialMemory afterMemory |	"make sure author initials are set before running, so we don't interrupt the tests"	Utilities authorInitials.	totalHeap := 0.	usedHeap := 0.	"<JS>gc(); _totalHeap = performance.memory.totalJSHeapSize; _usedHeap = performance.memory.usedJSHeapSize;</JS>"	initialMemory := (usedHeap // 1048576) printString, '/', (totalHeap // 1048576) printString.	initialMilliseconds := Time millisecondClockValue.	"<JS>try {</JS>"		self reset; runSuite: self suiteAll.	"<JS>} catch (e) {		if (!!e.isNonLocalReturn && e !!== 'TERMINATE')			yield* SmalltalkVM.debug();		throw e;	}</JS>"	self saveResultInHistory.	elapsed := Time millisecondClockValue - initialMilliseconds // 1000.	"<JS>gc(); _totalHeap = performance.memory.totalJSHeapSize; _usedHeap = performance.memory.usedJSHeapSize;</JS>"	afterMemory := (usedHeap // 1048576) printString, '/', (totalHeap // 1048576) printString.	result inspectResultsStringElapsed: elapsed initialMemory: initialMemory afterMemory: afterMemory.	"<JS>	for (const g in SmalltalkGlobals) {		const c = SmalltalkGlobals[g];		const all = AllInstances.get(c);		if (c.name === g && all && all.length > 100) {			let count = 0;			for (const i of all)				if (i.deref() !!== undefined ) count++;			console.log(g + ' - ' + count + ' out of ' + all.length)		}	}	</JS>"	^self! !!TestRunner class methodsFor: 'instance-creation' stamp: 'fm 10/11/2022 23:48'!open	| exclusionList |		exclusionList := ''.	"<JS>		const exclusionList = SmalltalkGlobals.TestExclusions === undefined ? '' :							SmalltalkGlobals.TestExclusions.trim().split(/[\n\r\s]+/).join(';');		_exclusionList = SmalltalkGlobals._ByteString.from(exclusionList);	</JS>"	^ ToolBuilder open: (self new filterClassesBy: exclusionList; selectInverseClasses).! !!TextEditor methodsFor: 'do-its' stamp: 'fm 6/17/2023 15:15'!jsEvaluateSelectionAndDo: aBlock debugging: aBoolean	"Treat the current selection as an expression; evaluate it and invoke aBlock with the result."	| result rcvr contents |	self lineSelectAndEmptyCheck: [^ nil].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver]		ifFalse: [rcvr := nil].	contents := paragraph string		copyFrom: self startIndex		to: self stopIndex - 1.	aBoolean ifTrue: [		contents := 'yield* SmalltalkVM.debug();', contents].	result := nil.	"<JS>try {			const GeneratorFunction = _jsEvaluateSelectionAndDo_debugging_.constructor;			_result = yield* (new GeneratorFunction(_contents.valueOf())).call(_rcvr);		} catch(e) {			if (e !!== 'TERMINATE')				yield* SmalltalkVM.debug();			throw e;		}</JS>"	^aBlock value: result! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'fm 10/10/2022 16:44'!initializeShiftedYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	shiftedYellowButtonMenu := MenuMorph fromArray: StringHolder jsMenuItems, StringHolder yellowButtonMenuItems.! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'fm 10/10/2022 16:43'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	yellowButtonMenu := MenuMorph fromArray: StringHolder jsMenuItems, StringHolder yellowButtonMenuItems! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'fm 5/4/2023 22:49'!toolsMenuOn: aDockingBar 	aDockingBar addItem: [ :item |		item			contents: 'Tools' translated;			addSubMenu: [ :menu | 				self					browserMenuItemOn: menu;					workspaceMenuItemOn: menu;					transcriptMenuItemOn: menu;					testRunnerMenuItemOn: menu;					methodFinderMenuItemOn: menu.				menu addLine.				self 					monticelloBrowserMenuItemOn: menu;					monticelloConfigurationsMenuItemOn: menu;					simpleChangeSorterMenuItemOn: menu;					dualChangeSorterMenuItemOn: menu.				menu addLine.				self					processBrowserMenuItemOn: menu;					preferenceBrowserMenuItemOn: menu;					fileListMenuItemOn: menu.				menu addLine.				self					fileInFromLocalMenuItemOn: menu.			] ]! !!TheWorldMainDockingBar methodsFor: 'submenu - tools' stamp: 'fm 5/4/2023 22:48'!fileInFromLocalMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'File in from local FS' translated;			help: 'Select a file from the local FS and file it in' translated;			icon: (self colorIcon: (Color r: 0.224 g: 1 b: 0.78));			target: StandardToolSet;			selector: #fileInFromLocalFS ]! !"Postscript:Add some JavaScript translation tooling"CodeHolder initialize.SmalltalkEditor initialize!