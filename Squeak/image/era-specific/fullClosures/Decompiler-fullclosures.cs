'From Squeak6.1alpha of 22 June 2023 [latest update: #22667] on 3 July 2023 at 11:50:46 pm'!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts conversionDict '	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag '	poolDictionaries: ''	category: 'Compiler-Kernel'!Object subclass: #TestResult	instanceVariableNames: 'timeStamp failures errors passed durations failureCauses '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!CompiledBlock methodsFor: 'comparing' stamp: 'fm 6/15/2023 15:01'!hasSameLiteralsAs: aMethod	"Answer whether the receiver has the same sequence of literals as the argument.	 Do not fully compare the last literal as this is the outerCode back pointer to the	 containing method or block, and following it would cause infinite recursion.  In any	 case this is a useful definition because it considers identical block methods in other-	 wise different containing blocks or methods to be the same, which makes sense."	| numLits fakeLiterals aMethodLits selfLits aMethodActualLits aMethodLast selfActualLits selfLast |	fakeLiterals := MessageNode classPool at: #MacroSelectors.	selfLits := self literals.	selfActualLits := selfLits reject: [:lit | fakeLiterals includes: lit].	aMethodLits := aMethod literals.	aMethodActualLits := aMethodLits reject: [:lit | fakeLiterals includes: lit].	numLits := selfActualLits size.	numLits = aMethodActualLits size ifFalse: [^false].	selfLast := selfLits last.	aMethodLast := aMethodLits last.	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := selfActualLits at: i.		lit2 := aMethodActualLits at: i.		(lit1 == lit2 or: [			lit1 isCompiledCode ifTrue: [				lit1 == selfLast ifTrue: [					lit2 == aMethodLast and: [aMethodLast isCompiledCode]				] ifFalse: [					lit2 ~~ aMethodLast and: [lit1 sameWithoutTrailerAs: lit2]				]			] ifFalse: [				lit1 literalEqual: lit2			]]) ifFalse: [^false]].	^true! !!CompiledBlock methodsFor: 'comparing' stamp: 'fm 5/6/2023 22:45'!sameWithoutTrailerAs: aMethod	| offset |	self == aMethod ifTrue:		[^true].	(aMethod isCompiledCode	 and: [(self header bitOr: 16r7FFF) = (aMethod header bitOr: 16r7FFF)]) ifFalse:"excludes numLiterals comparison."		[^false].	offset := aMethod initialPC - self initialPC.	self initialPC to: self endPC do:		[:i | (self at: i) = (aMethod at: i + offset) ifFalse: [^false]].	^self hasSameLiteralsAs: aMethod! !!CompiledMethod methodsFor: 'comparing' stamp: 'fm 6/15/2023 15:00'!hasSameLiteralsExceptPropertiesAs: aMethod	"Answer whether the receiver has the same sequence of literals as the argument.	 Compare the last literal, which is the class association, specially so as not to	 differentiate between otherwise identical methods installed in different classes.	 Compare the first literal carefully if it is the binding informaiton for an FFI or	 external primitive call.  Don't compare all of the state so that linked and unlinked	 methods are still considered equal."	| numLits fakeLiterals aMethodLits selfLits aMethodActualLits aMethodLast aMethodProps selfActualLits selfLast selfProps |	fakeLiterals := MessageNode classPool at: #MacroSelectors.	selfLits := self literals.	selfActualLits := selfLits reject: [:lit | fakeLiterals includes: lit].	aMethodLits := aMethod literals.	aMethodActualLits := aMethodLits reject: [:lit | fakeLiterals includes: lit].	numLits := selfActualLits size.	numLits = aMethodActualLits size ifFalse: [^false].	selfProps := selfLits at: selfLits size - 1.	selfLast := selfLits last.	aMethodProps := aMethodLits at: aMethodLits size - 1.	aMethodLast := aMethodLits last.	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := selfActualLits at: i.		lit2 := aMethodActualLits at: i.		(lit1 == lit2 or: [lit1 isCompiledCode ifTrue: [lit1 sameWithoutTrailerAs: lit2] ifFalse: [lit1 literalEqual: lit2]]) ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue:					[lit1 isArray						ifTrue:							[(lit2 isArray and: [(lit1 first: 2) = (lit2 first: 2)]) ifFalse:								[^false]]						ifFalse: "ExternalLibraryFunction"							[(lit1 analogousCodeTo: lit2) ifFalse:								[^false]]]				ifFalse:					[((lit1== selfProps and: [lit2 == aMethodProps])	"ignore properties"						or: "last literal (methodClassAssociation) of class-side methods is not unique"							[lit1== selfLast and: [lit2 == aMethodLast							 and: [lit1 isVariableBinding and: [lit1 value isBehavior							 and: [lit2 isVariableBinding and: [lit2 value isBehavior]]]]]]) ifFalse:								[^false]]]].	^true! !!CompiledMethod methodsFor: 'comparing' stamp: 'fm 5/28/2023 00:57'!sameWithoutTrailerAs: aMethod	| offset |	self == aMethod ifTrue:		[^true].	(aMethod isCompiledMethod	 and: [(self header bitOr: 16r7FFF) = (aMethod header bitOr: 16r7FFF)]) ifFalse:"excludes numLiterals comparison."		[^false].	offset := aMethod initialPC - self initialPC.	self initialPC to: self endPC do:		[:i | (self at: i) = (aMethod at: i + offset) ifFalse: [^false]].	^self hasSameLiteralsExceptPropertiesAs: aMethod! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'fm 6/16/2023 15:49'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments tempReadCounts: tempReadCounts		| node temp |	receiver ifNil: [ ^nil ].		"For instance, when cascading"	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].					(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	"Like #to:(by:)do:, support only local temps."	((receiver receiver isAssignmentNode not or: [tempReadCounts includesKey: (temp := receiver receiver variable)]) or: [		"What about 'object ifNotNil: [:o | ]', which as not read the blockArg? Just check that there is no remote vector pointing to it."		tempReadCounts keys noneSatisfy:			[:otherTemp |				otherTemp isIndirectTempVector					ifTrue: [otherTemp remoteTemps anySatisfy:						[:remoteTemp |						remoteTemp name = temp name]]					ifFalse: [otherTemp name = temp name]]			])		ifFalse: [^ nil].	temp notNil ifTrue: [		(temp isTemp and: [temp isRemote not])			ifFalse: [^ nil].		(receiver receiver value isParentOf: temp) 			ifTrue: [^ nil].		(arguments first isParentOf: temp) 			ifTrue: [^ nil].		arguments second nodesDo: [:e | 			(e isAssignmentNode and: [e variable key = temp key]) ifTrue: 				[^nil]]	].			arguments do: [:arg| arg noteOptimizedIn: self].	((temp notNil or: [receiver receiver isVariableNode]) and: [arguments second isJust: (temp ifNil: [receiver receiver])]) ifTrue: [		^MessageNode new			receiver: receiver receiver ifNilValue			selector: (self codeSelector: #ifNil: code: #macro)			arguments: (Array with: arguments first)			precedence: 3	].	node := (MessageNode new			receiver: receiver			selector: (self codeSelector: #ifNil:ifNotNil: code: #macro)			arguments: arguments			precedence: 3).	temp ifNil: [^ node].	temp scope: -1.	tempReadCounts removeKey: temp ifAbsent: [].	temp beBlockArg.	node arguments: {		arguments first.		arguments second copy arguments: { temp }; yourself }.					^ node! !!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'fm 1/9/2023 23:54'!interpretSistaV1Jump	"If the instruction at pc is an unconditional jump, interpret it, advancing the pc,	 and answering the jump distance. Otherwise answer nil."	"	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)	 *	225/16rE1	11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)	 *	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"	| method byte nextpc extB |	method := self method.	"consume and compute any extension first."	extB := 0.	nextpc := pc. "must not advance pc unless this is a jump."	[byte := self method at: nextpc.	 nextpc := nextpc + 1.	 byte = 16rE1] whileTrue:		[| extByte |		 extByte := self method at: nextpc.		 nextpc := nextpc + 1.		 extB := (extB = 0 and: [extByte > 127])					ifTrue: [extByte - 256]					ifFalse: [(extB bitShift: 8) + extByte]].	(byte between: 176 and: 183) ifTrue:		[pc := nextpc.		 ^byte - 175].	byte = 237 ifTrue:		[byte := method at: nextpc.		 pc := nextpc + 1.		 ^(extB bitShift: 8) + byte].	^nil! !!Decompiler methodsFor: 'control' stamp: 'fm 7/3/2023 12:56'!doClosureCopy: aCompiledBlock copiedValues: blockCopiedValues	"implementation note: must be invoked on a copy because it modifies states"	| savedPC blockArgs blockTemps blockTempsOffset block |	numLocalTemps := aCompiledBlock numTemps - aCompiledBlock numArgs - blockCopiedValues size.	blockTempsOffset := aCompiledBlock numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: aCompiledBlock])		ifTrue:			[tempVars := blockStartsToTempVars at: aCompiledBlock]		ifFalse:			[blockArgs := (1 to: aCompiledBlock numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + aCompiledBlock numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	tempVarCount := tempVarCount + aCompiledBlock numArgs + numLocalTemps.	savedPC := pc.	self method: (method := aCompiledBlock) pc: aCompiledBlock initialPC.	block := self blockTo: aCompiledBlock endPC + 1.	stack isEmpty ifFalse: [self error: 'block did alter the stack'].	^(constructor			codeArguments: (tempVars copyFrom: 1 to: aCompiledBlock numArgs)			temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)			block: block)				pc: aCompiledBlock -> savedPC; "c.f. BytecodeEncoder>>pc"				yourself! !!Decompiler methodsFor: 'control' stamp: 'fm 7/3/2023 23:27'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc jump blockArgs blockTemps blockTempsOffset block |	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter							tempCountForBlockStartingAt: pc							in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack isEmpty ifFalse: [self error: 'block did alter the stack'].	^(constructor			codeArguments: (tempVars copyFrom: 1 to: numArgs)			temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)			block: block)				pc: startpc;				yourself! !!Decompiler methodsFor: 'initialize-release' stamp: 'fm 6/6/2023 00:16'!initSymbols: aClass	constructor method: method class: aClass literals: method literals.	constTable := constructor codeConstants.	instVars := Array new: aClass instSize.	tempVarCount := method numTemps.	"(tempVars isNil	 and: [method holdsTempNames]) ifTrue:		[tempVars := method tempNamesString]."	tempVars isString		ifTrue:			[blockStartsToTempVars := self mapFromBlockKeysIn: method											toTempVarsFrom: tempVars											constructor: constructor.			 tempVars := blockStartsToTempVars at: method initialPC]		ifFalse:			[| namedTemps |			namedTemps := tempVars ifNil: [(1 to: tempVarCount) collect: [:i| 't', i printString]].			tempVars := (1 to: tempVarCount) collect:							[:i | i <= namedTemps size								ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]								ifFalse: [constructor codeTemp: i - 1]]].	1 to: method numArgs do:		[:i|		(tempVars at: i) beMethodArg].	tempReadCounts := Dictionary new.	conversionDict := IdentityDictionary new.! !!Decompiler methodsFor: 'instruction decoding' stamp: 'fm 6/9/2023 18:02'!jump: dist if: condition	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock	  thenJump elseJump condHasValue isIfNil saveStack |	lastJumpIfPcStack addLast: lastPc.	stack last == CaseFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].	elsePc := lastPc.	elseStart := pc + dist.	end := limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign := condition.	savePc := pc.	self interpretJump ifNotNil:		[:elseDist|		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:			 [sign := sign not.  elseStart := pc + elseDist]].	pc := savePc.	ifExpr := stack removeLast.	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:		[stack removeLast].	saveStack := stack.	stack := OrderedCollection new.	thenBlock := self blockTo: elseStart.	condHasValue := hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			[| blockBody blockArgs savedReadCounts blockBodyReadCounts selector |			 "Must be a while loop...			  thenJump will jump to the beginning of the while expr.  In the case of while's			  with a block in the condition, the while expr should include more than just			  the last expression: find all the statements needed by searching for the node			  with the relevant pc."			stack := saveStack.			savedReadCounts := tempReadCounts copy.			pc := thenJump.			blockBody := self statementsTo: elsePc.			blockBodyReadCounts := tempReadCounts.			savedReadCounts keysAndValuesDo:				[:temp :count|				 blockBodyReadCounts at: temp put: (blockBodyReadCounts at: temp) - count].			tempReadCounts := savedReadCounts.			"discard unwanted statements from block"			blockBody size - 1 timesRepeat: [statements removeLast].			blockArgs := thenBlock statements = constructor codeEmptyBlock statements							ifTrue: [#()]							ifFalse: [{ thenBlock }].			selector := blockArgs isEmpty							ifTrue: [sign ifTrue: [#whileFalse] ifFalse: [#whileTrue]]							ifFalse: [sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]].			statements addLast:				(constructor					codeMessage: (constructor codeBlock: blockBody returns: false)					selector: (constructor codeSelector: selector code: #macro)					arguments: blockArgs).			pc := elseStart.			selector == #whileTrue: ifTrue:				[self convertToDoLoop: blockBodyReadCounts]]		ifFalse:			["Must be a conditional..."			elseBlock := self blockTo: thenJump.			elseJump := exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc ifTrue:				[pc := lastPc].			cond := isIfNil						ifTrue:							[constructor								codeMessage: ifExpr ifNilReceiver								selector: (constructor											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])											code: #macro)								arguments: (Array with: thenBlock)]						ifFalse:							[(sign								ifTrue: [{elseBlock. thenBlock}]								ifFalse: [{thenBlock. elseBlock}]) in:									[:args |									(constructor										decodeIfNilWithReceiver: ifExpr										selector: #ifTrue:ifFalse:										arguments: args										tempReadCounts: tempReadCounts) 											ifNil: [constructor													codeMessage: ifExpr													selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)													arguments:	 args]											ifNotNil: [:node |												node arguments last arguments ifNotEmpty: [:arguments | arguments first scope < 0 ifTrue: [													conversionDict at: node 																	put: (Array with: (constructor																						codeMessage: ifExpr																						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)																						arguments:	 args))]].												node]]].			stack := saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]].	lastJumpIfPcStack removeLast.! !!Decompiler methodsFor: 'instruction decoding' stamp: 'fm 7/3/2023 13:56'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	stack addLast: (self shallowCopy initializeCopy doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize).	pc := pc + blockSize! !!Decompiler methodsFor: 'instruction decoding' stamp: 'fm 1/11/2023 22:49'!pushFullClosure: aCompiledBlock numCopied: numCopied  	| copiedValues |  	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed. 	stack addLast: (self shallowCopy initializeCopy doClosureCopy: aCompiledBlock copiedValues: copiedValues)! !!Decompiler methodsFor: 'instruction decoding' stamp: 'fm 5/6/2023 22:58'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	stack isEmpty ifTrue: ["unreachable code"		^self].	args := Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr := stack removeLast.	superFlag ifTrue: [rcvr := constructor codeSuper].	selNode := constructor codeAnySelector: selector.	rcvr == CaseFlag		ifTrue:			[| cases stmtStream elements node b |			selector == #= ifTrue:					[" = signals a case statement..."					statements addLast: args first.					stack addLast: rcvr. "restore CaseFlag"					^ self].			selector = #caseError ifFalse: [self error: 'unexpected message send while decompiling a caseOf:'].			stmtStream := ReadStream on: (self popTo: stack removeLast).						elements := OrderedCollection new.			b := OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node := stmtStream next) == CaseFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b := OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases := constructor codeBrace: elements.						stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf: code: #macro)					arguments: (Array with: cases)).			^self].	rcvr == CascadeFlag		ifTrue:			["May actually be a cascade or an ifNil: for value."			self willJumpIfFalse				ifTrue: "= generated by a case macro"					[selector == #= ifTrue:						[" = signals a case statement..."						statements addLast: args first.						stack removeLast; addLast: CaseFlag; addLast: CaseFlag.	"Properly mark the case statement"						^ self].					selector == #== ifTrue:						[" == signals an ifNil: for value..."						stack removeLast; removeLast.						rcvr := stack removeLast.						stack addLast: IfNilFlag;							addLast: (constructor								codeMessage: rcvr								selector: selNode								arguments: args).						^ self]]				ifFalse:					[(self willJumpIfTrue and: [selector == #==]) ifTrue:						[" == signals an ifNotNil: for value..."						stack removeLast; removeLast.						rcvr := stack removeLast.						stack addLast: IfNilFlag;							addLast: (constructor								codeMessage: rcvr								selector: selNode								arguments: args).						^ self]].			msgNode := constructor							codeCascadedMessage: selNode							arguments: args.			stack last == CascadeFlag ifFalse:				["Last message of a cascade"				statements addLast: msgNode.				messages := self popTo: stack removeLast.  "Depth saved by first dup"				msgNode := constructor								codeCascade: stack removeLast								messages: messages]]		ifFalse:			[msgNode := constructor						codeMessage: rcvr						selector: selNode						arguments: args].	stack addLast: msgNode! !!Decompiler methodsFor: 'public access' stamp: 'fm 7/3/2023 12:48'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			lastJumpIfPcStack := OrderedCollection new.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			self method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:				[pc := pc + (method encoderClass bytecodeSize: self firstByte).				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	self revertBadTransformationsIn: block.	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node preen! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/16/2023 13:00'!revertBadTransformationsIn: block.	conversionDict notEmpty ifTrue: [		block temporaries: (tempVars copyFrom: method numArgs + 1 to: tempVars size).	"this is just temporary"		block nodesDo: [:n | | invisibleTemps |			n isBlockNode ifTrue: [				invisibleTemps := OrderedCollection new.				n temporaries do: [:t | 										t isIndirectTempVector ifTrue: [						t remoteTemps do: [:a | 							(a scope < 0 and: [a isIndirectTempVector not]) ifTrue: [								invisibleTemps add: a]]					] ifFalse: [						t scope < 0 ifTrue: [							invisibleTemps add: t						]					]]. 				invisibleTemps do: [:t |	| key revertingCandidates refdOnlyByConvertedOrBlockArgs |						key := t key.						revertingCandidates := conversionDict keys select: [:m | 																	m arguments last arguments first key = key or: 																	[m macroPrinter == #printToDoOn:indent: and: [m originalArguments first key = key]]].					revertingCandidates isEmpty ifTrue: [						self halt.					] ifFalse: [						refdOnlyByConvertedOrBlockArgs := true.						n accept: (ParseNodeEnumerator									ofBlock: [:n1 | 										(n1 isTemp and: [n1 key = key]) ifTrue: [refdOnlyByConvertedOrBlockArgs := false]]									select: [:n1 | 										refdOnlyByConvertedOrBlockArgs and: 										[(revertingCandidates includes: n1) not and: 										[n1 isBlockNode not or: [n1 == n or: [n1 arguments , n1 temporaries noneSatisfy: [:a | a key = key]]]]]]).						refdOnlyByConvertedOrBlockArgs ifFalse: [							n nodesDo: [:n1 | | newStatements |								(n1 isBlockNode and: [n1 statements anySatisfy: [:a | revertingCandidates includes: a]]) ifTrue: [									newStatements := OrderedCollection new.									n1 statements do: [:a | 										(revertingCandidates includes: a) ifTrue: [											newStatements addAll: (conversionDict at: a)										] ifFalse: [											newStatements add: a										]									].									n1 statements: newStatements								] ifFalse: [									n1 isLeaf ifFalse: [										n1 getAllChildren do: [:child | | replaced |											(revertingCandidates includes: child) ifTrue: [												replaced := conversionDict at: child.												replaced size ~= 1 ifTrue: [													self halt].												n1 replaceNode: child with: replaced first											]										]									]								]							].							t beVisibleTemp						]]]]].		block temporaries: #().	"this will be overwritten with just the visible temps, see DecompilerConstructor>>codeMethod:block:tempVars:primitive:class:"	].! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/6/2023 00:16'!test1	"(Decompiler >> #test1) decompileWithTemps"	| i |		i := 1. 	[i <= 5] whileTrue: [self do: [:e | e at: i]. i := i + 1].	self do: [:e | e at: i].! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/6/2023 00:18'!test2	"(Decompiler >> #test2) decompileWithTemps"	| i |		i := 1. 	[i <= 5] whileTrue: [self do: [:e | e at: i]. i := i + 1].	i := 2.	[i <= 15] whileTrue: [self do: [:e | e at: i]. i := i + 1].	self do: [:e | e at: i].! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/6/2023 00:17'!test3	"(Decompiler >> #test3) decompileWithTemps"	| i |		i := 1. 	[i <= 5] whileTrue: [self do: [:e | e at: i]. i := i + 1].	[i <= 15] whileTrue: [self do: [:e | e at: i]. i := i + 1].! !!Decompiler methodsFor: 'public access' stamp: 'fm 6/6/2023 00:22'!test4	"(Decompiler >> #test4) decompileWithTemps"	| i |		self do: [:e |		i := 1. 		[i <= 5] whileTrue: [e at: i. i := i + 1]].	self do: [:e | e at: i].! !!Decompiler methodsFor: 'private' stamp: 'fm 6/9/2023 01:21'!convertToDoLoop: blockBodyTempCounts	"If statements contains the pattern		var := startExpr.		[var <= limit] whileTrue: [...statements... var := var + incConst]	or		var := startExpr.		limit := limitExpr.		[var <= limit] whileTrue: [...statements... var := var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]	 and answer true."	| whileStmt incrStmt initStmt limitStmt toDoStmt var replaced |	whileStmt := statements last.	incrStmt := whileStmt arguments first statements last.	incrStmt isAssignmentNode ifFalse:		[^false].	((var := incrStmt variable) isTemp and: [var isRemote not]) ifFalse: 		[^false]. 	(self startAndLimitFor: var from: stack into:							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr])		ifTrue:			[| limitInStatements limitName |			 limitInStatements := limitStmt isNil								    and: [statements size > 1								    and: [self startAndLimitFor: var from: { stack last. (statements last: 2) first } into:												[:startExpr :limitExpr| limitStmt := limitExpr]]].			"The init statement is mandatory, the limit one is not, so if something is not right with the limit,				we do not need to drop the conversion, we just exclude the limit from it"			(limitStmt notNil and: [limitStmt variable isTemp not]) ifTrue: 				[limitStmt := nil].			limitName := limitStmt notNil ifTrue: [				(tempReadCounts at: limitStmt variable) > (blockBodyTempCounts at: limitStmt variable) ifTrue: [					limitStmt := nil				] ifFalse: [					limitStmt variable name]].			(toDoStmt := whileStmt toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:				[^false].			replaced := OrderedCollection new.			(limitInStatements and: [limitStmt notNil])				ifTrue:					[replaced add: stack last; addAll: (statements last: 2).					 stack removeLast.					 statements removeLast: 2]				ifFalse:					[(limitInStatements or: [limitStmt isNil]) 						ifTrue:							[replaced add: initStmt.							 stack remove: initStmt ifAbsent: [].							 statements remove: initStmt ifAbsent: []]						ifFalse: 							[replaced add: (stack last: 2).							 stack removeLast: 2].					 replaced add: statements last.					 statements removeLast].			stack addLast: toDoStmt		] ifFalse: [(self startAndLimitFor: var from: statements allButLast into:							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr]) ifFalse:				[^false].			 (toDoStmt := whileStmt toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:				[^false].			 replaced := OrderedCollection withAll: (statements last: (limitStmt ifNil: [2] ifNotNil: [3])).			 statements				removeLast: (limitStmt ifNil: [2] ifNotNil: [3]);				addLast: toDoStmt].	conversionDict at: toDoStmt put: replaced.	self markTemp: var asOutOfScope: -1. "Flag arg as out of scope"	var beBlockArg.	limitStmt ifNotNil:		[self markTemp: limitStmt variable asOutOfScope: -2.		 toDoStmt arguments at: 1 put: limitStmt value]. "Flag limit as hidden"	^true! !!Decompiler methodsFor: 'private' stamp: 'fm 7/3/2023 23:49'!startAndLimitFor: incrVar from: aStack into: binaryBlock	"If incrVar matches the increment of a whileLoop at the end of statements	 evaluate binaryBlock with the init statement for incrVar and the init statement	 for the block's limit, if any, and answer true.  Otherwise answer false.  Used to	 help convert whileTrue: loops into to:[by:]do: loops."	| guard initExpr limitInit size |	((size := aStack size) >= 1	 and: [(initExpr := aStack at: size) ~~ CaseFlag]	 and: [initExpr isAssignmentNode]) ifFalse:		[^false].	initExpr variable == incrVar ifTrue:		[binaryBlock value: initExpr value: nil.		 ^true].	limitInit := initExpr.	(size >= 2	 and: [(initExpr := aStack at: size - 1) isAssignmentNode	 and: [initExpr variable == incrVar	 and: [(guard := statements last receiver) isBlockNode	 and: [guard statements size = 1	 and: [(guard := guard statements first) isMessageNode	 and: [guard receiver == incrVar	 and: [guard arguments size = 1	 and: [guard arguments first == limitInit variable	 and: [limitInit variable isTemp]]]]]]]]]) ifTrue:		[binaryBlock value: initExpr value: limitInit.		 ^true].	^false! !!MessageNode methodsFor: 'decompiling' stamp: 'fm 6/7/2023 01:05'!toDoFromWhileWithCounts: blockBodyTempCounts init: incrInit limit: limitInitOrNil	"If the receiver, a whileTrue: loop, represents a to:[by:]do: loop	 then answer the replacement to:[by:]do:, otherwise answer nil."	| variable incrStmt increment limit toDoBlock body test toDoMsg |	self assert: (selector key == #whileTrue:				and: [incrInit isAssignmentNode]).	(limitInitOrNil notNil "limit should not be referenced within the loop"	  and: [(blockBodyTempCounts at: limitInitOrNil variable ifAbsent: [0]) ~= 1]) ifTrue:		[^nil].	(variable := incrInit variable) isTemp ifFalse:		[^nil].	body := arguments last.	incrStmt := body statements last.	(increment := incrStmt toDoIncrement: variable) ifNil:		[^nil].	receiver statements size ~= 1 ifTrue:		[^nil].	(test := receiver statements first) isMessageNode ifFalse: 		[^nil].	limit := (test receiver = variable and: 			[(test selector key = #<= and: [increment key > 0]) or: [test selector key = #>= and: [increment key < 0]]])				ifTrue: [ test arguments first ]				ifFalse: [					(((test selector key = #>= and: [increment key > 0]) or: [test selector key = #<= and: [increment key < 0]]) and: 					[test arguments first = variable])						ifTrue: [ test receiver ]						ifFalse: [^nil]].		"The block must not overwrite the limit"	(limit isVariableNode and: [limit isArg not])		ifTrue: 			[body nodesDo: [:e | 				(e isAssignmentNode and: [e variable key = limit key]) ifTrue: 					[^nil]]]		ifFalse:			[(limit isArg not and: [limit isConstantNumber not]) ifTrue:				[^nil]].	"The block must not overwrite the variable (outside the last statement)"	body nodesDo: [:e | 		(e isAssignmentNode and: [e ~~ incrStmt and: [e variable key = variable key]]) ifTrue: 			[^nil]].	toDoBlock := BlockNode statements: body statements allButLast returns: false.	toDoBlock arguments: {variable}.	toDoBlock temporaries: body temporaries.	toDoMsg := MessageNode new		receiver: incrInit value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence.	toDoBlock noteOptimizedIn: toDoMsg.	^toDoMsg! !!TestResult methodsFor: 'running' stamp: 'fm 5/6/2023 19:54'!runCase: aTestCase	| testCasePassed |	testCasePassed := true.	[[[aTestCase runCase]		on: self class failure		do: [:signal | 			| o |			o := failureCauses at: aTestCase printString ifAbsentPut: [failures add: aTestCase. OrderedCollection new].			o add: signal printString.			testCasePassed := false.			signal return: false]]		on: BreakPoint		do: [:signal | "skip when running, active when debugging"			signal resume]]		on: self class exError		do: [:signal | 			| o |			o := failureCauses at: aTestCase printString ifAbsentPut: [errors add: aTestCase. OrderedCollection new].			o add: signal printString.			testCasePassed := false.			signal return: false].	testCasePassed		ifTrue: [passed add: aTestCase].! !!TestResult methodsFor: 'initialization' stamp: 'fm 12/29/2022 22:55'!initialize	super initialize.	passed := OrderedCollection new.	failures := Set new.	errors := OrderedCollection new.	timeStamp := TimeStamp now.	durations := Dictionary new.	failureCauses := Dictionary new! !Object subclass: #TestResult	instanceVariableNames: 'timeStamp failures errors passed durations failureCauses'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts conversionDict'	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'	poolDictionaries: ''	category: 'Compiler-Kernel'!