/* * Copyright (c) 2022  Florin Mateoc * * This file is part of JsSqueak. * * JsSqueak is free software: you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JsSqueak is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with JsSqueak.  If not, see <https://www.gnu.org/licenses/>. */Object.override(SmalltalkGlobals._LargePositiveInteger.prototype, {	primitive_105_impl(arg1, arg2, arg3, arg4) {		const arg1Val = arg1.valueOf(), arg2Val = arg2.valueOf(), arg4Val = arg4.valueOf(), bytes = this.bytes, arg3proto = arg3._class().prototype;		if (arg1Val > 0 && arg2Val >= arg1Val && arg4Val > 0 && (arg1Val | 0) === arg1Val && (arg2Val | 0) === arg2Val && bytes && arg2Val <= bytes.length			&& arg3proto.storageType === 'bytes' && (arg4Val | 0) === arg4Val) {			const start = arg1Val - 1, replacementStart = arg4Val - 1, replacementEnd = replacementStart + arg2Val - start;			let arg3bytes, replacement;			if (typeof arg3 === "bigint") {				let asString = (arg3 >= 0 ? arg3 : -arg3).toString(16);				const length = (asString.length + 1) >>> 1;				if (arg4Val + arg2Val - arg1Val > length)					return [false];				const doubleLength = length << 1;				asString = asString.padStart(doubleLength, "0");				replacement = new Uint8Array(replacementEnd - replacementStart);				for (let i = replacementEnd - 1, j = 0; i >= replacementStart; i--) {					const j = doubleLength - (i << 1);					replacement[i - replacementStart] = parseInt(asString.slice(j - 2, j), 16);				}			} else {				arg3bytes = arg3.bytes;				if (arg3bytes === undefined || replacementEnd > arg3bytes.length)					return [false];				replacement = arg3bytes.slice(replacementStart, replacementEnd);			}			bytes.set(replacement, start);			this.dirty = true;			return [true, this]}		else return [false]	},	*_abs() {		const val = this.valueOf();		//Number.isSafeInteger() does not work for bigInt arguments		return val < 9007199254740992n ? Number(val) : val	},	*_anyBitOfMagnitudeFrom_to_(_start, _stopArg) {		/*Tests for any magnitude bits in the interval from start to stopArg.*/		if (_start < 1 || _stopArg < 1)			return yield* this._error_(SmalltalkGlobals._Integer.prototype._anyBitOfMagnitudeFrom_to_.compiledMethod.literals[3] /* 'out of range' */);		if (_start > _stopArg)			return false;		const asString = (this.valueOf() >= 0 ? this.bigint : -this.bigint).toString(32);		const length = asString.length;		const quoStop = _stopArg / 5 | 0;		const remStop = _stopArg % 5;		const quoStart = (_start + 4) / 5 | 0;		const remStart = (_start + 4) % 5;		if (remStop > 0 && (remStart === 0 || quoStop - 1 !== quoStart)) {			const partialChar = Number.parseInt(asString[length - quoStop - 1], 32);			switch (remStop) {				case 4: if((partialChar & 15) !== 0) return true;					break;				case 3: if((partialChar & 7) !== 0) return true;					break;				case 2: if((partialChar & 3) !== 0) return true;					break;				case 1: if((partialChar & 1) !== 0) return true;			}		}		if (remStart > 0 && (remStop === 0 || quoStop - 1 !== quoStart)) {			const partialChar = Number.parseInt(asString[length - quoStart], 32);			switch (remStart) {				case 4: if((partialChar & 16) !== 0) return true;					break;				case 3: if((partialChar & 24) !== 0) return true;					break;				case 2: if((partialChar & 28) !== 0) return true;					break;				case 1: if((partialChar & 30) !== 0) return true;			}		}		if (remStart > 0 && remStop > 0 && quoStop - 1 === quoStart) {			const partialChar = Number.parseInt(asString[length - quoStart], 32);			switch (remStart * remStop) {				case 12: if((partialChar & 8) !== 0) return true;					break;				case 8: if((partialChar & 12) !== 0) return true;					break;				case 6: if((partialChar & 4) !== 0) return true;					break;				case 4: if((partialChar & 14) !== 0) return true;					break;				case 3: if((partialChar & 6) !== 0) return true;					break;				case 2: if((partialChar & 2) !== 0) return true;			}		}		const firstFullCharIndex = length - quoStop;		const lastFullCharIndexExclusive = length - quoStart;		if (lastFullCharIndexExclusive > firstFullCharIndex) {			const re = /[1-9A-V]/gi;			re.lastIndex = firstFullCharIndex;			const anyUpToEnd = re.test(asString);			return anyUpToEnd && re.lastIndex <= lastFullCharIndexExclusive;		}		return false;	},	*_asFloat() {		return new Float(Number(this.valueOf()))	},	*_bitAnd_(_n) {		if (typeof _n === 'bigint') {			const resultN = this.valueOf() & _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this.valueOf() & BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitAnd:`));	},	*_bitAt_(_anInteger) {		return Number(this.valueOf() >> BigInt(_anInteger - 1) & 1n);	},	*_bitCount() {		if (this.valueOf() < 0) {			yield* this._error_(SmalltalkGlobals._Integer.prototype._bitCount.compiledMethod.literals[2] /* 'Cannot count bits of negative i...etc... */);		}		return this.bigint.toString(2).replaceAll('0', '').length	},	*_bitInvert() {		return (-1n) - this.valueOf();	},	*_bitOr_(_n) {		if (typeof _n === 'bigint') {			const resultN = this.valueOf() | _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this.valueOf() | BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitOr:`));	},	*_bitShift_(_shiftCount) {		if (typeof _shiftCount === 'bigint') {			const resultN = this.valueOf() << _shiftCount;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _shiftCount.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this.valueOf() << BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitShift:`));	},	*_bitXor_(_n) {		if (typeof _n === 'bigint') {			const resultN = this.valueOf() ^ _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this.valueOf() ^ BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitXor:`));	},	*_eq(_aNumber) {		const primitiveValue = _aNumber.valueOf();		if (typeof primitiveValue === 'bigint')			return this.valueOf() === primitiveValue;		if (typeof primitiveValue === 'number')			return this.valueOf() == primitiveValue;		if (_aNumber instanceof SmalltalkGlobals._Number) {			return yield* _aNumber._adaptToInteger_andCompare_(this.valueOf(), SmalltalkGlobals._Integer.prototype._eq.compiledMethod.literals[5] /* #= */);		} else			return false;	},	*_even() {		return (this.valueOf() % 2n) === 0n	},	*_fullPrintString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>fullPrintString", false, false);		return SmalltalkGlobals._ByteString.from(this.valueOf().toString(10));	},	*_gcd_(_anInteger) {		const argVal = _anInteger.valueOf();		let _n = this.valueOf() < 0 ? -this.bigint : this.bigint,			_m = BigInt(argVal < 0 ? -argVal : argVal);		while (_n !== 0n) {			_n = _m - _m / _n * ( _m = _n);		}		return (_m < 9007199254740992n && _m > -9007199254740992n) ? Number(_m) : _m	},	*_hash() {		if (this.valueOf() < 9007199254740992n && this.bigint > -9007199254740992n)			return Number(this.bigint);		const asString = this.bigint.toString(32);		const stringSize = asString.length;		let hash = (yield * this._class()._hash()) & 268435455, low;		for (let pos = 0; pos < stringSize; pos++) {			hash += asString.charCodeAt(pos);			low = hash & 16383;			hash = ((9741 * low) + ((((9741 * (hash >>> 14)) + (101 * low)) & 16383) * 16384)) & 268435455;		}		return hash;	},	*_hashMultiply() {		return BigInt.asUintN(28, this.valueOf() * 1664525n);	},	*_highBitOfMagnitude() {		const asString = (this.valueOf() >= 0 ? this.bigint : -this.bigint).toString(32);		return (asString.length - 1) * 5 + (yield * (Number.parseInt(asString[0], 32)._highBitOfByte()));	},	*_identityHash() {		return BigInt.asIntN(53, this.valueOf())	},	*_isPowerOfTwo() {		if (this.valueOf() < 0)			return false;		return /^[1248Gg]0*$/.test(this.bigint.toString(32))	},	*_lowBit() {		if (this.valueOf() === 0n) {			return 0;		} else {			let _n = this.bigint, _result = 0, _lastByte;			while ((_lastByte = _n & 0xFFFFFFFFn) === 0n) {				_result += 32;				_n >>= 32n;			}			return _result + (yield * (Number(_lastByte)._lowBit()));		}	},	*_negated() {		const val = -this.valueOf();		//Number.isSafeInteger() does not work for bigInt arguments		return val > -9007199254740992n ? Number(val) : val	},	*_nextInstance() {		return nil	},	*_noMask_(_mask) {		/*Treat the argument as a bit mask. Answer whether none of the bits that        are 1 in the argument are 1 in the receiver.*/		if (typeof _mask === 'bigint') {			return (this.valueOf() & _mask) === 0n;		}		const argVal = _mask.valueOf();		if (Number.isSafeInteger(argVal)) {			return (this.valueOf() & BigInt(argVal)) === 0n;		}		return 0 == (yield* this.valueOf()._bitAnd_( _mask));	},	*_normalize() {		const val = this.valueOf();		//Number.isSafeInteger() does not work for bigInt arguments		return val < 9007199254740992n ? Number(val) : val	},	*_printOn_(_aStream) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printOn:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(this.valueOf().toString()));		return this;	},	*_printOn_base_(_aStream, _b) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printOn:base:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(_b > 10 ? this.valueOf().toString(_b).toUpperCase() :  this.valueOf().toString(_b)));		return this;	},	*_printString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printString", false, false);		return SmalltalkGlobals._ByteString.from(this.valueOf().toString());	},	*_printStringBase_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printStringBase:", false, false);		return SmalltalkGlobals._ByteString.from(_base > 10 ? this.valueOf().toString(_base).toUpperCase() :  this.valueOf().toString(_base));	},	*_printStringLimitedTo_(_limit) {		/*Answer a String whose characters are a description of the receiver.        If you want to print without a character limit, use fullPrintString.*/		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Object>>printStringLimitedTo:", false, false);		const powerOfTen = Math.trunc(Math.log10(32) * this.valueOf().toString(32).length);		if (this.bigint < 0)			_limit--;		if (_limit > powerOfTen)			return SmalltalkGlobals._ByteString.from(this.bigint.toString());		let native = this.bigint >= 0 ? "" : "-", n = this.bigint, digits = 0, divisor = 10n ** BigInt(powerOfTen);		while (digits++ < _limit && divisor > 0) {			const nextDigit = n / divisor;			n = n - nextDigit * divisor;			native += nextDigit;			divisor /= 10n		}		return SmalltalkGlobals._ByteString.from(native + '...etc...');	},	*_printStringRadix_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("SmallInteger>>printStringRadix:", false, false);		const absToStringBase = this.valueOf() < 0 ? (-this.bigint).toString(_base) : this.bigint.toString(_base);		return SmalltalkGlobals._ByteString.from((this.bigint < 0 ? '-' : '') + _base + 'r' + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase));	},	_raisedToInteger_: function *_raisedToInteger_(_anInteger) {		/*The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must		be handled as an indeterminate form.		I take the first context because that's the way that was previously handled.		Maybe further discussion is required on this topic.*/		const argVal = _anInteger.valueOf();		if (!Number.isSafeInteger(argVal))			yield* SmalltalkVM.debug();		if (argVal < 0) {			return yield* (yield* this.valueOf()._raisedToInteger_(-argVal))._reciprocal();		} else {			const resultN = this.valueOf() ** BigInt(argVal);			const result = Number(resultN);			return Number.isSafeInteger(result) && result == resultN ? result : resultN;		}	},	_scaledIdentityHash: function *_scaledIdentityHash() {		return BigInt.asIntN(53, this.valueOf())	},	*_sqrt() {		/*If we know for sure no exact solution exists, then just answer the cheap float approximation without wasting time.*/		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>sqrt", false, false);		let root;		const halfByteLen = this.valueOf().toString(16).length;		if (halfByteLen < 256) // small enough for direct double conversion?		{			let floatRoot = Math.sqrt(Number(this.bigint));			if (Number.isInteger(floatRoot)) {				root = BigInt(floatRoot);				if (root * root === this.bigint) {					if ((floatRoot | 0) === floatRoot || Number.isSafeInteger(floatRoot))						return floatRoot;					return root;				}			} else if (floatRoot < 9007199254740992n || floatRoot * floatRoot == this.bigint) {				return floatRoot;			} else				root = BigInt(Math.floor(floatRoot));		}		else // large: reduce with bitshifting, then convert to double (and back)		{			const reducedLen = BigInt(halfByteLen - 255);			root = BigInt(Math.sqrt(Number(this.bigint >> reducedLen * 4n))) << reducedLen * 2n;		}		for (; ; )		{			const root2 = this.bigint / root + root >> 1n;			if (root2 === root || root2 === root + 1n) {				const lowerBound = root * root;				if (this.bigint >= lowerBound && this.bigint <= lowerBound + (root << 1n)) {					if (lowerBound === this.bigint)						return root;					return Number(root2);				}			}			root = this.bigint / root2 + root2 >> 1n;			if (root === root2 || root === root2 + 1n) {				const lowerBound = root2 * root2;				if (this.bigint >= lowerBound && this.bigint <= lowerBound + (root2 << 1n)) {					if (lowerBound === this.bigint)						return root2;					return Number(root);				}			}		}	},	*_sqrtFloor() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Integer>>sqrtFloor", false, false);		let root;		const halfByteLen = this.valueOf().toString(16).length;		if (halfByteLen < 256) // small enough for direct double conversion?		{			root = Math.floor(Math.sqrt(Number(this.bigint)));			if ((root | 0) === root || Number.isSafeInteger(root))				return root;			return BigInt(root);		}		else // large: reduce with bitshifting, then convert to double (and back)		{			const reducedLen = BigInt(halfByteLen - 255);			root = BigInt(Math.sqrt(Number(this.bigint >> reducedLen * 4n))) << reducedLen * 2n;		}		for (; ; )		{			const root2 = this.bigint / root + root >> 1n;			if (root2 === root || root2 === root + 1n) {				const lowerBound = root * root;				if (this.bigint >= lowerBound && this.bigint <= lowerBound + (root << 1n))					return root;			}			root = this.bigint / root2 + root2 >> 1n;			if (root === root2 || root === root2 + 1n) {				const lowerBound = root2 * root2;				if (this.bigint >= lowerBound && this.bigint <= lowerBound + (root2 << 1n))					return root2;			}		}	},	_sqrtRem: function *_sqrtRem() {		/*See super*/		let _s = nil;		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("SmallInteger>>sqrtRem, checking interrupts:", false, false);		_s = yield* this._sqrtFloor();		return SmalltalkGlobals._Array.from([_s, yield* this.bigint._sub( yield* _s._mul( _s))]);	},	*_storeOn_(_aStream) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeOn:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(this.valueOf().toString()));		return this;	},	*_storeOn_base_(_aStream, _base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeOn:base:", false, false);		const absToStringBase = this.valueOf() < 0 ? (-this.bigint).toString(_base) : this.bigint.toString(_base);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from((this.bigint < 0 ? '-' : '') + (_base === 10 ? '' : _base + 'r') + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase)));		return this;	},	*_storeString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Object>>storeString", false, false);		return SmalltalkGlobals._ByteString.from(this.valueOf().toString());	},	*_storeStringBase_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeStringBase:", false, false);		const absToStringBase = this.valueOf() < 0 ? (-this.bigint).toString(_base) : this.bigint.toString(_base);		return SmalltalkGlobals._ByteString.from((this.bigint < 0 ? '-' : '') + (_base === 10 ? '' : _base + 'r') + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase));	},});Object.override(SmalltalkGlobals._LargePositiveInteger.constructor.prototype, {	_adoptInstance_: function *_adoptInstance_(_anObject) {		yield* SmalltalkGlobals._Behavior.prototype._adoptInstance_.call(this, _anObject);		_anObject.dirty = true;		return this;	}});