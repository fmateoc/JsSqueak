/* * Copyright (c) 2022  Florin Mateoc * * This file is part of JsSqueak. * * JsSqueak is free software: you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * JsSqueak is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with JsSqueak.  If not, see <https://www.gnu.org/licenses/>. */Object.override(BigInt.prototype, {	/*		const s = this.toString(16);		const t = (s.length + 1) >>> 1;		const bytes = new Uint8Array(t);		for (let i=s.length-1; i>=0; i-=2) {			const l = s.charCodeAt(i);			const h = i > 0 ? s.charCodeAt(i-1) : 48;			bytes[t - (i >>> 1) - 1] = (l > 57 ? l - 87 : l - 48) + (h > 57 ? h - 87 : h - 48) * 16;		}	 */	primitive_60_impl(arg) {		const argVal = arg.valueOf();		if (!Number.isSafeInteger(argVal) || argVal < 1)			return [false, undefined];		const asString = (this >= 0 ? this : -this).toString(16);		const index = asString.length + 1 - argVal * 2;		if (index < 0)			return [false, undefined];		let val = asString[index].charCodeAt(0);		val = val > 57 ? val - 87 : val - 48;		if (index > 0) {			const mshVal = asString[index - 1].charCodeAt(0);			val += (mshVal > 57 ? mshVal - 87 : mshVal - 48) * 16;		}		return [true, val]	},	primitive_62_impl() {return [true, ((this >= 0 ? this : -this).toString(16).length + 1) >> 1]},	primitive_73_impl(arg) {		const argVal = arg.valueOf();		if (!Number.isSafeInteger(argVal) || argVal < 1)			return [false, undefined];		const asString = (this >= 0 ? this : -this).toString(16);		const index = asString.length + 1 - argVal * 2;		if (index < 0)			return [false, undefined];		let val = asString[index].charCodeAt(0);		val = val > 57 ? val - 87 : val - 48;		if (index > 0) {			const mshVal = asString[index - 1].charCodeAt(0);			val += (mshVal > 57 ? mshVal - 87 : mshVal - 48) * 16;		}		return [true, val]	},	primitive_173_impl(arg) {		const argVal = arg.valueOf();		if (!Number.isSafeInteger(argVal) || argVal < 1)			return [false, undefined];		const asString = (this >= 0 ? this : -this).toString(16);		const index = asString.length + 1 - argVal * 2;		if (index < 0)			return [false, undefined];		let val = asString[index].charCodeAt(0);		val = val > 57 ? val - 87 : val - 48;		if (index > 0) {			const mshVal = asString[index - 1].charCodeAt(0);			val += (mshVal > 57 ? mshVal - 87 : mshVal - 48) * 16;		}		return [true, val]	},	*_abs() {		return this >= 0 ? this : -this	},	*_anyBitOfMagnitudeFrom_to_(_start, _stopArg) {		/*Tests for any magnitude bits in the interval from start to stopArg.*/		if (_start < 1 || _stopArg < 1)			return yield* this._error_(SmalltalkGlobals._Integer.prototype._anyBitOfMagnitudeFrom_to_.literals[3] /* 'out of range' */);		if (_start > _stopArg)			return false;		const asString = (this >= 0 ? this : -this).toString(32);		const length = asString.length;		const quoStop = _stopArg / 5 | 0;		const remStop = _stopArg % 5;		const quoStart = (_start + 4) / 5 | 0;		const remStart = (_start + 4) % 5;		if (remStop > 0 && (remStart === 0 || quoStop - 1 !== quoStart)) {			const partialChar = Number.parseInt(asString[length - quoStop - 1], 32);			switch (remStop) {				case 4: if((partialChar & 15) !== 0) return true;					break;				case 3: if((partialChar & 7) !== 0) return true;					break;				case 2: if((partialChar & 3) !== 0) return true;					break;				case 1: if((partialChar & 1) !== 0) return true;			}		}		if (remStart > 0 && (remStop === 0 || quoStop - 1 !== quoStart)) {			const partialChar = Number.parseInt(asString[length - quoStart], 32);			switch (remStart) {				case 4: if((partialChar & 16) !== 0) return true;					break;				case 3: if((partialChar & 24) !== 0) return true;					break;				case 2: if((partialChar & 28) !== 0) return true;					break;				case 1: if((partialChar & 30) !== 0) return true;			}		}		if (remStart > 0 && remStop > 0 && quoStop - 1 === quoStart) {			const partialChar = Number.parseInt(asString[length - quoStart], 32);			switch (remStart * remStop) {				case 12: if((partialChar & 8) !== 0) return true;					break;				case 8: if((partialChar & 12) !== 0) return true;					break;				case 6: if((partialChar & 4) !== 0) return true;					break;				case 4: if((partialChar & 14) !== 0) return true;					break;				case 3: if((partialChar & 6) !== 0) return true;					break;				case 2: if((partialChar & 2) !== 0) return true;			}		}		const firstFullCharIndex = length - quoStop;		const lastFullCharIndexExclusive = length - quoStart;		if (lastFullCharIndexExclusive > firstFullCharIndex) {			const re = /[1-9A-V]/gi;			re.lastIndex = firstFullCharIndex;			const anyUpToEnd = re.test(asString);			return anyUpToEnd && re.lastIndex <= lastFullCharIndexExclusive;		}		return false;	},	*_asFloat() {		return new Float(Number(this))	},	*_bitAnd_(_n) {		if (typeof _n === 'bigint') {			const resultN = this & _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this & BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitAnd:`));	},	*_bitAt_(_anInteger) {		return Number(this >> BigInt(_anInteger - 1) & 1n);	},	*_bitCount() {		if (this < 0) {			yield* this._error_(SmalltalkGlobals._Integer.prototype._bitCount.literals[2] /* 'Cannot count bits of negative i...etc... */);		}		return this.toString(2).replaceAll('0', '').length	},	*_bitInvert() {		return (-1n) - this;	},	*_bitOr_(_n) {		if (typeof _n === 'bigint') {			const resultN = this | _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this | BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitOr:`));	},	*_bitShift_(_shiftCount) {		if (typeof _shiftCount === 'bigint') {			const resultN = this << _shiftCount;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _shiftCount.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this << BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitShift:`));	},	*_bitXor_(_n) {		if (typeof _n === 'bigint') {			const resultN = this ^ _n;			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		const argVal = _n.valueOf();		if (Number.isSafeInteger(argVal)) {			const resultN = this ^ BigInt(argVal);			const result = Number(resultN);			return (result | 0) === result || Number.isSafeInteger(result) ? result : resultN;		}		yield* this._primitiveFailed_(SmalltalkGlobals._ByteSymbol.from(`bitXor:`));	},	*_clone() {		return this	},	*_deepCopy() {		return this	},	*_eq(_aNumber) {		const primitiveValue = _aNumber.valueOf();		if (typeof primitiveValue === 'bigint')			return this === primitiveValue;		if (typeof primitiveValue === 'number')			return this == primitiveValue;		if (_aNumber instanceof SmalltalkGlobals._Number) {			return yield* _aNumber._adaptToInteger_andCompare_(this, SmalltalkGlobals._Integer.prototype._eq.literals[5] /* #= */);		} else			return false;	},	*_even() {		return (this % 2n) === 0n	},	*_fullPrintString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>fullPrintString", false, false);		return SmalltalkGlobals._ByteString.from(this.toString(10));	},	*_gcd_(_anInteger) {		let _n = this < 0 ? -this : this,			_m = BigInt(_anInteger < 0 ? -_anInteger : _anInteger);		while (_n !== 0n) {			_n = _m - _m / _n * ( _m = _n);		}		return (_m < 9007199254740992n && _m > -9007199254740992n) ? Number(_m) : _m	},	*_hash() {		if (this < 9007199254740992n && this > -9007199254740992n)			return Number(this);		const asString = this.toString(32);		const stringSize = asString.length;		let hash = (yield * this._class()._hash()) & 268435455, low;		for (let pos = 0; pos < stringSize; pos++) {			hash += asString.charCodeAt(pos);			low = hash & 16383;			hash = ((9741 * low) + ((((9741 * (hash >>> 14)) + (101 * low)) & 16383) * 16384)) & 268435455;		}		return hash;	},	*_hashMultiply() {		return BigInt.asUintN(28, this * 1664525n);	},	*_highBitOfMagnitude() {		const asString = (this >= 0 ? this : -this).toString(32);		return (asString.length - 1) * 5 + (yield * (Number.parseInt(asString[0], 32)._highBitOfByte()));	},	*_identityHash() {		return BigInt.asIntN(53, this)	},	*_isPowerOfTwo() {		if (this < 0)			return false;		return /^[1248Gg]0*$/.test(this.toString(32))	},	*_lowBit() {		if (this === 0n) {			return 0;		} else {			let _n = this, _result = 0, _lastByte;			while ((_lastByte = _n & 0xFFFFFFFFn) === 0n) {				_result += 32;				_n >>= 32n;			}			return _result + (yield * (Number(_lastByte)._lowBit()));		}	},	*_negated() {		return -this	},	*_negative() {		return this < 0	},	*_nextInstance() {		return nil	},	*_noMask_(_mask) {		/*Treat the argument as a bit mask. Answer whether none of the bits that        are 1 in the argument are 1 in the receiver.*/		if (typeof _mask === 'bigint') {			return (this & _mask) === 0n;		}		const argVal = _mask.valueOf();		if (Number.isSafeInteger(argVal)) {			return (this & BigInt(argVal)) === 0n;		}		return 0 == (yield* this._bitAnd_( _mask));	},	*_normalize() {		//Number.isSafeInteger() does not work for bigInt arguments		return (this < 9007199254740992n && this > -9007199254740992n) ? Number(this) : this	},	*_positive() {		return this >= 0	},	*_printOn_(_aStream) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printOn:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(this.toString()));		return this;	},	*_printOn_base_(_aStream, _b) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printOn:base:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(_b > 10 ? this.toString(_b).toUpperCase() :  this.toString(_b)));		return this;	},	*_printString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printString", false, false);		return SmalltalkGlobals._ByteString.from(this.toString());	},	*_printStringBase_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>printStringBase:", false, false);		return SmalltalkGlobals._ByteString.from(_base > 10 ? this.toString(_base).toUpperCase() :  this.toString(_base));	},	*_printStringLimitedTo_(_limit) {		/*Answer a String whose characters are a description of the receiver.        If you want to print without a character limit, use fullPrintString.*/		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Object>>printStringLimitedTo:", false, false);		const powerOfTen = Math.trunc(Math.log10(32) * this.toString(32).length);		if (this < 0)			_limit--;		if (_limit > powerOfTen)			return SmalltalkGlobals._ByteString.from(this.toString());		let native = this >= 0 ? "" : "-", n = this, digits = 0, divisor = 10n ** BigInt(powerOfTen);		while (digits++ < _limit && divisor > 0) {			const nextDigit = n / divisor;			n = n - nextDigit * divisor;			native += nextDigit;			divisor /= 10n		}		return SmalltalkGlobals._ByteString.from(native + '...etc...');	},	*_printStringRadix_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("SmallInteger>>printStringRadix:", false, false);		const absToStringBase = this < 0 ? (-this).toString(_base) : this.toString(_base);		return SmalltalkGlobals._ByteString.from((this < 0 ? '-' : '') + _base + 'r' + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase));	},	_raisedToInteger_: function *_raisedToInteger_(_anInteger) {		/*The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must		be handled as an indeterminate form.		I take the first context because that's the way that was previously handled.		Maybe further discussion is required on this topic.*/		const argVal = _anInteger.valueOf();		if (!Number.isSafeInteger(argVal))			yield* SmalltalkVM.debug();		if (argVal < 0) {			return yield* (yield* this._raisedToInteger_(-argVal))._reciprocal();		} else {			const resultN = this ** BigInt(argVal);			const result = Number(resultN);			return Number.isSafeInteger(result) && result == resultN ? result : resultN;		}	},	_scaledIdentityHash: function *_scaledIdentityHash() {		return BigInt.asIntN(53, this)	},	*_shallowCopy() {		return this	},	*_sign() {		return this >= 0 ? 1 : -1	},	*_sqrt() {		if (this >= 0) { // Effective (inherited or local) source for #sqrt in LargePositiveInteger			/*If we know for sure no exact solution exists, then just answer the cheap float approximation without wasting time.*/			if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargePositiveInteger>>sqrt", false, false);			let root;			const halfByteLen = this.toString(16).length;			if (halfByteLen < 256) // small enough for direct double conversion?			{				let floatRoot = Math.sqrt(Number(this));				if (Number.isInteger(floatRoot)) {					root = BigInt(floatRoot);					if (root * root === this) {						if ((floatRoot | 0) === floatRoot || Number.isSafeInteger(floatRoot))							return floatRoot;						return root;					}				} else if (floatRoot < 9007199254740992n || floatRoot * floatRoot == this) {					return floatRoot;				} else					root = BigInt(Math.floor(floatRoot));			}			else // large: reduce with bitshifting, then convert to double (and back)			{				const reducedLen = BigInt(halfByteLen - 255);				root = BigInt(Math.sqrt(Number(this >> reducedLen * 4n))) << reducedLen * 2n;			}			for (; ; )			{				const root2 = this / root + root >> 1n;				if (root2 === root || root2 === root + 1n) {					const lowerBound = root * root;					if (this >= lowerBound && this <= lowerBound + (root << 1n)) {						if (lowerBound === this)							return root < 9007199254740992n ? Number(root) : root;						return Number(root2);					}				}				root = this / root2 + root2 >> 1n;				if (root === root2 || root === root2 + 1n) {					const lowerBound = root2 * root2;					if (this >= lowerBound && this <= lowerBound + (root2 << 1n)) {						if (lowerBound === this)							return root2 < 9007199254740992n ? Number(root2) : root2;						return Number(root);					}				}			}		} else { // Effective (inherited or local) source for #sqrt in LargeNegativeInteger			/*Answer the square root of the receiver.*/			if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("LargeNegativeInteger>>sqrt", false, false);			return yield* (yield* SmalltalkGlobals._DomainError._new()).setReceiver(this)._signal_(SmalltalkGlobals._LargeNegativeInteger.prototype._sqrt.literals[3] /* 'sqrt undefined for number less ...etc... */);		}	},	*_sqrtFloor() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Integer>>sqrtFloor", false, false);		let root;		const halfByteLen = this.toString(16).length;		if (halfByteLen < 256) // small enough for direct double conversion?		{			const floor = Math.floor(Math.sqrt(Number(this)));			root = BigInt(floor);			const product = root * root;			if (product <= this && product + root * 2n >= this) {				if ((floor | 0) === floor || Number.isSafeInteger(floor))					return floor;				return root;			}		}		else // large: reduce with bitshifting, then convert to double (and back)		{			const reducedLen = BigInt(halfByteLen - 255);			root = BigInt(Math.sqrt(Number(this >> reducedLen * 4n))) << reducedLen * 2n;		}		for (; ; )		{			const root2 = this / root + root >> 1n;			if (root2 === root || root2 === root + 1n) {				const lowerBound = root * root;				if (this >= lowerBound && this <= lowerBound + (root << 1n))					return root;			}			root = this / root2 + root2 >> 1n;			if (root === root2 || root === root2 + 1n) {				const lowerBound = root2 * root2;				if (this >= lowerBound && this <= lowerBound + (root2 << 1n))					return root2;			}		}	},	_sqrtRem: function *_sqrtRem() {		/*See super*/		let _s = nil;		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("SmallInteger>>sqrtRem, checking interrupts:", false, false);		_s = yield* this._sqrtFloor();		return SmalltalkGlobals._Array.from([_s, yield* this._sub( yield* _s._mul( _s))]);	},	*_storeOn_(_aStream) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeOn:", false, false);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from(this.toString()));		return this;	},	*_storeOn_base_(_aStream, _base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeOn:base:", false, false);		const absToStringBase = this < 0 ? (-this).toString(_base) : this.toString(_base);		yield * _aStream._nextPutAll_(SmalltalkGlobals._ByteString.from((this < 0 ? '-' : '') + (_base === 10 ? '' : _base + 'r') + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase)));		return this;	},	*_storeString() {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Object>>storeString", false, false);		return SmalltalkGlobals._ByteString.from(this.toString());	},	*_storeStringBase_(_base) {		if (GlobalActivationCounter-- < 0) yield* CheckInterruptsOrException("Number>>storeStringBase:", false, false);		const absToStringBase = this < 0 ? (-this).toString(_base) : this.toString(_base);		return SmalltalkGlobals._ByteString.from((this < 0 ? '-' : '') + (_base === 10 ? '' : _base + 'r') + (_base > 10 ? absToStringBase.toUpperCase() :  absToStringBase));	},	*_strictlyPositive() {		return this >= 0	},	*_veryDeepCopyWith_(_deepCopier) {		/*Return self.  I can't be copied.  Do not record me.*/		return this	},});